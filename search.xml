<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSDN博客导出为Hexo的MD文件</title>
      <link href="/2025/02/08/CSDN%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E4%B8%BAHexo%E7%9A%84MD%E6%96%87%E4%BB%B6/"/>
      <url>/2025/02/08/CSDN%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E4%B8%BAHexo%E7%9A%84MD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="CSDN博客导出为Hexo的MD文件"><a href="#CSDN博客导出为Hexo的MD文件" class="headerlink" title="CSDN博客导出为Hexo的MD文件"></a>CSDN博客导出为Hexo的MD文件</h1><p>一.获取所有文章地址、 二.使用脚本进行采集 </p><blockquote><p>参考：<a href="https://www.cnblogs.com/air/p/18429617">CSDN文章导出md并迁移至博客园 - lytcreate - 博客园</a> </p></blockquote><p>部分代码修正：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    url_list = [&#123;<span class="string">&#x27;url&#x27;</span>: item[<span class="string">&#x27;url&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: item[<span class="string">&#x27;title&#x27;</span>]&#125; <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 解析地址</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.helloworld.net/getUrlHtml?url=&#x27;</span></span><br><span class="line">    <span class="comment"># 解析错误的url</span></span><br><span class="line">    err_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(item[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">            res = requests.get(base_url + item[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">            content = res.json().get(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">            title = item[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(title+<span class="string">&#x27;已完成&#x27;</span>)</span><br><span class="line">            <span class="comment"># 调用函数，将HTML转换为Markdown并保存为文件</span></span><br><span class="line">            html_to_md(content, os.path.join(<span class="string">&#x27;md&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;title&#125;</span>.md&#x27;</span>)) </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">            <span class="built_in">print</span>(e) </span><br><span class="line">            err_list.append(item[<span class="string">&#x27;url&#x27;</span>]) </span><br><span class="line">        <span class="keyword">if</span> err_list: </span><br><span class="line">            <span class="built_in">print</span>(err_list) </span><br><span class="line">            df = pd.DataFrame([&#123;<span class="string">&#x27;name&#x27;</span>: err_list&#125;]) </span><br><span class="line">            df.to_csv(<span class="string">&#x27;err.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><em><strong>注：可能出现的问题：博客名不合规无法保存——修改文件名</strong></em></p><hr><h2 id="三-批量给md文件增加hexo识别码"><a href="#三-批量给md文件增加hexo识别码" class="headerlink" title="三.批量给md文件增加hexo识别码"></a>三.批量给md文件增加hexo识别码</h2><p>hexo识别文章需要添加如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;XXX&quot;</span><br><span class="line">date: 20XX-XX-XX XX:XX:XX</span><br><span class="line">tags: [&#x27;AA&#x27;, &#x27;BB&#x27;,...]</span><br><span class="line">......(依据manu设置)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>对于CSDN批量导出文章，采用以下方法快速增加相关信息：</p><ul><li>创建 <em>CSDN_INFO.txt</em> 保存之前在浏览器console导出的文章信息</li><li>使用脚本 <em>AddInfo_CSDN.py</em> 将信息自动添加到对应md文件中，将需要转换的 <em>.md</em> 文件保存在同目录的 <em>md</em> 文件夹中</li></ul><p><em>AddInfo_CSDN.py</em> 内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为所有md文件开头添加对应CSDN_INFO.txt中的信息</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="comment"># title: &quot;标题&quot;</span></span><br><span class="line"><span class="comment"># date: 2020-01-01 00:00:00</span></span><br><span class="line"><span class="comment"># tags: [&quot;标签1&quot;, &quot;标签2&quot;...]</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSDN_INFO.txt，提取每篇文章对应的文章标题title、日期postTime、标签tags</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readCSDNInfo</span>():</span><br><span class="line">    CSDNInfo = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;CSDN_INFO.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 字符匹配title、postTime、tags</span></span><br><span class="line">        title = re.findall(<span class="string">r&quot;title\&quot;: \&quot;(.*?)\&quot;&quot;</span>, f.read())</span><br><span class="line">        f.seek(<span class="number">0</span>)<span class="comment">#文件指针重置</span></span><br><span class="line">        postTime = re.findall(<span class="string">r&quot;postTime\&quot;: \&quot;(.*?)\&quot;&quot;</span>, f.read())</span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        all_tags = re.findall(<span class="string">r&#x27;&quot;tags&quot;:\s*\[([^\]]+)\]&#x27;</span>, f.read())</span><br><span class="line">        tags = [<span class="literal">None</span>] * <span class="built_in">len</span>(title)</span><br><span class="line">        <span class="comment"># 进一步提取每个标签</span></span><br><span class="line">        <span class="keyword">for</span> tag_group <span class="keyword">in</span> all_tags:</span><br><span class="line">            <span class="comment"># 提取双引号中的内容</span></span><br><span class="line">            tags[all_tags.index(tag_group)] = re.findall(<span class="string">r&#x27;&quot;([^&quot;]+)&quot;&#x27;</span>, tag_group)</span><br><span class="line">        <span class="comment"># 提取title、postTime、tags</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(title)):</span><br><span class="line">            CSDNInfo[title[i]] = &#123;&#125;</span><br><span class="line">            CSDNInfo[title[i]][<span class="string">&quot;postTime&quot;</span>] = postTime[i]</span><br><span class="line">            CSDNInfo[title[i]][<span class="string">&quot;tags&quot;</span>] = tags[i]</span><br><span class="line">    <span class="keyword">return</span> CSDNInfo</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 为md文件开头添加对应CSDN_INFO.txt中的信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addInfo2MD</span>(<span class="params">mdPath, CSDNInfo</span>):</span><br><span class="line">    title = os.path.basename(mdPath).split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">in</span> CSDNInfo:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="keyword">if</span> lines[<span class="number">0</span>].startswith(<span class="string">&quot;---&quot;</span>):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;title: \&quot;<span class="subst">&#123;title&#125;</span>\&quot;\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;date: <span class="subst">&#123;CSDNInfo[title][<span class="string">&#x27;postTime&#x27;</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;tags: <span class="subst">&#123;CSDNInfo[title][<span class="string">&#x27;tags&#x27;</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(content)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;AddInfo: <span class="subst">&#123;title&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;title&#125;</span> not in CSDN_INFO.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有md文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverseMDFiles</span>(<span class="params">mdDir, CSDNInfo</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(mdDir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">                mdPath = os.path.join(root, file)</span><br><span class="line">                addInfo2MD(mdPath, CSDNInfo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    mdDir = <span class="string">&quot;md&quot;</span></span><br><span class="line">    CSDNInfo = readCSDNInfo()</span><br><span class="line">    traverseMDFiles(mdDir, CSDNInfo)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/08/hello-world/"/>
      <url>/2025/02/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RANSAC算法的FPGA实现</title>
      <link href="/2024/05/27/RANSAC%E7%AE%97%E6%B3%95%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/27/RANSAC%E7%AE%97%E6%B3%95%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">一.算法原理</a></p><p><a href="about:blank#1.%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">1.参数变量</a></p><p><a href="about:blank#2.%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">2.算法流程</a></p><p><a href="about:blank#%3C1%3E%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">&lt;1&gt;随机读取数据</a></p><p><a href="about:blank#%3C2%3E%E6%8B%9F%E5%90%88%E6%A8%A1%E5%9E%8B">&lt;2&gt;拟合模型</a></p><p><a href="about:blank#%3C3%3E%E6%A3%80%E9%AA%8C%E6%A8%A1%E5%9E%8B">&lt;3&gt;检验模型</a></p><p><a href="about:blank#%3C4%3E%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86">&lt;4&gt;循环遍历</a></p><p><a href="about:blank#%E4%BA%8C.%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">二.设计思路</a></p><p><a href="about:blank#1.%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">1.设计目标</a></p><p><a href="about:blank#2.%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">2.模块设计</a></p><p><a href="about:blank#%3C1%3E%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%BA%A7%E7%94%9F%E6%A8%A1%E5%9D%97">&lt;1&gt;随机数产生模块</a></p><p><a href="about:blank#%3C2%3E%E6%9A%82%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8">&lt;2&gt;暂存寄存器</a></p><p><a href="about:blank#%3C3%3E%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97">&lt;3&gt;计算模块</a></p><p><a href="about:blank#%3C4%3E%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9D%97">&lt;4&gt;模型评估模块</a></p><p><a href="about:blank#%3C5%3E%E4%B8%BB%E4%BD%93%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BE%93%E5%87%BA%E6%A8%A1%E5%9D%97">&lt;5&gt;主体控制与输出模块</a></p><p><a href="about:blank#%3C6%3E%E6%95%B4%E5%90%88">&lt;6&gt;整合</a></p><p><a href="about:blank#%E4%B8%89.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">三.具体实现</a></p><p><a href="about:blank#1.Python%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97">1.Python数据生成模块</a></p><p><a href="about:blank#2.Verilog%20RANSAC%E7%AE%97%E6%B3%95%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">2.Verilog<br>RANSAC算法仿真结果</a></p><p><a href="about:blank#%E5%9B%9B.%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">四.性能分析</a></p><p><a href="about:blank#1.%E8%B5%84%E6%BA%90%E5%88%86%E6%9E%90">1.资源分析</a></p><p><a href="about:blank#2.%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90">2.速度分析</a></p><p><a href="about:blank#3.%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%A7%8D%E5%AD%90%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C">3.选择不同随机数种子下的结果</a></p><p><a href="about:blank#4.%E4%B8%8D%E5%90%8C%E9%A2%84%E8%AE%BE%E7%9B%B4%E7%BA%BF%E5%8F%82%E6%95%B0%E4%B8%8B%E7%9A%84%E6%8B%9F%E5%90%88%E7%BB%93%E6%9E%9C">4.不同预设直线参数下的拟合结果</a></p><p><a href="about:blank#%E4%BA%94.%E6%80%9D%E8%80%83%E4%B8%8E%E6%94%B9%E8%BF%9B">五.思考与改进</a></p><p><a href="about:blank#1.%E6%8F%90%E9%80%9F%E7%93%B6%E9%A2%88">1.提速瓶颈</a></p><p><a href="about:blank#2.%E5%A2%9E%E5%8A%A0%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%A6">2.增加并行程度</a></p><p><a href="about:blank#3.%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E6%94%B9%E8%BF%9B">3.算法流程改进</a></p><p><a href="about:blank#%E5%85%AD.%E9%99%84%E5%BD%95">六.附录</a></p><p><a href="about:blank#1.vivado%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86">1.vivado工程源码部分</a></p><p><a href="about:blank#%3C1%3E%E4%B8%BB%E4%BD%93%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86">&lt;1&gt;主体控制部分</a></p><p><a href="about:blank#%E4%B8%83.%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">七.参考文献</a></p><p><a href="about:blank#%E5%85%AB.%E8%AE%BE%E8%AE%A1%E6%94%B9%E8%BF%9B">八.设计改进</a></p><p><a href="about:blank#1.%E4%B8%8D%E5%8F%AF%E7%BB%BC%E5%90%88%E8%AF%AD%E5%8F%A5">1.不可综合语句</a></p><p><a href="about:blank#2.%E4%BF%AE%E6%AD%A3%E7%A8%8B%E5%BA%8F%E8%AF%AD%E5%8F%A5">2.修正程序语句</a></p><p><a href="about:blank#3.%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97">3.时钟模块</a></p><p><a href="about:blank#%E4%B9%9D.%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">九.设计实现分析</a></p><p><a href="about:blank#1.%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">1.静态时序分析</a></p><p><a href="about:blank#%E5%8D%81.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">十.下载验证</a></p><hr><p>参考：</p><p><a href="https://blog.csdn.net/Graduate2015/article/details/113133919" title="伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-CSDN博客">伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-<br>CSDN博客</a><a href="https://blog.csdn.net/xijuezhu8128/article/details/122930455" title="RANSAC算法(附RANSAC直线拟合C++与Python版本)-CSDN博客">RANSAC算法(附RANSAC直线拟合C++与Python版本)-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhoucoolqi/article/details/105497572?spm=1001.2014.3001.5506" title="RANSAC算法——看完保证你理解-CSDN博客">RANSAC算法——看完保证你理解-<br>CSDN博客</a><a href="https://blog.csdn.net/Graduate2015/article/details/113133919" title="伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-CSDN博客">伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-<br>CSDN博客</a></p><h2 id="一-算法原理"><a href="#一-算法原理" class="headerlink" title="一.算法原理"></a>一.算法原理</h2><h3 id="1-参数变量"><a href="#1-参数变量" class="headerlink" title="1.参数变量"></a>1.参数变量</h3><p>输入：数据集data、拟合模型model</p><p>中间参数：一次拟合需要的数据量n；算法最大遍历次数k；计算匹配阈值t；最小匹配数据数d</p><p>输出：完成信号done、最匹配的模型model参数</p><p>模型：二元一次线性模型，二元多次非线性模型，任意函数…</p><h3 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2.算法流程"></a>2.算法流程</h3><h4 id="随机读取数据"><a href="#随机读取数据" class="headerlink" title="&lt;1&gt;随机读取数据"></a>&lt;1&gt;随机读取数据</h4><p>随机数生成模块生成n个随机地址，取出存储器对应地址数据。</p><h4 id="拟合模型"><a href="#拟合模型" class="headerlink" title="&lt;2&gt;拟合模型"></a>&lt;2&gt;拟合模型</h4><p>由读出的n个数据拟合出相应模型</p><h4 id="检验模型"><a href="#检验模型" class="headerlink" title="&lt;3&gt;检验模型"></a>&lt;3&gt;检验模型</h4><p>检验存储器中所有数据对于该模型的拟合程度</p><h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="&lt;4&gt;循环遍历"></a>&lt;4&gt;循环遍历</h4><p>每次循环评价随机拟合的模型，当遍历k次后结束拟合，得到最佳模型</p><h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二.设计思路"></a>二.设计思路</h2><h3 id="1-设计目标"><a href="#1-设计目标" class="headerlink" title="1.设计目标"></a>1.设计目标</h3><pre><code>    工程能够完成一组坐标点集的线性拟合。输入坐标数据（x,y）的值为8bit 无符号整数数据类型，输出拟合直线参数，包括斜率k和y轴截距b，为8bit 有符号整数。</code></pre><h3 id="2-模块设计"><a href="#2-模块设计" class="headerlink" title="2.模块设计"></a>2.模块设计</h3><h4 id="随机数产生模块"><a href="#随机数产生模块" class="headerlink" title="&lt;1&gt;随机数产生模块"></a>&lt;1&gt;随机数产生模块</h4><pre><code>    利用线性反馈移位寄存器（Linear Feedback Shift Register，LFSR）产生随机数，对于反馈移位寄存器和异或门构成的电路，可以按下面的关系式生成序列[1]：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a2ef04e43713d49cbd2d77c4b3b13d13.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1a40e9fb00f3d512134c9efbe023418.png"></p><pre><code>    对于m位的线性反馈移位寄存器，最多可以产生2^m-1个不同状态。如果一个序列发生器正好生产这 2^m-1个不同状态之后才重复此序列。随机数产生器的初始队列成为种子（seed），随后队列对种子进行移位运算生成新队列。    工程中采用32位随机数产生模块，每次取前14位分别作为两随机点的地址（128个数据对应7位地址）。</code></pre><h4 id="暂存寄存器"><a href="#暂存寄存器" class="headerlink" title="&lt;2&gt;暂存寄存器"></a>&lt;2&gt;暂存寄存器</h4><pre><code>    通过rom读取文件内数据信息，存入相关数据。Rom深度为128，对应7位地址线，宽度为16位数据前8位为x，后8位为y。采用组合逻辑电路直接输出对应地址数据。</code></pre><h4 id="计算模块"><a href="#计算模块" class="headerlink" title="&lt;3&gt;计算模块"></a>&lt;3&gt;计算模块</h4><pre><code>    通过所给数据拟合出模型。输入为32位数据，前16位和后16位分别是(x1,y1)和(x2,y2)。实现的组合电路结构如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c14f200db8d3e933e48fbe49a193f1fc.png"></p><p>K&#x3D;(y2-y1)&#x2F;(x2-x1)    b&#x3D;y2-k*x2</p><h4 id="模型评估模块"><a href="#模型评估模块" class="headerlink" title="&lt;4&gt;模型评估模块"></a>&lt;4&gt;模型评估模块</h4><pre><code>    给定参数T_RANGE，表示允许残差平方RSS的最大值（RSS=(y-k*x-b)^2，表示期望值与实际值只差的平方），当RSS&lt;T_RANGE时，表示该点在允许范围之内。Fit信号输出为1。实现的组合电路结构如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fab333897437b774df5bb4bc2a42adc5.png"></p><h4 id="主体控制与输出模块"><a href="#主体控制与输出模块" class="headerlink" title="&lt;5&gt;主体控制与输出模块"></a>&lt;5&gt;主体控制与输出模块</h4><pre><code>    用于控制迭代次数K，以及产生随机数产生模块时钟和rom地址更新。每次迭代重新生成随机数以产生新模型。遍历rom检验后比较最大线内点数fit_num，如果大于最大值则更新模型参数</code></pre><h4 id="整合"><a href="#整合" class="headerlink" title="&lt;6&gt;整合"></a>&lt;6&gt;整合</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6b9180c527cfd5d39786f27076598b.png"></p><table><thead><tr><th>NAME</th><th>ADDR_WIDTH</th><th>DATA_WIDTH</th><th>INPUTDATA_WIDTH</th><th>PARA_WIDTH</th><th>T_WIDTH</th></tr></thead><tbody><tr><td>WIDTH&#x2F;BITS</td><td>7</td><td>16</td><td>32</td><td>16</td><td>16</td></tr><tr><td>DETAILS</td><td></td><td>x(h_8b)</td><td>y(l_8b)</td><td>x1(h_8b)</td><td>y1(l_8b)</td></tr></tbody></table><h2 id="三-具体实现"><a href="#三-具体实现" class="headerlink" title="三.具体实现"></a>三.具体实现</h2><h3 id="1-Python数据生成模块"><a href="#1-Python数据生成模块" class="headerlink" title="1.Python数据生成模块"></a>1.Python数据生成模块</h3><pre><code>    使用python编写代码生成十六进制数据集，包含线内点和噪声点，并给出python实现ransac和最小二乘法的拟合结果。如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f8b333fec06e0a78982e2978f077efd7.png"></p><pre><code>    设定直线的参数：斜率k=2，截距b=25，最小二乘法和ransac拟合参数结果如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aa641fc13e378827a3ed2d7763b60aab.png"></p><pre><code>    其中红色线是最小二乘法的拟合结果，绿色线是ransac在迭代1000次，允许误差为5的拟合结果。    将产生数据以16进制形式保存，并存储于data.mem文件中在vivado中读取。</code></pre><h3 id="2-Verilog-RANSAC算法仿真结果"><a href="#2-Verilog-RANSAC算法仿真结果" class="headerlink" title="2.Verilog RANSAC算法仿真结果"></a>2.Verilog RANSAC算法仿真结果</h3><pre><code>    工程拟合结果直线参数为：斜率k=2(0x02),b=24(0x18)，完全符合设定值。符合误差范围的点数最多为47个（0x2F），并在第450代（0x01C2）时随机产生的地址拟合出了最佳参数。此时的残差平方和RSS为2086（0x826）。    由于拟合和评估部分皆为组合逻辑电路，算法完成的速度取决于迭代次数K和时钟频率CLK_FRE。仿真采用100MHZ时钟，K取1000次，每次迭代遍历128个点需要128个时钟周期，故算法每次执行需要：128*K/CLK_FRE秒。本次仿真算法在0.00128s（128*1k/1M）左右结束，done信号置高电平有效，故算法频率为781.25HZ。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/face361f9b63a0ff29ebaa18ae4d4d2f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f39ebf2287ecd3f78f9f303dcd7d844.png"></p><h2 id="四-性能分析"><a href="#四-性能分析" class="headerlink" title="四.性能分析"></a>四.性能分析</h2><h3 id="1-资源分析"><a href="#1-资源分析" class="headerlink" title="1.资源分析"></a>1.资源分析</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2b5db5cfbb3689bbf2b38712717330ee.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/332a59e94e620fbd13c87aa0a98f3baa.png"></p><pre><code>    设计使用到的查找表、IO、缓存器等资源均较少，满足设计的资源限制。</code></pre><h3 id="2-速度分析"><a href="#2-速度分析" class="headerlink" title="2.速度分析"></a>2.速度分析</h3><pre><code>    下表给出不同迭代次数和时钟频率下的算法频率F=CLK_FRE/(128*K)：</code></pre><h2 id="F-CLK-FRE-128-K"><a href="#F-CLK-FRE-128-K" class="headerlink" title="F&#x3D;CLK_FRE&#x2F;(128*K)  "></a>F&#x3D;CLK_FRE&#x2F;(128*K)  </h2><p>CLK_FRE(&#x2F;M) |  K |  frequency(&#x2F;Hz)<br>100 |  1000 |  781.25<br>100 |  10000 |  78.125<br>100 |  500 |  1562.5<br>80 |  1000 |  625<br>15 |  1000 |  117.1875  </p><h3 id="3-选择不同随机数种子下的结果"><a href="#3-选择不同随机数种子下的结果" class="headerlink" title="3.选择不同随机数种子下的结果"></a>3.选择不同随机数种子下的结果</h3><pre><code>    在迭代次数k=1000次下，不同随机数种子下最终结果出现的时机（其中k是代数，para是拟合参数）：</code></pre><table><thead><tr><th>seed</th><th>0x12345678</th><th>0xFFFFFFFF</th><th>0x11111111</th><th>0xcd62f912</th><th>0x63e8c090</th></tr></thead><tbody><tr><td>K</td><td>450</td><td>403</td><td>13</td><td>524</td><td>360</td></tr><tr><td>PARA</td><td>0x0218</td><td>0x0218</td><td>0x0218</td><td>0x0218</td><td>0x0218</td></tr></tbody></table><h3 id="4-不同预设直线参数下的拟合结果"><a href="#4-不同预设直线参数下的拟合结果" class="headerlink" title="4.不同预设直线参数下的拟合结果"></a>4.不同预设直线参数下的拟合结果</h3><pre><code>    在seed=0x12345678下，不同预设直线参数下的拟合结果如下，其中k，b为设定值，ransac_k、ransac_b为拟合值，fit_num为检测为线内的点数（实际为128）：</code></pre><table><thead><tr><th>k</th><th>2</th><th>3</th><th>4</th><th>2.5</th></tr></thead><tbody><tr><td>ransac_k</td><td>2</td><td>3</td><td>4</td><td>2</td></tr><tr><td>b</td><td>25</td><td>10</td><td>77</td><td>16</td></tr><tr><td>ransac_b</td><td>24</td><td>11</td><td>51</td><td>41</td></tr><tr><td>fit_num</td><td>47</td><td>64</td><td>25</td><td>39</td></tr></tbody></table><h2 id="五-思考与改进"><a href="#五-思考与改进" class="headerlink" title="五.思考与改进"></a>五.思考与改进</h2><h3 id="1-提速瓶颈"><a href="#1-提速瓶颈" class="headerlink" title="1.提速瓶颈"></a>1.提速瓶颈</h3><pre><code>    在算法的实现流程中，计算和评估模块均采用组合逻辑电路，而 控制部分电路采用循环遍历的方式，依次选取rom中数据对模型进行检验，大大降低了算法的速度。</code></pre><h3 id="2-增加并行程度"><a href="#2-增加并行程度" class="headerlink" title="2.增加并行程度"></a>2.增加并行程度</h3><pre><code>    在检验阶段，设计一寄存器组，提前将rom中所有数据存储至寄存器组后并行输出，连接至同等数量的evaluate_kernel模块同时进行检验。实现由之前的循环遍历校验转化为同时并行检验：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb02859e4670ee07014b6af6ab546d75.png"></p><h3 id="3-算法流程改进"><a href="#3-算法流程改进" class="headerlink" title="3.算法流程改进"></a>3.算法流程改进</h3><p>&lt;1&gt;工程中模型的拟合采用直接随机选取n个数据进行拟合的方法，进而确定线内点。可以改进为最后增加一个步骤，由已经确定的线内点重新使用最小二乘法拟合参数，减小拟合参数的残差平方和RSS。</p><p>&lt;2&gt;线内点的确定可改进为投票式，即由k个模型共同投票符合要求的片内点，选取票数最高的点作为真正的片内点[2]。</p><h2 id="六-附录"><a href="#六-附录" class="headerlink" title="六.附录"></a>六.附录</h2><h3 id="1-vivado工程源码部分"><a href="#1-vivado工程源码部分" class="headerlink" title="1.vivado工程源码部分"></a>1.vivado工程源码部分</h3><h4 id="主体控制部分"><a href="#主体控制部分" class="headerlink" title="&lt;1&gt;主体控制部分"></a>&lt;1&gt;主体控制部分</h4><pre><code>`timescale 1ns / 1ps//// Engineer: switch_swq// Create Date: 2024/05/20 10:48:12//module evaluate#(    parameter ADDR_WIDTH = 7,    parameter DATA_WIDTH = 16,    parameter INPUTDATA_WIDTH = 32,    parameter PARA_WIDTH = 16,      parameter T_WIDTH = 18,      parameter T_RANGE = 10,    parameter K_RANGE = 1000,    parameter DATA_FILE = &quot;data.mem&quot;)(    input wire clk_in,    input wire rst_in,    output reg done,    //output reg [PARA_WIDTH-1:0]best_para    output wire [5:0]sel,     output wire [7:0]seg          );wire clk,rst;wire [31:0]random_num;wire [PARA_WIDTH-1:0] para;wire [DATA_WIDTH-1:0] data;wire [INPUTDATA_WIDTH-1:0]input_data;wire fit;wire [T_WIDTH-1:0]RSS;reg random_clk;reg [ADDR_WIDTH-1:0] addr,fit_count,fit_max;reg [T_WIDTH-1:0]rss_num,rss_min;reg [15:0]k_num;reg [PARA_WIDTH-1:0]best_para;wire [23:0]output_data;wire [5:0]point;assign rst=~rst_in;always@(posedge clk or posedge rst)if(rst==1&#39;b1)    addr&lt;=1&#39;b0;else    addr&lt;=addr+1;    always@(posedge clk or posedge rst)if(rst==1&#39;b1)    k_num&lt;=1&#39;b0;else if(k_num&lt;=K_RANGE &amp;&amp; addr==1&#39;b0)    k_num&lt;=k_num+1;    always@(posedge clk or posedge rst)if(rst==1&#39;b1)    random_clk&lt;=1&#39;b0;else if(k_num&lt;=K_RANGE &amp;&amp; addr==1&#39;b0)    random_clk&lt;=1&#39;b1;else     random_clk&lt;=1&#39;b0;   always@(posedge clk or posedge rst)if(rst==1&#39;b1)    done&lt;=1&#39;b0;else if(k_num&gt;K_RANGE)    done&lt;=1&#39;b1;else     done&lt;=1&#39;b0;always@(posedge clk or posedge rst)begin    if(rst==1&#39;b1)begin        rss_num&lt;=&#39;b0;        fit_count&lt;=&#39;b0;        fit_max&lt;=&#39;b0;                        best_para&lt;=&#39;b0;     end     else if(k_num&lt;=K_RANGE)begin           if(fit==1&#39;b1)begin            fit_count&lt;=fit_count+1;            rss_num&lt;=rss_num+RSS;        end                     if(addr==1&#39;b0)begin            if(fit_count&gt;fit_max)begin                best_para&lt;=para;                fit_max&lt;=fit_count;                rss_min&lt;=rss_num;            end            rss_num&lt;=&#39;b0;            fit_count&lt;=1&#39;b0;        end    endendassign output_data=&#123;8&#39;b0,best_para&#125;;assign point=6&#39;b0;clk_wiz_0 clk_wiz_0_inst   (    // Clock out ports    .clk_out1(clk),     // output clk_out1   // Clock in ports    .clk_in1(clk_in)      // input clk_in1);blk_mem_gen_0 blk_mem_gen_0_inst1 (  .clka(clk),    // input wire clka  .addra(addr),  // input wire [6 : 0] addra  .douta(data)  // output wire [15 : 0] douta);blk_mem_gen_0 blk_mem_gen_0_inst2 (  .clka(clk),    // input wire clka  .addra(random_num[6:0]),  // input wire [6 : 0] addra  .douta(input_data[INPUTDATA_WIDTH-1:INPUTDATA_WIDTH/2])  // output wire [15 : 0] douta);blk_mem_gen_0 blk_mem_gen_0_inst3 (  .clka(clk),    // input wire clka  .addra(random_num[13:7]),  // input wire [6 : 0] addra  .douta(input_data[INPUTDATA_WIDTH/2-1:0])  // output wire [15 : 0] douta);evaluate__kernel#(    .DATA_WIDTH(DATA_WIDTH),    .PARA_WIDTH(PARA_WIDTH),    .T_WIDTH   (T_WIDTH   ),    .T_RANGE   (T_RANGE   ) )evaluate__kernel_inst(    .data(data),    .para(para),    .RSS(RSS),    .fit(fit));calculate_kernel#(    .INPUTDATA_WIDTH(INPUTDATA_WIDTH),    .PARA_WIDTH(PARA_WIDTH))calculate_kernel_inst(    .input_data(input_data),    .para(para));random_num random_num_inst(    .clk   (random_clk)  ,    .rst   (rst   )  ,    .data  (random_num));seg_dynamic seg_dynamic_inst(    .sys_clk  (clk      )   ,    .sys_rst_n(rst      )   ,    .data     (output_data)   ,     .point    (point),    .sel      (sel      )   ,    .seg      (seg      )    );endmodule</code></pre><h2 id="七-参考文献"><a href="#七-参考文献" class="headerlink" title="七.参考文献"></a>七.参考文献</h2><p>[1]束礼宝,宋克柱,王砚方.伪随机数发生器的FPGA实现与研究[J].电路与系统学报,2003(03):121-124.</p><p>[2]江洁,凌思睿.一种投票式并行RANSAC算法及其FPGA实现[J].电子与信息学报,2014,36(05):1145-1150.</p><h2 id="八-设计改进"><a href="#八-设计改进" class="headerlink" title="八.设计改进"></a>八.设计改进</h2><h3 id="1-不可综合语句"><a href="#1-不可综合语句" class="headerlink" title="1.不可综合语句"></a>1.不可综合语句</h3><pre><code>    原代码中夹杂着不可综合语句，如rom中的initial语句。现将数据存储器使用xilinx block memory generator ip核替换原本不可综合的rom模块。</code></pre><h3 id="2-修正程序语句"><a href="#2-修正程序语句" class="headerlink" title="2.修正程序语句"></a>2.修正程序语句</h3><p>（1）原程序出现阻塞赋值和非阻塞赋值语句混用情况，现对evaluate、evaluate_kernel、calculate_kernel相关语句进行了修正。（说明：控制模块evaluate和随机数生成模块random_num采用时序逻辑，计算和评估模块_kernel仍使用组合逻辑）</p><p>（2）原程序的控制模块evaluate中语句较为混乱，现依据信号划分语句，使结构更为清晰。</p><h3 id="3-时钟模块"><a href="#3-时钟模块" class="headerlink" title="3.时钟模块"></a>3.时钟模块</h3><pre><code>    添加xilinx clocking wizard ip核代替原硬件时钟直连，方便后续进行时序分析和调试。</code></pre><h2 id="九-设计实现分析"><a href="#九-设计实现分析" class="headerlink" title="九.设计实现分析"></a>九.设计实现分析</h2><h3 id="1-静态时序分析"><a href="#1-静态时序分析" class="headerlink" title="1.静态时序分析"></a>1.静态时序分析</h3><pre><code>    在vivado设计实现中，观察“Timing Summary”内的时钟域内路径“intra-clock paths”以确定时钟频率。可以看到路径上的时序要求“requirement”为30.303ns，数据信号在时钟周期内稳定下来的最长时间在path1上，如下图：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8479c74fa867c5f9ca2329e5ac82e282.png"></p><pre><code>    该路径是从存储器blk_mem_gen0至寄存器fit_count_reg，即对应从随机从存储器中取数至模型遍历评估一个数结束。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/462f462ef19b1e592eaa28041ca7d0d8.png"></p><pre><code>    按照信号稳定的最长时间为30.303ns，计算出的最大频率约为33.00MHz。在时钟约束中设置时钟的输出频率为33MHz，implement后的结果如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91c5ac678cde8f1b0bf32fa7ae06f688.png"></p><pre><code>    可以看到系统的最差负时序裕量“WNS”和最差保持时序裕量“WHS”均为正；总的负时序裕量“TNS”和保持时序裕量“THS”为零，即所有的时序路径都能满足这些要求。</code></pre><h2 id="十-下载验证"><a href="#十-下载验证" class="headerlink" title="十.下载验证"></a>十.下载验证</h2><pre><code>    在工程中添加数码管显示模块，并生成比特流对工程进行下载验证。使用开发板芯片型号为xc7a35tfgg484-2，资源使用情况如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/32d8e202d68c50edda80d9e40a9f5d36.png"></p><pre><code>    实际运行情况如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd0a71b7d0b73f5101eb227302152b34.png"></p><h2 id="十一-后续改进"><a href="#十一-后续改进" class="headerlink" title="十一.后续改进"></a>十一.后续改进</h2><h3 id="1-时序电路设计"><a href="#1-时序电路设计" class="headerlink" title="1.时序电路设计"></a>1.时序电路设计</h3><pre><code>    将模型拟合模块和评估模块（calculate_kernel和evaluate__kernel模块）由组合逻辑改为时序逻辑，减小了信号传递的长度，从而减少线路上信号稳定所需要的时间。</code></pre><h3 id="2-流水线改进"><a href="#2-流水线改进" class="headerlink" title="2.流水线改进"></a>2.流水线改进</h3><pre><code>    在拟合和评估模块将相关计算步骤分解成流水线。</code></pre><p><img src="https://i-blog.csdnimg.cn/direct/7cc6346feffd47fbb37c328f1ba6f213.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/b4d02ced10924951b3a607efb1514515.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/1d33919743cf4a19a82137d91e857368.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/c561475921714635b0cce41ba03c8ab0.png"></p><h3 id="3-数值精度提升"><a href="#3-数值精度提升" class="headerlink" title="3.数值精度提升"></a>3.数值精度提升</h3><pre><code>    提升线路宽度从原来8位提高到16位，并使用定点小数表示数值。高8位为整数部分，低8位为小数部分。</code></pre><h3 id="4-算法结构改进"><a href="#4-算法结构改进" class="headerlink" title="4.算法结构改进"></a>4.算法结构改进</h3><pre><code>    将评估模块由原先循环取数评估改为并行评估（evaluate_parralle模块），将评估所需时钟周期数由128变为1，以适配流水线周期长度。</code></pre><p><img src="https://i-blog.csdnimg.cn/direct/4fda9ff18bf140c6a740e791e136710a.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/d00fb992865d4c92bf86772ec2471575.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/7a1311448ae04201b9232d675c8a8c9a.png"></p><h3 id="5-改进后性能"><a href="#5-改进后性能" class="headerlink" title="5.改进后性能"></a>5.改进后性能</h3><pre><code>    最高时钟频率约72.4MHz（最长路径时间为12.002ns）</code></pre><h3 id="6-现存问题"><a href="#6-现存问题" class="headerlink" title="6.现存问题"></a>6.现存问题</h3><p>&lt;1&gt;评估模块（evaluate_parralle模块）以空间换速度，占用资源较多</p><p>&lt;2&gt;使用vivado提供的除法运算“&#x2F;”所综合的器件导致该路径用时（logic delay）过长，成为时钟频率无法提升的主要问题，需进行改进。</p><p><img src="https://i-blog.csdnimg.cn/direct/c3fd17c5f6ca4efabdd1acaaab26491f.png"></p><p><img src="https://i-blog.csdnimg.cn/direct/5c821beb009e40e3b2ad1ac4a359fe48.png"></p><pre><code>    另一方面系统布线时延（net delay）也较长，表现在参数计算模块calculate_kernel的b_reg到并行评估模块kxb_reg上，仍在探索优化方法。</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/139198487">https://blog.csdn.net/qq_32971095/article/details/139198487</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> opencv </tag>
            
            <tag> 算法 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科大三下SOC微体系结构设计实验合集</title>
      <link href="/2024/05/23/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/"/>
      <url>/2024/05/23/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%BA%8C.%E7%BA%BF%E4%B8%8B%E5%AE%9E%E9%AA%8C">二.线下实验</a></p><p><a href="about:blank#%E7%AE%A1%E8%84%9A%E7%BB%91%E5%AE%9A%E6%A8%A1%E7%89%88">管脚绑定模版</a></p><p><a href="about:blank#%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97%E6%A8%A1%E7%89%88">通用模块模版</a></p><p><a href="about:blank#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></p><p><a href="about:blank#1.%E8%B7%91%E9%A9%AC%E7%81%AF%E6%8E%A7%E5%88%B6%E8%AE%BE%E8%AE%A1">1.跑马灯控制设计</a></p><p><a href="about:blank#2.8%20%E4%BD%8D%E5%B9%B6%E8%A1%8C%E5%85%A8%E5%8A%A0%E5%99%A8%E8%AE%BE%E8%AE%A1%2B%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">2.8<br>位并行全加器设计+数码管显示程序设计</a></p><p><a href="about:blank#3.%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1">3.阵列乘法器设计</a></p><p><a href="about:blank#4.%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%20FIFO%20%E7%9A%84%E8%AE%BE%E8%AE%A1">4.先进先出 FIFO<br>的设计</a></p><p><a href="about:blank#5.PC%20%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AE%BE%E8%AE%A1">5.PC<br>程序计数器设计</a></p><p><a href="about:blank#6.%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%20ROM%20%E8%AE%BE%E8%AE%A1">6.程序存储器 ROM<br>设计</a></p><p><a href="about:blank#7.%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E9%99%A4%E6%B3%95%E5%99%A8">7.加减交替除法器</a></p><p><a href="about:blank#8.%E6%8C%87%E4%BB%A4%E5%AD%98%E5%82%A8%E5%99%A8%20IR%20%E8%AE%BE%E8%AE%A1">8.指令存储器 IR<br>设计</a></p><p><a href="about:blank#9.%E5%AF%84%E5%AD%98%E5%99%A8%20RN%20%E8%AE%BE%E8%AE%A1">9.寄存器 RN<br>设计</a></p><p><a href="about:blank#10.ALU%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1">10.ALU算术逻辑单元设计</a></p><p><a href="about:blank#11.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%99%A8%20RAM%20%E8%AE%BE%E8%AE%A1">11.数据存储器 RAM<br>设计</a></p><p><a href="about:blank#12.%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%20SP%20%E8%AE%BE%E8%AE%A1">12.堆栈指针 SP<br>设计</a></p><p><a href="about:blank#13.%E9%87%87%E7%94%A8%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%20IO%20%E6%A8%A1%E5%9D%97">13.采用硬件描述语言语言设计 IO<br>模块</a></p><p><a href="about:blank#14.%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1">14.微控制器设计</a></p><p><a href="about:blank#15.8%20%E4%BD%8D%20SOC%20%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1">15.8 位 SOC<br>综合设计</a></p><p><a href="about:blank#1.%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">1.实验结果分析</a></p><p><a href="about:blank#%3C1%3E%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90">&lt;1&gt;模块工作顺序分析</a></p><p><a href="about:blank#%3C2%3E%E2%80%8B%E2%80%8B%E2%80%8B%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">&lt;2&gt;​​​指令执行过程分析</a></p><p><a href="about:blank#2.%E5%85%B6%E4%BB%96">2.其他</a></p><p><a href="about:blank#%3C1%3ESOC%E6%A8%A1%E5%9D%97%E9%9B%86%E6%88%90%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C">&lt;1&gt;SOC模块集成设计经验</a></p><p><a href="about:blank#%3C2%3E%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BSOC%E9%9B%86%E6%88%90%E5%85%B3%E9%94%AE">&lt;2&gt;SOC集成关键</a></p><hr><h2 id="二-线下实验"><a href="#二-线下实验" class="headerlink" title="二.线下实验"></a>二.线下实验</h2><h3 id="管脚绑定模版"><a href="#管脚绑定模版" class="headerlink" title="管脚绑定模版"></a>管脚绑定模版</h3><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/18 13:02:24#----------------------------------------------------------------------------------#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;a_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;a_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;a_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;a_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;a_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;a_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;a_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;a_in[7]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[7]&#125;]set_property PACKAGE_PIN B10        [get_ports &#123;b_in[0]&#125;]set_property PACKAGE_PIN A10        [get_ports &#123;b_in[1]&#125;]set_property PACKAGE_PIN B15        [get_ports &#123;b_in[2]&#125;]set_property PACKAGE_PIN A15        [get_ports &#123;b_in[3]&#125;]set_property PACKAGE_PIN A13        [get_ports &#123;b_in[4]&#125;]set_property PACKAGE_PIN A12        [get_ports &#123;b_in[5]&#125;]set_property PACKAGE_PIN D8         [get_ports &#123;b_in[6]&#125;]set_property PACKAGE_PIN D9         [get_ports &#123;b_in[7]&#125;]#SW16~23set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[7]&#125;]set_property PACKAGE_PIN F8         [get_ports &#123;c_in[0]&#125;]set_property PACKAGE_PIN F9         [get_ports &#123;c_in[1]&#125;]set_property PACKAGE_PIN H11        [get_ports &#123;c_in[2]&#125;]set_property PACKAGE_PIN H12        [get_ports &#123;c_in[3]&#125;]set_property PACKAGE_PIN G14        [get_ports &#123;c_in[4]&#125;]set_property PACKAGE_PIN J10        [get_ports &#123;c_in[5]&#125;]set_property PACKAGE_PIN H14        [get_ports &#123;c_in[6]&#125;]set_property PACKAGE_PIN J11        [get_ports &#123;c_in[7]&#125;]#sw31~24set_property PACKAGE_PIN J8         [get_ports rst]set_property IOSTANDARD LVCMOS18    [get_ports rst]set_property PACKAGE_PIN J14        [get_ports key_in]set_property IOSTANDARD LVCMOS18    [get_ports key_in]set_property PACKAGE_PIN H9         [get_ports wr]set_property IOSTANDARD LVCMOS18    [get_ports wr]set_property PACKAGE_PIN H8         [get_ports rd]set_property IOSTANDARD LVCMOS18    [get_ports rd]set_property PACKAGE_PIN G10        [get_ports a]set_property IOSTANDARD LVCMOS18    [get_ports a]set_property PACKAGE_PIN G9         [get_ports b]set_property IOSTANDARD LVCMOS18    [get_ports b]set_property PACKAGE_PIN J13        [get_ports c]set_property IOSTANDARD LVCMOS18    [get_ports c]set_property PACKAGE_PIN H13        [get_ports d]set_property IOSTANDARD LVCMOS18    [get_ports d]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]#LEDset_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[7]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;data_out[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;data_out[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;data_out[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;data_out[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;data_out[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;data_out[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;data_out[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;data_out[7]&#125;]#led15set_property PACKAGE_PIN L20        [get_ports empty]set_property IOSTANDARD LVCMOS33    [get_ports empty]#led11set_property PACKAGE_PIN J20        [get_ports full]set_property IOSTANDARD LVCMOS33    [get_ports full]</code></pre><h3 id="通用模块模版"><a href="#通用模块模版" class="headerlink" title="通用模块模版"></a>通用模块模版</h3><p>时钟分频：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity clk_div is    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end clk_div;architecture Behavioral of clk_div isbeginprocess(rst,clk_in)variable count:integer:=0;begin    if(rst=&#39;1&#39;)then count:=0;     elsif(clk_in=&#39;1&#39;and clk_in&#39;event)then         count:=count+1;        if(count&lt;=DIV_NUM/2)then            clk_out&lt;=&#39;1&#39;;        elsif(count&gt;DIV_NUM/2 and count&lt;DIV_NUM)then            clk_out&lt;=&#39;0&#39;;        elsif(count&gt;=DIV_NUM)then            count:=0;        end if;    end if;end process;end Behavioral;</code></pre><p>按键消抖：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity key_stroke is    generic(CLK_FRE:integer:=100000000);    Port (        clk:in std_logic;        reset:in std_logic;        key_in:in std_logic;        output:out std_logic               );end key_stroke;architecture Behavioral of key_stroke istype states is(s0,s1,s2,s3);signal state:states;beginprocess(reset,clk,key_in)variable count_num:integer:=3*CLK_FRE/1000;--delay 3msvariable count:integer:=0;    begin        if reset=&#39;0&#39;then            state&lt;=s0;            count:=0;            output&lt;=&#39;0&#39;;        elsif(clk=&#39;1&#39;and clk&#39;event)then            case state is                when s0=&gt;if(key_in=&#39;1&#39;)then count:=0;output&lt;=&#39;0&#39;;state&lt;=s1;end if;                when s1=&gt;                    count:=count+1;                    if (count&gt;=count_num) then state&lt;=s2; end if;                when s2=&gt;                    if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s3;                    --if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s0;--one clk cycle                    elsif(key_in=&#39;0&#39;)then state&lt;=s0;                    end if;                when s3=&gt;if(key_in=&#39;0&#39;)then state&lt;=s0;end if;                                                                               end case;                       end if;     end process;end Behavioral;</code></pre><p> 数码管显示：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity seg_dis is    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end seg_dis;architecture Behavioral of seg_dis issignal data_in_line: std_logic_vector(3 downto 0);type states is(s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15);signal state,next_state:states;begin   process(rst,clk)begin     if(rst=&#39;1&#39;)then state&lt;=s0;    elsif(clk=&#39;1&#39;and clk&#39;event)then         state&lt;=next_state;    end if;end process;process(state)begin    case state is    when s0 =&gt;  seg_dig&lt;=not&quot;0000000000000001&quot;;   data_in_line&lt;=data_in_A(3 downto 0);   next_state&lt;=s1;    when s1 =&gt;  seg_dig&lt;=not&quot;0000000000000010&quot;;   data_in_line&lt;=data_in_A(7 downto 4);   next_state&lt;=s2;    when s2 =&gt;  seg_dig&lt;=not&quot;0000000000000100&quot;;   data_in_line&lt;=data_in_A(11 downto 8);  next_state&lt;=s3;    when s3 =&gt;  seg_dig&lt;=not&quot;0000000000001000&quot;;   data_in_line&lt;=data_in_A(15 downto 12); next_state&lt;=s4;       when s4 =&gt;  seg_dig&lt;=not&quot;0000000000010000&quot;;   data_in_line&lt;=data_in_B(3 downto 0);   next_state&lt;=s5;    when s5 =&gt;  seg_dig&lt;=not&quot;0000000000100000&quot;;   data_in_line&lt;=data_in_B(7 downto 4);   next_state&lt;=s6;    when s6 =&gt;  seg_dig&lt;=not&quot;0000000001000000&quot;;   data_in_line&lt;=data_in_B(11 downto 8);  next_state&lt;=s7;    when s7 =&gt;  seg_dig&lt;=not&quot;0000000010000000&quot;;   data_in_line&lt;=data_in_B(15 downto 12); next_state&lt;=s8;         when s8 =&gt;  seg_dig&lt;=not&quot;0000000100000000&quot;;   data_in_line&lt;=data_in_C(3 downto 0);   next_state&lt;=s9;    when s9 =&gt;  seg_dig&lt;=not&quot;0000001000000000&quot;;   data_in_line&lt;=data_in_C(7 downto 4);   next_state&lt;=s10;    when s10=&gt;  seg_dig&lt;=not&quot;0000010000000000&quot;;   data_in_line&lt;=data_in_C(11 downto 8);  next_state&lt;=s11;    when s11=&gt;  seg_dig&lt;=not&quot;0000100000000000&quot;;   data_in_line&lt;=data_in_C(15 downto 12); next_state&lt;=s12;    when s12=&gt;  seg_dig&lt;=not&quot;0001000000000000&quot;;   data_in_line&lt;=data_in_D(3 downto 0);   next_state&lt;=s13;    when s13=&gt;  seg_dig&lt;=not&quot;0010000000000000&quot;;   data_in_line&lt;=data_in_D(7 downto 4);   next_state&lt;=s14;    when s14=&gt;  seg_dig&lt;=not&quot;0100000000000000&quot;;   data_in_line&lt;=data_in_D(11 downto 8);  next_state&lt;=s15;    when s15=&gt;  seg_dig&lt;=not&quot;1000000000000000&quot;;   data_in_line&lt;=data_in_D(15 downto 12); next_state&lt;=s0;    when others=&gt;next_state&lt;=s0;    end case;end process;process(data_in_line)begin    case data_in_line is        when &quot;0000&quot;=&gt;seg_data&lt;=not&quot;00111111&quot;;        when &quot;0001&quot;=&gt;seg_data&lt;=not&quot;00000110&quot;;        when &quot;0010&quot;=&gt;seg_data&lt;=not&quot;01011011&quot;;        when &quot;0011&quot;=&gt;seg_data&lt;=not&quot;01001111&quot;;        when &quot;0100&quot;=&gt;seg_data&lt;=not&quot;01100110&quot;;        when &quot;0101&quot;=&gt;seg_data&lt;=not&quot;01101101&quot;;        when &quot;0110&quot;=&gt;seg_data&lt;=not&quot;01111101&quot;;        when &quot;0111&quot;=&gt;seg_data&lt;=not&quot;00000111&quot;;        when &quot;1000&quot;=&gt;seg_data&lt;=not&quot;01111111&quot;;        when &quot;1001&quot;=&gt;seg_data&lt;=not&quot;01101111&quot;;        when &quot;1010&quot;=&gt;seg_data&lt;=not&quot;01110111&quot;;        when &quot;1011&quot;=&gt;seg_data&lt;=not&quot;01111100&quot;;        when &quot;1100&quot;=&gt;seg_data&lt;=not&quot;00111001&quot;;        when &quot;1101&quot;=&gt;seg_data&lt;=not&quot;01011110&quot;;        when &quot;1110&quot;=&gt;seg_data&lt;=not&quot;01111001&quot;;        when &quot;1111&quot;=&gt;seg_data&lt;=not&quot;01110001&quot;;        when others=&gt;seg_data&lt;=not&quot;11111111&quot;;    end case;end process;end Behavioral;</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p>1.器件型号：xc7k160tfbg676-2</p><p>2.输入一般cmos18 输出cmos33</p><p>3.输入数码管的时钟需分频</p><p>4.按键加消抖</p><p>5.程序的运行结合.xdc文件进行理解</p><h3 id="1-跑马灯控制设计"><a href="#1-跑马灯控制设计" class="headerlink" title="1.跑马灯控制设计"></a>1.跑马灯控制设计</h3><pre><code>    功能叙述：初始情况下 Y0=‘1’，其它为‘0’。然后，在 en 为高电平的情况下，在时钟信 号 clk 的下降沿进行移位。当 dir=‘1’时，每来一个时钟信号，循环左移一位，当 dir=‘0’时， 每来一个时钟，循环右移一位。 另外，移位控制时钟可以选择为按键，即每按键一次相当于一个时钟信号，系统可以在 按键和系统分频时钟之间进行选择。</code></pre><p>资源使用：</p><p>1）用 LED0~LED7 作为跑马灯输出显示，LED7 为高位，LED0 为低位；</p><p>2）SW0 为循环方向控制；</p><p>3）SW1 为工作允许 EN 控制端；</p><p>4）计数时钟频率为 1Hz，通过对 50Mhz 系统时钟分频得到；</p><p>5）扩展：可以由按键来控制循环（按键为 BTN_SOUTH），即每按一次 BTN_SOUTH, 则完成一次移位。通过 SW2 选择移位控制时钟沿。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbc0bb7faf453566ef923063e4d002fb.png"></p><p>源文件：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity run_led is    Port(        en,dir,sel,clk,con:in std_logic;        y:out std_logic_vector(7 downto 0)    );end run_led;architecture Behavioral of run_led issignal input:std_logic;signal clk_div:std_logic;beginprocess(clk)variable clk_cnt:integer:=0;variable clk_cnt_2:integer:=0;begin     if(clk=&#39;1&#39;and clk&#39;event)then         clk_cnt_2:=clk_cnt_2+1;        if(clk_cnt_2&gt;=10000)then         clk_cnt:=clk_cnt+1;        clk_cnt_2:=0;        end if;        if(clk_cnt&lt;5000)then clk_div&lt;=&#39;1&#39;;        elsif(clk_cnt&gt;=5000)then clk_div&lt;=&#39;0&#39;;        end if;        if(clk_cnt&gt;=10000)then clk_cnt:=0;        end if;     end if;end process;process(clk,en,clk_div,con,sel)    begin        if(en=&#39;1&#39;)then            if(sel=&#39;0&#39;)then input&lt;=clk_div;            elsif(sel=&#39;1&#39;)then input&lt;=con;            end if;        elsif(en=&#39;0&#39;)then input&lt;=&#39;0&#39;;        end if;end process;process(input,dir)variable count:integer:=0;beginif(input=&#39;1&#39;and input&#39;event)then     if(dir=&#39;1&#39;)then        count:=count+1;        if(count&gt;7)then count:=0;end if;    elsif(dir=&#39;0&#39;)then         count:=count-1;        if(count&lt;0)then count:=7;end if;    end if;              if(count=0)then y&lt;=&quot;00000001&quot;;    elsif(count=1)then y&lt;=&quot;00000010&quot;;    elsif(count=2)then y&lt;=&quot;00000100&quot;;    elsif(count=3)then y&lt;=&quot;00001000&quot;;    elsif(count=4)then y&lt;=&quot;00010000&quot;;    elsif(count=5)then y&lt;=&quot;00100000&quot;;    elsif(count=6)then y&lt;=&quot;01000000&quot;;    elsif(count=7)then y&lt;=&quot;10000000&quot;;    else y&lt;=&quot;11111111&quot;;    end if;    end if;       end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity run_led_tb isend run_led_tb;architecture Behavioral of run_led_tb iscomponent run_led    Port(        en,dir,sel,clk,con:in std_logic;        y:out std_logic_vector(7 downto 0)    );end component;SIGNAL en,dir,sel,clk,con: std_logic;SIGNAL y: std_logic_vector(7 downto 0);beginrun_led_inst:run_led port map(en=&gt;en,dir=&gt;dir,sel=&gt;sel,clk=&gt;clk,con=&gt;con,y=&gt;y); clock:processbegin     clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;key:processbegin     con&lt;=&#39;1&#39;;    wait for 25ns;    con&lt;=&#39;0&#39;;    wait for 25ns;end process;test:processbegin    en&lt;=&#39;0&#39;;    sel&lt;=&#39;1&#39;;    dir&lt;=&#39;1&#39;;    wait for 25ns;    en&lt;=&#39;1&#39;;    wait;end process;end Behavioral;</code></pre><p>xdc:</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/18 13:02:24#----------------------------------------------------------------------------------set_property PACKAGE_PIN C9 [get_ports dir]set_property PACKAGE_PIN AF12 [get_ports con]set_property PACKAGE_PIN B9 [get_ports en]set_property PACKAGE_PIN E10 [get_ports clk]set_property PACKAGE_PIN G11 [get_ports sel]set_property PACKAGE_PIN G16 [get_ports &#123;y[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;y[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;y[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;y[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;y[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;y[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;y[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;y[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[3]&#125;]set_property DRIVE 12 [get_ports &#123;y[4]&#125;]set_property DRIVE 12 [get_ports &#123;y[5]&#125;]set_property DRIVE 12 [get_ports &#123;y[0]&#125;]set_property DRIVE 12 [get_ports &#123;y[6]&#125;]set_property DRIVE 12 [get_ports &#123;y[1]&#125;]set_property DRIVE 12 [get_ports &#123;y[7]&#125;]set_property DRIVE 12 [get_ports &#123;y[2]&#125;]set_property DRIVE 12 [get_ports &#123;y[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports dir]set_property IOSTANDARD LVCMOS18 [get_ports con]set_property IOSTANDARD LVCMOS18 [get_ports en]set_property IOSTANDARD LVCMOS18 [get_ports clk]set_property IOSTANDARD LVCMOS18 [get_ports sel]</code></pre><h3 id="2-8-位并行全加器设计-数码管显示程序设计"><a href="#2-8-位并行全加器设计-数码管显示程序设计" class="headerlink" title="2.8 位并行全加器设计+数码管显示程序设计"></a>2.8 位并行全加器设计+数码管显示程序设计</h3><p><strong>注：数码管部分未使用优化代码</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce6fd932b35130aa5e27c5aed20ea4d1.png"></p><pre><code>    其中 a_in，b_in：数据输入，使用板上开关（SW0~SW15）； sum_out：运算结果输出，使用 LED 显示运算结果。</code></pre><p>（1）用硬件描述语言实现 16 个七段数码管扫描显示模块</p><pre><code>    七段数码管扫描显示模块电路如图所示，主要包括顶层的数码管扫描显示模块，以及输入数据向七段数码管进行译码的模块。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c7d8f4a915fe5bd8c1ead81f14b23a98.png"></p><pre><code>    该模块实现数码管扫描显示功能，扩展板上的 16 个数码管四个一组，分为 A，B，C，D 四组。模块管脚说明如下：clk 为系统的时钟输入，rst 信号为复位信号，data_in_A(15:0)为 A 组四个数码管的输入显示值，其中，data_in_A(3:0)对应于第一个数码管的输入显示值； data_in_A(7:4)对应第二个数码管的输入显示值；data_in_A(11:8）对应第三个数码管的输入显 示值；data_in_A(15:12)对应第四个数码管的输入显示值，其它各组与 A 组分配一致； data_in_B(15:0)为 B 组四个数码管的输入显示值；data_in_C(15:0)为 C 组四个数码管的输入显 示值；data_in_D(15:0)为 D 组四个数码管的输入显示值；seg_sel(3:0)为数码管选择编码输出 信号，seg_data(7:0)为数码管显示数据输出。 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/80cc88d89b55bfa5281ac1e8bd0b69bc.png"></p><pre><code>    该模块实现将输入的 4 为二进制数转换为数码管显示的数据；其中，data_in(3:0)为输入 值，seg_data(7:0)为数码管编码的输出值。</code></pre><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity adder is    Port (        clk,rst:in std_logic;        a,b:in std_logic_vector(7 downto 0);        c:in std_logic;                c_out:out std_logic;        sel_out:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)     );end adder;architecture Behavioral of adder iscomponent clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);        seg_sel:out std_logic_vector(3 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end component;component decoder4_16    Port (        sel_in:in std_logic_vector(3 downto 0);        sel_out:out std_logic_vector(15 downto 0)     );end component;signal clk_out_line:std_logic;signal sum_line:std_logic_vector(16 downto 0);signal data_line:std_logic_vector(15 downto 0);signal c_line:std_logic;signal sel_out_line:std_logic_vector(3 downto 0);beginclk_div_inst:clk_div generic map(10000)port map(clk,clk_out_line);seg_dis_inst:seg_dis port map(rst,clk_out_line,data_line,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,sel_out_line,seg_data);decoder4_16_inst:decoder4_16 port map(sel_out_line,sel_out);process(a,b,c)begin      sum_line&lt;=(&quot;00000000&quot;&amp;a)+(&quot;00000000&quot;&amp;b)+(&quot;0000000000000000&quot;&amp;c);    data_line&lt;=sum_line(15 downto 0);    c_out&lt;=sum_line(16);end process;    end Behavioral;</code></pre><p>模块：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity decoder4_16 is    Port (        sel_in:in std_logic_vector(3 downto 0);        sel_out:out std_logic_vector(15 downto 0)     );end decoder4_16;architecture Behavioral of decoder4_16 isbeginprocess(sel_in)begin    case sel_in is    when &quot;0000&quot;=&gt;sel_out&lt;=not&quot;0000000000000001&quot;;    when &quot;0001&quot;=&gt;sel_out&lt;=not&quot;0000000000000010&quot;;    when &quot;0010&quot;=&gt;sel_out&lt;=not&quot;0000000000000100&quot;;    when &quot;0011&quot;=&gt;sel_out&lt;=not&quot;0000000000001000&quot;;    when &quot;0100&quot;=&gt;sel_out&lt;=not&quot;0000000000010000&quot;;    when &quot;0101&quot;=&gt;sel_out&lt;=not&quot;0000000000100000&quot;;    when &quot;0110&quot;=&gt;sel_out&lt;=not&quot;0000000001000000&quot;;    when &quot;0111&quot;=&gt;sel_out&lt;=not&quot;0000000010000000&quot;;    when &quot;1000&quot;=&gt;sel_out&lt;=not&quot;0000000100000000&quot;;    when &quot;1001&quot;=&gt;sel_out&lt;=not&quot;0000001000000000&quot;;    when &quot;1010&quot;=&gt;sel_out&lt;=not&quot;0000010000000000&quot;;    when &quot;1011&quot;=&gt;sel_out&lt;=not&quot;0000100000000000&quot;;    when &quot;1100&quot;=&gt;sel_out&lt;=not&quot;0001000000000000&quot;;    when &quot;1101&quot;=&gt;sel_out&lt;=not&quot;0010000000000000&quot;;    when &quot;1110&quot;=&gt;sel_out&lt;=not&quot;0100000000000000&quot;;    when &quot;1111&quot;=&gt;sel_out&lt;=not&quot;1000000000000000&quot;;    when others=&gt;sel_out&lt;=not&quot;1111111111111111&quot;;    end case;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity seg_dis is    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);        seg_sel:out std_logic_vector(3 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end seg_dis;architecture Behavioral of seg_dis iscomponent data2seg    port(        data_in:in std_logic_vector(3 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end component;signal data_in_line: std_logic_vector(3 downto 0);type states is(s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15);signal state,next_state:states;begin   data2seg_inst:data2seg port map(data_in_line,seg_data);process(rst,clk)begin     if(rst=&#39;1&#39;)then state&lt;=s0;    elsif(clk=&#39;1&#39;and clk&#39;event)then        state&lt;=next_state;    end if;end process;process(state)begin    case state is    when s0=&gt;        seg_sel&lt;=&quot;0000&quot;;        data_in_line&lt;=data_in_A(3 downto 0);        next_state&lt;=s1;    when s1=&gt;        seg_sel&lt;=&quot;0001&quot;;        data_in_line&lt;=data_in_A(7 downto 4);        next_state&lt;=s2;    when s2=&gt;        seg_sel&lt;=&quot;0010&quot;;        data_in_line&lt;=data_in_A(11 downto 8);        next_state&lt;=s3;    when s3=&gt;        seg_sel&lt;=&quot;0011&quot;;        data_in_line&lt;=data_in_A(15 downto 12);        next_state&lt;=s4;        when s4=&gt;seg_sel&lt;=&quot;0100&quot;;data_in_line&lt;=data_in_B(3 downto 0);next_state&lt;=s5;    when s5=&gt;seg_sel&lt;=&quot;0101&quot;;data_in_line&lt;=data_in_B(7 downto 4);next_state&lt;=s6;    when s6=&gt;seg_sel&lt;=&quot;0110&quot;;data_in_line&lt;=data_in_B(11 downto 8);next_state&lt;=s7;    when s7=&gt;seg_sel&lt;=&quot;0111&quot;;data_in_line&lt;=data_in_B(15 downto 12);next_state&lt;=s8;        when s8=&gt;seg_sel&lt;=&quot;1000&quot;;data_in_line&lt;=data_in_C(3 downto 0);next_state&lt;=s9;    when s9=&gt;seg_sel&lt;=&quot;1001&quot;;data_in_line&lt;=data_in_C(7 downto 4);next_state&lt;=s10;    when s10=&gt;seg_sel&lt;=&quot;1010&quot;;data_in_line&lt;=data_in_C(11 downto 8);next_state&lt;=s11;    when s11=&gt;seg_sel&lt;=&quot;1011&quot;;data_in_line&lt;=data_in_C(15 downto 12);next_state&lt;=s12;        when s12=&gt;seg_sel&lt;=&quot;1100&quot;;data_in_line&lt;=data_in_D(3 downto 0);next_state&lt;=s13;    when s13=&gt;seg_sel&lt;=&quot;1101&quot;;data_in_line&lt;=data_in_D(7 downto 4);next_state&lt;=s14;    when s14=&gt;seg_sel&lt;=&quot;1110&quot;;data_in_line&lt;=data_in_D(11 downto 8);next_state&lt;=s15;    when s15=&gt;seg_sel&lt;=&quot;1111&quot;;data_in_line&lt;=data_in_D(15 downto 12);next_state&lt;=s0;        when others=&gt;state&lt;=next_state;    end case;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity data2seg is    port(        data_in:in std_logic_vector(3 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end data2seg;architecture Behavioral of data2seg isbegin process(data_in)begin    case data_in is        when &quot;0000&quot;=&gt;seg_data&lt;=not&quot;00111111&quot;;        when &quot;0001&quot;=&gt;seg_data&lt;=not&quot;00000110&quot;;        when &quot;0010&quot;=&gt;seg_data&lt;=not&quot;01011011&quot;;        when &quot;0011&quot;=&gt;seg_data&lt;=not&quot;01001111&quot;;        when &quot;0100&quot;=&gt;seg_data&lt;=not&quot;01100110&quot;;        when &quot;0101&quot;=&gt;seg_data&lt;=not&quot;00110111&quot;;        when &quot;0110&quot;=&gt;seg_data&lt;=not&quot;01111101&quot;;        when &quot;0111&quot;=&gt;seg_data&lt;=not&quot;00000111&quot;;        when &quot;1000&quot;=&gt;seg_data&lt;=not&quot;01111111&quot;;        when &quot;1001&quot;=&gt;seg_data&lt;=not&quot;01101111&quot;;        when &quot;1010&quot;=&gt;seg_data&lt;=not&quot;01110111&quot;;        when &quot;1011&quot;=&gt;seg_data&lt;=not&quot;01111100&quot;;        when &quot;1100&quot;=&gt;seg_data&lt;=not&quot;00111000&quot;;        when &quot;1101&quot;=&gt;seg_data&lt;=not&quot;01011110&quot;;        when &quot;1110&quot;=&gt;seg_data&lt;=not&quot;01111001&quot;;        when &quot;1111&quot;=&gt;seg_data&lt;=not&quot;01110001&quot;;        when others=&gt;seg_data&lt;=not&quot;11111111&quot;;    end case;        end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity adder_tb is--  Port ( );end adder_tb;architecture Behavioral of adder_tb iscomponent adder    Port (        clk,rst:in std_logic;        a,b:in std_logic_vector(7 downto 0);        c:in std_logic;        c_out:out std_logic;        sel_out:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)     );end component;signal clk,rst :std_logic;signal a,b     :std_logic_vector(7 downto 0);signal c       :std_logic;signal c_out   : std_logic;signal sel_out : std_logic_vector(15 downto 0);signal seg_data: std_logic_vector(7 downto 0);beginadder_inst:adder port map(clk,rst,a,b,c,c_out,sel_out,seg_data);clock:processbegin    clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;restart:processbegin    rst&lt;=&#39;1&#39;;    wait for 25ns;    rst&lt;=&#39;0&#39;;    wait;end process;test:processbegin    a&lt;=&quot;00100010&quot;;    b&lt;=&quot;01000100&quot;;    c&lt;=&#39;1&#39;;    wait for 100ns;        a&lt;=&quot;11111111&quot;;    b&lt;=&quot;11111111&quot;;    c&lt;=&#39;1&#39;;    wait;end process;end Behavioral;</code></pre><p>xdc：</p><pre><code>set_property PACKAGE_PIN E26 [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26 [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26 [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21 [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21 [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23 [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24 [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21 [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[0]&#125;]set_property PACKAGE_PIN E10 [get_ports clk]set_property PACKAGE_PIN C9 [get_ports &#123;a[0]&#125;]set_property PACKAGE_PIN B9 [get_ports &#123;a[1]&#125;]set_property PACKAGE_PIN G11 [get_ports &#123;a[2]&#125;]set_property PACKAGE_PIN F10 [get_ports &#123;a[3]&#125;]set_property PACKAGE_PIN D10 [get_ports &#123;a[4]&#125;]set_property PACKAGE_PIN E11 [get_ports &#123;a[5]&#125;]set_property PACKAGE_PIN D11 [get_ports &#123;a[6]&#125;]set_property PACKAGE_PIN A14 [get_ports &#123;a[7]&#125;]set_property PACKAGE_PIN B10 [get_ports &#123;b[0]&#125;]set_property PACKAGE_PIN A10 [get_ports &#123;b[1]&#125;]set_property PACKAGE_PIN B15 [get_ports &#123;b[2]&#125;]set_property PACKAGE_PIN A15 [get_ports &#123;b[3]&#125;]set_property PACKAGE_PIN A13 [get_ports &#123;b[4]&#125;]set_property PACKAGE_PIN A12 [get_ports &#123;b[5]&#125;]set_property PACKAGE_PIN D8 [get_ports &#123;b[6]&#125;]set_property PACKAGE_PIN D9 [get_ports &#123;b[7]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[7]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[7]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports clk]set_property IOSTANDARD LVCMOS18 [get_ports rst]set_property IOSTANDARD LVCMOS33 [get_ports c_out]set_property IOSTANDARD LVCMOS18 [get_ports c]set_property PACKAGE_PIN J14 [get_ports c]set_property PACKAGE_PIN G16 [get_ports c_out]set_property PACKAGE_PIN J8 [get_ports rst]#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[0]&#125;]#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[1]&#125;]#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[2]&#125;]#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[3]&#125;]#set_property PACKAGE_PIN F8 [get_ports &#123;sel_in[0]&#125;]#set_property PACKAGE_PIN F9 [get_ports &#123;sel_in[1]&#125;]#set_property PACKAGE_PIN H11 [get_ports &#123;sel_in[2]&#125;]#set_property PACKAGE_PIN H12 [get_ports &#123;sel_in[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[10]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[15]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[12]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[13]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[8]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[11]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[14]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[9]&#125;]set_property PACKAGE_PIN A23 [get_ports &#123;sel_out[15]&#125;]set_property PACKAGE_PIN A24 [get_ports &#123;sel_out[14]&#125;]set_property PACKAGE_PIN D26 [get_ports &#123;sel_out[13]&#125;]set_property PACKAGE_PIN C26 [get_ports &#123;sel_out[12]&#125;]set_property PACKAGE_PIN A20 [get_ports &#123;sel_out[11]&#125;]set_property PACKAGE_PIN J25 [get_ports &#123;sel_out[10]&#125;]set_property PACKAGE_PIN J24 [get_ports &#123;sel_out[9]&#125;]set_property PACKAGE_PIN H22 [get_ports &#123;sel_out[8]&#125;]set_property PACKAGE_PIN K21 [get_ports &#123;sel_out[7]&#125;]set_property PACKAGE_PIN L23 [get_ports &#123;sel_out[6]&#125;]set_property PACKAGE_PIN B25 [get_ports &#123;sel_out[5]&#125;]set_property PACKAGE_PIN B26 [get_ports &#123;sel_out[4]&#125;]set_property PACKAGE_PIN C24 [get_ports &#123;sel_out[3]&#125;]set_property PACKAGE_PIN D21 [get_ports &#123;sel_out[2]&#125;]set_property PACKAGE_PIN C22 [get_ports &#123;sel_out[1]&#125;]set_property PACKAGE_PIN B20 [get_ports &#123;sel_out[0]&#125;]</code></pre><h3 id="3-阵列乘法器设计"><a href="#3-阵列乘法器设计" class="headerlink" title="3.阵列乘法器设计"></a>3.阵列乘法器设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9b23c4e7c365f7e9bd09cd34b890dbe.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8ebdee3a1727312ec82f82a48997c04.png"></p><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier_seg is    Port (        rst,clk:in std_logic;        a_in,b_in:in std_logic_vector(7 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end array_multiplier_seg;architecture Behavioral of array_multiplier_seg iscomponent clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        clk_in:in std_logic;        clk_out:out std_logic    );end component;component array_multiplier    Port (        clk:in std_logic;        a_in,b_in:in std_logic_vector(7 downto 0);        sum_out:out std_logic_vector(15 downto 0)    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);        seg_sel:out std_logic_vector(3 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end component;component decoder4_16    Port (        sel_in:in std_logic_vector(3 downto 0);        sel_out:out std_logic_vector(15 downto 0)     );end component;signal clk_out_line:std_logic;signal sum_out_line:std_logic_vector(15 downto 0);signal seg_dig_line:std_logic_vector(3 downto 0);beginclk_div_inst:clk_div generic map(10000)port map(clk,clk_out_line);array_multiplier_inst:array_multiplier port map(clk_out_line,a_in,b_in,sum_out_line);seg_dis_inst:seg_dis port map(rst,clk_out_line,sum_out_line,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,seg_dig_line,seg_data);decoder4_16_inst:decoder4_16 port map(seg_dig_line,seg_dig);end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/48f312e41997369070448630c369ef88.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier is    Port (        clk:in std_logic;        a_in,b_in:in std_logic_vector(7 downto 0);        sum_out:out std_logic_vector(15 downto 0)    );end array_multiplier;architecture Behavioral of array_multiplier iscomponent array_multiplier_top    Port (        a_in:in std_logic;        b_in:in std_logic_vector(7 downto 0);        s:out std_logic_vector(7 downto 0)     );end component;component array_multiplier_unit    Port (        x_in:in std_logic;        y_in:in std_logic_vector(7 downto 0);        c_in:in std_logic_vector(6 downto 0);        z_in:in std_logic_vector(7 downto 0);        c_out:out std_logic_vector(6 downto 0);        z_out:out std_logic_vector(7 downto 0)     );end component;component array_multiplier_low    Port (        z_in,c_in:in std_logic_vector(6 downto 0);        s_out:out std_logic_vector(7 downto 0)     );end component;signal z_in0:std_logic_vector(7 downto 0);signal z_in1:std_logic_vector(7 downto 0);signal z_in2:std_logic_vector(7 downto 0);signal z_in3:std_logic_vector(7 downto 0);signal z_in4:std_logic_vector(7 downto 0);signal z_in5:std_logic_vector(7 downto 0);signal z_in6:std_logic_vector(7 downto 0);signal z_in7:std_logic_vector(7 downto 0);signal c_in1:std_logic_vector(6 downto 0);signal c_in2:std_logic_vector(6 downto 0);signal c_in3:std_logic_vector(6 downto 0);signal c_in4:std_logic_vector(6 downto 0);signal c_in5:std_logic_vector(6 downto 0);signal c_in6:std_logic_vector(6 downto 0);signal c_in7:std_logic_vector(6 downto 0);beginarray_multiplier_top_inst:array_multiplier_top port map(a_in(0),b_in,z_in0);array_multiplier_unit_inst1:array_multiplier_unit port map(a_in(1),b_in,&quot;0000000&quot;,z_in0,c_in1,z_in1);array_multiplier_unit_inst2:array_multiplier_unit port map(a_in(2),b_in,c_in1,z_in1,c_in2,z_in2);array_multiplier_unit_inst3:array_multiplier_unit port map(a_in(3),b_in,c_in2,z_in2,c_in3,z_in3);array_multiplier_unit_inst4:array_multiplier_unit port map(a_in(4),b_in,c_in3,z_in3,c_in4,z_in4);array_multiplier_unit_inst5:array_multiplier_unit port map(a_in(5),b_in,c_in4,z_in4,c_in5,z_in5);array_multiplier_unit_inst6:array_multiplier_unit port map(a_in(6),b_in,c_in5,z_in5,c_in6,z_in6);array_multiplier_unit_inst7:array_multiplier_unit port map(a_in(7),b_in,c_in6,z_in6,c_in7,z_in7);array_multiplier_low_inst:array_multiplier_low port map(z_in7(7 downto 1),c_in7,sum_out(15 downto 8));process(clk,a_in,b_in)begin    sum_out(0)&lt;=z_in0(0);    sum_out(1)&lt;=z_in1(0);    sum_out(2)&lt;=z_in2(0);    sum_out(3)&lt;=z_in3(0);    sum_out(4)&lt;=z_in4(0);    sum_out(5)&lt;=z_in5(0);    sum_out(6)&lt;=z_in6(0);    sum_out(7)&lt;=z_in7(0);end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2b81a5e7b42395fba8c9fb656d835fd.png"></p><p>模块：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier_top is    Port (        a_in:in std_logic;        b_in:in std_logic_vector(7 downto 0);        s:out std_logic_vector(7 downto 0)     );end array_multiplier_top;architecture Behavioral of array_multiplier_top isbeginprocess(a_in,b_in)begin    for i in 0 to 7 loop       s(i)&lt;=a_in and b_in(i);     end loop;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier_unit is    Port (        x_in:in std_logic;        y_in:in std_logic_vector(7 downto 0);        c_in:in std_logic_vector(6 downto 0);        z_in:in std_logic_vector(7 downto 0);        c_out:out std_logic_vector(6 downto 0);        z_out:out std_logic_vector(7 downto 0)     );end array_multiplier_unit;architecture Behavioral of array_multiplier_unit iscomponent adder_1bit    Port (        a,b,c_in:in std_logic;        s,c_out:out std_logic     );end component;signal a_line:std_logic_vector(7 downto 0);beginadder_1bit_inst1:adder_1bit port map(a_line(0),c_in(0),z_in(1),z_out(0),c_out(0));adder_1bit_inst2:adder_1bit port map(a_line(1),c_in(1),z_in(2),z_out(1),c_out(1));adder_1bit_inst3:adder_1bit port map(a_line(2),c_in(2),z_in(3),z_out(2),c_out(2));adder_1bit_inst4:adder_1bit port map(a_line(3),c_in(3),z_in(4),z_out(3),c_out(3));adder_1bit_inst5:adder_1bit port map(a_line(4),c_in(4),z_in(5),z_out(4),c_out(4));adder_1bit_inst6:adder_1bit port map(a_line(5),c_in(5),z_in(6),z_out(5),c_out(5));adder_1bit_inst7:adder_1bit port map(a_line(6),c_in(6),z_in(7),z_out(6),c_out(6));process(x_in,y_in)begin     z_out(7)&lt;=x_in and y_in(7);    for i in 0 to 7 loop       a_line(i)&lt;=x_in and y_in(i);    end loop;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a2c62b9b632c261aa03fc7767147d496.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier_low is    Port (        z_in,c_in:in std_logic_vector(6 downto 0);        s_out:out std_logic_vector(7 downto 0)     );end array_multiplier_low;architecture Behavioral of array_multiplier_low iscomponent adder_1bit    Port (        a,b,c_in:in std_logic;        s,c_out:out std_logic     );end component;signal c_line:std_logic_vector(5 downto 0);beginadder_1bit_inst0:adder_1bit port map(z_in(0),c_in(0),&#39;0&#39;,s_out(0),c_line(0));adder_1bit_inst1:adder_1bit port map(z_in(1),c_in(1),c_line(0),s_out(1),c_line(1));adder_1bit_inst2:adder_1bit port map(z_in(2),c_in(2),c_line(1),s_out(2),c_line(2));adder_1bit_inst3:adder_1bit port map(z_in(3),c_in(3),c_line(2),s_out(3),c_line(3));adder_1bit_inst4:adder_1bit port map(z_in(4),c_in(4),c_line(3),s_out(4),c_line(4));adder_1bit_inst5:adder_1bit port map(z_in(5),c_in(5),c_line(4),s_out(5),c_line(5));adder_1bit_inst6:adder_1bit port map(z_in(6),c_in(6),c_line(5),s_out(6),s_out(7));end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity adder_1bit is    Port (        a,b,c_in:in std_logic;        s,c_out:out std_logic     );end adder_1bit;architecture Behavioral of adder_1bit isbeginprocess(a,b,c_in)begin    s&lt;=a xor b xor c_in;    c_out&lt;=(a and b)or((a xor b)and c_in);end process;end Behavioral;</code></pre><p>testbench:</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity array_multiplier_tb is--  Port ( );end array_multiplier_tb;architecture Behavioral of array_multiplier_tb iscomponent array_multiplier_seg    Port (        rst,clk:in std_logic;        a_in,b_in:in std_logic_vector(7 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)    );end component;signal rst,clk:std_logic;signal a_in,b_in:std_logic_vector(7 downto 0);signal seg_dig:std_logic_vector(15 downto 0);signal seg_data:std_logic_vector(7 downto 0);beginarray_multiplier_seg_inst:array_multiplier_seg port map(rst,clk,a_in,b_in,seg_dig,seg_data);clock:processbegin     clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;restart:processbegin    rst&lt;=&#39;1&#39;;    wait for 25ns;    rst&lt;=&#39;0&#39;;    wait;end process;test:processbegin    a_in&lt;=&quot;10111101&quot;;    b_in&lt;=&quot;11001010&quot;;    wait;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c1acafbbcf9f2fcb9878c936a3f2244.png"></p><p>xdc:</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/18 13:02:24#----------------------------------------------------------------------------------#CLK_100Mset_property PACKAGE_PIN E10 [get_ports clk]set_property IOSTANDARD LVCMOS18 [get_ports clk]#SW0~15set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[7]&#125;]set_property PACKAGE_PIN C9 [get_ports &#123;a_in[0]&#125;]set_property PACKAGE_PIN B9 [get_ports &#123;a_in[1]&#125;]set_property PACKAGE_PIN G11 [get_ports &#123;a_in[2]&#125;]set_property PACKAGE_PIN F10 [get_ports &#123;a_in[3]&#125;]set_property PACKAGE_PIN D10 [get_ports &#123;a_in[4]&#125;]set_property PACKAGE_PIN E11 [get_ports &#123;a_in[5]&#125;]set_property PACKAGE_PIN D11 [get_ports &#123;a_in[6]&#125;]set_property PACKAGE_PIN A14 [get_ports &#123;a_in[7]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[7]&#125;]set_property PACKAGE_PIN B10 [get_ports &#123;b_in[0]&#125;]set_property PACKAGE_PIN A10 [get_ports &#123;b_in[1]&#125;]set_property PACKAGE_PIN B15 [get_ports &#123;b_in[2]&#125;]set_property PACKAGE_PIN A15 [get_ports &#123;b_in[3]&#125;]set_property PACKAGE_PIN A13 [get_ports &#123;b_in[4]&#125;]set_property PACKAGE_PIN A12 [get_ports &#123;b_in[5]&#125;]set_property PACKAGE_PIN D8 [get_ports &#123;b_in[6]&#125;]set_property PACKAGE_PIN D9 [get_ports &#123;b_in[7]&#125;]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23 [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24 [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26 [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26 [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20 [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25 [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24 [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22 [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21 [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23 [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25 [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26 [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24 [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21 [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22 [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20 [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26 [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26 [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26 [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21 [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21 [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23 [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24 [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21 [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[0]&#125;]set_property PACKAGE_PIN J8 [get_ports rst]set_property IOSTANDARD LVCMOS18 [get_ports rst]</code></pre><h3 id="4-先进先出-FIFO-的设计"><a href="#4-先进先出-FIFO-的设计" class="headerlink" title="4.先进先出 FIFO 的设计"></a>4.先进先出 FIFO 的设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/311aeef9dede913202b7df632c3aa302.png"></p><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24-- Module Name: FIFO_ring_test - Behavioral----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity FIFO_ring_test isgeneric(    CLK_FRE:integer:=100000000;    cycle_max:positive:=3;--最大读写圈数    depth:positive:=3;    width:positive:=8);    Port(        clk:in std_logic;        rst:in std_logic;        key_in:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end FIFO_ring_test;architecture Behavioral of FIFO_ring_test iscomponent key_stroke    generic(CLK_FRE:integer:=100000000);    Port (        clk:in std_logic;        reset:in std_logic;        key_in:in std_logic;        output:out std_logic               );end component;component FIFO_ringgeneric(    cycle_max:positive:=3;--最大读写圈数    depth:positive:=3;    width:positive:=8);    Port(        clk,clk_rd,clk_wr:in std_logic;        rst:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end component;signal out_put:std_logic;beginkey_stroke_inst:key_stroke generic map(CLK_FRE)port map(clk=&gt;clk,reset=&gt;rst,key_in=&gt;key_in,output=&gt;out_put);FIFO_ring_inst:FIFO_ring generic map(cycle_max,depth,width)port map(rst=&gt;rst,clk=&gt;clk,clk_rd=&gt;out_put,clk_wr=&gt;out_put,wr=&gt;wr,rd=&gt;rd,data_in=&gt;data_in,full=&gt;full,empty=&gt;empty,data_out=&gt;data_out);end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24-- Module Name: FIFO_ring - Behavioral----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity FIFO_ring isgeneric(    cycle_max:positive:=3;--最大读写圈数    depth:positive:=3;    width:positive:=8);    Port(        clk,clk_rd,clk_wr:in std_logic;        rst:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end FIFO_ring;architecture Behavioral of FIFO_ring iscomponent duaramgeneric(    depth:positive:=3;    width:positive:=8);Port(    clka:in std_logic;    wr:in std_logic;    wr_en:in std_logic;    addra:in std_logic_vector(depth-1 downto 0);    datain:in std_logic_vector(width-1 downto 0);        clkb:in std_logic;    rd:in std_logic;    rd_en:in std_logic;    addrb:in std_logic_vector(depth-1 downto 0);    dataout:out std_logic_vector(width-1 downto 0)); end component;component FIFO_ring_duaram_controllergeneric(    cycle_max:positive;--最大读写圈数    depth:positive);Port(    rst:in std_logic;    clk,clka,clkb:in std_logic;    wq:in std_logic;    rq:in std_logic;    full:out std_logic;    empty:out std_logic;        wr_pt:out std_logic_vector(depth-1 downto 0);    rd_pt:out std_logic_vector(depth-1 downto 0));end component;signal rp_line:std_logic_vector(depth-1 downto 0);signal wp_line:std_logic_vector(depth-1 downto 0);signal empty_line:std_logic;signal full_line:std_logic;beginduaram_inst:duaram generic map(depth,width)port map(clka=&gt;clk_wr,clkb=&gt;clk_rd,datain=&gt;data_in,dataout=&gt;data_out,addra=&gt;wp_line,addrb=&gt;rp_line,rd=&gt;rd,wr=&gt;wr,rd_en=&gt;empty_line,wr_en=&gt;full_line);FIFO_ring_duaram_controller_inst:FIFO_ring_duaram_controller generic map(cycle_max,depth)port map(rst=&gt;rst,clk=&gt;clk,clkb=&gt;clk_rd,clka=&gt;clk_wr,wq=&gt;wr,rq=&gt;rd,full=&gt;full_line,empty=&gt;empty_line,wr_pt=&gt;wp_line,rd_pt=&gt;rp_line);process(empty_line,full_line)begin    empty&lt;=empty_line;    full&lt;=full_line;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a99a9296939596a5890faf5f0a592e12.png"></p><p>模块：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24-- Module Name: FIFO_ring - Behavioral----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity duaram is    generic(        depth:positive;        width:positive    );    Port(        clka:in std_logic;        wr:in std_logic;        wr_en:in std_logic;        addra:in std_logic_vector(depth-1 downto 0);        datain:in std_logic_vector(width-1 downto 0);                clkb:in std_logic;        rd:in std_logic;        rd_en:in std_logic;        addrb:in std_logic_vector(depth-1 downto 0);        dataout:out std_logic_vector(width-1 downto 0)    );end duaram;architecture Behavioral of duaram istype ram is array(2**depth-1 downto 0)of std_logic_vector(width-1 downto 0);signal dualram:ram;begin    process(clka)    begin        if(clka&#39;event and clka=&#39;1&#39;)then            if(wr=&#39;0&#39;and wr_en=&#39;0&#39;)then dualram(conv_integer(addra))&lt;=datain;end if;        end if;    end process;        process(clkb)    begin        if(clkb&#39;event and clkb=&#39;1&#39;)then            if(rd=&#39;0&#39;and rd_en=&#39;0&#39;)then dataout&lt;=dualram(conv_integer(addrb));end if;        end if;    end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24-- Module Name: FIFO_ring_duaram_controller - Behavioral----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity FIFO_ring_duaram_controller isgeneric(    cycle_max:positive;--最大读写圈数    depth:positive);Port(    rst:in std_logic;    clk,clka,clkb:in std_logic;    wq:in std_logic;    rq:in std_logic;    full:out std_logic;    empty:out std_logic;        wr_pt:out std_logic_vector(depth-1 downto 0);    rd_pt:out std_logic_vector(depth-1 downto 0));end FIFO_ring_duaram_controller;architecture Behavioral of FIFO_ring_duaram_controller issignal wr_pt_t:std_logic_vector(depth+cycle_max-1 downto 0);signal rd_pt_t:std_logic_vector(depth+cycle_max-1 downto 0);signal full_line:std_logic;signal empty_line:std_logic;begin--write_pointerprocess(rst,clka)begin    if(rst=&#39;0&#39;)then        wr_pt_t&lt;=(others=&gt;&#39;0&#39;);    elsif(clka&#39;event and clka=&#39;1&#39;)then        if (wq=&#39;0&#39;and full_line=&#39;0&#39;)then wr_pt_t&lt;=wr_pt_t+1;end if;    end if;     end process;--read_pointerprocess(rst,clkb)begin    if(rst=&#39;0&#39;)then        rd_pt_t&lt;=(others=&gt;&#39;0&#39;);    elsif(clkb&#39;event and clkb=&#39;1&#39;)then        if (rq=&#39;0&#39;and empty_line=&#39;0&#39;)then rd_pt_t&lt;=rd_pt_t+1;end if;    end if;end process;--judge_statusprocess(rst,clk)begin    if(rst=&#39;0&#39;)then empty_line&lt;=&#39;1&#39;;full_line&lt;=&#39;0&#39;;    elsif(clk&#39;event and clk=&#39;1&#39;)then        if(wr_pt_t=rd_pt_t)then empty_line&lt;=&#39;1&#39;;full_line&lt;=&#39;0&#39;;        elsif(wr_pt_t=rd_pt_t+2**depth)then empty_line&lt;=&#39;0&#39;;full_line&lt;=&#39;1&#39;;        else empty_line&lt;=&#39;0&#39;;full_line&lt;=&#39;0&#39;;        end if;    end if;  end process;process(wr_pt_t)begin wr_pt&lt;=wr_pt_t(depth-1 downto 0);end process;process(rd_pt_t)begin rd_pt&lt;=rd_pt_t(depth-1 downto 0);end process;process(empty_line)begin empty&lt;=empty_line;end process;process(full_line)begin full&lt;=full_line;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24-- Module Name: FIFO_ring_tb - Behavioral----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity FIFO_ring_tb is--  Port ( );end FIFO_ring_tb;architecture Behavioral of FIFO_ring_tb iscomponent FIFO_ring_testgeneric(    CLK_FRE:integer:=100000000;    cycle_max:positive:=3;--最大读写圈数    depth:positive:=3;    width:positive:=8);    Port(        clk:in std_logic;        rst:in std_logic;        key_in:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end component;signal clk:std_logic;signal rst:std_logic;signal key_in:std_logic;signal data_in:std_logic_vector(7 downto 0);signal wr:std_logic;signal rd:std_logic;signal empty:std_logic;signal full:std_logic;signal data_out:std_logic_vector(7 downto 0);beginFIFO_ring_test_inst:FIFO_ring_test generic map(100000000,3,8)port map(clk,rst,key_in,data_in,wr,rd,empty,full,data_out);clock:processbegin    clk&lt;=&#39;0&#39;;    wait for 5ns;    clk&lt;=&#39;1&#39;;    wait for 5ns;end process;reset:processbegin    rst&lt;=&#39;0&#39;;    wait for 25ns;    rst&lt;=&#39;1&#39;;    wait;end process;test:processbegin    rd&lt;=&#39;1&#39;;    wr&lt;=&#39;1&#39;;    data_in&lt;=&quot;00000000&quot;;    key_in&lt;=&#39;0&#39;;    wait for 4ms;        rd&lt;=&#39;1&#39;;    wr&lt;=&#39;0&#39;;    data_in&lt;=&quot;00000001&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00000010&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00000100&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00001000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00010000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00100000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;01000000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;10000000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;11111111&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;00001111&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=&quot;11110000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;        wr&lt;=&#39;1&#39;;    rd&lt;=&#39;0&#39;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;        rd&lt;=&#39;1&#39;;    wr&lt;=&#39;0&#39;;    data_in&lt;=not&quot;00000001&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00000010&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00000100&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00001000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00010000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00100000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;01000000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;10000000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;11111111&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;00001111&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    data_in&lt;=not&quot;11110000&quot;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;        wr&lt;=&#39;1&#39;;    rd&lt;=&#39;0&#39;;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;    wait for 4ms;    key_in&lt;=&#39;1&#39;;    wait for 4ms;    key_in&lt;=&#39;0&#39;;    wait for 4ms;        wait;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/36a731b3be24e70c8626b6c8ffc27d7b.png"></p><p>xdc：</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/18 13:02:24#----------------------------------------------------------------------------------set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN C9 [get_ports &#123;data_in[0]&#125;]set_property PACKAGE_PIN B9 [get_ports &#123;data_in[1]&#125;]set_property PACKAGE_PIN G11 [get_ports &#123;data_in[2]&#125;]set_property PACKAGE_PIN F10 [get_ports &#123;data_in[3]&#125;]set_property PACKAGE_PIN D10 [get_ports &#123;data_in[4]&#125;]set_property PACKAGE_PIN E11 [get_ports &#123;data_in[5]&#125;]set_property PACKAGE_PIN D11 [get_ports &#123;data_in[6]&#125;]set_property PACKAGE_PIN A14 [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN E10 [get_ports clk]set_property IOSTANDARD LVCMOS18 [get_ports clk]#sw31set_property PACKAGE_PIN J8 [get_ports rst]set_property IOSTANDARD LVCMOS18 [get_ports rst]#sw30set_property PACKAGE_PIN J14 [get_ports key_in]set_property IOSTANDARD LVCMOS18 [get_ports key_in]#sw29set_property PACKAGE_PIN H9 [get_ports wr]set_property IOSTANDARD LVCMOS18 [get_ports wr]#sw28set_property PACKAGE_PIN H8 [get_ports rd]set_property IOSTANDARD LVCMOS18 [get_ports rd]#led15set_property PACKAGE_PIN L20 [get_ports empty]set_property IOSTANDARD LVCMOS33 [get_ports empty]#led11set_property PACKAGE_PIN J20 [get_ports full]set_property IOSTANDARD LVCMOS33 [get_ports full]#led0-7set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[7]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;data_out[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;data_out[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;data_out[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;data_out[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;data_out[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;data_out[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;data_out[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;data_out[7]&#125;]</code></pre><h3 id="5-PC-程序计数器设计"><a href="#5-PC-程序计数器设计" class="headerlink" title="5.PC 程序计数器设计"></a>5.PC 程序计数器设计</h3><p> PC 功能分析 加 1 功能、更新地址功能、PC 数值送到数据总线</p><p> PC 功能实现</p><p>1）全局异步复位功能</p><pre><code>     ADDR&lt;=“000000000000”;     数据总线高阻态;</code></pre><p>2）加 1 功能</p><pre><code>     clk_PC 上升沿有效;     M_PC 高电平有效，PC+1=&gt;ADDR;</code></pre><p>3）地址更新功能</p><pre><code>     clk_PC 上升沿有效，nLD_PC 低电平有效，新的 PC=&gt;ADDR；     PC 数值送到数据总线，nPCH 和 nPCL 低电平有效，注意分两次输出到总线上，先高 8 位后低 8 位。</code></pre><p><strong>注：自行添加按键消抖模块</strong></p><p>源码：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity pc is    Port (                rst,clk_PC,M_PC,nLD_PC:in std_logic;        PC_in:in std_logic_vector(11 downto 0);                DATA_BUS:inout std_logic_vector(7 downto 0);                nPCH,nPCL:out std_logic     );end pc;architecture Behavioral of pc issignal pc_count:std_logic_vector(11 downto 0);signal ADDR:std_logic_vector(11 downto 0);beginprocess(rst,clk_PC)variable addr_count:integer:=0;begin    if(rst=&#39;1&#39;)then         pc_count&lt;=PC_in;        ADDR&lt;=pc_count;        DATA_BUS&lt;=&quot;XXXXXXXX&quot;;        nPCH&lt;=&#39;1&#39;;nPCL&lt;=&#39;1&#39;;    elsif(clk_PC=&#39;1&#39;and clk_PC&#39;event)then        if(addr_count=0)then pc_count&lt;=pc_count+1;end if;        if(M_PC=&#39;1&#39;)then ADDR&lt;=pc_count;end if;        if(nLD_PC=&#39;0&#39;)then             if(addr_count=0)then DATA_BUS&lt;=&quot;0000&quot;&amp; ADDR(11 downto 8);addr_count:=addr_count+1;nPCH&lt;=&#39;0&#39;;nPCL&lt;=&#39;1&#39;;            elsif(addr_count=1)then DATA_BUS&lt;=ADDR(7 downto 0);addr_count:=addr_count-1;nPCH&lt;=&#39;1&#39;;nPCL&lt;=&#39;0&#39;;            end if;        end if;    end if;end process;end Behavioral;</code></pre><p>xdc:</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/18 13:02:24#----------------------------------------------------------------------------------set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;PC_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;PC_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;PC_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;PC_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;PC_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;PC_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;PC_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;PC_in[7]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[8]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[9]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[10]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[11]&#125;]set_property PACKAGE_PIN B10        [get_ports &#123;PC_in[8]&#125;]set_property PACKAGE_PIN A10        [get_ports &#123;PC_in[9]&#125;]set_property PACKAGE_PIN B15        [get_ports &#123;PC_in[10]&#125;]set_property PACKAGE_PIN A15        [get_ports &#123;PC_in[11]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[7]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;DATA_BUS[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;DATA_BUS[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;DATA_BUS[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;DATA_BUS[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;DATA_BUS[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;DATA_BUS[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;DATA_BUS[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;DATA_BUS[7]&#125;]#sw31set_property PACKAGE_PIN J8 [get_ports rst]set_property IOSTANDARD LVCMOS18 [get_ports rst]#sw30set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_PC]set_property PACKAGE_PIN J14 [get_ports clk_PC]set_property IOSTANDARD LVCMOS18 [get_ports clk_PC]#sw29set_property PACKAGE_PIN H9 [get_ports M_PC]set_property IOSTANDARD LVCMOS18 [get_ports M_PC]#sw28set_property PACKAGE_PIN H8 [get_ports nLD_PC]set_property IOSTANDARD LVCMOS18 [get_ports nLD_PC]#led15set_property PACKAGE_PIN L20 [get_ports nPCH]set_property IOSTANDARD LVCMOS33 [get_ports nPCH]#led11set_property PACKAGE_PIN J20 [get_ports nPCL]set_property IOSTANDARD LVCMOS33 [get_ports nPCL]</code></pre><h3 id="6-程序存储器-ROM-设计"><a href="#6-程序存储器-ROM-设计" class="headerlink" title="6.程序存储器 ROM 设计"></a>6.程序存储器 ROM 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ca1179f853bd18943bce21382adae2c2.png"></p><p>源码：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_unsigned.ALL;use IEEE.STD_LOGIC_textio.ALL;use std.textio.all;entity ROM is    generic(        depth:positive:=12;        width:positive:=8    );    Port (        clk_ROM,M_ROM,ROM_EN:in std_logic;        addr:in std_logic_vector(11 downto 0);        DATA_BUS:inout std_logic_vector(7 downto 0)    );end ROM;architecture Behavioral of ROM istype matrix is array (integer range&lt;&gt;)of std_logic_vector(width-1 downto 0);signal rom:matrix(0 to 2**depth-1);procedure load_rom (signal data_word:out matrix)isfile romfile:text open read_mode is &quot;romfile.dat&quot;;variable lbuf:line;variable i:integer:=0;variable fdata:std_logic_vector(7 downto 0);begin    while(not endfile(romfile)and i&lt;2**depth)loop        readline(romfile,lbuf);        read(lbuf,fdata);        data_word(i)&lt;=fdata;        i:=i+1;    end loop;end procedure;beginload_rom(rom);process(clk_ROM)begin    if(clk_ROM=&#39;1&#39;and clk_ROM&#39;event)then                if(ROM_EN=&#39;0&#39;and M_ROM=&#39;1&#39;)then            DATA_BUS&lt;=rom(conv_integer(addr));        else DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);        end if;    end if;end process;                end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 13:02:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity ROM_tb is--  Port ( );end ROM_tb;architecture Behavioral of ROM_tb iscomponent ROM    generic(        depth:positive:=12;        width:positive:=8    );    Port (        clk_ROM,M_ROM,ROM_EN:in std_logic;        addr:in std_logic_vector(11 downto 0);        DATA_BUS:inout std_logic_vector(7 downto 0)    );end component;signal rst:std_logic;signal clk_ROM,M_ROM,ROM_EN:std_logic;signal addr:std_logic_vector(11 downto 0);signal DATA_BUS:std_logic_vector(7 downto 0);beginROM_inst:ROM generic map(12,8)port map(clk_ROM,M_ROM,ROM_EN,addr,DATA_BUS);clock:processbegin    clk_ROM&lt;=&#39;1&#39;;    wait for 5ns;    clk_ROM&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    M_ROM&lt;=&#39;0&#39;;    ROM_EN&lt;=&#39;1&#39;;    addr&lt;=(others=&gt;&#39;0&#39;);    wait for 25ns;    M_ROM&lt;=&#39;1&#39;;    wait for 25ns;    ROM_EN&lt;=&#39;0&#39;;        wait for 5ns;    addr&lt;=&quot;000000000000&quot;;    wait for 20ns;      wait for 5ns;    addr&lt;=&quot;000000000001&quot;;    wait for 20ns;    wait for 5ns;    addr&lt;=&quot;000000000010&quot;;    wait for 20ns;    wait for 5ns;    addr&lt;=&quot;000000000011&quot;;    wait for 20ns;        wait;end process;end Behavioral;</code></pre><p>xdc:</p><pre><code>set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[6]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[7]&#125;]set_property PACKAGE_PIN C9 [get_ports &#123;addr[0]&#125;]set_property PACKAGE_PIN B9 [get_ports &#123;addr[1]&#125;]set_property PACKAGE_PIN G11 [get_ports &#123;addr[2]&#125;]set_property PACKAGE_PIN F10 [get_ports &#123;addr[3]&#125;]set_property PACKAGE_PIN D10 [get_ports &#123;addr[4]&#125;]set_property PACKAGE_PIN E11 [get_ports &#123;addr[5]&#125;]set_property PACKAGE_PIN D11 [get_ports &#123;addr[6]&#125;]set_property PACKAGE_PIN A14 [get_ports &#123;addr[7]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[8]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[9]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[10]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[11]&#125;]set_property PACKAGE_PIN B10 [get_ports &#123;addr[8]&#125;]set_property PACKAGE_PIN A10 [get_ports &#123;addr[9]&#125;]set_property PACKAGE_PIN B15 [get_ports &#123;addr[10]&#125;]set_property PACKAGE_PIN A15 [get_ports &#123;addr[11]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[7]&#125;]set_property PACKAGE_PIN G16 [get_ports &#123;DATA_BUS[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;DATA_BUS[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;DATA_BUS[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;DATA_BUS[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;DATA_BUS[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;DATA_BUS[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;DATA_BUS[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;DATA_BUS[7]&#125;]#sw30set_property PACKAGE_PIN J14 [get_ports ROM_EN]set_property IOSTANDARD LVCMOS18 [get_ports ROM_EN]#sw31set_property PACKAGE_PIN J8 [get_ports M_ROM]set_property IOSTANDARD LVCMOS18 [get_ports M_ROM]set_property PACKAGE_PIN E10 [get_ports clk_ROM]set_property IOSTANDARD LVCMOS18 [get_ports clk_ROM]</code></pre><h3 id="7-加减交替除法器"><a href="#7-加减交替除法器" class="headerlink" title="7.加减交替除法器"></a>7.加减交替除法器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/36f7c7ddcdd765b4f80b09904c236f2c.png"></p><p>原码加减交替除法器的运算法则：</p><p>1）除法运算前，应满足条件：X*&lt;Y*,且 Y*≠0,否则，按溢出或非法除数处理；</p><p>2）符号位不参与运算，单独处理：qf&#x3D; xf xor yf ;</p><p>3）部分余数采用单符号位或双符号位；</p><p>4）每步部分余数运算规则：</p><pre><code>    ①若余数 R≥0, 则商上 1，左移一次，减除数；    ②若余数 R＜0, 则商上 0，左移一次，加除数。</code></pre><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity divider_origin_test is    Port(        rst,clk,start:in std_logic;        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)        bin:in std_logic_vector(7 downto 0);--被除数        done:out std_logic;        seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end divider_origin_test;architecture Behavioral of divider_origin_test iscomponent clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                sel_out:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;component divider_origin    Port(        clk,start:in std_logic;        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)        bin:in std_logic_vector(7 downto 0);--被除数        done:out std_logic;        s,r:out std_logic_vector(7 downto 0)    );end component;signal clk_line:std_logic;signal s,r:std_logic_vector(7 downto 0);signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);beginclk_div_inst:clk_div generic map(10000)port map(rst,clk,clk_line);seg_dis_inst:seg_dis port map(rst,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);divider_origin_inst:divider_origin port map(clk,start,ain,bin,done,s,r);process(s,r,ain,bin)begin    data_in_A&lt;=&quot;00000000&quot;&amp;s;    data_in_B&lt;=&quot;00000000&quot;&amp;r;    data_in_C&lt;=&quot;00000000&quot;&amp;bin;    data_in_D&lt;=ain;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3579eeb2efc9ed74282411d3cc4a7c43.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity divider_origin is    Port(        clk,start:in std_logic;        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)        bin:in std_logic_vector(7 downto 0);--被除数        done:out std_logic;        s,r:out std_logic_vector(7 downto 0)    );end divider_origin;architecture Behavioral of divider_origin iscomponent divider_origin_ctrl    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end component;component divider_origin_16bitreg    Port (        clk,rst:in std_logic;        ain:in std_logic_vector(15 downto 0);        d:in std_logic_vector(8 downto 0);        c_out:out std_logic;        q:out std_logic_vector(15 downto 0)     );end component;component divider_origin_selector    Port (        clk,rst:in std_logic;        a0:in std_logic;        din:in std_logic_vector(7 downto 0);        cout:out std_logic;        dout:out std_logic_vector(7 downto 0)     );end component;component divider_origin_8bitadder    Port (        clk,rst:in std_logic;        cina,cinb:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end component;signal clk_line:std_logic;signal rst_line:std_logic;signal cina_line,cinb_line:std_logic;signal bin_line:std_logic_vector(7 downto 0);signal sout_line:std_logic_vector(8 downto 0);signal q_line:std_logic_vector(15 downto 0);begindivider_origin_ctrl_inst:divider_origin_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);divider_origin_16bitreg_inst:divider_origin_16bitreg port map(clk=&gt;clk_line,rst=&gt;rst_line,ain=&gt;ain,d=&gt;sout_line,c_out=&gt;cina_line,q=&gt;q_line);divider_origin_selector_inst:divider_origin_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;q_line(0),din=&gt;bin,cout=&gt;cinb_line,dout=&gt;bin_line);divider_origin_8bitadder_inst:divider_origin_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,cina=&gt;cina_line,cinb=&gt;cinb_line,ain=&gt;q_line(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);process(q_line)begin    s&lt;=q_line(7 downto 0);--&amp;not sout_line(8);    r&lt;=cina_line&amp;q_line(15 downto 9);    --r&lt;=q_line(15 downto 8);end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19d7c0eaa963aceabd7b7c37f2e266a9.png"></p><p>模块：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity divider_origin_ctrl is    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end divider_origin_ctrl;architecture Behavioral of divider_origin_ctrl issignal cnt4b:std_logic_vector(3 downto 0);beginprocess(clk,start)begin    rstall&lt;=start;    if(start=&#39;1&#39;)then cnt4b&lt;=&quot;0000&quot;;    elsif clk&#39;event and clk=&#39;1&#39;then if cnt4b&lt;=7 then cnt4b&lt;=cnt4b+1;end if;    end if;end process;process(clk,cnt4b,start)begin    if (start=&#39;1&#39;)then        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;;     elsif(start=&#39;0&#39;)then            if cnt4b&lt;=7 then clkout&lt;=clk;        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;        end if;     end if;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity divider_origin_16bitreg is    Port (        clk,rst:in std_logic;        ain:in std_logic_vector(15 downto 0);        d:in std_logic_vector(8 downto 0);        c_out:out std_logic;        q:out std_logic_vector(15 downto 0)     );end divider_origin_16bitreg;architecture Behavioral of divider_origin_16bitreg isbeginprocess(clk,rst)variable sr16b:std_logic_vector(15 downto 0);begin    if rst=&#39;1&#39;then        sr16b:=ain;        c_out&lt;=sr16b(15);--发送符号位        sr16b(15 downto 1):=sr16b(14 downto 0);--左移一位        sr16b(0):=&#39;0&#39;;--上0    elsif(clk=&#39;1&#39;and clk&#39;event)then          sr16b(15 downto 8):=d(7 downto 0);        c_out&lt;=sr16b(15);--发送符号位        sr16b(15 downto 1):=sr16b(14 downto 0);--左移一位        sr16b(0):=not d(8);    --上商取反符号位    end if;       q&lt;=sr16b;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity divider_origin_selector is    Port (        clk,rst:in std_logic;        a0:in std_logic;        din:in std_logic_vector(7 downto 0);        cout:out std_logic;        dout:out std_logic_vector(7 downto 0)     );end divider_origin_selector;architecture Behavioral of divider_origin_selector issignal complement_x_negative:std_logic_vector(7 downto 0);beginprocess(din)begin    complement_x_negative&lt;=(not din)+1;end process;process(clk,rst,a0,din)begin    if(rst=&#39;1&#39;)then dout&lt;=complement_x_negative;cout&lt;=&#39;1&#39;;    elsif(clk&#39;event and clk=&#39;0&#39;)then        if(a0=&#39;1&#39;)then dout&lt;=complement_x_negative;cout&lt;=&#39;1&#39;;--输出加数和其符号位        else dout&lt;=din;cout&lt;=&#39;0&#39;;        end if;    end if;    end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity divider_origin_8bitadder is    Port (        clk,rst:in std_logic;        cina,cinb:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end divider_origin_8bitadder;architecture Behavioral of divider_origin_8bitadder isbeginprocess(rst,clk,ain,bin,cina,cinb)begin    if(rst=&#39;1&#39;)then sout&lt;=(cina &amp; ain)+(cinb &amp; bin);    elsif(clk=&#39;0&#39;)then        sout&lt;=(cina &amp; ain)+(cinb &amp; bin);    end if;end process;end Behavioral;</code></pre><p>testbench:</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/18 19:49:35----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity divider_origin_tb is--  Port ( );end divider_origin_tb;architecture Behavioral of divider_origin_tb iscomponent divider_origin    Port(        clk,start:in std_logic;        ain:in std_logic_vector(15 downto 0);--除数        bin:in std_logic_vector(7 downto 0);--被除数        done:out std_logic;        s,r:out std_logic_vector(7 downto 0)    );end component;signal clk,start: std_logic;signal ain: std_logic_vector(15 downto 0);signal bin: std_logic_vector(7 downto 0);signal done: std_logic;signal s,r: std_logic_vector(7 downto 0);begindivider_origin_inst:divider_origin port map(clk,start,ain,bin,done,s,r);clock_gen:processbegin      clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    --09 0d    ain&lt;=x&quot;008B&quot;;    bin&lt;=x&quot;0E&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 100ns;        --00 ff    ain&lt;=x&quot;0001&quot;;    bin&lt;=x&quot;02&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 100ns;        --01 33    ain&lt;=x&quot;00AB&quot;;    bin&lt;=x&quot;78&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 100ns;        --ad 27    ain&lt;=x&quot;ABCD&quot;;    bin&lt;=x&quot;FE&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 100ns;       --01 01    ain&lt;=x&quot;0100&quot;;    bin&lt;=x&quot;FF&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 100ns;        wait;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb48954106bbd0bf39a333bc9517b390.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8445a0d3d348041fe6fd9b83e6bbab68.png"></p><p>xdc:</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/23 21:55:51#----------------------------------------------------------------------------------#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;ain[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;ain[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;ain[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;ain[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;ain[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;ain[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;ain[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;ain[7]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[8]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[9]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[10]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[11]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[12]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[13]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[14]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[15]&#125;]set_property PACKAGE_PIN B10        [get_ports &#123;ain[8]&#125;]set_property PACKAGE_PIN A10        [get_ports &#123;ain[9]&#125;]set_property PACKAGE_PIN B15        [get_ports &#123;ain[10]&#125;]set_property PACKAGE_PIN A15        [get_ports &#123;ain[11]&#125;]set_property PACKAGE_PIN A13        [get_ports &#123;ain[12]&#125;]set_property PACKAGE_PIN A12        [get_ports &#123;ain[13]&#125;]set_property PACKAGE_PIN D8         [get_ports &#123;ain[14]&#125;]set_property PACKAGE_PIN D9         [get_ports &#123;ain[15]&#125;]#SW16~SW23set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[7]&#125;]set_property PACKAGE_PIN F8         [get_ports &#123;bin[0]&#125;]set_property PACKAGE_PIN F9         [get_ports &#123;bin[1]&#125;]set_property PACKAGE_PIN H11        [get_ports &#123;bin[2]&#125;]set_property PACKAGE_PIN H12        [get_ports &#123;bin[3]&#125;]set_property PACKAGE_PIN G14        [get_ports &#123;bin[4]&#125;]set_property PACKAGE_PIN J10        [get_ports &#123;bin[5]&#125;]set_property PACKAGE_PIN H14        [get_ports &#123;bin[6]&#125;]set_property PACKAGE_PIN J11        [get_ports &#123;bin[7]&#125;]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]set_property PACKAGE_PIN J8         [get_ports rst]set_property IOSTANDARD LVCMOS18    [get_ports rst]set_property PACKAGE_PIN J14        [get_ports start]set_property IOSTANDARD LVCMOS18    [get_ports start]#LEDset_property IOSTANDARD LVCMOS33 [get_ports done]set_property PACKAGE_PIN G16[get_ports done]</code></pre><h3 id="8-指令存储器-IR-设计"><a href="#8-指令存储器-IR-设计" class="headerlink" title="8.指令存储器 IR 设计"></a>8.指令存储器 IR 设计</h3><p> IR 功能分析</p><pre><code>     传送指令编码到微控制器     生成 PC 的新地址     生成 RAM 的读写地址</code></pre><p> IR 功能实现</p><pre><code>     传送指令编码到微控制器            clk_IR 上升沿有效，LD_IR1 高电平有效， data-&gt;IR。     寄存器地址操作 Data[0]-&gt; RS；Data[1]-&gt;RD；     生成 PC 的新地址            clk_IR 上升沿有效，LD_IR2 高电平有效，data[3..0]-&gt;PC[11..8];            clk_IR 上升沿有效，LD_IR3 高电平有效，data[7..0]-&gt;PC[7..0]。     生成 RAM 的读写地址            clk_IR 上升沿有效，LD_IR3 高电平有效 data[7..0]-&gt;PC[7..0];            nARen 低电平有效， PC[6..0]-&gt;AR[6..0]。</code></pre><p>源码：  </p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/20 10:29:36----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity IR_test is    port (        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;                RS,RD:out std_logic;--传送操作寄存器（寄存器地址）                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end IR_test;architecture Behavioral of IR_test iscomponent IR    Port (        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;        DATA_BUS:in std_logic_vector(7 downto 0);                IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）        PC_out:out std_logic_vector(11 downto 0);--PC地址总线        AR:out std_logic_vector(6 downto 0)    );end component;component clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                sel_out:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;signal clk_line: std_logic;signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);signal DATA_BUS_line :std_logic_vector(7 downto 0);signal IR_line_line       :std_logic_vector(7 downto 0);--传送指令到指令寄存器signal PC_out_line   :std_logic_vector(11 downto 0);--PC地址总线signal AR_line       :std_logic_vector(6 downto 0);beginclk_div_inst:clk_div generic map(10000)port map(rst,clk_IR,clk_line);sig_dis_inst:seg_dis port map(rst,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);IR_inst:IR port map(rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen,DATA_BUS_line,IR_line_line,RS,RD,PC_out_line,AR_line);process(DATA_BUS_line,IR_line_line,PC_out_line,AR_line)begin        data_in_A&lt;=&quot;00000000&quot;&amp;DATA_BUS_line;        data_in_B&lt;=&quot;00000000&quot;&amp;IR_line_line;        data_in_C&lt;=&quot;0000&quot;&amp;PC_out_line;        data_in_D&lt;=&quot;000000000&quot;&amp;AR_line;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9b9e9bdcb11e643277242864ba0880d9.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/20 10:29:36----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity IR is    Port (        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;        DATA_BUS:in std_logic_vector(7 downto 0);                IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）        PC_out:out std_logic_vector(11 downto 0);--PC地址总线        AR:out std_logic_vector(6 downto 0)    );end IR;architecture Behavioral of IR isbeginprocess(rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen)begin    if(rst=&#39;1&#39;)then        IR_out&lt;=(others=&gt;&#39;0&#39;);        PC_out&lt;=(others=&gt;&#39;0&#39;);        RS&lt;=&#39;0&#39;;RD&lt;=&#39;0&#39;;    elsif(clk_IR=&#39;1&#39; and clk_IR&#39;event)then        if(LD_IR1=&#39;1&#39;)then IR_out&lt;=DATA_BUS;end if;        RS&lt;=DATA_BUS(0);RD&lt;=DATA_BUS(1);        if(LD_IR2=&#39;1&#39;)then PC_out(11 downto 8)&lt;=DATA_BUS(3 downto 0);        elsif(LD_IR3=&#39;1&#39;)then             PC_out(7 downto 0)&lt;=DATA_BUS(7 downto 0);            if(nARen=&#39;0&#39;)then AR&lt;=DATA_BUS(6 downto 0);end if;        end if;    end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/20 10:29:36----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity IR_tb is--  Port ( );end IR_tb;architecture Behavioral of IR_tb iscomponent IR    Port (        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;        DATA_BUS:in std_logic_vector(7 downto 0);                IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）        PC_out:out std_logic_vector(11 downto 0);--PC地址总线        AR:out std_logic_vector(6 downto 0)    );end component;signal rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen,RS,RD: std_logic;signal DATA_BUS :std_logic_vector(7 downto 0);signal IR_line       :std_logic_vector(7 downto 0);--传送指令到指令寄存器signal PC_out   :std_logic_vector(11 downto 0);--PC地址总线signal AR       :std_logic_vector(6 downto 0);beginIR_inst:IR port map(rst=&gt;rst,clk_IR=&gt;clk_IR,LD_IR1=&gt;LD_IR1,LD_IR2=&gt;LD_IR2,LD_IR3=&gt;LD_IR3,nARen=&gt;nARen,DATA_BUS=&gt;DATA_BUS,IR_out=&gt;IR_line,RS=&gt;RS,RD=&gt;RD,PC_out=&gt;PC_out,AR=&gt;AR);clock:processbegin    clk_IR&lt;=&#39;1&#39;;    wait for 5ns;    clk_IR&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    rst&lt;=&#39;1&#39;;    --DATA_BUS&lt;=x&quot;EE&quot;;    DATA_BUS&lt;=&quot;11111111&quot;;    LD_IR1&lt;=&#39;1&#39;;    LD_IR2&lt;=&#39;0&#39;;    LD_IR3&lt;=&#39;0&#39;;    nARen&lt;=&#39;1&#39;;    wait for 25ns;    rst&lt;=&#39;0&#39;;    wait for 20ns;    DATA_BUS&lt;=x&quot;FA&quot;;    LD_IR1&lt;=&#39;0&#39;;    LD_IR2&lt;=&#39;1&#39;;    LD_IR3&lt;=&#39;0&#39;;    nARen&lt;=&#39;1&#39;;    wait for 20ns;    DATA_BUS&lt;=x&quot;BC&quot;;    LD_IR1&lt;=&#39;0&#39;;    LD_IR2&lt;=&#39;0&#39;;    LD_IR3&lt;=&#39;1&#39;;    nARen&lt;=&#39;0&#39;;       wait;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/366b42fa88d3bab2b3d92539815238d9.png"></p><p>xdc：</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/23 21:55:51#----------------------------------------------------------------------------------#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]#sw31~24set_property PACKAGE_PIN J8         [get_ports rst]set_property IOSTANDARD LVCMOS18    [get_ports rst]set_property PACKAGE_PIN J14        [get_ports LD_IR1]set_property IOSTANDARD LVCMOS18    [get_ports LD_IR1]set_property PACKAGE_PIN H9         [get_ports LD_IR2]set_property IOSTANDARD LVCMOS18    [get_ports LD_IR2]set_property PACKAGE_PIN H8         [get_ports LD_IR3]set_property IOSTANDARD LVCMOS18    [get_ports LD_IR3]set_property PACKAGE_PIN G10        [get_ports nARen]set_property IOSTANDARD LVCMOS18    [get_ports nARen]#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk_IR]set_property IOSTANDARD LVCMOS18    [get_ports clk_IR]#LED0~1set_property IOSTANDARD LVCMOS33 [get_ports RS]set_property IOSTANDARD LVCMOS33 [get_ports RD]set_property PACKAGE_PIN G16[get_ports RS]set_property PACKAGE_PIN H16 [get_ports RD]#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]</code></pre><h3 id="9-寄存器-RN-设计"><a href="#9-寄存器-RN-设计" class="headerlink" title="9.寄存器 RN 设计"></a>9.寄存器 RN 设计</h3><p>RN 功能分析：</p><p> 数据锁存功能</p><p> 读写功能</p><pre><code>     读寄存器操作            clk_RN 上升沿有效，Ri_EN 低电平有效，读信号 RDRi 高电平有效，选择 RS 寄存器， 输出 data[7..0]。     写寄存器操作            clk_RN 上升沿有效，Ri_EN 低电平有效，写信号 WRRi 高电平有效，选择 RD 寄存器， data[7..0] RD 。</code></pre><p>源码：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/20 17:36:21----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity RN is    generic(        depth:integer:=1    );    Port(        clk_RN,Ri_EN,RDRi,WRRi:in std_logic;        RS,RD:in std_logic_vector(depth-1 downto 0);        data_in:in std_logic_vector(7 downto 0);        data_out:out std_logic_vector(7 downto 0)        --DATA_BUS:inout std_logic_vector(7 downto 0)    );end RN;architecture Behavioral of RN istype RN is array(2**depth-1 downto 0)of std_logic_vector(7 downto 0);signal RN_in:RN;beginprocess(clk_RN)begin    if(Ri_EN=&#39;1&#39;)then data_out&lt;=(others=&gt;&#39;Z&#39;);    elsif(clk_RN=&#39;1&#39;and clk_RN&#39;event)then        if(RDRi=&#39;1&#39;)then data_out&lt;=RN_in(conv_integer(RS));        elsif(WRRi=&#39;1&#39;)then RN_in(conv_integer(RD))&lt;=data_in;        else data_out&lt;=(others=&gt;&#39;Z&#39;);        end if;    end if;end process;end Behavioral;</code></pre><p>testbench:</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/22 09:34:26----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity RN_tb is--  Port ( );end RN_tb;architecture Behavioral of RN_tb iscomponent RN    generic(        depth:integer:=1    );    Port(        clk_RN,Ri_EN,RDRi,WRRi:in std_logic;        RS,RD:in std_logic_vector(depth-1 downto 0);        data_in:in std_logic_vector(7 downto 0);        data_out:out std_logic_vector(7 downto 0)        --DATA_BUS:inout std_logic_vector(7 downto 0)    );end component;signal clk_RN,Ri_EN,RDRi,WRRi:std_logic;signal RS,RD:std_logic_vector(0 downto 0);signal DATA_BUS:std_logic_vector(7 downto 0);signal data_in:std_logic_vector(7 downto 0);signal data_out:std_logic_vector(7 downto 0);beginRN_inst:RN generic map(1)port map(clk_RN,Ri_EN,RDRi,WRRi,RS,RD,data_in,data_out);--RN_inst:RN generic map(1)port map(clk_RN,Ri_EN,RDRi,WRRi,RS,RD,DATA_BUS);clock:processbegin    clk_RN&lt;=&#39;1&#39;;    wait for 5ns;    clk_RN&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    Ri_EN&lt;=&#39;1&#39;;    wait for 25ns;    Ri_EN&lt;=&#39;0&#39;;        RDRi&lt;=&#39;0&#39;;    WRRi&lt;=&#39;1&#39;;    RS&lt;=&quot;0&quot;;    RD&lt;=&quot;0&quot;;    data_in&lt;=x&quot;FF&quot;;    wait for 25ns;        RDRi&lt;=&#39;0&#39;;    WRRi&lt;=&#39;1&#39;;    RS&lt;=&quot;0&quot;;    RD&lt;=&quot;1&quot;;    data_in&lt;=x&quot;EE&quot;;    wait for 25ns;        RDRi&lt;=&#39;1&#39;;    WRRi&lt;=&#39;0&#39;;    RS&lt;=&quot;0&quot;;    RD&lt;=&quot;0&quot;;    wait for 25ns;        RDRi&lt;=&#39;1&#39;;    WRRi&lt;=&#39;0&#39;;    RS&lt;=&quot;1&quot;;    RD&lt;=&quot;0&quot;;           wait for 25ns;    Ri_EN&lt;=&#39;1&#39;;    wait;end process;end Behavioral;</code></pre><p>xdc:</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/23 21:55:51#----------------------------------------------------------------------------------#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]#LEDset_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[7]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;data_out[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;data_out[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;data_out[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;data_out[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;data_out[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;data_out[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;data_out[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;data_out[7]&#125;]#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk_RN]set_property IOSTANDARD LVCMOS18    [get_ports clk_RN]#sw31~24set_property PACKAGE_PIN J8         [get_ports Ri_EN]set_property IOSTANDARD LVCMOS18    [get_ports Ri_EN]set_property PACKAGE_PIN J14        [get_ports RDRi]set_property IOSTANDARD LVCMOS18    [get_ports RDRi]set_property PACKAGE_PIN H9         [get_ports WRRi]set_property IOSTANDARD LVCMOS18    [get_ports WRRi]set_property PACKAGE_PIN H8         [get_ports &#123;RS[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;RS[0]&#125;]set_property PACKAGE_PIN G10        [get_ports &#123;RD[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;RD[0]&#125;]</code></pre><h3 id="10-ALU算术逻辑单元设计"><a href="#10-ALU算术逻辑单元设计" class="headerlink" title="10.ALU算术逻辑单元设计"></a>10.ALU算术逻辑单元设计</h3><p>算术逻辑单元（ALU）:执行各种算术和逻辑运算。</p><p> 算术运算操作 :加、减、乘、除</p><p> 逻辑运算操作:与、或、非、异或</p><p> ALU 输入:操作数以及来自控制单元的控制命令</p><p> ALU 输出:运算结果，以及状态信息</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/43bde231cdd8555e9e66b22f437d9014.png"></p><p>源码：</p><p>顶层;</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/23 12:35:51----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;USE IEEE.STD_LOGIC_UNSIGNED.ALL;entity ALU_test is    port(        clk : in std_logic; --全局时钟和ALU时钟        nreset : in std_logic;      --全局复位信号        M_A,M_B : in std_logic;     --暂存器控制信号        M_F : in std_logic;         --程序状态字控制信号        nALU_EN : in std_logic;     --alu运算结果输出使能        nPSW_EN : in std_logic;     --psw输出使能        C0 : in std_logic;          --进位输入        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位        F_in : in std_logic_vector(1 downto 0);     --移位功能选择        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end ALU_test;architecture Behavioral of ALU_test iscomponent clock    Port(        clk,rst:in std_logic;        clk1,nclk1:out std_logic;   --clk        clk2,nclk2:out std_logic;   --clk二分频        w0,w1,w2,w3:out std_logic   --节拍信号    );end component;component clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;component ALU     port(        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟        nreset : in std_logic;      --全局复位信号        M_A,M_B : in std_logic;     --暂存器控制信号        M_F : in std_logic;         --程序状态字控制信号        nALU_EN : in std_logic;     --alu运算结果输出使能        nPSW_EN : in std_logic;     --psw输出使能        C0 : in std_logic;          --进位输入        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位        F_in : in std_logic_vector(1 downto 0);     --移位功能选择                regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线        AC : out std_logic;     --半进位标志        CY : out std_logic;     --进位标志        ZN : out std_logic;     --零标志        OV : out std_logic      --溢出标志    );end component;signal nclk2,clk_line:std_logic;signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);signal regA_out,regB_out,result_out:std_logic_vector(7 downto 0);signal AC : std_logic;     --半进位标志signal CY : std_logic;     --进位标志signal ZN : std_logic;     --零标志signal OV : std_logic;      --溢出标志beginclock_inst:clock port map(clk=&gt;clk,rst=&gt;nreset,nclk2=&gt;nclk2);clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);ALU_inst:ALU port map(clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,regA_out,regB_out,result_out,DATA_BUS,AC,CY,ZN,OV);process(DATA_BUS,AC,CY,ZN,OV,regA_out,regB_out,result_out)begin    data_in_A&lt;=&quot;00000000&quot;&amp;DATA_BUS;    data_in_B&lt;=&quot;000&quot;&amp; AC &amp; &quot;000&quot; &amp; CY &amp; &quot;000&quot; &amp; ZN &amp; &quot;000&quot; &amp; OV;    data_in_C&lt;=regA_out&amp;regB_out;    data_in_D&lt;=result_out&amp;&quot;00000000&quot;;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/22 11:58:10----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;USE IEEE.STD_LOGIC_UNSIGNED.ALL;entity ALU is    port(        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟        nreset : in std_logic;      --全局复位信号        M_A,M_B : in std_logic;     --暂存器控制信号        M_F : in std_logic;         --程序状态字控制信号        nALU_EN : in std_logic;     --alu运算结果输出使能        nPSW_EN : in std_logic;     --psw输出使能        C0 : in std_logic;          --进位输入        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位        F_in : in std_logic_vector(1 downto 0);     --移位功能选择                regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线        AC : out std_logic;     --半进位标志        CY : out std_logic;     --进位标志        ZN : out std_logic;     --零标志        OV : out std_logic      --溢出标志    );end ALU;architecture Behavioral of ALU iscomponent array_multiplier    Port (        clk:in std_logic;        a_in,b_in:in std_logic_vector(7 downto 0);        sum_out:out std_logic_vector(15 downto 0)    );end component;component divider_origin    Port(        clk,start:in std_logic;        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)        bin:in std_logic_vector(7 downto 0);--被除数        done:out std_logic;        s,r:out std_logic_vector(7 downto 0)    );end component;signal regA:std_logic_vector(8 downto 0);signal regB:std_logic_vector(8 downto 0);signal result:std_logic_vector(8 downto 0);signal PSW_reg:std_logic_vector(7 downto 0);        --pws(0):CY psw(1):ZNsignal AC_signal :std_logic;signal CY_signal :std_logic;signal ZN_signal :std_logic;signal OV_signal :std_logic;signal multiplier_out:std_logic_vector(15 downto 0);signal start,done:std_logic;signal divider_ina:std_logic_vector(15 downto 0);signal divider_r:std_logic_vector(7 downto 0);beginarray_multiplier_inst:array_multiplier port map(clk_ALU,regA(7 downto 0),regB(7 downto 0),multiplier_out);--divider_origin_inst:divider_origin port map(clk,start,divider_ina,DATA_BUS,done,result(7 downto 0),divider_r);process(clk_ALU,nreset) variable count:integer:=0;begin    if(nreset = &#39;1&#39;)then        start&lt;=&#39;1&#39;;           regA &lt;= &quot;000000000&quot;;        regA &lt;= &quot;000000000&quot;;        result &lt;= &quot;000000000&quot;;        DATA_BUS &lt;= &quot;ZZZZZZZZ&quot;;        AC&lt;= &#39;0&#39;;CY&lt;= &#39;0&#39;;ZN&lt;= &#39;0&#39;;OV&lt;= &#39;0&#39;;            elsif(clk_ALU&#39;event and clk_ALU = &#39;1&#39;)then        if(M_A=&#39;1&#39;and M_B=&#39;0&#39;)then     --锁存到A            regA(7 downto 0) &lt;= DATA_BUS;            regA(8) &lt;= &#39;0&#39;;        elsif(M_A=&#39;0&#39;and M_B=&#39;1&#39;)then     --锁存到B             regB(7 downto 0) &lt;= DATA_BUS;            regB(8) &lt;= &#39;0&#39;;                    elsif(nALU_EN = &#39;0&#39;)then            case S is                when &quot;00000&quot; =&gt;         --直传                    result &lt;= regA;                    CY_signal &lt;= result(8);                when &quot;00001&quot; =&gt;         --加法                    result &lt;= regA+regB+C0;                    CY_signal &lt;= result(8);                when &quot;00010&quot; =&gt;         --减法                    result &lt;= regA - regB;                    CY_signal &lt;= result(8);                    if(regA&lt;regB)then OV_signal&lt;=&#39;1&#39;;end if;                 when &quot;00100&quot; =&gt;         --乘法                    result(7 downto 0) &lt;= multiplier_out(7 downto 0);                    CY_signal &lt;= regA(8)xor regB(8);                    if(regA*regB&gt;x&quot;FF&quot;)then OV_signal&lt;=&#39;1&#39;;end if;                 when &quot;01000&quot; =&gt;         --除法                    case count is                        when 0=&gt;                            divider_ina&lt;=regA(7 downto 0)&amp;regB(7 downto 0);                            start&lt;=&#39;0&#39;;                            count:=count+1;                        when others=&gt;null;                    end case;                    CY_signal &lt;= regA(8)xor regB(8);                                    when &quot;10000&quot; =&gt;         --清零                    regA &lt;= &quot;000000000&quot;;                    result &lt;= regA;                    CY_signal &lt;= &#39;0&#39;;                when &quot;10001&quot; =&gt;         --与                    result &lt;= regA and regB;                    CY_signal &lt;= &#39;0&#39;;                when &quot;10010&quot; =&gt;         --或                    result &lt;= regA or regB;                    CY_signal &lt;= &#39;0&#39;;                when &quot;10100&quot; =&gt;         --A取非                    result &lt;= not regA;                    CY_signal &lt;= &#39;0&#39;;                when &quot;11000&quot; =&gt;         --异或                    result &lt;= regA xor regB;                    CY_signal &lt;= &#39;0&#39;;                when others =&gt;                    result &lt;= &quot;000000000&quot;;            end case;                        case F_in is                 when &quot;00&quot; =&gt; DATA_BUS&lt;= result(7 downto 0);--直接传送                when &quot;01&quot; =&gt; DATA_BUS&lt;= result(8 downto 1);--带C右移                when &quot;10&quot; =&gt; DATA_BUS&lt;= result(6 downto 0)&amp;CY_signal;--循环左移                when &quot;11&quot; =&gt; DATA_BUS&lt;= result(6 downto 0)&amp;&#39;0&#39;;--逻辑左移                when others =&gt; DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);            end case;                        CY &lt;= CY_signal;            if(result=&quot;000000000&quot;)then ZN_signal&lt;=&#39;1&#39;;else ZN_signal&lt;=&#39;0&#39;;end if;            ZN&lt;=ZN_signal;                    elsif(nPSW_EN = &#39;0&#39;)then            PSW_reg(0) &lt;= CY_signal;            PSW_reg(1) &lt;= ZN_signal;            DATA_BUS&lt;= PSW_reg;        else            DATA_BUS &lt;= &quot;ZZZZZZZZ&quot;;        end if;            end if;end process;process(regA,regB,result)begin    regA_out&lt;=regA(7 downto 0);    regB_out&lt;=regB(7 downto 0);    result_out&lt;=result(7 downto 0);end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/23 13:34:13----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity ALU_tb is--  Port ( );end ALU_tb;architecture Behavioral of ALU_tb iscomponent ALU    port(        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟        nreset : in std_logic;      --全局复位信号        M_A,M_B : in std_logic;     --暂存器控制信号        M_F : in std_logic;         --程序状态字控制信号        nALU_EN : in std_logic;     --alu运算结果输出使能        nPSW_EN : in std_logic;     --psw输出使能        C0 : in std_logic;          --进位输入        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位        F_in : in std_logic_vector(1 downto 0);     --移位功能选择                DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线        AC : out std_logic;     --半进位标志        CY : out std_logic;     --进位标志        ZN : out std_logic;     --零标志        OV : out std_logic      --溢出标志    );end component;signal clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0:std_logic;signal S :std_logic_vector(4 downto 0);signal F_in :std_logic_vector(1 downto 0);     signal DATA_BUS:std_logic_vector(7 downto 0);   signal AC : std_logic;     --半进位标志signal CY : std_logic;     --进位标志signal ZN : std_logic;     --零标志signal OV : std_logic;      --溢出标志beginALU_inst:ALU port map(clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,DATA_BUS,AC,CY,ZN,OV);clock:processbegin    clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;clock_nclk2:processbegin    nclk2&lt;=&#39;0&#39;;    wait for 10ns;    nclk2&lt;=&#39;1&#39;;    wait for 10ns;end process;test:processbegin    nreset&lt;=&#39;1&#39;;    M_A&lt;=&#39;0&#39;;    M_B&lt;=&#39;0&#39;;    M_F&lt;=&#39;0&#39;;    nALU_EN&lt;=&#39;1&#39;;    nPSW_EN&lt;=&#39;1&#39;;    C0&lt;=&#39;0&#39;;    S&lt;=&quot;10010&quot;;    F_in&lt;=&quot;00&quot;;    wait for 25ns;        nreset&lt;=&#39;0&#39;;    DATA_BUS&lt;=X&quot;04&quot;;    M_A&lt;=&#39;1&#39;;    M_B&lt;=&#39;0&#39;;    wait for 25ns;    DATA_BUS&lt;=X&quot;02&quot;;    M_A&lt;=&#39;0&#39;;    M_B&lt;=&#39;1&#39;;    wait for 25ns;--    DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;    M_A&lt;=&#39;0&#39;;    M_B&lt;=&#39;0&#39;;    nALU_EN&lt;=&#39;0&#39;;    wait for 50ns;        nALU_EN&lt;=&#39;1&#39;;    nPSW_EN&lt;=&#39;0&#39;;    wait;    end process;end Behavioral;</code></pre><p>xdc：</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/23 21:55:51#----------------------------------------------------------------------------------#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;DATA_BUS[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;DATA_BUS[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;DATA_BUS[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;DATA_BUS[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;DATA_BUS[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;DATA_BUS[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;DATA_BUS[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;DATA_BUS[7]&#125;]#sw31~23set_property PACKAGE_PIN J8         [get_ports nreset]set_property IOSTANDARD LVCMOS18    [get_ports nreset]set_property PACKAGE_PIN J14        [get_ports nALU_EN]set_property IOSTANDARD LVCMOS18    [get_ports nALU_EN]set_property PACKAGE_PIN H9         [get_ports nPSW_EN]set_property IOSTANDARD LVCMOS18    [get_ports nPSW_EN]set_property PACKAGE_PIN H8         [get_ports M_A]set_property IOSTANDARD LVCMOS18    [get_ports M_A]set_property PACKAGE_PIN G10        [get_ports M_B]set_property IOSTANDARD LVCMOS18    [get_ports M_B]set_property PACKAGE_PIN G9         [get_ports M_F]set_property IOSTANDARD LVCMOS18    [get_ports M_F]set_property PACKAGE_PIN J13        [get_ports C0]set_property IOSTANDARD LVCMOS18    [get_ports C0]#SW16~20set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[4]&#125;]set_property PACKAGE_PIN F8         [get_ports &#123;S[0]&#125;]set_property PACKAGE_PIN F9         [get_ports &#123;S[1]&#125;]set_property PACKAGE_PIN H11        [get_ports &#123;S[2]&#125;]set_property PACKAGE_PIN H12        [get_ports &#123;S[3]&#125;]set_property PACKAGE_PIN G14        [get_ports &#123;S[4]&#125;]#SW22~23set_property IOSTANDARD LVCMOS18    [get_ports &#123;F_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;F_in[1]&#125;]set_property PACKAGE_PIN H14        [get_ports &#123;F_in[0]&#125;]set_property PACKAGE_PIN J11        [get_ports &#123;F_in[1]&#125;]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]</code></pre><h3 id="11-数据存储器-RAM-设计"><a href="#11-数据存储器-RAM-设计" class="headerlink" title="11.数据存储器 RAM 设计"></a>11.数据存储器 RAM 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0f5ae5f7d65bf36add50df2465e24d2.png"></p><p>高电平写操作有效，低电平读有效。其中 clk_RAM&#x3D;nclk1 &amp; W1，在组建 CPU 模块时使用。</p><p>1）读数据操作：clk_RAM 上升沿有效，RAM_CS 高电平，wr_nRD 低电平，nRAM_EN 低 电平，[AR] -&gt; data 。</p><p>2）写数据操作：clk_RAM 上升沿有效，RAM_CS 高电平，wr_nRD 高电平有效，data-&gt;[AR]。</p><p>源码：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/23 21:55:51----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity RAM is    generic(        depth:integer:=7;        width:integer:=8        );    port(         clk_RAM:in STD_LOGIC;       --RAM时钟信号        n_reset:in STD_LOGIC;       --RAM选择信号        RAM_CS:in STD_LOGIC;        --RAM片选信号        nRAM_EN:in STD_LOGIC;       --RAM输出使能        Wr_nRD :in STD_LOGIC;       --RAM读写信号        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号                --DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线        data_in:in STD_LOGIC_VECTOR (width-1 downto 0);        data_out:out STD_LOGIC_VECTOR (width-1 downto 0)        );end RAM;architecture Behavioral of RAM istype ram_array is array(0 to 2**depth) of STD_LOGIC_VECTOR (width-1 downto 0);signal index : integer range 0 to 2**depth;signal SRAM:ram_array;beginprocess (n_reset,clk_RAM) begin    index&lt;=conv_integer(AR);    if(n_reset=&#39;1&#39;)  then         --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);        data_out&lt;=(others=&gt;&#39;Z&#39;);    elsif(clk_RAM&#39;event and clk_RAM=&#39;1&#39;) then        if(RAM_CS=&#39;1&#39;)then            if(Wr_nRD=&#39;1&#39;)then                --SRAM(index)&lt;=DATA_BUS;                SRAM(index)&lt;=data_in;            elsif(nRAM_EN=&#39;0&#39;)then                --DATA_BUS&lt;=SRAM(index);                data_out&lt;=SRAM(index);            else                --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);                data_out&lt;=(others=&gt;&#39;Z&#39;);            end if;        else             --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);            data_out&lt;=(others=&gt;&#39;Z&#39;);        end if;    end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/23 21:55:51----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity RAM_tb is--  Port ( );end RAM_tb;architecture Behavioral of RAM_tb iscomponent RAM    generic(        depth:positive:=7;        width:positive:=8    );    Port (        clk_RAM:in STD_LOGIC;       --RAM时钟信号        n_reset:in STD_LOGIC;       --RAM选择信号        RAM_CS:in STD_LOGIC;        --RAM片选信号        nRAM_EN:in STD_LOGIC;       --RAM输出使能        Wr_nRD :in STD_LOGIC;       --RAM读写信号        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号                DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线        --data_in:in STD_LOGIC_VECTOR (width-1 downto 0);        --data_out:out STD_LOGIC_VECTOR (width-1 downto 0))    );end component;signal clk_RAM,n_reset,RAM_CS,nRAM_EN,Wr_nRD:std_logic;signal AR:std_logic_vector(6 downto 0);signal DATA_BUS:std_logic_vector(7 downto 0);signal data_in,data_out:std_logic_vector(7 downto 0);beginRAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;n_reset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,DATA_BUS=&gt;DATA_BUS);--RAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;n_reset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,data_in=&gt;data_in,data_out=&gt;data_out);clock:processbegin    clk_RAM&lt;=&#39;1&#39;;    wait for 5ns;    clk_RAM&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    n_reset&lt;=&#39;1&#39;;    wait for 25ns;    n_reset&lt;=&#39;0&#39;;        RAM_CS&lt;=&#39;1&#39;;    nRAM_EN&lt;=&#39;1&#39;;    Wr_nRD&lt;=&#39;1&#39;;    AR&lt;=&quot;0000000&quot;;    wait for 25ns;    DATA_BUS&lt;=x&quot;FF&quot;;    wait for 25ns;    AR&lt;=&quot;0000001&quot;;    wait for 25ns;    DATA_BUS&lt;=x&quot;EE&quot;;    wait for 25ns;        nRAM_EN&lt;=&#39;0&#39;;    Wr_nRD&lt;=&#39;0&#39;;    AR&lt;=&quot;0000000&quot;;    wait for 25ns;    AR&lt;=&quot;0000001&quot;;        wait;end process;end Behavioral;</code></pre><p>xdc：</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/23 21:55:51#----------------------------------------------------------------------------------#sw0~6set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[0]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[1]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[2]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[3]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[4]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[5]&#125;]set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[6]&#125;]set_property PACKAGE_PIN C9 [get_ports &#123;AR[0]&#125;]set_property PACKAGE_PIN B9 [get_ports &#123;AR[1]&#125;]set_property PACKAGE_PIN G11 [get_ports &#123;AR[2]&#125;]set_property PACKAGE_PIN F10 [get_ports &#123;AR[3]&#125;]set_property PACKAGE_PIN D10 [get_ports &#123;AR[4]&#125;]set_property PACKAGE_PIN E11 [get_ports &#123;AR[5]&#125;]set_property PACKAGE_PIN D11 [get_ports &#123;AR[6]&#125;]#LED#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[0]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[1]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[2]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[3]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[4]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[5]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[6]&#125;]#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[7]&#125;]#set_property PACKAGE_PIN G16 [get_ports &#123;DATA_BUS[0]&#125;]#set_property PACKAGE_PIN H16 [get_ports &#123;DATA_BUS[1]&#125;]#set_property PACKAGE_PIN D16 [get_ports &#123;DATA_BUS[2]&#125;]#set_property PACKAGE_PIN D15 [get_ports &#123;DATA_BUS[3]&#125;]#set_property PACKAGE_PIN C18 [get_ports &#123;DATA_BUS[4]&#125;]#set_property PACKAGE_PIN C17 [get_ports &#123;DATA_BUS[5]&#125;]#set_property PACKAGE_PIN B19 [get_ports &#123;DATA_BUS[6]&#125;]#set_property PACKAGE_PIN C19 [get_ports &#123;DATA_BUS[7]&#125;]#sw31set_property PACKAGE_PIN J8 [get_ports n_reset]set_property IOSTANDARD LVCMOS18 [get_ports n_reset]#sw30~28set_property PACKAGE_PIN J14 [get_ports RAM_CS]set_property IOSTANDARD LVCMOS18 [get_ports RAM_CS]set_property PACKAGE_PIN H9         [get_ports nRAM_EN]set_property IOSTANDARD LVCMOS18    [get_ports nRAM_EN]set_property PACKAGE_PIN H8         [get_ports Wr_nRD]set_property IOSTANDARD LVCMOS18    [get_ports Wr_nRD]#clkset_property PACKAGE_PIN E10 [get_ports clk_RAM]set_property IOSTANDARD LVCMOS18 [get_ports clk_RAM]#LEDset_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[6]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;data_out[7]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;data_out[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;data_out[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;data_out[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;data_out[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;data_out[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;data_out[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;data_out[6]&#125;]set_property PACKAGE_PIN C19 [get_ports &#123;data_out[7]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN B10        [get_ports &#123;data_in[0]&#125;]set_property PACKAGE_PIN A10        [get_ports &#123;data_in[1]&#125;]set_property PACKAGE_PIN B15        [get_ports &#123;data_in[2]&#125;]set_property PACKAGE_PIN A15        [get_ports &#123;data_in[3]&#125;]set_property PACKAGE_PIN A13        [get_ports &#123;data_in[4]&#125;]set_property PACKAGE_PIN A12        [get_ports &#123;data_in[5]&#125;]set_property PACKAGE_PIN D8         [get_ports &#123;data_in[6]&#125;]set_property PACKAGE_PIN D9         [get_ports &#123;data_in[7]&#125;]</code></pre><h3 id="12-堆栈指针-SP-设计"><a href="#12-堆栈指针-SP-设计" class="headerlink" title="12.堆栈指针 SP 设计"></a>12.堆栈指针 SP 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/450ff7787e4fbc15befc93420b279e3f.png"></p><p>其中 clk_SP&#x3D;nclk2，在组建 CPU 模块时使用。</p><p>1）数据存储功能：clk_SP 上升沿有效，SP_CS 高电平，nSP_EN 高电平，data-&gt;SP。</p><p>2）加 1 功能：clk_SP 上升沿有效，SP_CS 高电平，SP_UP 高电平，nSP_EN 低电平有效，SP+1-&gt;SP,SP-&gt;AR。</p><p>3）减 1 功能：clk_SP 上升沿有效，SP_CS 高电平，SP_DN 高电平，nSP_EN 低电平有效， SP-1-&gt;SP,SP-&gt;AR。</p><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 13:45:37----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity SP_test is    Port(        clk:in std_logic;       --时钟信号        nreset:in std_logic;    --复位信号                        SP_CS:in std_logic;     --SP选择信号        SP_UP:in std_logic;     --SP+1控制        SP_DN:in std_logic;     --SP-1控制        nSP_EN:in std_logic;    --SP输出使能        key_in:in std_logic;    --按键时钟                AR:out std_logic_vector(6 downto 0);--SP指向RAM地址        --data_in:in std_logic_vector(7 downto 0);        --data_out:out std_logic_vector(7 downto 0)        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线    );end SP_test;architecture Behavioral of SP_test iscomponent SP    Port(        clk_SP:in std_logic;    --SP时钟信号        nreset:in std_logic;    --复位信号                        SP_CS:in std_logic;     --SP选择信号        SP_UP:in std_logic;     --SP+1控制        SP_DN:in std_logic;     --SP-1控制        nSP_EN:in std_logic;    --SP输出使能                AR:out std_logic_vector(6 downto 0);--SP指向RAM地址        --data_in:in std_logic_vector(7 downto 0);        --data_out:out std_logic_vector(7 downto 0)        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线    );end component;component key_stroke    generic(CLK_FRE:integer:=100000000);    Port (        clk:in std_logic;        reset:in std_logic;        key_in:in std_logic;        output:out std_logic               );end component;signal clk_line:STD_LOGIC;beginkey_stroke_inst:key_stroke generic map(100000000)port map(clk,nreset,key_in,clk_line);SP_inst:SP PORT MAP(clk_line,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ca7b953040d5420bd324dcceae3363c.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 10:52:17----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity SP is    Port(        clk_SP:in std_logic;    --SP时钟信号        nreset:in std_logic;    --复位信号                        SP_CS:in std_logic;     --SP选择信号        SP_UP:in std_logic;     --SP+1控制        SP_DN:in std_logic;     --SP-1控制        nSP_EN:in std_logic;    --SP输出使能                AR:out std_logic_vector(6 downto 0);--SP指向RAM地址        --data_in:in std_logic_vector(7 downto 0);        --data_out:out std_logic_vector(7 downto 0)        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线    );end SP;architecture Behavioral of SP issignal SP_p:std_logic_vector(6 downto 0);--指向RAM地址beginprocess(clk_SP,nreset)begin       if(nreset=&#39;0&#39;)then AR&lt;=(others=&gt;&#39;Z&#39;);    elsif(clk_SP=&#39;1&#39;and clk_SP&#39;event)then        if(SP_CS=&#39;1&#39;)then            if(nSP_EN=&#39;1&#39;)then                 --SP_p&lt;=data_in;                SP_p&lt;=DATA_BUS(6 downto 0);            else                if(SP_UP=&#39;1&#39;and SP_DN=&#39;0&#39;)then SP_p&lt;=SP_p+1;                elsif(SP_UP=&#39;0&#39;and SP_DN=&#39;1&#39;)then SP_p&lt;=SP_p-1;                end if;                --data_out&lt;=SP_p;                AR&lt;=SP_p;            end if;        else AR&lt;=(others=&gt;&#39;Z&#39;);        end if;    end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 13:29:19----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity SP_tb is--  Port ( );end SP_tb;architecture Behavioral of SP_tb iscomponent SP    Port(        clk_SP:in std_logic;    --SP时钟信号        nreset:in std_logic;    --复位信号                        SP_CS:in std_logic;     --SP选择信号        SP_UP:in std_logic;     --SP+1控制        SP_DN:in std_logic;     --SP-1控制        nSP_EN:in std_logic;    --SP输出使能                AR:out std_logic_vector(6 downto 0);--SP指向RAM地址        --data_in:in std_logic_vector(7 downto 0);        --data_out:out std_logic_vector(7 downto 0)        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线    );end component;signal clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN:STD_LOGIC;signal AR:std_logic_vector(6 downto 0);signal DATA_BUS:std_logic_vector(7 downto 0);beginSP_inst:SP PORT MAP(clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);clock:processbegin    clk_SP&lt;=&#39;1&#39;;    wait for 5ns;    clk_SP&lt;=&#39;0&#39;;    wait for 5ns;end process;test:processbegin    nreset&lt;=&#39;0&#39;;    SP_CS&lt;=&#39;1&#39;;    SP_UP&lt;=&#39;0&#39;;    SP_DN&lt;=&#39;0&#39;;    nSP_EN&lt;=&#39;1&#39;;    DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;    wait for 25ns;        DATA_BUS&lt;=x&quot;0F&quot;;    nreset&lt;=&#39;1&#39;;    wait for 25ns;        SP_UP&lt;=&#39;1&#39;;    SP_DN&lt;=&#39;0&#39;;    nSP_EN&lt;=&#39;0&#39;;    wait for 25ns;        SP_UP&lt;=&#39;1&#39;;    SP_DN&lt;=&#39;0&#39;;    nSP_EN&lt;=&#39;0&#39;;    wait for 25ns;        SP_UP&lt;=&#39;0&#39;;    SP_DN&lt;=&#39;1&#39;;    nSP_EN&lt;=&#39;0&#39;;    wait for 25ns;        wait;    end process;end Behavioral;</code></pre><p>xdc：</p><pre><code>#clkset_property PACKAGE_PIN E10 [get_ports clk]set_property IOSTANDARD LVCMOS18 [get_ports clk]#sw31~28set_property PACKAGE_PIN J8 [get_ports nreset]set_property IOSTANDARD LVCMOS18 [get_ports nreset]set_property PACKAGE_PIN J14        [get_ports SP_CS]set_property IOSTANDARD LVCMOS18    [get_ports SP_CS]set_property PACKAGE_PIN H9         [get_ports key_in]set_property IOSTANDARD LVCMOS18    [get_ports key_in]set_property PACKAGE_PIN H8         [get_ports nSP_EN]set_property IOSTANDARD LVCMOS18    [get_ports nSP_EN]set_property PACKAGE_PIN G10        [get_ports SP_UP ]set_property IOSTANDARD LVCMOS18    [get_ports SP_UP ]set_property PACKAGE_PIN G9         [get_ports SP_DN ]set_property IOSTANDARD LVCMOS18    [get_ports SP_DN ]#LED0~6set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[0]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[1]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[2]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[3]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[4]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[5]&#125;]set_property IOSTANDARD LVCMOS33 [get_ports &#123;AR[6]&#125;]set_property PACKAGE_PIN G16[get_ports &#123;AR[0]&#125;]set_property PACKAGE_PIN H16 [get_ports &#123;AR[1]&#125;]set_property PACKAGE_PIN D16 [get_ports &#123;AR[2]&#125;]set_property PACKAGE_PIN D15 [get_ports &#123;AR[3]&#125;]set_property PACKAGE_PIN C18 [get_ports &#123;AR[4]&#125;]set_property PACKAGE_PIN C17 [get_ports &#123;AR[5]&#125;]set_property PACKAGE_PIN B19 [get_ports &#123;AR[6]&#125;]#SW0~7set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;DATA_BUS[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;DATA_BUS[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;DATA_BUS[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;DATA_BUS[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;DATA_BUS[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;DATA_BUS[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;DATA_BUS[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;DATA_BUS[7]&#125;]</code></pre><h3 id="13-采用硬件描述语言语言设计-IO-模块"><a href="#13-采用硬件描述语言语言设计-IO-模块" class="headerlink" title="13.采用硬件描述语言语言设计 IO 模块"></a>13.采用硬件描述语言语言设计 IO 模块</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/de38a24f3d908b663a479d455c4f613d.png"></p><p>其中 clk_P0&#x3D;nclk2，在组建 CPU 模块时使用。</p><p>1）输入锁存：</p><pre><code>    clk_PO 上升沿有效，P0_CS 高电平，P0_IEN 低电平，    P0_IN-&gt; 暂存器，RIEN 低电平， 暂存器 -&gt;数据总线（data）。</code></pre><p>2）输出锁存：</p><pre><code>    clk_PO 上升沿有效，P0_CS 高电平，P0_OEN 低电平，    数据总线（data）-&gt;暂存器，ROEN 低电平，暂存器 -&gt;P0_OUT。</code></pre><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 14:37:22----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity IO_test is    Port(        clk:in std_logic;    --IO时钟信号        nreset:in std_logic;    --IO复位信号        IO_CS:in std_logic;     --IO选择信号        IO_IEN:in std_logic;    --IO输入使能        IO_OEN:in std_logic;    --IO输出使能        RI_EN:in std_logic;     --IO缓存器输入使能        RO_EN:in std_logic;     --IO缓存器输出使能        IO_in:in std_logic_vector(7 downto 0);          --IO输入                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end IO_test;architecture Behavioral of IO_test iscomponent IO    Port(        clk_IO:in std_logic;    --IO时钟信号        nreset:in std_logic;    --IO复位信号        IO_CS:in std_logic;     --IO选择信号        IO_IEN:in std_logic;    --IO输入使能        IO_OEN:in std_logic;    --IO输出使能        RI_EN:in std_logic;     --IO缓存器输入使能        RO_EN:in std_logic;     --IO缓存器输出使能        IO_in:in std_logic_vector(7 downto 0);          --IO输入                IO_out:out std_logic_vector(7 downto 0);        --IO输出        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线    );end component;component clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;signal clk_line,rst_seg:std_logic;signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0); signal IO_out,DATA_BUS:std_logic_vector(7 downto 0);beginIO_inst:IO port map(clk,nreset,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN,IO_in,IO_out,DATA_BUS);clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);process(IO_in,IO_out,DATA_BUS)begin    data_in_A&lt;=&quot;00000000&quot;&amp;IO_in;    data_in_B&lt;=&quot;00000000&quot;&amp;DATA_BUS;    data_in_C&lt;=&quot;00000000&quot;&amp;IO_out;    data_in_D&lt;=&quot;0000000000000000&quot;;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7c0424c57486f62ce1df707bbc1d0f14.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: -- Create Date: 2024/04/24 14:06:31----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity IO is    Port(        clk_IO:in std_logic;    --IO时钟信号        nreset:in std_logic;    --IO复位信号        IO_CS:in std_logic;     --IO选择信号        IO_IEN:in std_logic;    --IO输入使能        IO_OEN:in std_logic;    --IO输出使能        RI_EN:in std_logic;     --IO缓存器输入使能        RO_EN:in std_logic;     --IO缓存器输出使能        IO_in:in std_logic_vector(7 downto 0);          --IO输入                IO_out:out std_logic_vector(7 downto 0);        --IO输出        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线    );end IO;architecture Behavioral of IO issignal reg:std_logic_vector(7 downto 0);beginprocess(nreset,clk_IO)begin    if(nreset=&#39;0&#39;)then IO_out&lt;=&quot;ZZZZZZZZ&quot;;DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;    elsif(clk_IO=&#39;1&#39;and clk_IO&#39;event)then        if(IO_CS=&#39;1&#39;)then            if(IO_IEN=&#39;0&#39;)then                 reg&lt;=IO_in;                if(RI_EN=&#39;0&#39;)then DATA_BUS&lt;=reg;end if;            elsif(IO_OEN=&#39;0&#39;)then                 reg&lt;=DATA_BUS;                if(RO_EN=&#39;0&#39;)then IO_out&lt;=reg;END IF;            end if;         else IO_out&lt;=&quot;ZZZZZZZZ&quot;;DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;        end if;    end if;end process;end Behavioral;</code></pre><p>xdc：</p><pre><code>#----------------------------------------------------------------------------------#-- Engineer: switch_swq#-- Create Date: 2024/04/24 15:50:00#----------------------------------------------------------------------------------#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#SW0~7set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;IO_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;IO_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;IO_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;IO_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;IO_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;IO_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;IO_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;IO_in[7]&#125;]#sw31~24set_property PACKAGE_PIN J8         [get_ports nreset]set_property IOSTANDARD LVCMOS18    [get_ports nreset]set_property PACKAGE_PIN J14        [get_ports IO_CS]set_property IOSTANDARD LVCMOS18    [get_ports IO_CS]set_property PACKAGE_PIN H9         [get_ports IO_IEN]set_property IOSTANDARD LVCMOS18    [get_ports IO_IEN]set_property PACKAGE_PIN H8         [get_ports IO_OEN]set_property IOSTANDARD LVCMOS18    [get_ports IO_OEN]set_property PACKAGE_PIN G10        [get_ports RI_EN]set_property IOSTANDARD LVCMOS18    [get_ports RI_EN]set_property PACKAGE_PIN G9         [get_ports RO_EN]set_property IOSTANDARD LVCMOS18    [get_ports RO_EN]</code></pre><h3 id="14-微控制器设计"><a href="#14-微控制器设计" class="headerlink" title="14.微控制器设计"></a>14.微控制器设计</h3><p>微程序控制器基本原理：</p><pre><code>    1)将指令分解为基本的微命令序列，把操作控制信号编制成微指令，存放到控制存储器 (CM)。    2)运行时，从控存中取出微指令，产生指令运行所需的操作控制信号。</code></pre><p>微程序控制器基本结构：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3df769d2ac5eb7d9b1a2a850829c1e56.png"></p><p> 控制存储器 CM –存放微程序</p><p> 微指令寄存器 µIR –存放现行微指令</p><p> 微地址形成电路–提供下一条微地址</p><p> 微地址寄存器 µAR–存放现在微地址</p><p>控制信号设计：</p><pre><code>    • 39 条控制信号（39 位编码）    • 27 条指令（5 位编码）-&gt;8 位微地址</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/29292e122740addc20eb4a530ec67bd0.png"></p><p>其中 clk_MC&#x3D;clk2 &amp; W0，在组建 CPU 模块时使用。</p><p>源码：</p><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/25 16:09:02----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity uC_test is    Port(        clk:in std_logic;    --微程序控制器时钟信号        nreset:in std_logic;    --复位信号        M_uA:in std_logic;      --微地址控制信号        IR:in std_logic_vector(7 downto 2); --IR操作码信息        CMROM_CS:in std_logic;  --控制存储器选通信号                seg_dig : out std_logic_vector(15 downto 0);        seg_data : out std_logic_vector(7 downto 0)    );end uC_test;architecture Behavioral of uC_test iscomponent uC    Port(        clk_uC:in std_logic;    --微程序控制器时钟信号        nreset:in std_logic;    --复位信号        M_uA:in std_logic;      --微地址控制信号        IR:in std_logic_vector(7 downto 2); --IR操作码信息        CMROM_CS:in std_logic;  --控制存储器选通信号                CM:out std_logic_vector(47 downto 8)    --控制信号输出    );end component;component clock    Port(        clk,rst:in std_logic;        clk1,nclk1:out std_logic;   --clk        clk2,nclk2:out std_logic;   --clk二分频        w0,w1,w2,w3:out std_logic   --节拍信号    );end component;component clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;signal clk_line,clk_line2,clk_uC,clk2,w0:std_logic;signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0); signal CM_line:std_logic_vector(47 downto 8);beginuC_inst:uC port map(clk_uC,nreset,M_uA,IR,CMROM_CS,CM_line);clock_inst:clock port map(clk=&gt;clk_line2,rst=&gt;nreset,clk2=&gt;clk2,w0=&gt;w0);clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);clk_div_inst2:clk_div generic map(10000000)port map(nreset,clk,clk_line2);seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);process(clk2,w0)begin    clk_uC&lt;=clk2 and w0;end process;process(IR,CM_line)begin    data_in_A&lt;=&quot;0000000000&quot;&amp;IR;    data_in_B&lt;=CM_line(15 downto 8)&amp;&quot;00000000&quot;;    data_in_C&lt;=CM_line(31 downto 16);    data_in_D&lt;=CM_line(47 downto 32);end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef02d5402b0594182dafe67debe07644.png"></p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 16:22:50----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity uC is    Port(        clk_uC:in std_logic;    --微程序控制器时钟信号        nreset:in std_logic;    --复位信号        M_uA:in std_logic;      --微地址控制信号        IR:in std_logic_vector(7 downto 2); --IR操作码信息        CMROM_CS:in std_logic;  --控制存储器选通信号                CM:out std_logic_vector(47 downto 8)    --控制信号输出    );end uC;architecture Behavioral of uC iscomponent uC_uA    Port(        clk:in std_logic;        nreset:in std_logic;    --复位信号        M_uA:in std_logic;        IR:in std_logic_vector(7 downto 2);     --IR操作码信息        uA_in:in std_logic_vector(7 downto 0);  --uIR传送的微地址                uA_out:out std_logic_vector(7 downto 0) --下一条微指令的地址    );end component;component uC_uAR    Port(        clk:in std_logic;        nreset: in std_logic;        uAR_in:in std_logic_vector(7 downto 0);  --uA传送的微地址                uAR_out:out std_logic_vector(7 downto 0) --送至uCM的地址    );end component;component uC_CM    generic(        width:integer := 48;    --位宽        depth:integer := 8      --深度    );    port(        clk:in std_logic;        addr:in std_logic_vector(depth-1 downto 0);     ----uC_ROM地址        CMROM_CS:in std_logic;  --uC_ROM输出使能                data_out:out std_logic_vector(width-1 downto 0) --uC_ROM输出    );end component;component uC_uIR  Port (    clk:in std_logic;    CM:in std_logic_vector(47 downto 0);        uA:out std_logic_vector(7 downto 0);    uI:out std_logic_vector(47 downto 8)  );end component;signal uA_in,uA_out,uAR_out:std_logic_vector(7 downto 0); signal CM_line:std_logic_vector(47 downto 0);beginuC_uA_inst:uC_uA port map(clk_uC,nreset,M_uA,IR,uA_in,uA_out);uC_uAR_inst:uC_uAR port map(clk_uC,nreset,uA_out,uAR_out);uC_uCM_inst:uC_CM generic map(48,8)port map(clk_uC,uAR_out,CMROM_CS,CM_line);uC_uIR_inst:uC_uIR port map(clk_uC,CM_line,uA_in,CM);end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/63008edd2b3325b6e6ef2c8e700998d8.png"></p><p><img src="https://img-blog.csdnimg.cn/direct/e135b733d411449797e2018f91c18b99.png"></p><p>  模块：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 16:22:50----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.std_logic_unsigned.all;use IEEE.std_logic_textio.all;use STD.textio.all;entity uC_CM is    generic(        width:integer := 48;    --位宽        depth:integer := 8      --深度    );    port(        clk:in std_logic;        addr:in std_logic_vector(depth-1 downto 0);     ----uC_ROM地址        CMROM_CS:in std_logic;  --uC_ROM输出使能                data_out:out std_logic_vector(width-1 downto 0) --uC_ROM输出    );end uC_CM;architecture Behavioral of uC_CM istype matrix is array(integer range&lt;&gt;) of std_logic_vector(width-1 downto 0);signal uC_ROM : matrix(0 to 2**depth-1);procedure load_rom(signal data_word:out matrix) is     file romfile:text open read_mode is &quot;uC_ROM.txt&quot;;    variable lbuf:line;    variable i:integer := 0; --循环变量    variable fdata:std_logic_vector(width-1 downto 0);begin    while(not endfile(romfile) and i&lt;2**depth) loop        readline(romfile,lbuf); -- 逐行读数据        read(lbuf,fdata); -- 将行数据保存到变量fdata        data_word(i)&lt;=fdata; -- 将fdata保存到内存信号量中        i := i+1;    end loop;end procedure;beginload_rom(uC_ROM);data_out &lt;= uC_ROM(conv_integer(addr)) when CMROM_CS=&#39;1&#39;else(others=&gt;&#39;0&#39;);end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 16:22:50----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity uC_uA is    Port(        clk:in std_logic;        nreset:in std_logic;    --复位信号        M_uA:in std_logic;        IR:in std_logic_vector(7 downto 2);     --IR操作码信息        uA_in:in std_logic_vector(7 downto 0);  --uIR传送的微地址                uA_out:out std_logic_vector(7 downto 0) --下一条微指令的地址    );end uC_uA;architecture Behavioral of uC_uA isbeginprocess(clk,nreset)begin    if(nreset=&#39;0&#39;)then uA_out&lt;=(others=&gt;&#39;0&#39;);    elsif(clk=&#39;1&#39;and clk&#39;event)then        if(M_uA=&#39;1&#39;)then uA_out&lt;=IR&amp;&quot;00&quot;;        else uA_out&lt;=uA_in;        end if;    end if;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 16:22:50----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity uC_uAR is    Port(        clk:in std_logic;        nreset: in std_logic;        uAR_in:in std_logic_vector(7 downto 0);  --uA传送的微地址                uAR_out:out std_logic_vector(7 downto 0) --送至uCM的地址    );end uC_uAR;architecture Behavioral of uC_uAR isbeginprocess(clk,nreset)begin    if(nreset=&#39;0&#39;)then uAR_out&lt;=(others=&gt;&#39;0&#39;);    elsif(clk=&#39;1&#39;and clk&#39;event)then uAR_out&lt;=uAR_in;    end if;end process;end Behavioral;------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/24 16:22:50----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity uC_uIR is  Port (    clk:in std_logic;    CM:in std_logic_vector(47 downto 0);        uA:out std_logic_vector(7 downto 0);    uI:out std_logic_vector(47 downto 8)  );end uC_uIR;architecture Behavioral of uC_uIR isbeginuA&lt;=CM(7 downto 0);uI&lt;=CM(47 downto 8);end Behavioral;</code></pre><p> uC_ROM.txt：</p><pre><code>100000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000010001000000000000000000000000000000000000000000011000100000000000000000000000000000000000000000100000010000000000000000000000000000000000000000101000001000000000000000000000000000000000000000110000000100000000000000000000000000000000000000111000000010000000000000000000000000000000000000000</code></pre><p>xdc：</p><pre><code>#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#SW0~15set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[7]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;IR[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;IR[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;IR[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;IR[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;IR[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;IR[7]&#125;]#sw31~24set_property PACKAGE_PIN J8         [get_ports nreset]set_property IOSTANDARD LVCMOS18    [get_ports nreset]set_property PACKAGE_PIN J14         [get_ports CMROM_CS]set_property IOSTANDARD LVCMOS18    [get_ports CMROM_CS]set_property PACKAGE_PIN H9        [get_ports M_uA]set_property IOSTANDARD LVCMOS18    [get_ports M_uA]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]</code></pre><h3 id="15-8-位-SOC-综合设计"><a href="#15-8-位-SOC-综合设计" class="headerlink" title="15.8 位 SOC 综合设计"></a>15.8 位 SOC 综合设计</h3><p>根据以上所设计的功能模块连接成完整的 8 位 SOC 结构。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cfdc1dbc85d346b9c3541e7e13e4fd2f.png"></p><p>模块修改记录：</p><pre><code>SOC:修改PC/ROM*修改各模块时钟修改各模块总线输出时机提高片选及使能优先级，并加入到敏感检测列表修改uC使能：M_uA和CMROM_CS低电平有效（根据指令知）uC输入输出冲突，同时输入输出控制信号修改微指令34H：IO_CS位修改微指令38H：IO_CS位修改微指令24H：Ri_EN错误修改微指令8AH：M_PC位修改微指令65H： RDRi位PC不再产生nPCL和nPCH信号并修改PC模块ADD微程序增加一条微指令</code></pre><p>源码：</p><p>顶层测试：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/27 20:08:24----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity CPU_test is    generic(        CLK_FRE:integer:=100000000    );    Port(        clk:in std_logic;        nreset:in std_logic;        data_in:in std_logic_vector(7 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end CPU_test;architecture Behavioral of CPU_test iscomponent CPU    generic(        CLK_FRE:integer:=100000000    );    Port(        clk:in std_logic;        nreset:in std_logic;        data_in:in std_logic_vector(7 downto 0);                regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);        data_out:out std_logic_vector(7 downto 0)    );end component;component clk_div    generic(        DIV_NUM:integer:=10000    );    Port (        rst:in std_logic;        clk_in:in std_logic;        clk_out:out std_logic    );end component;component seg_dis    port(        rst,clk:in std_logic;        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);                seg_dig:out std_logic_vector(15 downto 0);        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a    );end component;signal clk_line:std_logic;signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);signal regA_out,regB_out,result_out,data_out:std_logic_vector(7 downto 0);beginclk_div_inst:clk_div generic map(1000000)port map(nreset,clk,clk_line);seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);CPU_inst:CPU generic map(100000000)port map(clk_line,nreset,data_in,regA_out,regB_out,result_out,data_out);process(regA_out,regB_out,result_out,data_out)begin    data_in_A&lt;=&quot;00000000&quot;&amp;result_out;    data_in_B&lt;=&quot;00000000&quot;&amp;regB_out;    data_in_C&lt;=&quot;00000000&quot;&amp;regA_out;    data_in_D&lt;=&quot;00000000&quot;&amp;data_out;end process;end Behavioral;</code></pre><p>顶层：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/25 17:50:57----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity CPU is    generic(        CLK_FRE:integer:=100000000    );    Port(        clk:in std_logic;        nreset:in std_logic;        data_in:in std_logic_vector(7 downto 0);                regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);        data_out:out std_logic_vector(7 downto 0)    );end CPU;architecture Behavioral of CPU issignal clk1,nclk1:std_logic;   --clksignal clk2,nclk2:std_logic;   --clk二分频signal w0,w1,w2,w3:std_logic;   --节拍信号component clock    Port(        clk,rst:in std_logic;        clk1,nclk1:out std_logic;   --clk        clk2,nclk2:out std_logic;   --clk二分频        w0,w1,w2,w3:out std_logic   --节拍信号    );end component;signal clk_uC,M_uA,CMROM_CS:std_logic;signal IR_line:std_logic_vector(7 downto 0);signal CTR_BUS:std_logic_vector(47 downto 8);component uC    Port(        clk_uC:in std_logic;    --微程序控制器时钟信号        nreset:in std_logic;    --复位信号        M_uA:in std_logic;      --微地址控制信号        IR:in std_logic_vector(7 downto 2); --IR操作码信息        CMROM_CS:in std_logic;  --控制存储器选通信号                CM:out std_logic_vector(47 downto 8)    --控制信号输出    );end component;signal clk_SP,SP_CS,SP_UP,SP_DN,nSP_EN:STD_LOGIC;signal AR:std_logic_vector(6 downto 0);signal DATA_BUS:std_logic_vector(7 downto 0);component SP    Port(        clk_SP:in std_logic;    --SP时钟信号        nreset:in std_logic;    --复位信号                        SP_CS:in std_logic;     --SP选择信号        SP_UP:in std_logic;     --SP+1控制        SP_DN:in std_logic;     --SP-1控制        nSP_EN:in std_logic;    --SP输出使能                AR:out std_logic_vector(6 downto 0);--SP指向RAM地址        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线    );end component;signal clk_IO,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN:std_logic;signal IO_in,IO_out:std_logic_vector(7 downto 0);component IO    Port(        clk_IO:in std_logic;    --IO时钟信号        nreset:in std_logic;    --IO复位信号        IO_CS:in std_logic;     --IO选择信号        IO_IEN:in std_logic;    --IO输入使能        IO_OEN:in std_logic;    --IO输出使能        RI_EN:in std_logic;     --IO缓存器输入使能        RO_EN:in std_logic;     --IO缓存器输出使能        IO_in:in std_logic_vector(7 downto 0);          --IO输入                IO_out:out std_logic_vector(7 downto 0);        --IO输出        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线    );end component;signal clk_RAM,RAM_CS,nRAM_EN,Wr_nRD:std_logic;component RAM    generic(        depth:positive:=7;        width:positive:=8    );    Port (        clk_RAM:in STD_LOGIC;       --RAM时钟信号        n_reset:in STD_LOGIC;       --RAM选择信号        RAM_CS:in STD_LOGIC;        --RAM片选信号        nRAM_EN:in STD_LOGIC;       --RAM输出使能        Wr_nRD :in STD_LOGIC;       --RAM读写信号        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号                DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线    );end component;signal clk_ALU,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0:std_logic;signal S :std_logic_vector(4 downto 0);signal F_in :std_logic_vector(1 downto 0);    --signal regA_out,regB_out,result_out:std_logic_vector(7 downto 0);signal AC : std_logic;     --半进位标志signal CY : std_logic;     --进位标志signal ZN : std_logic;     --零标志signal OV : std_logic;      --溢出标志component ALU     port(        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟        nreset : in std_logic;      --全局复位信号        M_A,M_B : in std_logic;     --暂存器控制信号        M_F : in std_logic;         --程序状态字控制信号        nALU_EN : in std_logic;     --alu运算结果输出使能        nPSW_EN : in std_logic;     --psw输出使能        C0 : in std_logic;          --进位输入        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位        F_in : in std_logic_vector(1 downto 0);     --移位功能选择                regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线        AC : out std_logic;     --半进位标志        CY : out std_logic;     --进位标志        ZN : out std_logic;     --零标志        OV : out std_logic      --溢出标志    );end component;signal clk_RN,Rn_CS,nRi_EN,RDRi,WRRi:std_logic;signal RS,RD:std_logic;component RN    Port(        clk_RN,Rn_CS,nRi_EN,RDRi,WRRi:in std_logic;        RS,RD:in std_logic;        DATA_BUS:inout std_logic_vector(7 downto 0)    );end component;signal clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen: std_logic;signal IR_AR       :std_logic_vector(6 downto 0);component IR    Port (        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;        DATA_BUS:in std_logic_vector(7 downto 0);                IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）        PC_out:out std_logic_vector(11 downto 0);--PC地址总线        AR:out std_logic_vector(6 downto 0)    );end component;signal clk_ROM,M_ROM,ROM_EN:std_logic;signal ROM_PC:std_logic_vector(11 downto 0);component ROM    generic(        depth:positive:=12;        width:positive:=8    );    Port (        clk_ROM,M_ROM,ROM_EN:in std_logic;        addr:in std_logic_vector(11 downto 0);        DATA_BUS:inout std_logic_vector(7 downto 0)    );end component;signal clk_PC,M_PC,nLD_PC,nPCH,nPCL:std_logic;signal PC_in:std_logic_vector(11 downto 0):=(others=&gt;&#39;0&#39;);component pc    Port (                rst,clk_PC,M_PC,nLD_PC:in std_logic;        nPCH,nPCL:in std_logic;        PC_in:in std_logic_vector(11 downto 0);                PC_out:out std_logic_vector(11 downto 0);        DATA_BUS:inout std_logic_vector(7 downto 0)     );end component;signal test_line:std_logic_vector(7 downto 0);beginclock_inst:clock port map(clk,nreset,clk1,nclk1,clk2,nclk2,w0,w1,w2,w3);PC_inst:PC port map(nreset,clk_PC,M_PC,nLD_PC,nPCH,nPCL,PC_in,ROM_PC,DATA_BUS);ROM_inst:ROM generic map(12,8)port map(clk_ROM,M_ROM,ROM_EN,ROM_PC,DATA_BUS);uC_inst:uC port map(clk_uC,nreset,M_uA,IR_line(7 downto 2),CMROM_CS,CTR_BUS);IR_inst:IR port map(rst=&gt;nreset,clk_IR=&gt;clk_IR,LD_IR1=&gt;LD_IR1,LD_IR2=&gt;LD_IR2,LD_IR3=&gt;LD_IR3,nARen=&gt;nARen,DATA_BUS=&gt;DATA_BUS,IR_out=&gt;IR_line,RS=&gt;RS,RD=&gt;RD,PC_out=&gt;PC_in,AR=&gt;AR(6 downto 0));RAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;nreset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,DATA_BUS=&gt;DATA_BUS);IO_inst:IO port map(clk_IO,nreset,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN,data_in,data_out,DATA_BUS);--SP_inst:SP PORT MAP(clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);ALU_inst:ALU port map(clk,clk_ALU,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,regA_out,regB_out,result_out,DATA_BUS,AC,CY,ZN,OV);RN_inst:RN port map(clk_RN,Rn_CS,nRi_EN,RDRi,WRRi,RS,RD,DATA_BUS);clk_PC&lt;=clk1 and clk2;clk_ROM&lt;=nclk1 and clk2;clk_IR&lt;=clk1 and nclk2;clk_uC&lt;=nclk1 and nclk2;clk_RN&lt;=clk1 and nclk2;clk_ALU&lt;=nclk1 and nclk2;--clk_IO&lt;=clk2;--（LED程序使用）clk_IO&lt;=nclk1 and clk2;--（ADD程序使用）clk_RAM&lt;=nclk1 and w1;clk_SP&lt;=clk1 and clk2 and w1;M_A &lt;= CTR_BUS(47);M_B &lt;= CTR_BUS(46);M_F &lt;= CTR_BUS(45);S(4) &lt;= CTR_BUS(44);S(3) &lt;= CTR_BUS(43);S(2) &lt;= CTR_BUS(42);S(1) &lt;= CTR_BUS(41);S(0) &lt;= CTR_BUS(40);F_in(1) &lt;= CTR_BUS(39);F_in(0) &lt;= CTR_BUS(38);nALU_EN &lt;= CTR_BUS(37);nPSW_EN &lt;= CTR_BUS(36);C0 &lt;= CTR_BUS(35);RAM_CS &lt;= CTR_BUS(34);Wr_nRD &lt;= CTR_BUS(33); nRAM_EN &lt;= CTR_BUS(32);Rn_CS &lt;= CTR_BUS(31);RDRi &lt;= CTR_BUS(30);WRRi &lt;= CTR_BUS(29);nRi_EN &lt;= CTR_BUS(28);LD_IR1 &lt;= CTR_BUS(27);LD_IR2 &lt;= CTR_BUS(26);LD_IR3 &lt;= CTR_BUS(25);nAREN &lt;= CTR_BUS(24);M_PC &lt;= CTR_BUS(23);nLD_PC &lt;= CTR_BUS(22); nPCH &lt;= CTR_BUS(21); nPCL &lt;= CTR_BUS(20); SP_UP &lt;= CTR_BUS(19);SP_DN &lt;= CTR_BUS(18);SP_CS &lt;= CTR_BUS(17); nSP_EN &lt;= CTR_BUS(16); IO_CS &lt;= CTR_BUS(15);IO_IEN &lt;= CTR_BUS(14);IO_OEN &lt;= CTR_BUS(13);RI_EN&lt;=&#39;0&#39;;RO_EN&lt;=&#39;0&#39;;-- &lt;= CTR_BUS(12);M_ROM &lt;= CTR_BUS(11);ROM_EN &lt;= CTR_BUS(10);M_uA &lt;= CTR_BUS(9);CMROM_CS &lt;= CTR_BUS(8);process(nPCH,nPCL)begin    if(nPCH=&#39;0&#39;)then PC_in(11 downto 8)&lt;=DATA_BUS(3 downto 0);    elsif(nPCL=&#39;0&#39;)then PC_in(7 downto 0)&lt;=DATA_BUS;    end if;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b870e7e63c2438527c9603091d047576.png"></p><p>时钟：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bd3c1b7d51ed7ee02fd3b42b4c4ba89.png"></p><p>ADD微程序：</p><pre><code>00111000 --IR:38H MOV Ri,IO00111011 --IR:38H MOV Ri,IO00001000 --ADD R0,R100000100 --JMP addr1200000000 --addr1:00H00000000 --addr2:00H</code></pre><p>LED微程序：</p><pre><code>00100100 --IR:24H MOV Ri,#data00000001 --data:01H00110100 --IR:34H MOV IO,Ri00100100 --IR:24H00000010 --data:02H00110100 --IR:34H00100100 --IR:24H00000100 --data:04H00110100 --IR:34H00100100 --IR:24H00001000 --data:08H00110100 --IR:34H00100100 --IR:24H00010000 --data:10H00110100 --IR:34H00100100 --IR:24H00100000 --data:20H00110100 --IR:34H00100100 --IR:24H01000000 --data:40H00110100 --IR:34H00100100 --IR:24H10000000 --data:80H00110100 --IR:34H00000100 --JMP addr1200000000 --addr:00H00000000 --addr:00H00000000</code></pre><p> 程序：</p><pre><code>000000000011000100011001111100110111100100000000--00H000000000000000000000000000000000000000000000000--01H000000000000000000000000000000000000000000000000--02H000000000000000000000000000000000000000000000000--03H000000000011000100010101111100110111101100000101--04H JMP addr12000000000011000100010011111100110111101100000110--05H000000000011000100010001101100110111011100000000--06H000000000000000000000000000000000000000000000000--07H010000000011000101000001011100110111011100001001--08H ADD Ri,Rj100000000011000101000001011100110111011100001010--09H001000010001000100110001011100110111011100000000--0AH000000000001000100100001111100110111011100000000--0BH000000000000000000000000000000000000000000000000--0CH000000000000000000000000000000000000000000000000--0DH000000000000000000000000000000000000000000000000--0EH000000000000000000000000000000000000000000000000--0FH000000000000000000000000000000000000000000000000--10H000000000000000000000000000000000000000000000000--11H000000000000000000000000000000000000000000000000--12H000000000000000000000000000000000000000000000000--13H000000000000000000000000000000000000000000000000--14H000000000000000000000000000000000000000000000000--15H000000000000000000000000000000000000000000000000--16H000000000000000000000000000000000000000000000000--17H000000000000000000000000000000000000000000000000--18H000000000000000000000000000000000000000000000000--19H000000000000000000000000000000000000000000000000--1AH000000000000000000000000000000000000000000000000--1BH000000000000000000000000000000000000000000000000--1CH000000000000000000000000000000000000000000000000--1DH000000000000000000000000000000000000000000000000--1EH000000000000000000000000000000000000000000000000--1FH000000000000000000000000000000000000000000000000--20H000000000000000000000000000000000000000000000000--21H000000000000000000000000000000000000000000000000--22H000000000000000000000000000000000000000000000000--23H000000000011000100100001111100110111101100100101--24H MOV Ri,#data ***修改***000000000011000100010001011100110111011100100110--25H000000000011000100010001011100110111011100000000--26H000000000000000000000000000000000000000000000000--27H000000000011000101100001011100110111011100101001--28H000000000011000101100001011100110111011100101010--29H000000000011000100010001011100110111011100000000--2AH000000000000000000000000000000000000000000000000--2BH000000000011000100010010111100110111101100101101--2CH000000000011010000100000011100110111011100101110--2DH000000000011000100010001011100110111011100000000--2EH000000000000000000000000000000000000000000000000--2FH000000000011000100010010111100110111101100110001--30H000000000011011101000000011100110111011100110010--31H000000000011000100010001011100110111011100000000--32H000000000000000000000000000000000000000000000000--33H000000000011000101000001011100111101011100110101--34H MOV IO,Ri000000000011000100010001011100110101011100110110--35H 000000000011000100010001011100110111011100000000--36H000000000000000000000000000000000000000000000000--37H000000000011000100010001011100111011011100111001--38H MOV Ri,IO000000000011000100100001011100111001011100111010--39H000000000011000100010001011100110111011100000000--3AH000000000000000000000000000000000000000000000000--3BH000000000011000100010001111100010111101100111101--3CH000000000011000100010001011100110111011100111110--3DH000000000011000100010001011100110111011100000000--3EH000000000000000000000000000000000000000000000000--3FH010000010011000101000001011100110111011101000001--40H000000000011000101100001011100110111011101000010--41H100000000011000111000001011100110111011101000011--42H001000010001000100110001111100110111011101000100--43H000000000011000100010001011100110111011100000000--44H000000000000000000000000000000000000000000000000--45H</code></pre><p>testbench：</p><pre><code>------------------------------------------------------------------------------------ Engineer: switch_swq-- Create Date: 2024/04/26 08:47:54----------------------------------------------------------------------------------library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity CPU_tb isend CPU_tb;architecture Behavioral of CPU_tb iscomponent CPU    generic(        CLK_FRE:integer:=100000000    );    Port(        clk:in std_logic;        nreset:in std_logic;        data_in:in std_logic_vector(7 downto 0);                data_out:out std_logic_vector(7 downto 0)    );end component;signal clk,nreset:std_logic;signal data_in,data_out:std_logic_vector(7 downto 0);beginCPU_inst:CPU generic map(100000000)port map(clk,nreset,data_in,data_out);clock:processbegin    clk&lt;=&#39;1&#39;;    wait for 5ns;    clk&lt;=&#39;0&#39;;    wait for 5ns;end process;reset:processbegin    nreset&lt;=&#39;0&#39;;    wait for 15ns;    nreset&lt;=&#39;1&#39;;    wait;end process;test:processbegin    data_in&lt;=x&quot;FF&quot;;    wait;end process;end Behavioral;</code></pre><p>LED结果：</p><p>整体：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f9cfb770135c8cd06409fe765cdb265.png"></p><p>取数（00100100 –IR:24H MOV Ri,#data 00000001 –data:01H）：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/595f539ee9983cb3ad064110256b9d3d.png"></p><p>IO输出（00110100 –IR:34H MOV IO,Ri）：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/deb8630114a8896456e6eea801735970.png"></p><p>ADD结果：</p><p>整体：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/08792675191fd507e190b166618ace0c.png"></p><p>IO输入（00111000 –IR:38H MOV Ri,IO）：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b48d14803e3b211bfb14f2d81f5dc40a.png"></p><p>加法（00001000 –ADD R0,R1）：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5399cba63467fb5d837fe1e49c0adb02.png"></p><p>xdc：</p><pre><code>#CLK_100Mset_property PACKAGE_PIN E10        [get_ports clk]set_property IOSTANDARD LVCMOS18    [get_ports clk]#sw31~24set_property PACKAGE_PIN J8         [get_ports nreset]set_property IOSTANDARD LVCMOS18    [get_ports nreset]#SW0~7set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]#SEG_DIG1~16set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]#seg_dataset_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]</code></pre><h4 id="1-实验结果分析"><a href="#1-实验结果分析" class="headerlink" title="1.实验结果分析"></a>1.实验结果分析</h4><h5 id="模块工作顺序分析"><a href="#模块工作顺序分析" class="headerlink" title="&lt;1&gt;模块工作顺序分析"></a>&lt;1&gt;<strong>模块工作顺序分析</strong></h5><pre><code>    各个模块工作的逻辑顺序如上时钟时序图所示，每条指令执行则可分为m0~3四个阶段。在m0阶段首先由PC发送地址至ROM，然后ROM输出该地址的指令或数据，传送至IR，IR经过简单处理后继续传送至UC，UC产生各个模块的控制信号。在m1~3阶段，依据微程序产生3次控制信号，实现相应指令功能（注意ALU、RN、IO时钟不同，后面有相关解释）。</code></pre><h5 id="​​​指令执行过程分析"><a href="#​​​指令执行过程分析" class="headerlink" title="&lt;2&gt;​​​指令执行过程分析"></a>&lt;2&gt;​​​<strong>指令执行过程分析</strong></h5><ul><li><strong><strong>以ADD加法为例：</strong></strong></li></ul><p><strong><strong>MOV Ri,IO：</strong></strong></p><pre><code>    m1~3——执行38H MOV Ri,IO：在m1使能IO相关信号使IO_IN-&gt;REG，在m2时，REG-&gt;DATA_BUS-&gt;Ri（IO的时钟先于RN，使数据在DATA_BUS刚好能传送至RN）</code></pre><p><strong><strong>ADD R0,R1：</strong></strong></p><pre><code>    m1~3——执行08H ADD R0,R1：由于无法在计算出结果的同时将结果通过数据总线DATA_BUS传送至RN，所以在一条指令中，我的ADD指令只能实现计算功能，计算结果由ALU另行输出至result总线。在m1和m2分别实现RN-&gt;DATA_BUS-&gt;regA/B（其中regA/B为ALU内部缓冲器），在m3实现计算和UC地址回到00H操作。</code></pre><p><strong><strong>以LED流水灯为例：</strong></strong></p><pre><code>    m0——取指令：PC-&gt;ROM-&gt;DATA_BUS-&gt;IR-&gt;UC，微指令为0x003119f37900H    注意到ROM将地址信息输出到总线，IR接收并传递地址到UC，从而执行24H地址的微程序。</code></pre><p><strong><strong>MOV Ri,#data：</strong></strong></p><pre><code>    m1~3——执行24H MOV Ri,#data：在m1将ROM中的立即数输出至</code></pre><p>DATA_BUS，在m2传输至Ri之中，在m3阶段UC地址回到00H准备进入下一条指令，即取值公操作。</p><p><strong><strong>MOV IO,Ri：</strong></strong></p><pre><code>    m1~3——执行34H MOV IO,Ri：在m1将Ri-&gt;DATA_BUS，在m2，DATA_BUS-&gt;REG-&gt;IO_OUT（REG是IO内暂存器，由于UC控制信号不包含RI_EN和RO_EN，一直使能，即DATA_BUS&lt;-&gt;IO直接完成），在m3阶段UC地址回到00H准备进入下一条指令，即取值公操作。</code></pre><p><strong><strong>JMP addr12</strong></strong><strong><strong>：</strong></strong></p><pre><code>    m1~3——执行04H JMP addr12：在m1、m2依次将立即数加载至IR中，对应LD_IR2和LD_IR3分别有效，IR将新地址传送至PC。</code></pre><ul><li><strong><strong>以ADD加法为例：</strong></strong></li></ul><p><strong><strong>MOV Ri,IO：</strong></strong></p><pre><code>    m1~3——执行38H MOV Ri,IO：在m1使能IO相关信号使IO_IN-&gt;REG，在m2时，REG-&gt;DATA_BUS-&gt;Ri（IO的时钟先于RN，使数据在DATA_BUS刚好能传送至RN）</code></pre><p><strong><strong>ADD R0,R1：</strong></strong></p><pre><code>    m1~3——执行08H ADD R0,R1：由于无法在计算出结果的同时将结果通过数据总线DATA_BUS传送至RN，所以在一条指令中，我的ADD指令只能实现计算功能，计算结果由ALU另行输出至result总线。在m1和m2分别实现RN-&gt;DATA_BUS-&gt;regA/B（其中regA/B为ALU内部缓冲器），在m3实现计算和UC地址回到00H操作。</code></pre><h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h4><h5 id="SOC-模块集成设计经验"><a href="#SOC-模块集成设计经验" class="headerlink" title="&lt;1&gt;SOC****模块集成设计经验"></a>&lt;1&gt;<strong>SOC****模块集成设计经验</strong></h5><pre><code>    在集成各个组成模块时，为避免总线冲突以及方便调试，采用各个模块依次添加测试的方法。    首先测试PC、ROM、IR、UC组成的系统，要求取指令时4个模块的运行顺序为：PC发送ROM地址-&gt;ROM输出指令/数据-&gt;IR传送指令-&gt;UC解析执行微程序。随后依次加入IO、RN、ALU、RAM模块进行调试（按照指令执行逻辑顺序）。</code></pre><h5 id="SOC集成关键"><a href="#SOC集成关键" class="headerlink" title="&lt;2&gt;SOC集成关键"></a>&lt;2&gt;<strong>SOC集成关键</strong></h5><p>在集成各个模块时，关键在于：</p><ul><li><p>清楚模块工作逻辑顺序</p><pre><code>需清楚知晓各个模块工作先后关系，理清数据/控制/地址信号流的传递顺序，以避免读写顺序出错，出现写未读到的情况。</code></pre></li><li><p>避免总线冲突</p><pre><code>主要是DATA_BUS数据总线使用的原子性，各模块严格按照时钟时序进行输出，在允许输出时输入/出数据到数据总线，其他时刻不要忘记将数据总线置高阻态。</code></pre></li><li><p>考虑信号的建立、保持</p><pre><code>在课程参考资料中，ALU、IO、RN的时钟都是nclk2，但是对于任意一条微指令，如果涉及到上述3个模块的协作,如将RN中数据传送至ALU中缓存器regA，由于时钟相同，且都在上升沿工作，则在同一时刻，RN中数据传输到数据总线，上一时刻数据总线的数值传送至regA，并不能实现RN-&gt;DATA_BUS-&gt;regA这一连贯操作。解决方法在于错开操作时间，即RN-&gt;DATA_BUS先于DATA_BUS-&gt;regA，需要修改模块时钟，故出现了上面仿真图中的时钟。</code></pre></li></ul><p>&lt;3&gt;反思与改进</p><ul><li><p>对数据不能在总线上连续传递的思考</p><pre><code>考虑上面“考虑信号的建立、保持”部分产生的问题，问题产生的原因在于组合逻辑电路和时序逻辑电路的区别，如果将信号的触发条件由时钟的上升沿改为高电平（类似于使能信号），则将时序逻辑转变为组合逻辑，可能解决上述问题，使得ALU、IO、RN等模块的时钟可以都是nclk2。</code></pre></li><li><p>ADD指令的改进</p><pre><code>上述实现的ADD指令在有限的m1~3阶段内计算完结果无法实现结果存储至RN（在上面ADD指令时序图可观测到计算结果曾短时间内输出到数据总线DATA_BUS上），仅一个指令周期无法实现，可以扩展成两个，即在第二个指令周期的m0~3阶段实现指令存储至RN。</code></pre></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/999503810dc63f0f906be47e3bbaca66.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/139143519">https://blog.csdn.net/qq_32971095/article/details/139143519</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> vhdl </tag>
            
            <tag> soc </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科大三下SOC微体系结构设计作业合集</title>
      <link href="/2024/04/03/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86/"/>
      <url>/2024/04/03/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.VHDL%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A">一.VHDL设计作业</a></p><p><a href="about:blank#1.%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E7%9A%843-8%E8%AF%91%E7%A0%81%E5%99%A8%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1">1.基于硬件描述语言的3-8译码器逻辑电路设计</a></p><p><a href="about:blank#2.8%E4%BD%8D%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E8%AE%A1">2.8位双向移位寄存器设计</a></p><p><a href="about:blank#3.%E5%9F%BA%E4%BA%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%87%AA%E5%8A%A9%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">3.基于有限状态机的自助售票系统设计</a></p><p><a href="about:blank#4.%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1">4.按键消抖电路设计</a></p><p><a href="about:blank#5.%E5%90%8C%E6%AD%A5%E7%8E%AF%E5%BD%A2FIFO%E8%AE%BE%E8%AE%A1">5.同步环形FIFO设计</a></p><p><a href="about:blank#6.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">6.线上实验——时钟模块设计</a></p><p><a href="about:blank#7.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%8E%9F%E7%A0%81%E4%BA%8C%E4%BD%8D%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1%C2%A0">7.线上实验——原码二位乘法器设计</a></p><p><a href="about:blank#8.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%B8%83%E6%96%AF%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1">8.线上实验——布斯乘法器设计</a></p><hr><h2 id="一-VHDL设计作业"><a href="#一-VHDL设计作业" class="headerlink" title="一.VHDL设计作业"></a>一.VHDL设计作业</h2><p>源文件、测试文件及仿真结果</p><h3 id="1-基于硬件描述语言的3-8译码器逻辑电路设计"><a href="#1-基于硬件描述语言的3-8译码器逻辑电路设计" class="headerlink" title="1.基于硬件描述语言的3-8译码器逻辑电路设计"></a>1.基于硬件描述语言的3-8译码器逻辑电路设计</h3><p>根据3-8译码器基本原理，采用硬件描述语言设计一个3-8译码器逻辑电路，并给出仿真结果。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity decoder3_8 is    Port (          OE: in std_logic;        X: in std_logic_vector(2 downto 0);        Y: out std_logic_vector(7 downto 0)    );end decoder3_8;architecture Behavioral of decoder3_8 isbeginprocess(OE,X)begin    if OE=&#39;0&#39; then Y&lt;=&quot;00000000&quot;;    elsif OE=&#39;1&#39;then        Case X is            When &quot;000&quot; =&gt;Y&lt;=&quot;11111110&quot;;            When &quot;001&quot; =&gt;Y&lt;=&quot;11111101&quot;;            When &quot;010&quot; =&gt;Y&lt;=&quot;11111011&quot;;            When &quot;011&quot; =&gt;Y&lt;=&quot;11110111&quot;;            When &quot;100&quot; =&gt;Y&lt;=&quot;11101111&quot;;            When &quot;101&quot; =&gt;Y&lt;=&quot;11011111&quot;;            When &quot;110&quot; =&gt;Y&lt;=&quot;10111111&quot;;            When &quot;111&quot; =&gt;Y&lt;=&quot;01111111&quot;;            When others =&gt;Y&lt;=&quot;11111111&quot;;        END CASE;       end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity decoder3_8_tb is--  Port ( );end decoder3_8_tb;architecture structural of decoder3_8_tb iscomponent decoder3_8    port(        OE: in std_logic;        X: in std_logic_vector(2 downto 0);        Y: out std_logic_vector(7 downto 0)    );end component;signal oe:std_logic;signal input:std_logic_vector(2 downto 0);signal output:std_logic_vector(7 downto 0);begind1:decoder3_8 port map(oe,input,output);ensure:process    begin        oe&lt;=&#39;0&#39;;        wait for 50ns;        oe&lt;=&#39;1&#39;;        wait;end process;sel:process    begin        input&lt;=&quot;000&quot;;        wait for 20ns;        input&lt;=&quot;001&quot;;        wait for 20ns;        input&lt;=&quot;010&quot;;        wait for 20ns;        input&lt;=&quot;011&quot;;        wait for 20ns;        input&lt;=&quot;100&quot;;        wait for 20ns;        input&lt;=&quot;101&quot;;        wait for 20ns;        input&lt;=&quot;110&quot;;        wait for 20ns;        input&lt;=&quot;111&quot;;        wait for 20ns;end process;end structural;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cdaef1463aa82317fd6029b8c7bb08e.png"></p><h3 id="2-8位双向移位寄存器设计"><a href="#2-8位双向移位寄存器设计" class="headerlink" title="2.8位双向移位寄存器设计"></a>2.8位双向移位寄存器设计</h3><p>采用硬件描述语言实现8位双向移位寄存器，其功能包括异步置零，同步置数，左移，右移和保持状态不变等5种功能。其中输入端口包括8位并行数据、两位的选择信号和两个1位串行数据，输出是8位并行数据。当RESET信号为低电平时，寄存器的输出被异步置零；否则当RESET&#x3D;1时，与时钟有关的四种功能由输入信号MODE决定。请给出仿真结果。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity shift_register is    Port (        clk,reset,left,right:in std_logic;        mode:in std_logic_vector(1 downto 0);        input_data:in std_logic_vector(7 downto 0);        output_data:inout std_logic_vector(7 downto 0)    );end shift_register;architecture Behavioral of shift_register isbeginprocess(reset,clk,mode)begin    if (reset=&#39;0&#39;)then        output_data&lt;=&quot;00000000&quot;;    elsif(reset=&#39;1&#39;and clk=&#39;1&#39;)then        case mode is            when &quot;00&quot;=&gt;output_data&lt;=output_data;            when &quot;01&quot;=&gt;output_data&lt;=input_data;            when &quot;10&quot;=&gt;                    output_data(0)&lt;=left;                    output_data(7)&lt;=output_data(6);                    output_data(6)&lt;=output_data(5);                    output_data(5)&lt;=output_data(4);                    output_data(4)&lt;=output_data(3);                    output_data(3)&lt;=output_data(2);                    output_data(2)&lt;=output_data(1);                    output_data(1)&lt;=output_data(0);                          when &quot;11&quot;=&gt;                    output_data(0)&lt;=output_data(1);                    output_data(1)&lt;=output_data(2);                    output_data(2)&lt;=output_data(3);                    output_data(3)&lt;=output_data(4);                    output_data(4)&lt;=output_data(5);                    output_data(5)&lt;=output_data(6);                    output_data(6)&lt;=output_data(7);                    output_data(7)&lt;=right;            when others=&gt;output_data&lt;=output_data;        end case;             end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity shift_register_tb is--  Port ( );end shift_register_tb;architecture Behavioral of shift_register_tb iscomponent shift_registerport(        clk,reset,left,right:in std_logic;        mode:in std_logic_vector(1 downto 0);        input_data:in std_logic_vector(7 downto 0);        output_data:inout std_logic_vector(7 downto 0)   );end component;signal clk,reset,left,right:std_logic;signal mode:std_logic_vector(1 downto 0);signal input_data:std_logic_vector(7 downto 0);signal output_data:std_logic_vector(7 downto 0);   beginsr1:shift_register port map(clk,reset,left,right,mode,input_data,output_data);clock_gen:process    begin        left&lt;=output_data(7);        right&lt;=output_data(0);        clk&lt;=&#39;0&#39;;        wait for 10ns;        clk&lt;=&#39;1&#39;;        wait for 10ns;end process;reset_gen:process    begin        reset&lt;=&#39;0&#39;;        wait for 25ns;        reset&lt;=&#39;1&#39;;        wait;end process;mode_test:process    begin        mode&lt;=&quot;00&quot;;        wait for 30ns;        mode&lt;=&quot;01&quot;;        input_data&lt;=&quot;00001111&quot;;        wait for 30ns;        mode&lt;=&quot;10&quot;;        wait for 200ns;        mode&lt;=&quot;01&quot;;        input_data&lt;=&quot;00001111&quot;;        wait for 30ns;        mode&lt;=&quot;11&quot;;        wait for 200ns;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5dcfe13e83a9275011aae48f12d1be1c.png"></p><h3 id="3-基于有限状态机的自助售票系统设计"><a href="#3-基于有限状态机的自助售票系统设计" class="headerlink" title="3.基于有限状态机的自助售票系统设计"></a>3.基于有限状态机的自助售票系统设计</h3><p>某自助售票系统只能接收 5元和10元纸币，若一张票的价格设定为 25元。<br>请利用有限状态机设计该售票系统，<br>1. 首先给出状态说明，然后画出具体的状态图及说明状态转移关系。<br>2. 并完成硬件描述语言程序设计。</p><p>3.将第1和2题的答案做成word文档上传。</p><p>4.扩展要求（加分10分）：增加20元纸币输入。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity ticket_state_machine is    Port (        clk,reset:in std_logic;        input_money:in std_logic_vector(2 downto 0);        return_money:out std_logic_vector(2 downto 0);        output_ticket:out std_logic    );end ticket_state_machine;architecture Behavioral of ticket_state_machine istype states is (m0,m5,m10,m15,m20,m25,m30,m35,m40);signal current_state,next_state:states;beginstart:process(reset,clk)    begin        if(reset=&#39;1&#39;)then            current_state&lt;=m0;        elsif(reset=&#39;0&#39;and clk=&#39;1&#39;and clk&#39;event)then            current_state&lt;=next_state;        end if;         end process;state_machine:process(current_state,input_money)    begin        case current_state is            when m0=&gt;                output_ticket&lt;=&#39;0&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m0;                    when&quot;001&quot;=&gt;next_state&lt;=m5;                    when&quot;010&quot;=&gt;next_state&lt;=m10;                    when&quot;100&quot;=&gt;next_state&lt;=m20;                    when others=&gt;next_state&lt;=current_state;                end case;            when m5=&gt;                output_ticket&lt;=&#39;0&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m5;                    when&quot;001&quot;=&gt;next_state&lt;=m10;                    when&quot;010&quot;=&gt;next_state&lt;=m15;                    when&quot;100&quot;=&gt;next_state&lt;=m25;                    when others=&gt;next_state&lt;=current_state;                end case;            when m10=&gt;                output_ticket&lt;=&#39;0&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m10;                    when&quot;001&quot;=&gt;next_state&lt;=m15;                    when&quot;010&quot;=&gt;next_state&lt;=m20;                    when&quot;100&quot;=&gt;next_state&lt;=m30;                    when others=&gt;next_state&lt;=current_state;                end case;             when m15=&gt;                output_ticket&lt;=&#39;0&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m15;                    when&quot;001&quot;=&gt;next_state&lt;=m20;                    when&quot;010&quot;=&gt;next_state&lt;=m25;                    when&quot;100&quot;=&gt;next_state&lt;=m35;                    when others=&gt;next_state&lt;=current_state;                end case;             when m20=&gt;                output_ticket&lt;=&#39;0&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m20;                    when&quot;001&quot;=&gt;next_state&lt;=m25;                    when&quot;010&quot;=&gt;next_state&lt;=m30;                    when&quot;100&quot;=&gt;next_state&lt;=m40;                    when others=&gt;next_state&lt;=current_state;                end case;             when m25=&gt;                output_ticket&lt;=&#39;1&#39;;                return_money&lt;=&quot;000&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m0;                    when&quot;001&quot;=&gt;next_state&lt;=m5;                    when&quot;010&quot;=&gt;next_state&lt;=m10;                    when&quot;100&quot;=&gt;next_state&lt;=m20;                    when others=&gt;next_state&lt;=current_state;                end case;             when m30=&gt;                output_ticket&lt;=&#39;1&#39;;                return_money&lt;=&quot;001&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m0;                    when&quot;001&quot;=&gt;next_state&lt;=m5;                    when&quot;010&quot;=&gt;next_state&lt;=m10;                    when&quot;100&quot;=&gt;next_state&lt;=m20;                    when others=&gt;next_state&lt;=current_state;                end case;             when m35=&gt;                output_ticket&lt;=&#39;1&#39;;                return_money&lt;=&quot;010&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m0;                    when&quot;001&quot;=&gt;next_state&lt;=m5;                    when&quot;010&quot;=&gt;next_state&lt;=m10;                    when&quot;100&quot;=&gt;next_state&lt;=m20;                    when others=&gt;next_state&lt;=current_state;                end case;                when m40=&gt;                output_ticket&lt;=&#39;1&#39;;                return_money&lt;=&quot;011&quot;;                case input_money is                    when&quot;000&quot;=&gt;next_state&lt;=m0;                    when&quot;001&quot;=&gt;next_state&lt;=m5;                    when&quot;010&quot;=&gt;next_state&lt;=m10;                    when&quot;100&quot;=&gt;next_state&lt;=m20;                    when others=&gt;next_state&lt;=current_state;                end case;            end case;             end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity ticket_state_machine_tb is--  Port ( );end ticket_state_machine_tb;architecture Behavioral of ticket_state_machine_tb iscomponent ticket_state_machine    Port (        clk,reset:in std_logic;        input_money:in std_logic_vector(2 downto 0);        return_money:out std_logic_vector(2 downto 0);        output_ticket:out std_logic    );end component;signal clk,reset: std_logic;signal input_money: std_logic_vector(2 downto 0);signal return_money: std_logic_vector(2 downto 0);signal output_ticket: std_logic;begintsm:ticket_state_machine port map(clk,reset,input_money,return_money,output_ticket);clock:process    begin        clk&lt;=&#39;0&#39;;        wait for 10ns;        clk&lt;=&#39;1&#39;;        wait for 10ns;end process;start:process    begin        reset&lt;=&#39;1&#39;;        wait for 20ns;        reset&lt;=&#39;0&#39;;        wait;end process;test:process    begin        wait for 50ns;        input_money&lt;=&quot;001&quot;;        wait for 20ns;        input_money&lt;=&quot;000&quot;;        wait for 50ns;        input_money&lt;=&quot;010&quot;;        wait for 20ns;        input_money&lt;=&quot;000&quot;;        wait for 50ns;        input_money&lt;=&quot;100&quot;;        wait for 20ns;        input_money&lt;=&quot;000&quot;;        wait for 50ns;        input_money&lt;=&quot;010&quot;;        wait for 20ns;        input_money&lt;=&quot;000&quot;;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/711bd6d2672a650569b2474d89e3f38e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dfad20f27e654f243f373cfb9b80256c.png"></p><h3 id="4-按键消抖电路设计"><a href="#4-按键消抖电路设计" class="headerlink" title="4.按键消抖电路设计"></a>4.按键消抖电路设计</h3><p>请使用硬件描述语言设计一个按键消抖电路，假设输入时钟频率为50MHZ。请给出设计方案及仿真验证结果。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity key_stroke is    generic(CLK_FRE:integer:=50000000);    Port (        clk:in std_logic;        reset:in std_logic;        key_in:in std_logic;        output:out std_logic               );end key_stroke;architecture Behavioral of key_stroke istype states is(s0,s1,s2,s3,s4);signal state:states;beginprocess(reset,clk,key_in)variable count_num:integer:=3*CLK_FRE/1000;variable count:integer:=0;    begin        if reset=&#39;1&#39;then            state&lt;=s0;            count:=0;            output&lt;=&#39;0&#39;;        elsif reset=&#39;0&#39;then            case state is                when s0=&gt;if key_in=&#39;1&#39; then state&lt;=s1;end if;                when s1=&gt;                    if clk=&#39;1&#39; then count:=count+1;end if;                    if count=count_num then state&lt;=s2; end if;                when s2=&gt;                    if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s3;                    elsif(key_in=&#39;0&#39;)then output&lt;=&#39;0&#39;;state&lt;=s4;                    end if;                when s3=&gt;                    output&lt;=&#39;0&#39;;                    if(key_in=&#39;0&#39;)then state&lt;=s4;end if;                when s4=&gt;                    state&lt;=s0;                    count:=0;                    output&lt;=&#39;0&#39;;                         end case;                       end if;     end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity key_stroke_tb is--  Port ( );end key_stroke_tb;architecture Behavioral of key_stroke_tb iscomponent key_stroke    generic(CLK_FRE:integer:=50000000);    port(        clk:in std_logic;        reset:in std_logic;        key_in:in std_logic;        output:out std_logic     ); end component;signal clk:std_logic;signal reset:std_logic;signal key_in:std_logic;signal output:std_logic;beginks:key_stroke generic map(50000000)port map(clk,reset,key_in,output);clock:processbegin    clk&lt;=&#39;0&#39;;    wait for 10ns;    clk&lt;=&#39;1&#39;;    wait for 10ns;end process;rst:processbegin    reset&lt;=&#39;1&#39;;    wait for 25ns;    reset&lt;=&#39;0&#39;;    wait;end process;test:processbegin    key_in&lt;=&#39;1&#39;;    wait for 50ns;    key_in&lt;=&#39;0&#39;;    wait for 70ns;    key_in&lt;=&#39;1&#39;;    wait for 100ns;    key_in&lt;=&#39;0&#39;;    wait for 40ns;    key_in&lt;=&#39;1&#39;;    wait for 120ns;    key_in&lt;=&#39;0&#39;;    wait for 30ns;    key_in&lt;=&#39;1&#39;;    wait for 40ns;    key_in&lt;=&#39;0&#39;;    wait for 70ns;    key_in&lt;=&#39;1&#39;;    wait for 30ns;    key_in&lt;=&#39;0&#39;;    wait for 100ns;    key_in&lt;=&#39;1&#39;;    wait for 50ns;    key_in&lt;=&#39;0&#39;;    wait for 20ns;    key_in&lt;=&#39;1&#39;;    wait for 1000ns;    key_in&lt;=&#39;0&#39;;    wait for 2000ns;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2b1e4d12b3c904bbdb1f64914294b450.png"></p><h3 id="5-同步环形FIFO设计"><a href="#5-同步环形FIFO设计" class="headerlink" title="5.同步环形FIFO设计"></a>5.同步环形FIFO设计</h3><p>请采用硬件描述语言设计实现一个存储深度M和数据宽度N可以用户配置的同步FIFO存储器，请给出仿真结果。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity FIFO_ring isgeneric(    depth:positive :=8;    width:positive:=8);    Port(        clk:in std_logic;        rst:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;--        wr_clr:in std_logic;--        wr_en:in std_logic;--        rd_clr:in std_logic;--        rd_en:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end FIFO_ring;architecture Behavioral of FIFO_ring iscomponent duaramgeneric(    depth:positive :=8;    width:positive:=8);Port(    clka:in std_logic;    wr:in std_logic;    addra:in std_logic_vector(depth-1 downto 0);    datain:in std_logic_vector(width-1 downto 0);        clkb:in std_logic;    rd:in std_logic;    addrb:in std_logic_vector(depth-1 downto 0);    dataout:out std_logic_vector(width-1 downto 0)); end component;component write_pointer    generic(        depth:positive    );    Port(        clk:in std_logic;        rst:in std_logic;        wq:in std_logic;        wr_pt:out std_logic_vector(depth-1 downto 0)    );end component;component read_pointer    generic(        depth:positive    );    Port(        clk:in std_logic;        rst:in std_logic;        rq:in std_logic;        rd_pt:out std_logic_vector(depth-1 downto 0)    );end component;component judge_status    generic(        depth:positive    );    port(        clk:in std_logic;        rst:in std_logic;        wr_pt:in std_logic_vector(depth-1 downto 0);        rd_pt:in std_logic_vector(depth-1 downto 0);        empty:out std_logic;        full:out std_logic    );end component;signal rp_line:std_logic_vector(depth-1 downto 0);signal wp_line:std_logic_vector(depth-1 downto 0);beginduaram_inst:duaram generic map(depth,width)port map(clka=&gt;clk,clkb=&gt;clk,datain=&gt;data_in,dataout=&gt;data_out,addra=&gt;wp_line,addrb=&gt;rp_line,rd=&gt;rd,wr=&gt;wr);write_pointer_inst:write_pointer generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,wq=&gt;wr,wr_pt=&gt;wp_line);read_pointer_inst:read_pointer generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,rq=&gt;rd,rd_pt=&gt;rp_line);judge_status_inst:judge_status generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,wr_pt=&gt;wp_line,rd_pt=&gt;rp_line,full=&gt;full,empty=&gt;empty);end Behavioral;library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity duaram isgeneric(    depth:positive :=8;    width:positive:=8);Port(    clka:in std_logic;    wr:in std_logic;    addra:in std_logic_vector(depth-1 downto 0);    datain:in std_logic_vector(width-1 downto 0);        clkb:in std_logic;    rd:in std_logic;    addrb:in std_logic_vector(depth-1 downto 0);    dataout:out std_logic_vector(width-1 downto 0));end duaram;architecture Behavioral of duaram istype ram is array(2**depth-1 downto 0)of std_logic_vector(width-1 downto 0);signal dualram:ram;beginprocess(clka,clkb)begin    if(clka&#39;event and clka=&#39;1&#39;)then        if(wr=&#39;0&#39;)then dualram(conv_integer(addra))&lt;=datain;end if;    end if;end process;process(clkb)begin    if(clkb&#39;event and clkb=&#39;1&#39;)then        if(rd=&#39;0&#39;)then dataout&lt;=dualram(conv_integer(addrb));end if;    end if;end process;end Behavioral;library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity write_pointer is    generic(        depth:positive    );    Port(        clk:in std_logic;        rst:in std_logic;        wq:in std_logic;        wr_pt:out std_logic_vector(depth-1 downto 0)    );end write_pointer;architecture Behavioral of write_pointer issignal wr_pt_t:std_logic_vector(depth-1 downto 0);beginprocess(rst,clk)begin    if(rst=&#39;0&#39;)then        wr_pt_t&lt;=(others=&gt;&#39;0&#39;);    elsif(clk&#39;event and clk=&#39;1&#39;)then        if wq=&#39;0&#39;then wr_pt_t&lt;=wr_pt_t+1;end if;    end if;     end process;wr_pt&lt;=wr_pt_t;end Behavioral;library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity read_pointer is    generic(        depth:positive    );    Port(        clk:in std_logic;        rst:in std_logic;        rq:in std_logic;        rd_pt:out std_logic_vector(depth-1 downto 0)    );end read_pointer;architecture Behavioral of read_pointer issignal rd_pt_t:std_logic_vector(depth-1 downto 0);beginprocess(rst,clk)begin    if(rst=&#39;0&#39;)then        rd_pt_t&lt;=(others=&gt;&#39;0&#39;);    elsif(clk&#39;event and clk=&#39;1&#39;)then        if rq=&#39;0&#39;then rd_pt_t&lt;=rd_pt_t+1;end if;    end if;     end process;rd_pt&lt;=rd_pt_t;end Behavioral;library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity judge_status is    generic(        depth:positive    );    port(        clk:in std_logic;        rst:in std_logic;        wr_pt:in std_logic_vector(depth-1 downto 0);        rd_pt:in std_logic_vector(depth-1 downto 0);        empty:out std_logic;        full:out std_logic    );end entity judge_status;architecture Behavioral of judge_status isbeginprocess(rst,clk)begin    if(rst=&#39;0&#39;)then empty&lt;=&#39;1&#39;;    elsif clk&#39;event and clk=&#39;1&#39;then        if wr_pt=rd_pt then empty&lt;=&#39;1&#39;;        else empty&lt;=&#39;0&#39;;        end if;    end if;  end process;process(rst,clk)begin    if(rst=&#39;0&#39;)then full&lt;=&#39;0&#39;;    elsif clk&#39;event and clk=&#39;1&#39;then        if wr_pt&gt;rd_pt then            if(depth+rd_pt)=wr_pt then full&lt;=&#39;1&#39;;else full&lt;=&#39;0&#39;;end if;        end if;    end if;  end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity FIFO_ring_tb is--  Port ( );end FIFO_ring_tb;architecture Behavioral of FIFO_ring_tb iscomponent FIFO_ringgeneric(    depth:positive :=8;    width:positive:=8);    Port(        clk:in std_logic;        rst:in std_logic;        data_in:in std_logic_vector(7 downto 0);        wr:in std_logic;        rd:in std_logic;--        wr_clr:in std_logic;--        wr_en:in std_logic;--        rd_clr:in std_logic;--        rd_en:in std_logic;                empty:out std_logic;        full:out std_logic;        data_out:out std_logic_vector(7 downto 0)    );end component;signal clk:std_logic;signal rst:std_logic;signal data_in:std_logic_vector(7 downto 0);signal wr:std_logic;signal rd:std_logic;signal empty:std_logic;signal full:std_logic;signal data_out:std_logic_vector(7 downto 0);beginFIFO_ring_inst:FIFO_ring generic map(8,8)port map(clk,rst,data_in,wr,rd,empty,full,data_out);clock:processbegin    clk&lt;=&#39;0&#39;;    wait for 10ns;    clk&lt;=&#39;1&#39;;    wait for 10ns;end process;reset:processbegin    rst&lt;=&#39;0&#39;;    wait for 25ns;    rst&lt;=&#39;1&#39;;    wait;end process;test:processbegin    rd&lt;=&#39;1&#39;;    wr&lt;=&#39;1&#39;;    data_in&lt;=&quot;00000000&quot;;    wait for 50ns;    data_in&lt;=&quot;00000001&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;00000010&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;00000100&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;00001000&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;00010000&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;00100000&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;01000000&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 30ns;    data_in&lt;=&quot;10000000&quot;;    wr&lt;=&#39;0&#39;;    wait for 20ns;    wr&lt;=&#39;1&#39;;    wait for 50ns;        rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;    rd&lt;=&#39;0&#39;;    wait for 20ns;    rd&lt;=&#39;1&#39;;    wait for 30ns;        wait;    end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9085cd14c31cada75062d36a643fb2b5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4dbe7b6e7886a88433a6fb76f77ee7f8.png"></p><h3 id="6-线上实验——时钟模块设计"><a href="#6-线上实验——时钟模块设计" class="headerlink" title="6.线上实验——时钟模块设计"></a>6.线上实验——时钟模块设计</h3><p>采用硬件描述语言设计实现CPU时钟模块，输出信号包括四个节拍信号（每两个时钟周期一个节拍），时钟反相信号，时钟2分频信号及其反相信号，完成逻辑功能设计及仿真验证，并给出仿真结果。</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity clock is    Port(        clk,rst:in std_logic;        clk1,nclk1:out std_logic;   --clk        clk2,nclk2:out std_logic;   --clk二分频        w0,w1,w2,w3:out std_logic   --节拍信号    );end clock;architecture Behavioral of clock isbeginprocess(clk)variable count_clk2:integer:=0;variable count_w:integer:=0;begin    if(rst=&#39;0&#39;)then        w0&lt;=&#39;0&#39;;        w1&lt;=&#39;0&#39;;        w2&lt;=&#39;0&#39;;        w3&lt;=&#39;0&#39;;        clk1&lt;=&#39;0&#39;;        nclk1&lt;=&#39;1&#39;;        clk2&lt;=&#39;0&#39;;        nclk2&lt;=&#39;1&#39;;        count_clk2:=0;        count_w:=0;    elsif(rst=&#39;1&#39;)then        clk1&lt;=clk;        nclk1&lt;=not clk;        if(clk&#39;event and clk=&#39;1&#39;)then            if(count_clk2=0)then count_clk2:=1;clk2&lt;=&#39;1&#39;;nclk2&lt;=&#39;0&#39;;            elsif(count_clk2=1)then count_clk2:=0;clk2&lt;=&#39;0&#39;;nclk2&lt;=&#39;1&#39;;            end if;            if(count_w&gt;=0 and count_w&lt;=3)then w0&lt;=&#39;1&#39;;else w0&lt;=&#39;0&#39;;end if;            if(count_w&gt;=4 and count_w&lt;=7)then w1&lt;=&#39;1&#39;;else w1&lt;=&#39;0&#39;;end if;            if(count_w&gt;=8 and count_w&lt;=11)then w2&lt;=&#39;1&#39;;else w2&lt;=&#39;0&#39;;end if;            if(count_w&gt;=12 and count_w&lt;=15)then w3&lt;=&#39;1&#39;;else w3&lt;=&#39;0&#39;;end if;            if(count_w&lt;15)then count_w:=count_w+1;else count_w:=0;end if;        end if;    end if;end process;end Behavioral;</code></pre><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity clock_tb is--  Port ( );end clock_tb;architecture Behavioral of clock_tb iscomponent clock    Port(        clk,rst:in std_logic;        clk1,nclk1:out std_logic;   --clk        clk2,nclk2:out std_logic;   --clk二分频        w0,w1,w2,w3:out std_logic   --节拍信号    );end component;signal clk,rst:std_logic;signal clk1,nclk1:std_logic;   --clksignal clk2,nclk2:std_logic;   --clk二分频signal w0,w1,w2,w3:std_logic;  --节拍信号beginclock_inst:clock port map(clk,rst,clk1,nclk1,clk2,nclk2,w0,w1,w2,w3);clock_gen:processbegin    clk&lt;=&#39;0&#39;;    wait for 10ns;    clk&lt;=&#39;1&#39;;    wait for 10ns;end process;reset_gen:processbegin    rst&lt;=&#39;0&#39;;    wait for 25ns;    rst&lt;=&#39;1&#39;;    wait;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/adec0f2295677479c7321988b4b0f166.png"></p><h3 id="7-线上实验——原码二位乘法器设计"><a href="#7-线上实验——原码二位乘法器设计" class="headerlink" title="7.线上实验——原码二位乘法器设计"></a>7.线上实验——原码二位乘法器设计</h3><p>请用硬件描述语言设计一个原码二位乘法器，其中两个操作数位宽为8，请给出仿真结果。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7bb5fc46ac6d878964e59ddeb1fe803c.png"></p><p>顶层——multiplier_2bit：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity multiplier_2bit is    Port(        clk,start:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        done:out std_logic;        sout:inout std_logic_vector(15 downto 0)    );end multiplier_2bit;architecture Behavioral of multiplier_2bit iscomponent multiplier_ctrl    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end component;component multiplier_8bitshiftreg    Port (        clk,load:in std_logic;        din:in std_logic_vector(7 downto 0);        qb0,qb1:out std_logic     );end component;component multiplier_16bitreg    Port (        clk,clr:in std_logic;        d:in std_logic_vector(8 downto 0);        q:out std_logic_vector(15 downto 0)     );end component;component multiplier_selector    Port (        clk,rst:in std_logic;        a0,a1,cin:in std_logic;        din:in std_logic_vector(7 downto 0);        cout:out std_logic;        dout:out std_logic_vector(7 downto 0)     );end component;component multiplier_8bitadder    Port (        clk,rst:in std_logic;        cin:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end component;signal clk_line:std_logic;signal rst_line:std_logic;signal cin_line:std_logic;signal qb1_line,qb0_line:std_logic;signal bin_line:std_logic_vector(7 downto 0);signal sout_line:std_logic_vector(8 downto 0);signal test_line:std_logic_vector(8 downto 0);beginmultiplier_ctrl_inst:multiplier_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);multiplier_8bitshiftreg_inst:multiplier_8bitshiftreg port map(clk=&gt;clk_line,load=&gt;rst_line,din=&gt;ain,qb0=&gt;qb0_line,qb1=&gt;qb1_line);multiplier_16bitreg_inst:multiplier_16bitreg port map(clk=&gt;clk_line,clr=&gt;rst_line,d=&gt;sout_line,q=&gt;sout);multiplier_selector_inst:multiplier_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;qb0_line,a1=&gt;qb1_line,cin=&gt;sout_line(8),din=&gt;bin,cout=&gt;cin_line,dout=&gt;bin_line);multiplier_8bitadder_inst:multiplier_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,cin=&gt;cin_line,ain=&gt;sout(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f30332a988566f33bab93454ab0c0ca.png"></p><p>testbench:</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity multiplier_2bit_tb is--  Port ( );end multiplier_2bit_tb;architecture Behavioral of multiplier_2bit_tb iscomponent multiplier_2bit    Port(        clk,start:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        done:out std_logic;        sout:inout std_logic_vector(15 downto 0)    );end component;signal clk,start: std_logic;signal ain,bin: std_logic_vector(7 downto 0);signal done: std_logic;signal sout: std_logic_vector(15 downto 0);beginmultiplier_2bit_inst:multiplier_2bit port map(clk,start,ain,bin,done,sout);clock_gen:processbegin      clk&lt;=&#39;1&#39;;    wait for 10ns;    clk&lt;=&#39;0&#39;;    wait for 10ns;end process;test:processbegin    ain&lt;=&quot;10011010&quot;;    bin&lt;=&quot;01100101&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 150ns;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/559a1c00923a7cda00c06f63c6dec1cc.png"></p><p>模块：</p><p>multiplier_2bit_ctrl ：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_ctrl is    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end multiplier_ctrl;architecture Behavioral of multiplier_ctrl issignal cnt3b:std_logic_vector(2 downto 0);beginprocess(clk,start)begin    rstall&lt;=start;    if(start=&#39;1&#39;)then cnt3b&lt;=&quot;000&quot;;    elsif clk&#39;event and clk=&#39;1&#39;then if cnt3b&lt;=4 then cnt3b&lt;=cnt3b+1;end if;    end if;end process;process(clk,cnt3b,start)begin    if (start=&#39;1&#39;)then        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;;     elsif(start=&#39;0&#39;)then            if cnt3b&lt;=4 then clkout&lt;=clk;        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;        end if;     end if;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/920cb7c013bd5af2e09bc59aafba028c.png"></p><p>multiplier_2bit_8bitshiftreg：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_8bitshiftreg is    Port (        clk,load:in std_logic;        din:in std_logic_vector(7 downto 0);        qb0,qb1:out std_logic     );end multiplier_8bitshiftreg;architecture Behavioral of multiplier_8bitshiftreg issignal reg8b:std_logic_vector(7 downto 0);beginprocess(clk,load)begin    if load=&#39;1&#39;then reg8b&lt;=din;qb0&lt;=&#39;0&#39;;qb1&lt;=&#39;0&#39;;end if;    if(load=&#39;0&#39;and clk=&#39;1&#39;)then         qb0&lt;=reg8b(0);        qb1&lt;=reg8b(1);        reg8b(5 downto 0)&lt;=reg8b(7 downto 2);        reg8b(7 downto 6)&lt;=&quot;00&quot;;       end if;     end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d171f9dc0e6d54b72cf1ffe1f8c759ec.png"></p><p>multiplier_2bit_16bitreg：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_16bitreg is    Port (        clk,clr:in std_logic;        d:in std_logic_vector(8 downto 0);        q:out std_logic_vector(15 downto 0)     );end multiplier_16bitreg;architecture Behavioral of multiplier_16bitreg isbeginprocess(clk,clr)variable sr16b:std_logic_vector(15 downto 0);begin    if clr=&#39;1&#39;then        sr16b:=&quot;0000000000000000&quot;;    elsif(clr=&#39;0&#39;and clk&#39;event and clk=&#39;1&#39;)then          sr16b(15 downto 8):=d(7 downto 0);        sr16b(13 downto 0):=sr16b(15 downto 2);        sr16b(15):=d(8);        sr16b(14):=d(8);    end if;       q&lt;=sr16b;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/08847d6e576be1f9f61c68f8d15899b6.png"></p><p>multiplier_2bit_selector：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_selector is    Port (        clk,rst:in std_logic;        a0,a1,cin:in std_logic;        din:in std_logic_vector(7 downto 0);        cout:out std_logic;        dout:out std_logic_vector(7 downto 0)     );end multiplier_selector;architecture Behavioral of multiplier_selector isbeginprocess(clk,a0,a1,cin,din)begin    if(rst=&#39;1&#39;)then cout&lt;=&#39;0&#39;;dout&lt;=&quot;00000000&quot;;    elsif(rst=&#39;0&#39;and clk&#39;event and clk=&#39;0&#39;)then        if(a0=a1 and a0=cin)then dout&lt;=&quot;00000000&quot;;cout&lt;=cin;        elsif(a1=&#39;0&#39;and (a0 xor cin)=&#39;1&#39;)then dout&lt;=din;cout&lt;=&#39;0&#39;;        elsif((a1 xor a0)=&#39;1&#39;and a0=cin)then            dout(7 downto 1)&lt;=din(6 downto 0);              dout(0)&lt;=&#39;0&#39;;            cout&lt;=&#39;0&#39;;        elsif(a1=&#39;1&#39;and(a0 xor cin)=&#39;1&#39;)then            dout&lt;=(not din)+1;            cout&lt;=&#39;1&#39;;          end if;    end if;    end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e286d15abce298cf0b629350ba7e076e.png"></p><p>multiplier_2bit_8bitadder：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_8bitadder is    Port (        clk,rst:in std_logic;        cin:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end multiplier_8bitadder;architecture Behavioral of multiplier_8bitadder isbeginprocess(clk,rst,ain,bin,cin)begin    if(rst=&#39;1&#39;)then sout&lt;=&quot;000000000&quot;;    elsif(rst=&#39;0&#39;and clk=&#39;0&#39;)then        sout&lt;=(&#39;0&#39;&amp; ain)+(cin &amp; bin);    end if;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdd818c3fea80ef3bef0a36c7c6ab446.png"></p><p><strong>设计注意点：</strong></p><p>0.设计顺序：控制器-8b移位寄存器-16位缓存器-选择器-加法器</p><p>1.输入位8位无符号数，若输入有符号数需修改位宽并另外计算符号位。</p><p>2.共用总线需注意时序，防止总线冲突以及数据读取错误</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b25fa007565503bdd4b69b5d6c31496d.png"></p><p>共用总线sout时序设计：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/daac7ca07dca672e89a3e831d4b8bd9a.png"></p><p>3.process内语句顺序执行的次序。</p><p>4.变量的使用：mulitiplier_16bitreg中</p><pre><code>variable sr16b:std_logic_vector(15 downto 0);</code></pre><p>若使用 signal sr16b，则 q&lt;&#x3D;sr16b; 无效</p><p>5.位拓展：</p><pre><code>sout&lt;=(&#39;0&#39;&amp; ain)+(cin &amp; bin); </code></pre><p>使用 &amp; 符拓展位宽</p><h3 id="8-线上实验——布斯乘法器设计"><a href="#8-线上实验——布斯乘法器设计" class="headerlink" title="8.线上实验——布斯乘法器设计"></a>8.线上实验——布斯乘法器设计</h3><p>采用硬件描述语言设计实现布斯乘法器，完成逻辑功能设计及仿真验证，并给出仿真结果。</p><p>按照7中的设计顺序对7中设计文件进行修改：</p><pre><code>    ctrl模块发出时钟周期数改为8；8bitshiftreg和16bitreg模块每个时钟周期移动1位，且8；8bitshiftreg输出的是a0和a-1；16bitreg和selector模块载入数值后求补；selector模块删去cin和cout信号并修改规则；adder无cin...</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8c09ab4e531a18f069ba4afb9e18d438.png"></p><p>顶层模块——multiplier_booth：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity multiplier_booth is    Port(        clk,start:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        done:out std_logic;        sout:inout std_logic_vector(15 downto 0)    );end multiplier_booth;architecture Behavioral of multiplier_booth iscomponent multiplier_booth_ctrl    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end component;component multiplier_booth_8bitshiftreg    Port (        clk,load:in std_logic;        din:in std_logic_vector(7 downto 0);        qb0,qb1:out std_logic     );end component;component multiplier_booth_16bitreg    Port (        clk,clr:in std_logic;        d:in std_logic_vector(8 downto 0);        q:out std_logic_vector(15 downto 0)     );end component;component multiplier_booth_selector    Port (        clk,rst:in std_logic;        a0,a1:in std_logic;        din:in std_logic_vector(7 downto 0);        dout:out std_logic_vector(7 downto 0)     );end component;component multiplier_booth_8bitadder    Port (        clk,rst:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end component;signal clk_line:std_logic;signal rst_line:std_logic;signal qb1_line,qb0_line:std_logic;signal bin_line:std_logic_vector(7 downto 0);signal sout_line:std_logic_vector(8 downto 0);signal test_line:std_logic_vector(8 downto 0);beginmultiplier_booth_ctrl_inst:multiplier_booth_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);multiplier_booth_8bitshiftreg_inst:multiplier_booth_8bitshiftreg port map(clk=&gt;clk_line,load=&gt;rst_line,din=&gt;ain,qb0=&gt;qb0_line,qb1=&gt;qb1_line);multiplier_booth_16bitreg_inst:multiplier_booth_16bitreg port map(clk=&gt;clk_line,clr=&gt;rst_line,d=&gt;sout_line,q=&gt;sout);multiplier_booth_selector_inst:multiplier_booth_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;qb0_line,a1=&gt;qb1_line,din=&gt;bin,dout=&gt;bin_line);multiplier_booth_8bitadder_inst:multiplier_booth_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,ain=&gt;sout(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3e67513e1e27963a8e15f23f6a8cc7c.png"></p><p>testbench：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;entity multiplier_booth_tb is--  Port ( );end multiplier_booth_tb;architecture Behavioral of multiplier_booth_tb iscomponent multiplier_booth    Port(        clk,start:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        done:out std_logic;        sout:inout std_logic_vector(15 downto 0)    );end component;signal clk,start: std_logic;signal ain,bin: std_logic_vector(7 downto 0);signal done: std_logic;signal sout: std_logic_vector(15 downto 0);beginmultiplier_booth_inst:multiplier_booth port map(clk,start,ain,bin,done,sout);clock_gen:processbegin      clk&lt;=&#39;1&#39;;    wait for 10ns;    clk&lt;=&#39;0&#39;;    wait for 10ns;end process;test:processbegin    ain&lt;=&quot;00000010&quot;;    bin&lt;=&quot;10000010&quot;;    wait for 25ns;    start&lt;=&#39;1&#39;;    wait for 25ns;    start&lt;=&#39;0&#39;;        wait for 200ns;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cd31e8dc5958ee6e4b4eedfd590f2fa.png"></p><p>模块：</p><p>multiplier_booth_ctrl：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_booth_ctrl is    Port (        clk,start:in std_logic;        clkout,rstall,done:out std_logic     );end multiplier_booth_ctrl;architecture Behavioral of multiplier_booth_ctrl issignal cnt4b:std_logic_vector(3 downto 0);beginprocess(clk,start)begin    rstall&lt;=start;    if(start=&#39;1&#39;)then cnt4b&lt;=&quot;0000&quot;;    elsif clk&#39;event and clk=&#39;1&#39;then if cnt4b&lt;=8 then cnt4b&lt;=cnt4b+1;end if;    end if;end process;process(clk,cnt4b,start)begin    if (start=&#39;1&#39;)then        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;;     elsif(start=&#39;0&#39;)then            if cnt4b&lt;=8 then clkout&lt;=clk;        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;        end if;     end if;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/83c13baff1be05be6cda0e582d59099f.png"></p><p>multiplier_booth_8bitshiftreg：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_booth_8bitshiftreg is    Port (        clk,load:in std_logic;        din:in std_logic_vector(7 downto 0);        qb0,qb1:out std_logic     );end multiplier_booth_8bitshiftreg;architecture Behavioral of multiplier_booth_8bitshiftreg issignal reg8b:std_logic_vector(8 downto 0);beginprocess(clk,load)begin    if load=&#39;1&#39;then         if(din(7)=&#39;1&#39;)then reg8b(8 downto 1)&lt;=(din(7)&amp;(not din(6 downto 0)))+1;else reg8b(8 downto 1)&lt;=din;end if;  --取补码        reg8b(0)&lt;=&#39;0&#39;;        qb0&lt;=&#39;0&#39;;qb1&lt;=&#39;0&#39;;    end if;    if(load=&#39;0&#39;and clk=&#39;1&#39;)then         qb0&lt;=reg8b(0);        qb1&lt;=reg8b(1);        reg8b(7 downto 0)&lt;=reg8b(8 downto 1);        reg8b(8)&lt;=&#39;0&#39;;       end if;     end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/61bbc405e10beaea2c2635a94871b4cb.png"></p><p>multiplier_booth_16bitreg：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_booth_16bitreg is    Port (        clk,clr:in std_logic;        d:in std_logic_vector(8 downto 0);        q:out std_logic_vector(15 downto 0)     );end multiplier_booth_16bitreg;architecture Behavioral of multiplier_booth_16bitreg isbeginprocess(clk,clr)variable sr16b:std_logic_vector(15 downto 0);begin    if clr=&#39;1&#39;then        sr16b:=&quot;0000000000000000&quot;;    elsif(clr=&#39;0&#39;and clk&#39;event and clk=&#39;1&#39;)then          sr16b(15 downto 8):=d(7 downto 0);        sr16b(14 downto 0):=sr16b(15 downto 1);        sr16b(15):=d(8);    --移位复制符号位    end if;       q&lt;=sr16b;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/78e8dae445e0aa8620fd29c657228abd.png"></p><p>multiplier_booth_selector：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_booth_selector is    Port (        clk,rst:in std_logic;        a0,a1:in std_logic;        din:in std_logic_vector(7 downto 0);        dout:out std_logic_vector(7 downto 0)     );end multiplier_booth_selector;architecture Behavioral of multiplier_booth_selector isbeginprocess(clk,a0,a1,din)variable complement_x:std_logic_vector(7 downto 0);variable complement_x_negative:std_logic_vector(7 downto 0);begin    if(rst=&#39;1&#39;)then dout&lt;=&quot;00000000&quot;;    elsif(rst=&#39;0&#39;and clk&#39;event and clk=&#39;0&#39;)then        if(din(7)=&#39;1&#39;)then complement_x:=(din(7)&amp;(not din(6 downto 0)))+1;else complement_x:=din;end if;    --取X补码        if((not din(7))=&#39;1&#39;)then complement_x_negative:=((not din(7))&amp;(not din(6 downto 0)))+1;else complement_x_negative:=(not din(7))&amp;din(6 downto 0);end if; --取-X补码        if(a1=a0)then dout&lt;=&quot;00000000&quot;;        elsif(a0=&#39;1&#39;and a1=&#39;0&#39;)then dout&lt;=complement_x;        elsif(a0=&#39;0&#39;and a1=&#39;1&#39;)then dout&lt;=complement_x_negative;        end if;    end if;    end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9597c2a19cccbc17358d377d0ee32df8.png"></p><p>multiplier_booth_8bitadder：</p><pre><code>library IEEE;use IEEE.STD_LOGIC_1164.ALL;use IEEE.STD_LOGIC_UNSIGNED.ALL;entity multiplier_booth_8bitadder is    Port (        clk,rst:in std_logic;        ain,bin:in std_logic_vector(7 downto 0);        sout:out std_logic_vector(8 downto 0)     );end multiplier_booth_8bitadder;architecture Behavioral of multiplier_booth_8bitadder isbeginprocess(clk,rst,ain,bin)begin    if(rst=&#39;1&#39;)then sout&lt;=&quot;000000000&quot;;    elsif(rst=&#39;0&#39;and clk=&#39;0&#39;)then        sout&lt;=(ain(7) &amp; ain)+(bin(7)  &amp; bin);   --符号位扩展加法    end if;end process;end Behavioral;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7c983ed1ce45af2d329d820c088e9dd.png"></p><p><strong>设计注意点：</strong></p><p>1.求补码的方法：</p><pre><code>if(din(7)=&#39;1&#39;)then     reg8b(8 downto 1)&lt;=(din(7)&amp;(not din(6 downto 0)))+1;else reg8b(8 downto 1)&lt;=din;end if;  --取补码</code></pre><p>2.求和时符号位拓展：</p><pre><code>sout&lt;=(ain(7) &amp; ain)+(bin(7)  &amp; bin);   --符号位扩展加法</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/137247923">https://blog.csdn.net/qq_32971095/article/details/137247923</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> vhdl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vitis AI——FPGA学习笔记</title>
      <link href="/2024/03/29/Vitis%20AI%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/29/Vitis%20AI%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><p>[Xilinx&#x2F;Vitis-AI-Tutorials (github.com)](<a href="https://github.com/Xilinx/Vitis-AI-">https://github.com/Xilinx/Vitis-AI-</a><br>Tutorials “Xilinx&#x2F;Vitis-AI-Tutorials (github.com)“)</p><p><a href="https://github.com/Xilinx/Vitis-AI" title="Xilinx&#x2F;Vitis-AI: Vitis AI is Xilinx’s development stack for AI inference on Xilinx hardwareplatforms">Xilinx&#x2F;Vitis-AI: Vitis AI is Xilinx’s development stack for AI inference on<br>Xilinx hardware platforms</a></p><p><a href="https://www.bilibili.com/video/BV1iR4y1k7wn/?spm_id_from=333.788&vd_source=01cde8042a76495bf513aa4407a56cd6" title="【03】ALINX Zynq UltraScale+ MPSoC XILINX FPGA视频教程Vitis AI开发">【03】ALINX Zynq UltraScale+ MPSoC XILINX FPGA视频教程Vitis<br>AI开发</a></p><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>边缘计算edge-ai；cloud-computing-edge-computing</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/089f9efe7c54689a339a571239a84873.png"></p><p>edge端inference全栈部署方案</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/966474c137754c658fddaa07152e7ef2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/319a2ebc600fdfb819856d52d5825acc.png"></p><h4 id="安装vitis-ai的准备"><a href="#安装vitis-ai的准备" class="headerlink" title="安装vitis-ai的准备"></a>安装vitis-ai的准备</h4><p>In addition, Vitis AI supports three host types（对于三种类型的机器，安装vitis-ai需做一定准备：</p><blockquote><blockquote><ul><li>CPU-only with no GPU acceleration：CPU hosts require no special<br>preparation.<blockquote><ul><li>CUDA-capable GPUs</li></ul></blockquote></li></ul></blockquote></blockquote><blockquote><blockquote><ul><li>AMD ROCm™ GPUs：见[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt#id3 “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt”)</li></ul></blockquote></blockquote><blockquote><blockquote></blockquote></blockquote><p>&lt;1&gt;安装docker、Clone github Repository：</p><pre><code>git clone https://github.com/Xilinx/Vitis-AIcd Vitis-AI</code></pre><p>注：You are now ready to start working with the Vitis AI Docker container. At<br>this stage you will choose whether you wish to <strong>use the pre-built container,<br>or build the container from scripts</strong>. docker环境的搭建可以选择Vitis-<br>ai中的脚本搭建或者docker官方直接下载<strong>预构建的</strong> 特定架构docker（见后），即：</p><pre><code>docker pull xilinx/vitis-ai-&lt;Framework&gt;-&lt;Arch&gt;:latest</code></pre><table><thead><tr><th>Desired Docker</th><th><Framework></Framework></th><th><Arch></Arch></th></tr></thead><tbody><tr><td>PyTorch cpu-only</td><td>pytorch</td><td>cpu</td></tr><tr><td>TensorFlow 2 cpu-only</td><td>tensorflow2</td><td>cpu</td></tr><tr><td>TensorFlow 1.15 cpu-only</td><td>tensorflow</td><td>cpu</td></tr><tr><td>PyTorch ROCm</td><td>pytorch</td><td>rocm</td></tr><tr><td>TensorFlow 2 ROCm</td><td>tensorflow2</td><td>rocm</td></tr></tbody></table><p>或：</p><pre><code>cd &lt;Vitis-AI install path&gt;/Vitis-AI./docker_run.sh xilinx/vitis-ai-&lt;pytorch|tensorflow2|tensorflow&gt;-&lt;cpu|rocm&gt;:latest</code></pre><p>适用机器类型：</p><ol><li>CPU-only</li><li>CUDA-capable GPUs</li><li>ROCm-capable GPUs</li></ol><p>注：The <code>cpu</code> option <em>does not provide GPU acceleration support</em>  which is<br><strong>strongly recommended</strong>  for acceleration of the Vitis AI [:ref:<code>Quantization process &lt;quantization-process&gt;</code>](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt#id11<br>“:ref:<code>Quantization process &lt;quantization-process&gt;</code> “). The pre-built <code>cpu</code><br>container should only be used when a GPU is not available on the host machine.</p><p>（原文详细介绍了在NVIDIA器件上支持CUDA GPU的vitis-ai搭建）</p><p>注：vitis-ai补丁安装：[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt”)</p><p>&lt;2&gt;安装交叉编译环境</p><p>By default, the<strong>cross compiler</strong> will be installed in<br><strong><code>~/petalinux_sdk_2023.1</code></strong>. The ~&#x2F;petalinux_sdk_2023.1 path is recommended<br>for the installation. Regardless of the path you choose for the installation,<br>make sure the path has read-write permissions. In this quickstart, it is<br>installed in ~&#x2F;petalinux_sdk_2023.1</p><p>在bash中执行：</p><pre><code>[Host] $ cd Vitis-AI/board_setup/vek280[Host] $ sudo chmod u+r+x host_cross_compiler_setup.sh[Host] $ ./host_cross_compiler_setup.sh</code></pre><p>注：为下载相关资源，执行前的软件安装源为清华源，也可参考：[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.”)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/93def47e1072cf25c9fb7e564d9ac777.png"></p><p> When the installation is complete, follow the prompts and execute the<br>following command:</p><pre><code>source ~/petalinux_sdk_2023.1/environment-setup-cortexa72-cortexa53-xilinx-linux</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc05d626369cb12f1b1b386fad291dfc.png"></p><pre><code>     The **DPU** implements **an efficient tensor-level instruction set **designed to support and **accelerate** various popular **convolutional neural networks** , such as VGG, ResNet, GoogLeNet, YOLO, SSD, and MobileNet, among others.     The DPU supports on AMD **Zynq™ UltraScale+™ MPSoCs, the Kria™ KV260, Versal™ and Alveo cards**. It scales to meet the requirements of many diverse applications in terms of throughput, latency, scalability, and power. </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/acb9834ffdad75aafa209db3944d7929.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b926c0530c9f863597c101da17b84dd2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7632c574e72b01f31355845825ac6439.png"></p><h5 id="Zynq-™-UltraScale-™-MPSoC-DPUCZDX8G-workflow-system"><a href="#Zynq-™-UltraScale-™-MPSoC-DPUCZDX8G-workflow-system" class="headerlink" title="Zynq ™ UltraScale+ ™ MPSoC: DPUCZDX8G([workflow-system-"></a>Zynq ™ UltraScale+ ™ MPSoC: DPUCZDX8G([workflow-system-</h5><p>integration.rst.txt at master](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;workflow-system-integration.rst.txt<br>“workflow-system-integration.rst.txt at master”)</p><p>The DPUCZDX8G IP has been optimized for Zynq UltraScale+ MPSoC. You can<br>integrate this IP as a block in the programmable logic (PL) of the selected<br>Zynq UltraScale+ MPSoCs with direct connections to the processing system (PS).<br>The DPU is user-configurable and exposes several parameters which can be<br>specified to optimize PL resources or customize enabled features.</p><p> 下载地址：</p><table><thead><tr><th>Product Guide</th><th>Platforms</th><th>Vitis AI Release</th><th>Reference Design</th><th>IP-only Download</th></tr></thead><tbody><tr><td>DPUCV2DX8G <a href="https://docs.xilinx.com/r/en-US/pg425-dpu" title="PG425">PG425</a></td><td></td><td></td><td></td><td></td></tr><tr><td>VEK280&#x2F;V70&#x2F;Vx2802</td><td>3.5</td><td></td><td></td><td></td></tr><tr><td>[Download](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_VAI_v3.5.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_VAI_v3.5.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Download”)</td><td>[Get</td><td></td><td></td><td></td></tr><tr><td>IP](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_ip_repo_VAI_v3.5.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_ip_repo_VAI_v3.5.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Get IP”)</td><td></td><td></td><td></td><td></td></tr><tr><td>DPUCV2DX8G <a href="https://docs.xilinx.com/r/en-US/pg425-dpu" title="PG425">PG425</a></td><td></td><td></td><td></td><td></td></tr><tr><td>VE2302(see note)</td><td>3.5</td><td>[Early Access](<a href="https://account.amd.com/en/member/vitis-">https://account.amd.com/en/member/vitis-</a></td><td></td><td></td></tr><tr><td>ai-ve2302.html “Early Access”)</td><td>[Early</td><td></td><td></td><td></td></tr><tr><td>Access](<a href="https://account.amd.com/en/member/vitis-ai-ve2302.html">https://account.amd.com/en/member/vitis-ai-ve2302.html</a> “Early Access”)</td><td></td><td></td><td></td><td></td></tr><tr><td>DPUCZDX8G <a href="https://docs.xilinx.com/r/en-US/pg338-dpu" title="PG338">PG338</a></td><td>MPSoC &amp;</td><td></td><td></td><td></td></tr><tr><td>Kria K26</td><td>3.0</td><td></td><td></td><td></td></tr><tr><td>[Download](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_VAI_v3.0.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Download”)</td><td>[Get</td><td></td><td></td><td></td></tr><tr><td>IP](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_ip_repo_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_ip_repo_VAI_v3.0.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Get IP”)</td><td></td><td></td><td></td><td></td></tr><tr><td>DPUCVDX8G <a href="https://docs.xilinx.com/r/en-US/pg389-dpu" title="PG389">PG389</a></td><td>VCK190</td><td></td><td></td><td></td></tr><tr><td>3.0</td><td></td><td></td><td></td><td></td></tr><tr><td>[Download](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_VAI_v3.0.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Download”)</td><td>[Get</td><td></td><td></td><td></td></tr><tr><td>IP](<a href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_ip_repo_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_ip_repo_VAI_v3.0.tar.gz</a></td><td></td><td></td><td></td><td></td></tr><tr><td>“Get IP”)</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>For MPSoC and Versal AI Core (non AIE-ML devices) please refer to the**&#x2F;dpu**<br>subdirectory in the Vitis AI 3.0 Github repository.</p><p><strong>部署过程：</strong>[Vitis-AI-Tutorials&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD at 2.0 ·<br>Xilinx&#x2F;Vitis-AI-Tutorials (github.com)](<a href="https://github.com/Xilinx/Vitis-AI-">https://github.com/Xilinx/Vitis-AI-</a><br>Tutorials&#x2F;tree&#x2F;2.0&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD “Vitis-AI-<br>Tutorials&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD at 2.0 · Xilinx&#x2F;Vitis-AI-Tutorials<br>(github.com)“)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/959557dd80a7f6cf4d928cceb75051d3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0508c091f64853b67804b2e760e60cbb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3caf388ba1b35f2a14b2243c95dc133c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/999d2443c9fa5ace609d9ea94ced32fa.png"></p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7830ed03ef207f14e4a19700168625d9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd38dd26c8c57234f377f0f7a4a2ef48.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5558aa103e0c00df512de7552ebe3804.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8bd66f3a8c93d2eb320e9af0f1109b3c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/18e33f756df780499701f1488563de29.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8913598ae8b0c899f6a709062fe876f9.png"></p><h3 id="3-vitis-ai的解决方案"><a href="#3-vitis-ai的解决方案" class="headerlink" title="3.vitis-ai的解决方案"></a>3.vitis-ai的解决方案</h3><p>The Vitis AI solution is packaged and delivered as follows:</p><ul><li>AMD open download: pre-built target <strong>images</strong> integrating the <strong>DPU</strong></li><li>Vitis AI <strong>docker containers</strong> : model development tools</li><li>Vitis AI <strong>github repository</strong> : model deployment libraries, setup scripts, examples and reference designs</li></ul><h3 id="4-vitis-ai工具链"><a href="#4-vitis-ai工具链" class="headerlink" title="4.vitis-ai工具链"></a>4.vitis-ai工具链</h3><p><strong>Model Development</strong><br><strong>Vitis AI Model Zoo</strong><br>The :ref:<code>Vitis AI Model Zoo &lt;workflow-model-zoo&gt;</code> includes <strong>optimized deep<br>learning models</strong> to speed up the deployment of deep learning inference on<br>adaptable AMD platforms. These models cover different applications, including<br>ADAS&#x2F;AD, video surveillance, robotics, and data center. You can get started<br>with these pre-trained models to enjoy the benefits of deep learning<br>acceleration.</p><p><strong>Vitis AI Model Inspector</strong><br>The :ref:<code>Vitis AI Model Inspector &lt;model-inspector&gt;</code> is used to <strong>perform<br>initial sanity checks</strong> to confirm that t<strong>he operators and sequence of<br>operators</strong> in the graph is compatible with Vitis AI. Novel neural network<br>architectures, operators, and activation types are constantly being developed<br>and optimized for prediction accuracy and performance. Vitis AI provides<br>mechanisms to leverage operators that are not natively supported by your<br>specific DPU target.</p><p><strong>Vitis AI Optimizer</strong><br>The :ref:<code>Vitis AI Optimizer &lt;model-optimization&gt;</code> exploits <strong>the notion of<br>sparsity</strong> to r<strong>educe the overall computational complexity</strong> for inference by<br>5x to 50x with minimal accuracy degradation. Many deep neural network<br>topologies employ significant levels of redundancy. This is particularly true<br>when the network backbone is optimized for prediction accuracy with training<br>datasets supporting many classes. In many cases, this redundancy can be<br>reduced by “pruning” some of the operations out of the graph.</p><p><strong>Vitis AI Quantizer</strong><br>The :ref:<code>Vitis AI Quantizer &lt;model-quantization&gt;</code>, integrated as a component<br>of either TensorFlow or PyTorch, <strong>converts 32-bit floating-point weights</strong><br>and activations to<strong>fixed-point integers like INT8</strong> to reduce the computing<br>complexity without losing prediction accuracy. The fixed-point network model<br>requires less memory bandwidth and provides faster speed and higher power<br>efficiency than the floating-point model.</p><p><strong>Vitis AI Compiler</strong><br>The :ref:<code>Vitis AI Compiler &lt;model-compilation&gt;</code> maps the AI quantized<br>model<strong>to a highly-efficient instruction set and dataflow model</strong>. The<br>compiler performs multiple optimizations; for example, batch normalization<br>operations are fused with convolution when the convolution operator precedes<br>the normalization operator. As the DPU supports <strong>multiple dimensions of<br>parallelism</strong> , efficient instruction scheduling is <strong>key to exploiting the<br>inherent parallelism</strong> and potential for <strong>data reuse</strong> in the graph. The<br>Vitis AI Compiler addresses such optimizations.</p><p><strong>Model Deployment<br>Vitis AI Runtime</strong><br>The :ref:<code>Vitis AI Runtime &lt;vitis-ai-runtime&gt;</code> (VART) is<strong>a set of low-level<br>API functions</strong> that support the integration of the DPU into software<br>applications. VART is built on top of the Xilinx Runtime (XRT) amd provides a<br>unified high-level runtime for both Data Center and Embedded targets. Key<br>features of the <strong>Vitis AI Runtime API</strong> include:</p><p>Asynchronous <strong>submission</strong> of <strong>jobs</strong> to the <strong>DPU</strong>.<br>Asynchronous <strong>collection</strong> of <strong>jobs</strong> from the <strong>DPU</strong>.<br><strong>C++ and Python API</strong> implementations.<br>Support for <strong>multi-threading and multi-process</strong> execution.<br><strong>Vitis AI Library</strong><br>The :ref:<code>Vitis AI Library &lt;vitis-ai-library&gt;</code> is a set of <strong>high-level<br>libraries and APIs built on top of the Vitis AI Runtime (VART)</strong>. The higher-<br>level APIs included in the Vitis AI Library give developers a head-start on<br>model deployment. While it is possible for developers to directly leverage the<br>Vitis AI Runtime APIs to deploy a model on AMD platforms, it is often more<br>beneficial to start with a ready-made example that incorporates the various<br>elements of a typical application, including:</p><p><strong>Simplified CPU-based pre and post-processing implementations.</strong><br>Vitis AI Runtime integration at an application level.<br><strong>Vitis AI Profiler</strong><br>The :ref:<code>Vitis AI Profiler &lt;vitis-ai-profiler&gt;</code> profiles and visualizes AI<br>applications to find <strong>bottlenecks</strong> and allocates computing resources among<br>different devices. It is easy to use and requires no code changes. It can<br><strong>trace function calls</strong> and <strong>run time</strong> , and also <strong>collect hardware<br>information</strong> , including CPU, DPU, and memory utilization.</p><p>模型开发：示例模型、检查器（语法、适用性）、优化器（稀疏连接）、量化器（位宽）、编译器（DPU指令）</p><p>模型部署：VART（DPU API）、Library（优化预处理、后处理）、分析器（各环节运行时间）</p><h2 id="二-Docker环境搭建"><a href="#二-Docker环境搭建" class="headerlink" title="二.Docker环境搭建"></a>二.Docker环境搭建</h2><p>在第一部分“安装的准备”已经介绍了搭建的两种方法。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/32b5b070bc91e1a49bc4d0cf742becc9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0f0f5995489ccc5498b68acb9a6ac56.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3fde56db0b1e14a450d2f3f07ce98f82.png"></p><pre><code>sudo apt-get remove docker-engine docker-ce docker.iosudo apt-get install curlcurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-get update &amp;&amp; sudo apt install docker-ce docker-ce-cll containerd.iosystemctl status dockersudo docker run hello-worldsudo usermod -aG docker $USERnewgrp dockerdocker run hello-worlddocker infodocker imagesdocker ps -a</code></pre><p>若安装docker-ce失败：</p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/docker-ce/" title="docker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror">docker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>下载vitis-ai的docker：</p><p><a href="https://hub.docker.com/r/xilinx/vitis-ai-cpu" title="xilinx&#x2F;vitis-ai-cpu - Docker Image | Docker Hub">xilinx&#x2F;vitis-ai-cpu - Docker Image | Docker Hub</a></p><p><a href="https://hub.docker.com/r/xilinx/vitis-ai" title="xilinx&#x2F;vitis-ai - Docker Image | Docker Hub">xilinx&#x2F;vitis-ai - Docker Image | Docker Hub</a></p><pre><code>docker pull xilinx/vitis-ai</code></pre><p>使用git命令下载vitis-ai</p><pre><code>git clone https://github.com/Xilinx/Vitis-AI</code></pre><p>启动docker环境：vitis-ai目录下运行脚本</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/17de1dceb4e74e034696eb3b16af2272.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/53bfce013f7c4c2e53486eb49cae2149.png"></p><p>可以看到其工作目录为workspace，上机目录直接为系统根目录：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00f5736efd94ea115591a8121f7171b4.png"></p><p> 而且这个docker预装了conda，进入 tensorflow 的conda并打印其组件：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1a916ce4ff8de0d37df1060bec900bd9.png"></p><p>其他docker命令：[Docker最新超详细版教程通俗易懂(基础版) - 知乎<br>(zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/442442997">https://zhuanlan.zhihu.com/p/442442997</a> “Docker最新超详细版教程通俗易懂(基础版)</p><ul><li>知乎 (zhihu.com)“)</li></ul><h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三.实例"></a>三.实例</h2><h3 id="1-下载示例模型"><a href="#1-下载示例模型" class="headerlink" title="1.下载示例模型"></a>1.下载示例模型</h3><p>在model_zoo文件夹内可以浏览各种支持的模型，这里我们选择tf_yolov3_3.5，打开model_info.md文件：</p><pre><code># YOLOv3### Contents1. [Use Case and Application](#Use-Case-and-Application)2. [Specification](#Specification)3. [Paper and Architecture](#Paper-and-Architecture)4. [Dataset Preparation](#Dataset-Preparation)5. [Use Guide](#Use-Guide)6. [License](#License)7. [Note](#Note)### Use Case and Application   - Classic Object Detection   - Trained on VOC dataset      ### Specification| Metric             | Value                                   || :----------------- | :-------------------------------------- || Framework          | TensorFlow2                             || Prune Ratio        | 0%                                      || FLOPs              | 65.63G                                  || Input Dims (H W C) | 416,416,3                               || FP32 Accuracy      | 0.7846 mAP                              || INT8 Accuracy      | 0.7729 mAP                              || Train Dataset      | voc07+12_trainval                   || Test Dataset       | voc07_test                              || Supported Platform | GPU, VEK280, V70                        |  ### Paper and Architecture 1. Network Architecture: YOLOv32. Paper Link: https://arxiv.org/abs/1804.02767   ### Dataset Preparation1. Dataset descriptionThe model is trained on VOC2007_trainval + VOC2012_trainval and tested on VOC2007_test.2. Download and prepare the datasetOur script `prepare_data.sh` downloads and prepares the dataset automatically. But if you have downloaded the VOC2007 test set before, you could place them in the `data` directory manually and choose to skip downloading the dataset when the script asking for a choice. Run the script:   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash code/test/dataset_tools/prepare_data.sh</span><br></pre></td></tr></table></figure>Dataset diretory structure  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOCdevkit is unpacked from the downloaded data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">voc2007_test is generated by our code <span class="keyword">for</span> data preparation</span></span><br><span class="line">+ data</span><br><span class="line">  + VOCdevkit</span><br><span class="line">    + VOC2007</span><br><span class="line">      + ImageSets</span><br><span class="line">      + JPEGImages</span><br><span class="line">      + Annotations</span><br><span class="line">  + voc2007_test</span><br><span class="line">    + images</span><br><span class="line">      + 000001.jpg</span><br><span class="line">      + 000002.jpg</span><br><span class="line">      + ...</span><br><span class="line">    + test.txt</span><br><span class="line">    + gt_detection.txt</span><br></pre></td></tr></table></figure>### Use Guide1. Evaluation    Configure the model path and data path in [code/test/run_eval.sh](code/test/run_eval.sh)    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash code/test/run_eval.sh</span><br></pre></td></tr></table></figure>     ### LicenseApache License 2.0For details, please refer to **[Vitis-AI License](https://github.com/Xilinx/Vitis-AI/blob/master/LICENSE)**### Note1. Data preprocess  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data channel order: RGB(0~255)</span><br><span class="line">input = input / 255</span><br><span class="line">resize: keep aspect ratio of the raw image and resize it to make the length of the longer side equal to 416</span><br><span class="line">padding: pad along the short side with 0.5 to generate the input image with size = 416 x 416</span><br></pre></td></tr></table></figure>2. Node information  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input node: &#x27;input_1:0&#x27;</span><br><span class="line">output nodes: &#x27;conv2d_59/BiasAdd:0&#x27;, &#x27;conv2d_67/BiasAdd:0&#x27;, &#x27;conv2d_75/BiasAdd:0&#x27;</span><br></pre></td></tr></table></figure>  ### Quantize1. Quantize tool installation   Please refer to [vai_q_tensorflow](../../../src/vai_quantizer/vai_q_tensorflow1.x)  2. Quantize workspace   You could use code/quantize/ folder.</code></pre><p><strong>详细阅读该文件介绍，接下来下载所需文件：</strong></p><p>在model_zoo文件夹，运行downloader.py，下载tf_yolov3_3.5</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9a7d62a708af32a1de4b5d1c059a76e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/13689caf7d2c1dcba28ba1b59e594a71.png"></p><p> 下载后对文件进行解压：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/154c0219b2383c095a676e4a40d64715.png"></p><p>通常model-zoo提供的模型文件结构如下：</p><p>tensorflow：</p><pre><code>├── code                            # Contains test code that can execute the model on the target and showcase model performance.││├── readme.md                       # Documents the environment requirements, data pre-processing requirements, and model information.│                                     Developers should refer to this to understand how to test the model with scripts.│├── data                            # The dataset target directory that can be used for model verification and training.│                                     When test or training scripts run successfully, the dataset will be placed in this directory.│├── quantized│   └── quantize_eval_model.pb      # Quantized model for evaluation.│└── float    └── frozen.pb                   # The floating-point frozen model is used as the input to the quantizer.                                      The naming of the protobuf file may differ from the model naming used in the model list.</code></pre><p>pytorch：</p><pre><code>├── code                            # Contains test and training code.││├── readme.md                       # Contains the environment requirements, data pre-processing requirements and model information.│                                     Developers should refer to this to understand how to test and train the model with scripts.│├── data                            # The dataset target directory that is used for model verification and training.│                                     When test or training scripts run successfully, the dataset will be placed in this directory.│├── qat                             # Contains the QAT (Quantization Aware Training) results.│                                     For some models, the accuracy of QAT is higher than with Post Training Quantization (PTQ) methods.│                                     Some models, but not all, provide QAT reference results, and only these models have a QAT folder.│├── quantized│   ├── _int.pth                    # Quantized model.│   ├── quant_info.json             # Quantization steps of tensors got. Please keep it for evaluation of quantized model.│   ├── _int.py                     # Converted vai_q_pytorch format model.│   └── _int.xmodel                 # Deployed model. The name of different models may be different.│                                     For some models that support QAT you could find better quantization results in &#39;qat&#39; folder.││└── float    └── _int.pth                    # Trained float-point model. The pth name of different models may be different.                                      Path and model name in test scripts could be modified according to actual situation.</code></pre><p>打开下载好的tf_yolov3_3.5文件夹，其中按照之前的model_info文件所叙述的内容，进行“Download and prepare the<br>dataset”（不是必须运行）：</p><pre><code>bash code/test/dataset_tools/prepare_data.sh</code></pre><p>下载好的文件结构也在md文件中，在docker中执行评估（不是必须运行）（docker外需配置环境cv2、numpy）：</p><pre><code>bash code/test/run_eval.sh</code></pre><p>评估结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/38b92c92fb4b1a06262e88117770e500.png"></p><p>安装snap和snapcraft后安装模型查看工具netron：</p><pre><code>sudo apt-get install snapsudo apt-get install snapcraftsudo snap install netron</code></pre><p>然后就可以查看float文件夹下的pb文件网络的结构：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a57b4d4b3f8c4bcd95910f16c04e505.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5c9e1dc7906295e163c8989b3a3b743.png"></p><pre><code>1. Data preprocess  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data channel order: RGB(0~255)</span><br><span class="line">input = input / 255</span><br><span class="line">resize: keep aspect ratio of the raw image and resize it to make the length of the longer side equal to 416</span><br><span class="line">padding: pad along the short side with 0.5 to generate the input image with size = 416 x 416</span><br></pre></td></tr></table></figure>2. Node information  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input node: &#x27;input_1:0&#x27;</span><br><span class="line">output nodes: &#x27;conv2d_59/BiasAdd:0&#x27;, &#x27;conv2d_67/BiasAdd:0&#x27;, &#x27;conv2d_75/BiasAdd:0&#x27;</span><br></pre></td></tr></table></figure> </code></pre><p>可以看到在第59、67、75个conv2d节点后进行了输出：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/030fa826ada83d08a466bb23919680bc.png"></p><h3 id="2-模型量化"><a href="#2-模型量化" class="headerlink" title="2.模型量化"></a>2.模型量化</h3><p>在上述md文件最后给出了量化指引：</p><pre><code>### Quantize1. Quantize tool installation   Please refer to [vai_q_tensorflow](../../../src/vai_quantizer/vai_q_tensorflow1.x)  2. Quantize workspace   You could use code/quantize/ folder.</code></pre><p>量化参考vitis-ai文件夹下src…和code&#x2F;quantize&#x2F;里的内容</p><p>在code&#x2F;quantize&#x2F;中的config.ini是配置文件，包括量化后模型名、存放位置为&#x2F;quantized及各种参数；</p><p>打开quantize.sh脚本，关注以下内容：</p><pre><code>source ./config.inivai_q_tensorflow quantize \  --input_frozen_graph $FLOAT_MODEL \  --input_nodes $Q_INPUT_NODE \  --input_shapes ?,$INPUT_HEIGHT,$INPUT_WIDTH,3 \  --output_nodes $Q_OUTPUT_NODE \  --input_fn $CALIB_INPUT_FN \  --method $METHOD \  --gpu $GPUS \  --calib_iter $CALIB_ITER \  --output_dir $QUANTIZE_DIR \</code></pre><p>可以看到在量化过程中其调用config.ini中的各种参数，然后通过src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x工具进行量化，转到对应位置，在readme文件中可以看到详细信息：</p><p>[Vitis-AI&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x at master · Xilinx&#x2F;Vitis-AI<br>(github.com)](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;tree&#x2F;master&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x “Vitis-<br>AI&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x at master · Xilinx&#x2F;Vitis-AI<br>(github.com)“)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9d34d43f9036308c8f83f589b763afd2.jpeg"></p><pre><code>#目的：The process of inference is computation intensive and requires a high memory bandwidth to satisfy the low-latency and high-throughput requirement of edge applications.#介绍（vitis-ai工具只包含量化工具，修建工具在optimizer中）：Quantization and channel pruning techniques are employed to address these issues while achieving high performance and high energy efficiency with little degradation in accuracy. Quantization makes it possible to use integer computing units and to represent weights and activations by lower bits, while pruning reduces the overall required operations. In the Vitis AI quantizer, only the quantization tool is included. The pruning tool is packaged in the Vitis AI optimizer. Contact the support team for the Vitis AI development kit if you require the pruning tool.</code></pre><p>将32位浮点数转化为8位整数：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b4e03ee0be4436f378980db2d44681b1.jpeg"></p><p>量化的步骤：</p><pre><code>## Running vai_q_tensorflow### Preparing the Float Model and Related Input Files|1|frozen_graph.pb|Floating-point frozen inference graph. Ensure that the graph is the inference graph rather than the training graph.||2|calibration dataset|A subset of the training dataset containing 100 to 1000 images.||3|input_fn|An input function to convert the calibration dataset to the input data of the frozen_graph during quantize calibration. Usually performs data pre-processing and augmentation.|#### **Generating the Frozen Inference Graph**Training a model with TensorFlow 1.x creates a folder containing a GraphDef file (usually ending with *a.pb* or *.pbtxt* extension) and a set of checkpoint files. What you need for mobile or embedded deployment is a single GraphDef file that has been “frozen,” or had its variables converted into inline constants, so everything is in one file. To handle the conversion, TensorFlow provides *freeze_graph.py*, which is automatically installed with the vai_q_tensorflow quantizer.#### **Preparing the Calibration Dataset and Input Function**The calibration set is usually a subset of the training/validation dataset or actual application images (at least 100 images for performance). The input function is a Python importable function to load the calibration dataset and perform data preprocessing. The vai_q_tensorflow quantizer can accept an input_fn to do the preprocessing, which is not saved in the graph. If the preprocessing subgraph is saved into the frozen graph, the input_fn only needs to read the images from dataset and return a feed_dict.### Quantizing the Model Using vai_q_tensorflow### Generating the Quantized Model- *quantize_eval_model.pb* is used to evaluate the CPU/GPUs, and can be used to simulate the results on hardware.|1|deploy_model.pb|Quantized model for the Vitis AI compiler (extended TensorFlow format) for targeting DPUCZDX8G implementations.||2|quantize_eval_model.pb|Quantized model for evaluation (also, the Vitis AI compiler input for most DPU architectures, like DPUCAHX8H, and DPUCADF8H).|### (Optional) Fast FinetuneFast finetune adjusts the weights layer by layer with calibration dataset and may get better accuracy for some models. It will take much longer time than normal PTQ (still shorter than QAT as calibration dataset is much smaller than train dataset) and is disabled by default to save time, and can be turned on to try to improve the performance if you see accuracy issues.### (Optional) Exporting the Quantized Model to ONNXThe quantized model is tensorflow protobuf format by default. If you want to get a ONNX format model, just add *output_format* to the *vai_q_tensorflow* command.### (Optional) Evaluating the Quantized ModelIf you have scripts to evaluate floating point models, like the models in [Vitis AI Model Zoo](https://github.com/Xilinx/Vitis-AI/tree/master/model_zoo), apply the following two changes to evaluate the quantized model:...### (Optional) Dumping the Simulation Results## vai_q_tensorflow Quantization Aware TrainingQuantization aware training (QAT, also called *quantize finetuning* in [Quantization Overview](#quantization-overview)) is similar to float model training/finetuning, but in QAT, the vai_q_tensorflow APIs are used to rewrite the float graph to convert it to a quantized graph before the training starts. The typical workflow is as follows:...### Generated Files### QAT APIs for TensorFlow 1.x## Converting to Float16 or BFloat16The vai_q_tensorflow supports data type conversions for float models, including Float16, BFloat16, Float, and Double. To achieve this, you can add *convert_datatype* to the vai_q_tensorflow command. ## vai_q_tensorflow Supported Operations and APIs</code></pre><p> 在准备阶段包括：推理图的固化（freeze_graph.py已安装在vai_q_tensorflow内）、准备验证数据集和输入函数…</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2035fe160556f3713512b51266287de1.png"></p><p>关于vai_q_tensorflow命令的详细使用见readme中的vai_q_tensorflow Usage，例：</p><pre><code>#show help: $vai_q_tensorflow --help#quantize:$vai_q_tensorflow quantize --input_frozen_graph frozen_graph.pb \--input_nodes inputs \--output_nodes predictions \--input_shapes ?,224,224,3 \--input_fn my_input_fn.calib_input#dump quantized model:$vai_q_tensorflow dump --input_frozen_graph quantize_results/quantize_eval_model.pb \--input_fn my_input_fn.dump_input</code></pre><p>将 &#x2F;float&#x2F;文件夹下的fb文件重命名为float.fb，在docker环境中转到&#x2F;quantize文件夹下运行量化脚本（下载包含运行后文件，非必要）：</p><pre><code>bash quantize.sh</code></pre><p>运行结果如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d38f0ab41704bb97f91f371d5b4c3cfd.png"></p><p>量化后的模型文件位于&#x2F;quantize的pb文件，继续运行&#x2F;quantize下的evaluate_quantize_model.sh文件（非必要）对量化后的模型进行评估，结果如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c32c7a9a74429a18ef81f04ae3638c1.png"></p><h3 id="3-模型编译"><a href="#3-模型编译" class="headerlink" title="3.模型编译"></a>3.模型编译</h3><h2 id="四-mpsoc快速开始"><a href="#四-mpsoc快速开始" class="headerlink" title="四.mpsoc快速开始"></a>四.mpsoc快速开始</h2><p>见：[Vitis-AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt at v3.5 ·<br>Xilinx&#x2F;Vitis-AI (github.com)](<a href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;v3.5&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt at v3.5 · Xilinx&#x2F;Vitis-AI<br>(github.com)“)</p><p>（适合xilinx官方开发板zcu102、zcu104、kv260）</p><h2 id="五-官方资料"><a href="#五-官方资料" class="headerlink" title="五.官方资料"></a>五.官方资料</h2><p>vivado_integration：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c5bf2b5b0093972699eb12988ab59d9.png"></p><p>vitis_integration：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/478de52c0e6c34207461eb523f74eb5a.png"></p><p>vek280_setup:</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/781bf68946aadd0ca2d81fe1be31e3f9.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/136803363">https://blog.csdn.net/qq_32971095/article/details/136803363</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI学习笔记</title>
      <link href="/2024/03/29/AI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/29/AI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E7%BB%ADopencv%E2%80%94%E2%80%94%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8">一.续opencv——级联分类器</a></p><p><a href="about:blank#%E4%BA%8C.c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95">二.c语言实现进化算法</a></p><p><a href="about:blank#%E4%B8%89.LeNet%20%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%20MNIST%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB">三.LeNet 网络实现 MNIST<br>手写数字识别</a></p><p><a href="about:blank#%E5%9B%9B.the%20simplest%20neural%20network%20model">四.the simplest neural network<br>model</a></p><p><a href="about:blank#%E4%BA%94.Multi-Layered%20Perceptron">五.Multi-Layered Perceptron</a></p><p><a href="about:blank#1.Gradient%20Descent%20Optimization%EF%BC%88%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%EF%BC%89">1.Gradient Descent<br>Optimization（梯度下降算法）</a></p><p>[2.Multi-Layered Perceptrons and<br>Backpropagation（多层感知器和反向传播）](about:blank#2.Multi-<br>Layered%20Perceptrons%20and%20Backpropagation%EF%BC%88%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%89)</p><p><a href="about:blank#3.%E5%8D%95%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B">3.单层感知器模型</a></p><p><a href="about:blank#%3C1%3E%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8CX%E4%B8%BA%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%EF%BC%8CY%E4%B8%BA%E6%A0%87%E7%AD%BE%EF%BC%9A">&lt;1&gt;创建数据集，X为特征向量，Y为标签：</a></p><p><a href="about:blank#%3C2%3E%C2%A0%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%EF%BC%9A%C2%A0">&lt;2&gt; 前向传播计算过程：</a></p><p><a href="about:blank#%3C3%3E%E4%BD%BF%E7%94%A8softmax%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A6%82%E7%8E%87%EF%BC%9A">&lt;3&gt;使用softmax函数转换为概率：</a></p><p><a href="about:blank#%3C4%3E%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">&lt;4&gt;交叉熵损失函数</a></p><p><a href="about:blank#%3C5%3ELoss%20Minimization%20Problem%20and%20Network%20Training%EF%BC%9A">&lt;5&gt;Loss Minimization Problem and Network<br>Training：</a></p><p><a href="about:blank#%3C6%3E%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93">&lt;6&gt;函数小结</a></p><p><a href="about:blank#%3C7%3ETraining%20the%20Model%C2%A0">&lt;7&gt;Training the Model </a></p><p><a href="about:blank#4.%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">4.网络模型</a></p><p><a href="about:blank#%3C1%3E%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%B1%BB%EF%BC%9A">&lt;1&gt;定义网络类：</a></p><p><a href="about:blank#%3C2%3EMulti-Layered%20Models">&lt;2&gt;Multi-Layered Models</a></p><p><a href="about:blank#5.%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88">5.代码整合</a></p><p><a href="about:blank#6.3-layer%20network%20%E5%AE%9E%E7%8E%B0%20mnist%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB">6.3-layer network 实现 mnist<br>手写数字识别</a></p><p><a href="about:blank#%E5%85%AD.Neural%20Network%20Frameworks">六.Neural Network<br>Frameworks</a></p><p><a href="about:blank#1.Keras">1.Keras</a></p><p>[&lt;1&gt;Training One-Layer Network<br>(Perceptron)](about:blank#%3C1%3ETraining%20One-<br>Layer%20Network%20%28Perceptron%29)</p><p><a href="about:blank#%E2%91%A0%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89">①模型定义</a></p><p><a href="about:blank#%E2%91%A1%E6%A8%A1%E5%9E%8B%E7%BC%96%E8%AF%91%EF%BC%88%E6%8C%87%E5%AE%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E3%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E3%80%90%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AD%89%E3%80%91%E3%80%81%E7%B2%BE%E5%BA%A6%EF%BC%89">②模型编译（指定损失函数、优化方法【梯度下降等】、精度）</a></p><p><a href="about:blank#%E2%91%A2%E8%AE%AD%E7%BB%83">③训练</a></p><p>[&lt;2&gt;Multi-Class Classificatio（多分类问题）](about:blank#%3C2%3EMulti-<br>Class%20Classificatio%EF%BC%88%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89)</p><p>[&lt;3&gt;Multi-Label Classification（多标签分类）](about:blank#%3C3%3EMulti-<br>Label%20Classification%EF%BC%88%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%EF%BC%89)</p><p><a href="about:blank#%3C4%3E%E6%80%BB%E7%BB%93%C2%A0Summary%20of%20Classification%20Loss%20Functions">&lt;4&gt;总结 Summary of Classification Loss<br>Functions</a></p><hr><p>参考资料：<a href="https://github.com/microsoft/AI-For-Beginners" title="microsoft&#x2F;AI-For-Beginners: 12 Weeks, 24 Lessons, AI for All! (github.com)">microsoft&#x2F;AI-For-Beginners: 12 Weeks, 24 Lessons, AI for All!<br>(github.com)</a></p><h2 id="一-续opencv——级联分类器"><a href="#一-续opencv——级联分类器" class="headerlink" title="一.续opencv——级联分类器"></a>一.续opencv——级联分类器</h2><p> <a href="https://blog.csdn.net/qq_32971095/article/details/131609797" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_opencv 数字图像处理-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_opencv 数字图像处理-<br>CSDN博客</a></p><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &quot;imgproc.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)VideoCapture capture(0);Mat image;CascadeClassifier face_cascade;// 人脸检测vector&lt;Rect&gt; faces;int main()&#123;    Mat frame_gray;    face_cascade.load(&quot;OPENCV安装路径/opencv/sources/data/haarcascades/haarcascade_frontalface_alt.xml&quot;);    while (capture.isOpened())    &#123;        capture &gt;&gt; image;        if (image.empty())break;        if (waitKey(1) == 27)break;        // BGR2GRAY        cvtColor(image, frame_gray, COLOR_BGR2GRAY);        face_cascade.detectMultiScale(frame_gray, faces);        for (size_t i = 0; i &lt; faces.size(); i++)        &#123;            // 人脸画框            rectangle(image, faces[i], Scalar(255, 0, 0), 1, 8);        &#125;        imshow(&quot;Face detection&quot;,image);    &#125;&#125;</code></pre><h2 id="二-c语言实现进化算法"><a href="#二-c语言实现进化算法" class="headerlink" title="二.c语言实现进化算法"></a>二.c语言实现进化算法</h2><p><a href="https://blog.csdn.net/qq_32971095/article/details/136715239" title="c语言实现进化算法——人工智能导论＜1＞-CSDN博客">c语言实现进化算法——人工智能导论＜1＞-CSDN博客</a></p><h2 id="三-LeNet-网络实现-MNIST-手写数字识别"><a href="#三-LeNet-网络实现-MNIST-手写数字识别" class="headerlink" title="三.LeNet 网络实现 MNIST 手写数字识别"></a>三.LeNet 网络实现 MNIST 手写数字识别</h2><p><a href="https://download.csdn.net/download/qq_32971095/88681364?spm=1001.2014.3001.5501" title="西电计科大三上计算机视觉作业">西电计科大三上计算机视觉作业</a></p><h2 id="四-the-simplest-neural-network-model"><a href="#四-the-simplest-neural-network-model" class="headerlink" title="四.the simplest neural network model"></a>四.the simplest neural network model</h2><p>one-layered perceptron, a linear two-class classification model.（单层线性感知机）</p><p>Perceptron Model：</p><pre><code>    假设我们的模型中有N个特征，在这种情况下，输入向量将是一个大小为N的向量。感知器是一个二元分类模型，即它可以区分两类输入数据。我们将假设对于每个输入向量x，感知器的输出将是+1或-1，这取决于类别。输出将使用以下公式计算:</code></pre><p>y(x) &#x3D; f(wTx)</p><p>Training the Perceptron：</p><pre><code>    为了训练感知器，我们需要找到一个权重向量w，它能正确地分类大多数值，即产生最小的误差。该误差由感知器准则定义如下:</code></pre><p>E(w) &#x3D; -∑wTxiti</p><p>对那些导致错误分类的训练数据点I求和，xi是输入数据，对于负例和正例，ti分别为-1或+1。</p><pre><code>    这个标准被认为是权重w的函数，我们需要最小化它。通常，我们使用一种称为梯度下降的方法，在这种方法中，我们从一些初始权重w(0)开始，然后在每一步中根据公式更新权重:</code></pre><p>w(t+1) &#x3D; w(t) - η∇E(w)</p><p>这里η是所谓的学习率，∇E(w)表示E的梯度，计算出梯度后，我们得到</p><p>w(t+1) &#x3D; w(t) + ∑ηxiti</p><pre><code>//perceptron.h#ifndef _PERCEPTRON_H#define _PERCEPTRON_H//the simplest neural network model - one-layered perceptron, a linear two-class classification model.#include&lt;stdio.h&gt;#include&lt;time.h&gt;#define FREATURE_NUM 2//特征数（输入向量维数）#define LEARNING_RATE 1 //学习率 typedef struct input_data&#123;double freature[FREATURE_NUM];int label;&#125;input_data;typedef struct input_dataset&#123;input_data* input;int set_num;&#125;input_dataset;double weight[FREATURE_NUM]=&#123;0&#125;;void train(input_dataset dataset,int iteration);void perceptron(input_data *input);#endif//perceptron.c#include&quot;perceptron.h&quot;void train(input_dataset dataset,int iteration)&#123;//生成随机数种子 srand((unsigned)time(NULL));int set_num=dataset.set_num;int i,j,k;for(i=0;i&lt;iteration;i++)&#123;k=rand()%set_num;//梯度下降方法搜寻for(j=0;j&lt;FREATURE_NUM;j++)&#123;weight[j]+=1.0*LEARNING_RATE*dataset.input[k].freature[j]*dataset.input[k].label;//printf(&quot;%lf %lf\n&quot;,weight[j],dataset.input[k].freature[j]);&#125;&#125;return; &#125;void perceptron(input_data *input)&#123;int i,temp;for(i=0,temp=0;i&lt;FREATURE_NUM;i++)temp+=weight[i]*input-&gt;freature[i];if(temp&gt;=0)input-&gt;label=1;else input-&gt;label=-1;printf(&quot;label:%d\n&quot;,input-&gt;label);return;&#125;#include&lt;stdio.h&gt;#include&quot;perceptron.c&quot;int main()&#123;input_data input[2];input[0].freature[0]=-3.0;input[0].freature[1]=1.0;input[0].label=1;input[1].freature[0]=-1.0;input[1].freature[1]=3.0;input[1].label=1;input[2].freature[0]=2.0;input[2].freature[1]=4;input[2].label=-1;input[3].freature[0]=4.0;input[3].freature[1]=-2.0;input[3].label=-1;input_dataset dataset;dataset.input=input;dataset.set_num=4;train(dataset,10);int i;for(i=0;i&lt;FREATURE_NUM;i++)printf(&quot;%lf\n&quot;,weight[i]);input_data test;scanf(&quot;%lf%lf&quot;,&amp;test.freature[0],&amp;test.freature[1]);perceptron(&amp;test);return 0;&#125;</code></pre><p> python实现及mnist手写数字识别（两类）：[NeuralNetworks&#x2F;03-Perceptron at<br>main](<a href="https://github.com/microsoft/AI-For-">https://github.com/microsoft/AI-For-</a><br>Beginners&#x2F;tree&#x2F;main&#x2F;lessons&#x2F;3-NeuralNetworks&#x2F;03-Perceptron<br>“NeuralNetworks&#x2F;03-Perceptron at main”)</p><p> （特征：28pix*28pix）</p><p>实现N类感知器：训练N个感知器：</p><ol><li>Create 10 <strong><em>one-vs-all</em> datasets</strong> for all digits</li><li>Train <strong>10 perceptrons</strong></li><li>Define <code>classify</code> function to perform digit classification</li><li>Measure the accuracy of classification and print <em>confusion matrix</em></li><li>[Optional] Create improved <code>classify</code> function that performs the classification using one matrix multiplication.</li></ol><h2 id="五-Multi-Layered-Perceptron"><a href="#五-Multi-Layered-Perceptron" class="headerlink" title="五.Multi-Layered Perceptron"></a>五.Multi-Layered Perceptron</h2><p><strong>简介：</strong></p><p>we will extend themodel above into a more flexible framework, allowing us to:</p><ul><li>perform <strong>multi-class classification</strong>  in addition to two-class</li><li>solve <strong>regression problems</strong>  in addition to classification</li><li>separate classes that are not linearly separable</li></ul><p>We will also develop our own modular framework in Python that will allow us to<br>construct different neural network architectures.</p><p>Suppose we have a training dataset <strong>X</strong>  with labels <strong>Y</strong> , and we need to<br>build a **model  <em>f</em>  **that will make most accurate predictions. The quality<br>of predictions is measured by <strong>Loss function</strong>  <strong>ℒ</strong>. The following loss<br>functions are often used:</p><ul><li>For <strong>regression problem(回归问题)</strong> , when we need to predict a number, we can use <strong>absolute error</strong>    **∑i|f(x(i))-y(i)|   **, or <strong>squared error</strong>    **∑i(f(x(i))-y(i))^2   **</li><li>For <strong>classification(分类问题)</strong> , we use <strong>0-1 loss</strong>  (which is essentially the same as <strong>accuracy</strong>  of the model), or <strong>logistic loss</strong>.</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/621e77f5fb5595bedf41e588670f4c80.png"></p><p>从p对损失函数L的影响来看逻辑损失函数更好</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/11de84ee5edc6ce0c8007f9604f71c73.png"></p><p>For <strong>one-level perceptron</strong> , function <em>f</em>  was defined as a **linear<br>function  <em>f(x)&#x3D;wx+b</em>  **(here <em>w</em>  is the weight matrix, <em>x</em>  is the vector<br>of input features, and <strong><em>b</em>  is bias vector</strong>). For different neural network<br>architectures, this function can take more <strong>complex form.</strong></p><blockquote><p>In the case of <strong>classification</strong> , it is often desirable to get<br><strong>probabilities</strong> of corresponding classes as <strong>network output.</strong>  To<br>convert arbitrary numbers to probabilities (eg. to normalize the output), we<br>often use <strong>softmax</strong>  function <strong>σ</strong> , and the function <em>f</em>  becomes<br><em>f(x)&#x3D;σ(wx+b)</em></p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1760fe528375040727919cbb4587890d.png"></p><p>In the definition of <em>f</em>  above, <em>w</em>  and <em>b</em>  are called <strong>parameters</strong>  θ&#x3D;〈<br><em>w,b</em> 〉. Given the dataset 〈<strong>X</strong> ,<strong>Y</strong> 〉, we can compute an overall error on<br>the whole dataset as a function of parameters θ.</p><blockquote><p>✅ <strong>The goal of neural network training is to minimize the error （Loss<br>function</strong> <strong>ℒ</strong><strong>） by varying parameters θ</strong></p></blockquote><h3 id="1-Gradient-Descent-Optimization（梯度下降算法）"><a href="#1-Gradient-Descent-Optimization（梯度下降算法）" class="headerlink" title="1.Gradient Descent Optimization（梯度下降算法）"></a>1.Gradient Descent Optimization（梯度下降算法）</h3><p>This can be formalized as follows:</p><ul><li>Initialize parameters by some random values w(0), b(0)</li><li>Repeat the following step many times: <ul><li>w(i+1) &#x3D; w(i)-η∂ℒ&#x2F;∂w</li><li>b(i+1) &#x3D; b(i)-η∂ℒ&#x2F;∂b</li></ul></li></ul><p>During training, the optimization steps are supposed to be calculated<br>considering the whole dataset (remember that loss is calculated as a sum<br>through all training samples). However, in real life we take small portions of<br>the dataset called <strong>minibatches</strong> , and calculate gradients based on a subset<br>of data. Because subset is taken randomly each time, such method is called<br><strong>stochastic gradient descent</strong>  (SGD).</p><h3 id="2-Multi-Layered-Perceptrons-and-Backpropagation（多层感知器和反向传播）"><a href="#2-Multi-Layered-Perceptrons-and-Backpropagation（多层感知器和反向传播）" class="headerlink" title="2.Multi-Layered Perceptrons and Backpropagation（多层感知器和反向传播）"></a><strong>2.Multi-Layered Perceptrons and Backpropagation（多层感知器和反向传播）</strong></h3><p><strong>一个示例——两层感知器</strong> ：</p><p>One-layer network, as we have seen above, is capable of classifying linearly<br>separable classes. To build a richer model, we can <strong>combine several layers of<br>the network</strong>. Mathematically it would mean that the function <em>f</em>  would have<br>a more complex form, and will be computed in several steps:</p><ul><li>z1&#x3D;w1x+b1</li><li>z2&#x3D;w2α(z1)+b2</li><li>f &#x3D; σ(z2)</li></ul><p>Here, <strong>α</strong>  is a <strong>non-linear activation function</strong> , <strong>σ  is a softmax<br>function</strong>, and parameters θ&#x3D;&lt;_w1,b1,w2,b2_ &gt;.</p><p>The gradient descent algorithm would remain the same, but it would be more<br>difficult to calculate gradients. Given the chain differentiation rule, we can<br>calculate derivatives as:</p><ul><li>∂ℒ&#x2F;∂w2 &#x3D; (∂ℒ&#x2F;∂σ)(∂σ&#x2F;∂z2)(∂z2&#x2F;∂w2)</li><li>∂ℒ&#x2F;∂w1 &#x3D; (∂ℒ&#x2F;∂σ)(∂σ&#x2F;∂z2)(∂z2&#x2F;∂α)(∂α&#x2F;∂z1)(∂z1&#x2F;∂w1)</li></ul><blockquote><p>✅ The <strong>chain differentiation rule</strong> is used to calculate derivatives of the<br>loss function with respect to parameters.</p></blockquote><p><strong>链式规则、后向传播更新参数θ</strong> ：</p><p>Note that the left-most part of all those expressions is the same, and thus we<br>can** effectively calculate derivatives** **starting from the loss function<br>and going  “backwards” **through the computational graph. Thus the method of<br>training a multi-layered perceptron is called <strong>backpropagation</strong> , or<br>‘backprop’.</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98446f8f75153030ff57d774b4684b02.png"></p><p>即：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/82d7932c55daa1260a98b128ecb829ba.png"></p><h3 id="3-单层感知器模型"><a href="#3-单层感知器模型" class="headerlink" title="3.单层感知器模型"></a>3.单层感知器模型</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/28b6864aabe5cda4e0786e846d3f43df.png"></p><pre><code>    Two outputs of the network correspond to two classes, and the class with highest value among two outputs corresponds to the right solution.</code></pre><p>The model is defined as：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/093e6e1eb8cb98c2846ce0e7fac93586.png"></p><p><strong>相关依赖：</strong></p><pre><code>import matplotlib.pyplot as plt from matplotlib import gridspecfrom sklearn.datasets import make_classificationimport numpy as np# pick the seed for reproducibility - change it to explore the effects of random variationsnp.random.seed(0)import random</code></pre><h4 id="1-创建数据集，X为特征向量，Y为标签："><a href="#1-创建数据集，X为特征向量，Y为标签：" class="headerlink" title="&lt; 1&gt;创建数据集，X为特征向量，Y为标签："></a><strong>&lt; 1&gt;创建数据集，X为特征向量，Y为标签：</strong></h4><pre><code>n = 100X, Y = make_classification(n_samples = n, n_features=2,                           n_redundant=0, n_informative=2, flip_y=0.2)X = X.astype(np.float32)Y = Y.astype(np.int32)# Split into train and test datasettrain_x, test_x = np.split(X, [n*8//10])train_labels, test_labels = np.split(Y, [n*8//10])#显示数据集print(train_x[:5])print(train_labels[:5])[[-0.836906  -1.382417 ] [ 3.0352616 -1.1195285] [ 1.6688806  2.4989042] [-0.5790065  2.1814067] [-0.8730455 -1.4692409]][0 1 1 1 0]</code></pre><h4 id="2-前向传播计算过程："><a href="#2-前向传播计算过程：" class="headerlink" title="**&lt; 2&gt; 前向传播计算过程： **"></a>**&lt; 2&gt; 前向传播计算过程： **</h4><pre><code>class Linear:    #初始化权重    def __init__(self,nin,nout):        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))        self.b = np.zeros((1,nout))    #前向传播计算        def forward(self, x):        return np.dot(x, self.W.T) + self.b    net = Linear(2,2)net.forward(train_x[0:5])#5个输入的输出0,1.772021,-0.2538451,0.283708,-0.3961062,-0.300974,0.3051323,-0.812048,0.5607944,-1.235197,0.339497</code></pre><h4 id="使用softmax函数转换为概率："><a href="#使用softmax函数转换为概率：" class="headerlink" title="&lt;3&gt;使用softmax函数转换为概率："></a>&lt;3&gt;使用softmax函数转换为概率：</h4><pre><code>class Softmax:    def forward(self,z):        zmax = z.max(axis=1,keepdims=True)        expz = np.exp(z-zmax)        Z = expz.sum(axis=1,keepdims=True)        return expz / Zsoftmax = Softmax()softmax.forward(net.forward(train_x[0:10]))        In case we have more than 2 classes, softmax will normalize probabilities across all of them.</code></pre><h4 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="&lt;4&gt;交叉熵损失函数"></a>&lt;4&gt;交叉熵损失函数</h4><pre><code>        A loss function in classification is typically a **logistic function** , which can **be generalized as cross-entropy loss**. Cross-entropy loss is a function that can calculate similarity between two arbitrary probability distributions. def cross_ent(prediction, ground_truth):    t = 1 if ground_truth &gt; 0.5 else 0    return -t * np.log(prediction) - (1 - t) * np.log(1 - prediction)plot_cross_ent()</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f4b2ad0f83c2804efe05f9563c4c85f.png"></p><pre><code>        Cross-entropy loss will be defined again as **a separate layer** , but `forward` function will have _**two input values: output of the previous layers of the network `p`, and the expected class `y`:**_</code></pre><p><strong>应用：</strong></p><pre><code>class CrossEntropyLoss:    def forward(self,p,y):        self.p = p        self.y = y        p_of_y = p[np.arange(len(y)), y]        log_prob = np.log(p_of_y)        return -log_prob.mean() # average over all input samplescross_ent_loss = CrossEntropyLoss()p = softmax.forward(net.forward(train_x[0:10]))cross_ent_loss.forward(p,train_labels[0:10])</code></pre><blockquote><p><strong>IMPORTANT</strong> : Loss function returns a number that shows how good (or bad)<br>our network performs. It should return us one number for the whole dataset,<br>or for the part of the dataset (minibatch). Thus after calculating cross-<br>entropy loss for each individual component of the input vector, we need to<br>average (or add) all components together - which is done by the call to<br><code>.mean()</code>.</p><p>（注意计算的是<strong>交叉熵均值</strong> ：return -log_prob.mean() # average over all input samples ）</p></blockquote><pre><code>z = net.forward(train_x[0:10])    #输出p = softmax.forward(z)            #softmax归一化loss = cross_ent_loss.forward(p,train_labels[0:10])#cross_ent_loss = CrossEntropyLoss()print(loss)</code></pre><h4 id="Loss-Minimization-Problem-and-Network-Training："><a href="#Loss-Minimization-Problem-and-Network-Training：" class="headerlink" title="&lt;5&gt;Loss Minimization Problem and Network Training："></a>&lt;5&gt;Loss Minimization Problem and Network Training：</h4><p>数学描述：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/44ff93f6ec92975a705328447d9fcb28.png"></p><p>采用梯度下降法进行计算（见2.）</p><p><strong>网络训练</strong> 包括前向和后向传播两个过程（<strong>原理</strong> 见2和3&lt;2&gt;）</p><p>One pass of the <strong>network training</strong> consists of two parts:</p><ul><li><strong>Forward pass</strong> , when we calculate the value of loss function for a given input minibatch</li><li><strong>Backward pass</strong> , when we try to minimize this error by distributing it back to the model parameters through the computational graph.</li></ul><p><strong>后向传播的具体实现：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcc3707448e65ae4040d2b305dc71a12.png"></p><p><em>注意参数的更新在一个minibatch完全计算完后，而不是单个样本</em></p><pre><code>def update(self,lr):    self.W -= lr*self.dW        self.b -= lr*self.db#LR是学习率</code></pre><h4 id="函数小结"><a href="#函数小结" class="headerlink" title="&lt;6&gt;函数小结"></a>&lt;6&gt;函数小结</h4><pre><code>class Linear:    def __init__(self,nin,nout):        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))        self.b = np.zeros((1,nout))        self.dW = np.zeros_like(self.W)        self.db = np.zeros_like(self.b)            def forward(self, x):        self.x=x        return np.dot(x, self.W.T) + self.b        def backward(self, dz):        dx = np.dot(dz, self.W)        dW = np.dot(dz.T, self.x)        db = dz.sum(axis=0)        self.dW = dW        self.db = db        return dx        def update(self,lr):        self.W -= lr*self.dW        self.b -= lr*self.dbclass Softmax:    def forward(self,z):        self.z = z        zmax = z.max(axis=1,keepdims=True)        expz = np.exp(z-zmax)        Z = expz.sum(axis=1,keepdims=True)        return expz / Z    def backward(self,dp):        p = self.forward(self.z)        pdp = p * dp        return pdp - p * pdp.sum(axis=1, keepdims=True)    class CrossEntropyLoss:    def forward(self,p,y):        self.p = p        self.y = y        p_of_y = p[np.arange(len(y)), y]        log_prob = np.log(p_of_y)        return -log_prob.mean()    def backward(self,loss):        dlog_softmax = np.zeros_like(self.p)        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)        return dlog_softmax / self.p</code></pre><h4 id="Training-the-Model"><a href="#Training-the-Model" class="headerlink" title="&lt;7&gt;Training the Model"></a>&lt;7&gt;Training the Model</h4><pre><code>    Now we are ready to write the **training loop** , which will go through our dataset, and perform the optimization minibatch by minibatch._One complete pass through the dataset is often called**an epoch** :_lin = Linear(2,2)softmax = Softmax()cross_ent_loss = CrossEntropyLoss()learning_rate = 0.1pred = np.argmax(lin.forward(train_x),axis=1)acc = (pred==train_labels).mean()print(&quot;Initial accuracy: &quot;,acc)batch_size=4for i in range(0,len(train_x),batch_size):    xb = train_x[i:i+batch_size]    yb = train_labels[i:i+batch_size]        # forward pass    z = lin.forward(xb)    p = softmax.forward(z)    loss = cross_ent_loss.forward(p,yb)        # backward pass    dp = cross_ent_loss.backward(loss)    dz = softmax.backward(dp)    dx = lin.backward(dz)    lin.update(learning_rate)    pred = np.argmax(lin.forward(train_x),axis=1)acc = (pred==train_labels).mean()print(&quot;Final accuracy: &quot;,acc)    Initial accuracy:  0.2625Final accuracy:  0.7875</code></pre><h3 id="4-网络模型"><a href="#4-网络模型" class="headerlink" title="4.网络模型"></a>4.网络模型</h3><h4 id="定义网络类-："><a href="#定义网络类-：" class="headerlink" title="&lt;1&gt;定义网络类 ："></a>&lt;1&gt;定义<strong>网络类</strong> ：</h4><pre><code>    Since in many cases neural network is just **a composition of layers** , we can build a class that will allow us to **stack layers together** and**make forward and backward passes** through them without explicitly programming that logic. We will **store the list of layers inside the`Net` class**, and **use`add()` function to add new layers**:class Net:    def __init__(self):        self.layers = []        def add(self,l):        self.layers.append(l)            def forward(self,x):        for l in self.layers:            x = l.forward(x)        return x        def backward(self,z):        for l in self.layers[::-1]:            z = l.backward(z)        return z        def update(self,lr):        for l in self.layers:            if &#39;update&#39; in l.__dir__():                l.update(lr)</code></pre><p>定义网络和训练：</p><pre><code>net = Net()net.add(Linear(2,2))net.add(Softmax())loss = CrossEntropyLoss()def get_loss_acc(x,y,loss=CrossEntropyLoss()):    p = net.forward(x)    l = loss.forward(p,y)    pred = np.argmax(p,axis=1)    acc = (pred==y).mean()    return l,accprint(&quot;Initial loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))def train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):    for i in range(0,len(train_x),batch_size):        xb = train_x[i:i+batch_size]        yb = train_labels[i:i+batch_size]        p = net.forward(xb)        l = loss.forward(p,yb)        dp = loss.backward(l)        dx = net.backward(dp)        net.update(lr) train_epoch(net,train_x,train_labels)        print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))Initial loss=0.8977914474068779, accuracy=0.4625: Final loss=0.47908832233966514, accuracy=0.825: Test loss=0.5317198099647931, accuracy=0.8:</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f0836ab887616dbe48bcedfff0a5ea8.png"></p><h4 id="Multi-Layered-Models"><a href="#Multi-Layered-Models" class="headerlink" title="&lt;2&gt;Multi-Layered Models"></a>&lt;2&gt;Multi-Layered Models</h4><pre><code>        Very important thing to note, however, is that _**in between linear layers we need to have a non-linear** **activation function**_ , such as _**tanh**_. Without such non-linearity, several linear layers would have the same expressive power as just one layers - because _**composition of linear functions is also linear!**_</code></pre><p>在线性层之间添加激活函数，线性函数的叠加仍是线性。</p><pre><code>class Tanh:    def forward(self,x):        y = np.tanh(x)        self.y = y        return y    def backward(self,dy):        return (1.0-self.y**2)*dy    Adding several layers make sense, because unlike one-layer network, multi-layered model will **be able to accuratley classify sets that are not linearly separable**. I.e., a model with several layers will be **reacher**.</code></pre><blockquote><p>It can be demonstrated that with sufficient number of neurons a <strong>two-<br>layered model</strong> is capable to classifying any <strong>convex set of data points</strong><br>, and <strong>three-layered network</strong> can classify <strong>virtually any set.</strong></p></blockquote><p>多层网络的形式见前（2.）</p><p>两层网络示例：</p><pre><code>net = Net()net.add(Linear(2,10))net.add(Tanh())net.add(Linear(10,2))net.add(Softmax())loss = CrossEntropyLoss()</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aa5a7f818f593a302d689193dc8bf872.png"></p><p>关于线性模型和多层复杂模型的区别和**过拟合（**<strong>overfitting）</strong> 问题：</p><p><strong>A linear model:</strong></p><ul><li>We are likely to get high training loss - so-called <strong>underfitting</strong> , when the model does not have enough power to correctly separate all data.</li><li>Valiadation loss and training loss are more or less the same. The model is likely to generalize well to test data.</li></ul><p><strong>Complex multi-layered model</strong></p><ul><li>Low training loss - the model can approximate training data well, because it has enough expressive power.</li><li>Validation loss can be much higher than training loss and can start to increase during training - this is because the model “memorizes” training points, and loses the “overall picture”</li></ul><p><strong>小结：</strong></p><p><strong>Takeaways</strong></p><ul><li>Simple models (fewer layers, fewer neurons) with low number of parameters (“low capacity”) are less likely to overfit</li><li>More complex models (more layers, more neurons on each layer, high capacity) are likely to overfit. We need to monitor validation error to make sure it does not start to rise with further training</li><li>More complex models need more data to train on.</li><li>You can solve overfitting problem by either: <ul><li>simplifying your model</li><li>increasing the amount of training data</li></ul></li><li><strong>Bias-variance trade-off</strong> is a term that shows that you need to get the compromise <ul><li>between power of the model and amount of data,</li><li>between overfittig and underfitting</li></ul></li><li>There is not single recipe on how many layers of parameters you need - the best way is to experiment</li></ul><h3 id="5-代码整合"><a href="#5-代码整合" class="headerlink" title="5.代码整合"></a>5.代码整合</h3><pre><code>#################################################################### package# matplotlib nbaggimport matplotlib.pyplot as plt from matplotlib import gridspecfrom sklearn.datasets import make_classificationimport numpy as np# pick the seed for reproducibility - change it to explore the effects of random variationsnp.random.seed(0)import random#################################################################### datasetn = 100X, Y = make_classification(n_samples = n, n_features=2,                           n_redundant=0, n_informative=2, flip_y=0.2)X = X.astype(np.float32)Y = Y.astype(np.int32)# Split into train and test datasettrain_x, test_x = np.split(X, [n*8//10])train_labels, test_labels = np.split(Y, [n*8//10])#################################################################### layersclass Linear:    def __init__(self,nin,nout):        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))        self.b = np.zeros((1,nout))        self.dW = np.zeros_like(self.W)        self.db = np.zeros_like(self.b)            def forward(self, x):        self.x=x        return np.dot(x, self.W.T) + self.b        def backward(self, dz):        dx = np.dot(dz, self.W)        dW = np.dot(dz.T, self.x)        db = dz.sum(axis=0)        self.dW = dW        self.db = db        return dx        def update(self,lr):        self.W -= lr*self.dW        self.b -= lr*self.dbclass Tanh:    def forward(self,x):        y = np.tanh(x)        self.y = y        return y    def backward(self,dy):        return (1.0-self.y**2)*dyclass Softmax:    def forward(self,z):        self.z = z        zmax = z.max(axis=1,keepdims=True)        expz = np.exp(z-zmax)        Z = expz.sum(axis=1,keepdims=True)        return expz / Z    def backward(self,dp):        p = self.forward(self.z)        pdp = p * dp        return pdp - p * pdp.sum(axis=1, keepdims=True)    class CrossEntropyLoss:    def forward(self,p,y):        self.p = p        self.y = y        p_of_y = p[np.arange(len(y)), y]        log_prob = np.log(p_of_y)        return -log_prob.mean()    def backward(self,loss):        dlog_softmax = np.zeros_like(self.p)        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)        return dlog_softmax / self.p#################################################################### networkclass Net:    def __init__(self):        self.layers = []        def add(self,l):        self.layers.append(l)            def forward(self,x):        for l in self.layers:            x = l.forward(x)        return x        def backward(self,z):        for l in self.layers[::-1]:            z = l.backward(z)        return z        def update(self,lr):        for l in self.layers:            if &#39;update&#39; in l.__dir__():                l.update(lr)def get_loss_acc(x,y,loss=CrossEntropyLoss()):    p = net.forward(x)    l = loss.forward(p,y)    pred = np.argmax(p,axis=1)    acc = (pred==y).mean()    return l,accdef train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):    for i in range(0,len(train_x),batch_size):        xb = train_x[i:i+batch_size]        yb = train_labels[i:i+batch_size]        p = net.forward(xb)        l = loss.forward(p,yb)        dp = loss.backward(l)        dx = net.backward(dp)        net.update(lr)        print(&quot;epoch=&#123;&#125;: &quot;.format(i),end=&quot;&quot;)        print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))        print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))#################################################################### mainnet = Net()net.add(Linear(2,10))net.add(Tanh())net.add(Linear(10,2))net.add(Softmax())train_epoch(net,train_x,train_labels)</code></pre><h3 id="6-3-layer-network-实现-mnist-手写数字识别"><a href="#6-3-layer-network-实现-mnist-手写数字识别" class="headerlink" title="6.3-layer network 实现 mnist 手写数字识别"></a>6.3-layer network 实现 mnist 手写数字识别</h3><p>训练模型，保存结果：</p><pre><code>#################################################################### packagesimport matplotlib.pyplot as plt from matplotlib import gridspecfrom sklearn.datasets import make_classificationimport numpy as np# pick the seed for reproducibility - change it to explore the effects of random variationsnp.random.seed(0)import random#################################################################### datasetn=70000# generate data# X, Y = make_classification(n_samples = n, n_features=28*28,n_redundant=0, n_informative=8*8, flip_y=0.2)# get data from mnistfrom torchvision import datasets, transformsmnist_train = datasets.MNIST(root=&#39;./data&#39;, train=True, transform=transforms.ToTensor())X = mnist_train.data.numpy()Y = mnist_train.targets.numpy()X = X.reshape(X.shape[0],-1)X = X.astype(np.float32)                            Y = Y.astype(np.int32)# Split into train and test datasettrain_x, test_x = np.split(X, [n*8//10])            # 80% training and 20% testtrain_labels, test_labels = np.split(Y, [n*8//10])  #################################################################### layersclass Linear:    def __init__(self,nin,nout):        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))        self.b = np.zeros((1,nout))        self.dW = np.zeros_like(self.W)        self.db = np.zeros_like(self.b)            def forward(self, x):        self.x=x        return np.dot(x, self.W.T) + self.b        def backward(self, dz):        dx = np.dot(dz, self.W)        dW = np.dot(dz.T, self.x)        db = dz.sum(axis=0)        self.dW = dW        self.db = db        return dx        def update(self,lr):        self.W -= lr*self.dW        self.b -= lr*self.dbclass Tanh:    def forward(self,x):        y = np.tanh(x)        self.y = y        return y    def backward(self,dy):        return (1.0-self.y**2)*dyclass Softmax:    def forward(self,z):        self.z = z        zmax = z.max(axis=1,keepdims=True)        expz = np.exp(z-zmax)        Z = expz.sum(axis=1,keepdims=True)        return expz / Z    def backward(self,dp):        p = self.forward(self.z)        pdp = p * dp        return pdp - p * pdp.sum(axis=1, keepdims=True)    class CrossEntropyLoss:    def forward(self,p,y):        self.p = p        self.y = y        p_of_y = p[np.arange(len(y)), y]        log_prob = np.log(p_of_y)        return -log_prob.mean()    def backward(self,loss):        dlog_softmax = np.zeros_like(self.p)        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)        return dlog_softmax / self.p#################################################################### networkclass Net:    def __init__(self):        self.layers = []        def add(self,l):        self.layers.append(l)            def forward(self,x):        for l in self.layers:            x = l.forward(x)        return x        def backward(self,z):        for l in self.layers[::-1]:            z = l.backward(z)        return z        def update(self,lr):        for l in self.layers:            if &#39;update&#39; in l.__dir__():                l.update(lr)def get_loss_acc(x,y,loss=CrossEntropyLoss()):    p = net.forward(x)    l = loss.forward(p,y)    pred = np.argmax(p,axis=1)    acc = (pred==y).mean()    return l,accdef train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):    for i in range(0,len(train_x),batch_size):        xb = train_x[i:i+batch_size]        yb = train_labels[i:i+batch_size]        p = net.forward(xb)        l = loss.forward(p,yb)        dp = loss.backward(l)        dx = net.backward(dp)        net.update(lr)        print(&quot;epoch=&#123;&#125;: &quot;.format(i//batch_size))        print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))        print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))#################################################################### mainif __name__ == &#39;__main__&#39;:    # model    net = Net()    net.add(Linear(28*28,300))    net.add(Tanh())    net.add(Linear(300,10))    net.add(Softmax())    train_epoch(net,train_x,train_labels,batch_size=1000)     #save the model    import pickle    with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:        pickle.dump(net, f)    </code></pre><p>加载模型，进行测试：</p><pre><code>import OwnFrameworkimport torchvisionimport numpy as npimport pickleimport matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecimport random# import the model   with open(&#39;model.pkl&#39;, &#39;rb&#39;) as f:    OwnFramework.net = pickle.load(f)# test the data from minsttest_data = torchvision.datasets.MNIST(&#39;./data&#39;, train=False, download=False)test_x = test_data.data.numpy().reshape(-1,28*28)test_labels = test_data.targets.numpy()# test the modelprint(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*OwnFramework.get_loss_acc(test_x,test_labels)))# show the images and the predictionsfig=plt.figure(figsize=(8, 8))gs = gridspec.GridSpec(4, 4)for i in range(16):    j=random.randint(0,len(test_x))    ax = plt.subplot(gs[i])    ax.imshow(test_x[j].reshape(28,28))    ax.set_title(&quot;Predicted: &#123;&#125;&quot;.format(np.argmax(OwnFramework.net.forward(test_x[j:j+1]))))    ax.axis(&#39;off&#39;)plt.show()# show the images that are not predicted not correctlyfig=plt.figure(figsize=(12, 8))gs = gridspec.GridSpec(4, 4)i=0for j in range(len(test_x)):    if np.argmax(OwnFramework.net.forward(test_x[j:j+1])) != test_labels[j]:        ax = plt.subplot(gs[i])        ax.imshow(test_x[j].reshape(28,28))        ax.set_title(&quot;Predicted: &#123;&#125;, True: &#123;&#125;&quot;.format(np.argmax(OwnFramework.net.forward(test_x[j:j+1])),test_labels[j]))        ax.axis(&#39;off&#39;)        i+=1    if i==16:        breakplt.show()</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f2a5124db743b6101b0841143d3f591.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/94e98f86a86028bb9b2d14b0ed7f50d3.png"></p><h2 id="六-Neural-Network-Frameworks"><a href="#六-Neural-Network-Frameworks" class="headerlink" title="六.Neural Network Frameworks"></a>六.Neural Network Frameworks</h2><p><strong>架构API：</strong></p><p>to be able to train neural networks efficiently we need to do two things:</p><ul><li><p>To <strong>operate</strong> on <strong>tensors</strong> , eg. to multiply, add, and compute some functions such as sigmoid or softmax</p></li><li><p>To compute <strong>gradients</strong> of all expressions, in order to perform gradient descent optimization</p><pre><code>While the **`numpy`  library** can **do the first part** , we need some mechanism to compute gradients. In our framework that we have developed in the previous section we had to manually program all derivative functions inside the `backward` method, which does backpropagation. Ideally, _**a framework should give us the opportunity to compute gradients of _any expression_  that we can define**_.Another important thing is to be able to **perform computations on GPU** , or any other specialized compute units, such as [TPU](https://en.wikipedia.org/wiki/Tensor_Processing_Unit &quot;TPU&quot;). Deep neural network training requires _a lot_  of computations, and to be able to parallelize those computations on GPUs is very important.</code></pre></li></ul><p><strong>底层和高层API：</strong>  </p><pre><code>    Currently, the two **most popular neural frameworks** are:** [TensorFlow](http://tensorflow.org/ &quot;TensorFlow&quot;) and [PyTorch](https://pytorch.org/ &quot;PyTorch&quot;).** Both provide a **low-level API** to operate with **tensors on both CPU and GPU**. On top of the low-level API, there is also **higher-level API** , called** [Keras](https://keras.io/ &quot;Keras&quot;) and [PyTorch Lightning](https://pytorchlightning.ai/ &quot;PyTorch Lightning&quot;) **correspondingly.</code></pre><p>Low-Level API| <a href="http://tensorflow.org/" title="TensorFlow">TensorFlow</a>|</p><p><a href="https://pytorch.org/" title="PyTorch">PyTorch</a><br>—|—|—<br>High-level API| <a href="https://keras.io/" title="Keras">Keras</a>| <a href="https://pytorchlightning.ai/" title="PyTorch Lightning">PyTorch<br>Lightning</a>  </p><p><strong>Low-level APIs</strong>  in both frameworks allow you to build so-called<br><strong>computational graphs</strong>. This graph defines how to compute the output<br>(usually <strong>the loss function</strong>) <strong>with given input parameters</strong> , and can be<br>pushed for computation <strong>on GPU</strong> , if it is available. There are functions to<br>differentiate this computational graph and compute gradients, which can then<br>be used for optimizing model parameters.</p><p><strong>High-level APIs</strong>  pretty much consider neural networks as a <strong>sequence of<br>layers</strong> , and make constructing most of the neural networks much easier.<br>Training the model usually requires <strong>preparing the data</strong> and then calling a<br><strong><code>fit</code> function</strong> to do the job.</p><pre><code>    The high-level API allows you to construct typical neural networks **very quickly without worrying about lots of details**. At the same time, low-level API offer much more control over the training process, and thus they are **used a lot in research** , when you are dealing with **new neural network architectures.**    It is also important to understand that you can**use both APIs together** , eg. you can develop your own network layer architecture using low-level API, and then use it inside the larger network constructed and trained with the high-level API. Or you can define a network using the high-level API as a sequence of layers, and then use your own low-level training loop to perform optimization. Both APIs use the same basic underlying concepts, and they are designed to work well together.</code></pre><p><strong>过拟合检测：</strong></p><p><strong>How to detect overfitting</strong></p><pre><code>    As you can see from the graph above, overfitting can be detected by a very low training error, and a high validation error. Normally during training we will see both training and validation errors starting to decrease, and then **at some point validation error might stop decreasing and start rising**. This will be a sign of overfitting, and the indicator that we should probably **stop training at this point**  (or at least **make a snapshot of the model**).（及时备份）</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9c3db5d1878b3ecef22e81631f39e2b0.png"></p><h3 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h3><pre><code>    Keras is **a part of Tensorflow 2.x framework**. Let’s make sure we have version 2.x.x of Tensorflow installed:# packagesimport tensorflow as tffrom tensorflow import kerasimport numpy as npfrom sklearn.datasets import make_classificationimport matplotlib.pyplot as pltprint(f&#39;Tensorflow version = &#123;tf.__version__&#125;&#39;)# data preparenp.random.seed(0) # pick the seed for reproducibility - change it to explore the effects of random variationsn = 100X, Y = make_classification(n_samples = n, n_features=2,                           n_redundant=0, n_informative=2, flip_y=0.05,class_sep=1.5)X = X.astype(np.float32)Y = Y.astype(np.int32)split = [ 70*n//100 ]train_x, test_x = np.split(X, split)train_labels, test_labels = np.split(Y, split)</code></pre><p>**关于张量的概念：（多维向量）  **</p><p><strong>Tensor</strong> is a <strong>multi-dimensional array</strong>. It is very convenient to use<br>tensors to represent different types of data:</p><ul><li>400x400 - black-and-white picture</li><li>400x400x3 - color picture</li><li>16x400x400x3 - minibatch of 16 color pictures</li><li>25x400x400x3 - one second of 25-fps video</li><li>8x25x400x400x3 - minibatch of 8 1-second videos</li></ul><p>Tensors give us a convenient way to represent input&#x2F;output data, as well we<br>weights inside the neural network.</p><p><strong>归一化数据：（约束网络参数范围）Normalizing Data</strong></p><p>Before training, it is common to bring our input features<strong>to the standard<br>range of [0,1] (or [-1,1]).</strong> The exact reasons for that we will discuss later<br>in the course, but in short the reason is the following. We want to avoid<br>values that flow through our network <strong>getting too big or too small</strong> , and we<br>normally agree to keep all values in the small range close to 0. Thus we<br><strong>initialize the weights with small random numbers</strong> , and we keep signals in<br>the same range.</p><pre><code>train_x_norm = (train_x-np.min(train_x,axis=0)) / (np.max(train_x,axis=0)-np.min(train_x,axis=0))test_x_norm = (test_x-np.min(train_x,axis=0)) / (np.max(train_x,axis=0)-np.min(train_x,axis=0))</code></pre><h4 id="Training-One-Layer-Network-Perceptron"><a href="#Training-One-Layer-Network-Perceptron" class="headerlink" title="&lt;1&gt;Training One-Layer Network (Perceptron)"></a>&lt;1&gt;Training One-Layer Network (Perceptron)</h4><h5 id="①模型定义"><a href="#①模型定义" class="headerlink" title="①模型定义"></a>①模型定义</h5><p>In many cases, a neural network would be <strong>a sequence of layers.</strong> It can be<br>defined in Keras using **<code>Sequential</code> **model in the following manner:</p><pre><code>model = keras.models.Sequential()model.add(keras.Input(shape=(2,)))model.add(keras.layers.Dense(1))model.add(keras.layers.Activation(keras.activations.sigmoid))model.summary()# or# Input size, as well as activation function, can also be specified directly in the Dense layer for brevity:model = keras.models.Sequential()model.add(keras.layers.Dense(1,input_shape=(2,),activation=&#39;sigmoid&#39;))model.summary()</code></pre><p>说明：</p><p>Here, we first create the model, and then add layers to it:</p><ul><li><p>First <code>Input</code> layer (<strong>which is not strictly speaking a layer</strong>) contains the specification of network’s <strong>input size</strong></p></li><li><p><code>Dense</code> layer is the actual perceptron that <strong>contains trainable weights</strong></p></li><li><p>Finally, there is a layer with **<em>sigmoid</em> <code>Activation</code> function **to bring the result of the network into 0-1 range (to make it a probability).</p><h1 id="Model-“sequential”-Layer-type-Output-Shape-Param"><a href="#Model-“sequential”-Layer-type-Output-Shape-Param" class="headerlink" title="Model: “sequential”_________________________________________________________________ Layer (type)                Output Shape              Param #"></a>Model: “sequential”<br>_________________________________________________________________<br> Layer (type)                Output Shape              Param #</h1><p> dense (Dense)               (None, 1)                 3</p><p> activation (Activation)     (None, 1)                 0</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>Total params: 3 (12.00 Byte)<br>Trainable params: 3 (12.00 Byte)<br>Non-trainable params: 0 (0.00 Byte)</p><hr></li></ul><h5 id="②模型编译（指定损失函数、优化方法【梯度下降等】、精度）"><a href="#②模型编译（指定损失函数、优化方法【梯度下降等】、精度）" class="headerlink" title="②模型编译（指定损失函数、优化方法【梯度下降等】、精度）"></a>②模型编译（指定损失函数、优化方法【梯度下降等】、精度）</h5><p>Before training the model, we need to <strong>compile it</strong> , which essentially mean<br>specifying:</p><ul><li><strong>Loss function</strong> , which defines how loss is calculated. Because we have two-class classification problem, we will use <em>binary cross-entropy loss</em>.</li><li><strong>Optimizer</strong> to use. The simplest option would be to use <code>sgd</code> for <em>stochastic gradient descent</em> , or you can use more sophisticated optimizers such as <code>adam</code>.</li><li><strong>Metrics</strong> that we want to use to measure success of our training. Since it is classification task, a good metrics would be <code>Accuracy</code> (or <code>acc</code> for short)</li></ul><p>We can specify loss, metrics and optimizer either as <strong>strings</strong> , or by<br>providing some <strong>objects from Keras framework</strong>. In our example, we need to<br>**specify<code>learning_rate</code> parameter **to fine-tune learning speed of our model,<br>and thus we provide <strong>full name of Keras SGD optimizer.</strong></p><p><strong>（可使用字符串或对象来定义）</strong></p><pre><code>model.compile(optimizer=keras.optimizers.SGD(learning_rate=0.2),loss=&#39;binary_crossentropy&#39;,metrics=[&#39;acc&#39;])</code></pre><h5 id="③训练"><a href="#③训练" class="headerlink" title="③训练"></a>③训练</h5><p>After compiling the model, we can do the actual training by calling <strong><code>fit</code><br>method.</strong> The most important parameters are:</p><ul><li><p><code>x</code> and <code>y</code> specify <strong>training data, features and labels respectively</strong></p></li><li><p>If we want validation to be performed on each epoch, we can specify **<code>validation_data</code> **parameter, which would be a tuple of features and labels</p></li><li><p>**<code>epochs</code> **specified the number of epochs</p></li><li><p>If we want training to happen in <strong>minibatches</strong> , we can specify **<code>batch_size</code> **parameter. You can also pre-batch the data manually before passing it to <code>x</code>&#x2F;<code>y</code>&#x2F;<code>validation_data</code>, in which case you do not need <strong><code>batch_size</code></strong></p><p>model.fit(x&#x3D;train_x_norm,y&#x3D;train_labels,validation_data&#x3D;(test_x_norm,test_labels),epochs&#x3D;10,batch_size&#x3D;1)</p></li></ul><blockquote><p>Note that you can c<strong>all<code>fit</code> function several times</strong> in a row to <strong>further<br>train the network</strong>. If you want to <strong>start training from scratch</strong> - you<br>need to <strong>re-run the cell with the model definition.</strong></p></blockquote><p>注：训练是叠加的，想从头训练需<strong>重定义网络</strong></p><h4 id="Multi-Class-Classificatio（多分类问题）"><a href="#Multi-Class-Classificatio（多分类问题）" class="headerlink" title="&lt;2&gt;Multi-Class Classificatio（多分类问题）"></a>&lt;2&gt;Multi-Class Classificatio（多分类问题）</h4><pre><code>    If you need to solve a problem of multi-class classification, your network would have more that one output - corresponding to the number of classes .**Each output will contain the probability of a given class.（多类多输出）**</code></pre><p>**         <strong>When you expect a network to output a set of probabilities , we<br>need all of them to add up to 1. To ensure this, we use <code>softmax</code> as a final<br>activation function on the last layer. <strong>Softmax</strong> takes a vector input, and<br>makes sure that all components of that vector are transformed into<br>probabilities.</strong>（softmax 使所有概率和为1）**</p><pre><code>    Also, since the output of the network is a C-dimensional vector, we need labels to have the same form. This can be achieved by using **one-hot encoding** , when the number of a class is i converted to **a vector of zeroes, with 1 at the i-th position.（独热码，一位1其他位0）**    To compare the probability output of the neural network with expected one-hot-encoded label, we use **cross-entropy loss** function. It takes two probability distributions, and outputs a value of how different they are.**（概率输出和独热码标签计算交叉熵损失函数）**</code></pre><p>So, to <strong>summarize</strong> what we need to do for multi-class classification with<br>classes:</p><ul><li><p>The network should have neurons in the last layer</p></li><li><p><strong>Last activation function</strong> should be <strong>softmax</strong></p></li><li><p>Loss should be <strong>cross-entropy loss</strong></p></li><li><p>Labels should be converted to <strong>one-hot encoding</strong> (this can be done using <code>numpy</code>, or using Keras utils <code>to_categorical</code>)</p><p>model &#x3D; keras.models.Sequential([<br>keras.layers.Dense(5,input_shape&#x3D;(2,),activation&#x3D;’relu’),<br>keras.layers.Dense(2,activation&#x3D;’softmax’)<br>])<br>model.compile(keras.optimizers.Adam(0.01),’categorical_crossentropy’,[‘acc’])</p><h1 id="Two-ways-to-convert-to-one-hot-encoding"><a href="#Two-ways-to-convert-to-one-hot-encoding" class="headerlink" title="Two ways to convert to one-hot encoding"></a>Two ways to convert to one-hot encoding</h1><p>train_labels_onehot &#x3D; keras.utils.to_categorical(train_labels)<br>test_labels_onehot &#x3D; np.eye(2)[test_labels]</p><p>hist &#x3D; model.fit(x&#x3D;train_x_norm,y&#x3D;train_labels_onehot,validation_data&#x3D;[test_x_norm,test_labels_onehot],batch_size&#x3D;1,epochs&#x3D;10)</p></li></ul><p><strong>Sparse Categorical Cross-Entropy（稀疏分类交叉熵）（使用整数标签代替独热码标签）</strong></p><p>Often labels in multi-class classification are represented by class numbers.<br>Keras also supports another kind of loss function called <strong>sparse categorical<br>crossentropy</strong> , which expects class number to be <strong>integers</strong> , and not one-<br>hot vectors. Using this kind of loss function, we can simplify our training<br>code:</p><pre><code>model.compile(keras.optimizers.Adam(0.01),&#39;sparse_categorical_crossentropy&#39;,[&#39;acc&#39;])model.fit(x=train_x_norm,y=train_labels,validation_data=[test_x_norm,test_labels],batch_size=1,epochs=10)</code></pre><h4 id="Multi-Label-Classification（多标签分类）"><a href="#Multi-Label-Classification（多标签分类）" class="headerlink" title="&lt;3&gt;Multi-Label Classification（多标签分类）"></a>&lt;3&gt;Multi-Label Classification（多标签分类）</h4><pre><code>    With multi-label classification, instead of one-hot encoded vector, we will **have a vector that has 1 in position corresponding to all classes** relevant to the input sample. Thus, output of the network should not have normalized probabilities for all classes, but rather for each class individually - which corresponds to using **sigmoid** activation function. Cross-entropy loss can still be used as a loss function.**（不再使用独热码，而是标签中所有包含的位为1）**</code></pre><h4 id="总结-Summary-of-Classification-Loss-Functions"><a href="#总结-Summary-of-Classification-Loss-Functions" class="headerlink" title="&lt;4&gt;总结 Summary of Classification Loss Functions"></a>&lt;4&gt;总结 <strong>Summary of Classification Loss Functions</strong></h4><pre><code>    We have seen that binary, multi-class and multi-label classification **differ by the type of loss function and activation function on the last layer** of the network. It may all be a little bit confusing if you are just starting to learn, but here are a few rules to keep in mind:</code></pre><ul><li>If the network has one output (<strong>binary classification</strong>), we use <strong>sigmoid</strong> <strong>activation function</strong> , for <strong>multiclass classification</strong> - <strong>softmax</strong></li><li>If the output class is represented as one-hot-encoding, the <strong>loss function</strong> will be <strong>cross entropy loss</strong> (categorical cross-entropy), if the output contains class number - <strong>sparse categorical cross-entropy</strong>. For <strong>binary classification</strong> - use <strong>binary cross-entropy</strong> (same as <strong>log loss</strong>)</li><li><strong>Multi-label classification</strong> is when we can have an object belonging to several classes at the same time. In this case, we need to encode labels using one-hot encoding, and use <strong>sigmoid</strong> as activation function, so that each class probability is between 0 and 1.</li></ul><table><thead><tr><th>Classification</th><th>Label Format</th><th>Activation Function</th><th>Loss</th></tr></thead><tbody><tr><td>Binary</td><td>Probability of 1st class</td><td>sigmoid</td><td>binary crossentropy</td></tr><tr><td>Binary</td><td>One-hot encoding (2 outputs)</td><td>softmax</td><td>categorical crossentropy</td></tr><tr><td>Multiclass</td><td>One-hot encoding</td><td>softmax</td><td>categorical crossentropy</td></tr><tr><td>Multiclass</td><td>Class Number</td><td>softmax</td><td>sparse categorical crossentropy</td></tr><tr><td>Multilabel</td><td>One-hot encoding</td><td>sigmoid</td><td>categorical crossentropy</td></tr></tbody></table><h3 id="2-Tensorflow2-x-Keras"><a href="#2-Tensorflow2-x-Keras" class="headerlink" title="2.Tensorflow2.x+Keras"></a>2.Tensorflow2.x+Keras</h3><pre><code>        Tensorflow 2.x + Keras - new version of Tensorflow with integrated Keras functionality, which supports **dynamic computation graph** , allowing to perform tensor operations very similar to numpy (and PyTorch)import tensorflow as tfimport numpy as npprint(tf.__version__)</code></pre><h4 id="简单张量操作"><a href="#简单张量操作" class="headerlink" title="&lt;1&gt;简单张量操作"></a>&lt;1&gt;简单张量操作</h4><h5 id="①创建"><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h5><p>You can easily create simple tensors from lists of np-arrays, or generate<br>random ones</p><pre><code># 创建常量张量a = tf.constant([[1,2],[3,4]])print(a)# 创建正态分布随机10*3张量a = tf.random.normal(shape=(10,3))print(a)</code></pre><h5 id="②运算"><a href="#②运算" class="headerlink" title="②运算"></a>②运算</h5><p>You can use arithmetic operations on tensors, which are performed element-<br>wise, as in numpy. Tensors are automatically expanded to required dimension,<br>if needed. <strong>To extract numpy-array from tensor, use<br><code>.numpy()</code>:（将张量转化为np数组）（以下是运算示例：）</strong></p><pre><code>print(a-a[0])print(tf.exp(a)[0].numpy())</code></pre><h4 id="计算梯度"><a href="#计算梯度" class="headerlink" title="&lt;2&gt;计算梯度"></a>&lt;2&gt;计算梯度</h4><p>For back propagation, you need to compute gradients. This is done using<br><strong><code>tf.GradientTape()</code></strong> idiom:</p><ul><li><p>Add <code>with tf.GradientTape() as tape:</code> block around our computations</p></li><li><p>Mark those tensors with respect to which we need to compute gradients by calling <code>tape.watch</code> (all variables are <strong>watched automatically</strong>)</p></li><li><p>Compute whatever we need (build computational graph)</p></li><li><p>Obtain gradients using <code>tape.gradient</code></p><p>a &#x3D; tf.random.normal(shape&#x3D;(2, 2))<br>b &#x3D; tf.random.normal(shape&#x3D;(2, 2))</p><p>with tf.GradientTape() as tape:<br>  tape.watch(a)  # Start recording the history of operations applied to <code>a</code><br>  c &#x3D; tf.sqrt(tf.square(a) + tf.square(b))  # Do some math using <code>a</code></p><h1 id="What’s-the-gradient-of-c-with-respect-to-a"><a href="#What’s-the-gradient-of-c-with-respect-to-a" class="headerlink" title="What’s the gradient of c with respect to a?"></a>What’s the gradient of <code>c</code> with respect to <code>a</code>?</h1><p>  dc_da &#x3D; tape.gradient(c, a)<br>  print(dc_da)</p></li></ul><p>监视变量、构建运算关系、计算梯度</p><h4 id="3-例1：线性回归问题"><a href="#3-例1：线性回归问题" class="headerlink" title="&lt; 3&gt;例1：线性回归问题"></a><strong>&lt; 3&gt;例1：线性回归问题</strong></h4><p>生成数据集</p><pre><code>import matplotlib.pyplot as pltfrom sklearn.datasets import make_classification, make_regressionfrom sklearn.model_selection import train_test_splitimport randomnp.random.seed(13) # pick the seed for reproducability - change it to explore the effects of random variationstrain_x = np.linspace(0, 3, 120)train_labels = 2 * train_x + 0.9 + np.random.randn(*train_x.shape) * 0.5plt.scatter(train_x,train_labels)</code></pre><p>定义损失函数：</p><pre><code>input_dim = 1output_dim = 1learning_rate = 0.1# This is our weight matrixw = tf.Variable([[100.0]])# This is our bias vectorb = tf.Variable(tf.zeros(shape=(output_dim,)))def f(x):  return tf.matmul(x,w) + bdef compute_loss(labels, predictions):  return tf.reduce_mean(tf.square(labels - predictions))</code></pre><p>训练函数：</p><pre><code>def train_on_batch(x, y):  with tf.GradientTape() as tape:    predictions = f(x)    loss = compute_loss(y, predictions)    # Note that `tape.gradient` works with a list as well (w, b).    dloss_dw, dloss_db = tape.gradient(loss, [w, b])  w.assign_sub(learning_rate * dloss_dw)  b.assign_sub(learning_rate * dloss_db)  return loss</code></pre><p>训练集生成：</p><pre><code># Shuffle the data. 打乱数据indices = np.random.permutation(len(train_x))features = tf.constant(train_x[indices],dtype=tf.float32)labels = tf.constant(train_labels[indices],dtype=tf.float32)</code></pre><p>训练过程：（第 i 到 i+batch_size 为一组）</p><pre><code>batch_size = 4for epoch in range(10):  for i in range(0,len(features),batch_size):    loss = train_on_batch(tf.reshape(features[i:i+batch_size],(-1,1)),tf.reshape(labels[i:i+batch_size],(-1,1)))  print(&#39;Epoch %d: last batch loss = %.4f&#39; % (epoch, float(loss)))</code></pre><p>绘制：</p><pre><code>plt.scatter(train_x,train_labels)x = np.array([min(train_x),max(train_x)])y = w.numpy()[0,0]*x+b.numpy()[0]plt.plot(x,y,color=&#39;red&#39;)We now have obtained optimized parameters $W$ and $b$. Note that their values are **similar to the original values used when generating the dataset** (W=2, b=1)</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/137124492">https://blog.csdn.net/qq_32971095/article/details/137124492</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> python </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言实现进化算法——人工智能导论＜1＞</title>
      <link href="/2024/03/14/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/"/>
      <url>/2024/03/14/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一.问题描述"></a>一.问题描述</h2><p>求该函数的最优解：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b72b9e9aec3b2c8f64d8b9f4e22efa21.png"></p><p>解题思路：</p><p>变量编码-&gt;生成种群-&gt;交叉-&gt;变异-&gt;选择-&gt;迭代</p><pre><code>    对x1和x2在变量范围内的值按照给定精度计算编码成二进制码的位数；随机生成一定规模的种群，其二进制编码随机； 随机对种群内个体的编码进行交叉；随机对种群内个体的编码进行按位变异；对二进制码进行解码、求解适应度函数值、保留一定数量的精英、采用轮盘赌随机选取其余个体最终组成新的种群；迭代，重复 交叉-&gt;变异-&gt;选择 至最优适应度基本不变或迭代一定次数。</code></pre><h2 id="二-代码解析"><a href="#二-代码解析" class="headerlink" title="二.代码解析"></a>二.代码解析</h2><h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdbool.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#define POPULATION_SIZE 100//种群规模#define RESERVE_NUM 3//每代精英保留数 #define VARI_NUM 2//变量个数 #define ITERATION 1000//迭代次数#define END_TIMES 100//稳定终止次数 #define PC 0.6//交叉概率 #define CROSS_LEN 8//交叉长度 #define PM 0.1//变异概率 //种群结构体 typedef struct v&#123;bool encode[50];//二进制编码 double value[VARI_NUM];//解码数值 bool change;//标记是否发生交叉或变异  double fitness;//适应度double fit_rate;//适应度占比 &#125;v;double lower[VARI_NUM],upper[VARI_NUM],accur;//x1,x2上下界和精度 int encode_num,encode_number[VARI_NUM];//二进制编码位数 double real_accur[VARI_NUM];//实际精度 v optimization_popu;//最优个体 //函数声明 v Get_Optimization(void);void Init_Population(v* group);void Cross(v* group);void Mutation(v* group);v* Select(v**group);double Fitness(double x1,double x2); void Output_Result(v* optimization);void Free_space(v** group);//************************************************************************************************************int main()&#123;int i;v temp;//输入样例：-3.0 12.1 4.1 5.8 0.0001 printf(&quot;输入变量x1和x2的上下界和精度(x1_lower,x1_upper,x2_lower,x2_upper,accur):&quot;);scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;lower[0],&amp;upper[0],&amp;lower[1],&amp;upper[1],&amp;accur);//可以多次进行实验for(i=0;i&lt;1;i++)&#123;temp=Get_Optimization();if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;&#125;Output_Result(&amp;optimization_popu);return 0;&#125;//************************************************************************************************************v Get_Optimization(void)&#123;srand((unsigned)time(NULL));int i,j;double temp;v** group=(v**)malloc(3*sizeof(v*));//原始、交叉、变异种群for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);v* optimization=group[0],opt_tmep;//最优种群 //初始化种群 Init_Population(group[0]);memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);//迭代 for(i=j=0;i&lt;ITERATION;i++)&#123;//交叉Cross(group[1]); //变异Mutation(group[2]);//选择 temp=optimization-&gt;fitness;optimization=Select(group); if((optimization-&gt;fitness-temp)&lt;accur)&#123;j++;if(j&gt;=END_TIMES)break;//结果保持稳定则退出 &#125; &#125;//输出结果Output_Result(optimization); opt_tmep=*optimization;Free_space(group);return opt_tmep;&#125;//计算变量二进制编码位数 int Encode_Num(double lower,double upper,double accur)&#123;int num,i,j;num=(upper-lower)/accur+1;for(i=0,j=1;j&lt;num;j*=2,i++);return i;&#125;void Init_Population(v* group)&#123;int i,j;for(i=encode_num=0;i&lt;VARI_NUM;i++)encode_num+=(encode_number[i]=Encode_Num(lower[i],upper[i],accur));//计算编码位数for(i=0;i&lt;VARI_NUM;i++)real_accur[i]=(upper[i]-lower[i])/(pow(2,encode_number[i])-1);//计算实际精度//初始化种群 for(i=0;i&lt;POPULATION_SIZE;i++)&#123;//随机生成二进制编码 for(j=0;j&lt;encode_num;j++)&#123;group[i].encode[j]=rand()%2;//printf(&quot;%d %d:%d\n&quot;,i,j,group[i].encode[j]);&#125;group[i].change=true;&#125;&#125;//交叉lower和upper之间的编码 void Cross(v* group)&#123;double p;int i,j,lower,upper;bool temp;//随机选取交叉片段lower=rand()%(encode_num-CROSS_LEN-1);upper=lower+CROSS_LEN; for(i=0;i&lt;POPULATION_SIZE/2-1;i++)&#123;p=1.0*rand()/RAND_MAX;//***随机数*** if(p&lt;PC)&#123; //交叉 for(j=lower;j&lt;upper;j++)&#123;temp=group[i].encode[j];group[i].encode[j]=group[POPULATION_SIZE-1-i].encode[j];group[POPULATION_SIZE-1-i].encode[j]=temp;&#125;&#125;//标记未交叉 else group[i].change=group[POPULATION_SIZE-1-i].change=false;&#125;&#125; //按位变异  void Mutation(v* group)&#123;double p;int i,j;for(i=0;i&lt;POPULATION_SIZE/2;i++)&#123;for(j=0;j&lt;encode_num;j++)&#123;p=1.0*rand()/RAND_MAX;//***随机数*** if(p&lt;PM)group[i].encode[j]=!group[i].encode[j];else group[i].change=false;&#125;&#125;&#125;//选择v* Select(v**group)&#123;v* fitist[RESERVE_NUM],*group_temp=(v*)malloc(sizeof(v)*POPULATION_SIZE);int i,j,k,l,m,n;int vaild_num;//有效个数 double fit_sum;//适应度总大小for(i=0;i&lt;RESERVE_NUM;i++)fitist[i]=&amp;group[0][0]; //解码并计算适应度函数 for(vaild_num=fit_sum=i=0;i&lt;3;i++)&#123;for(j=0;j&lt;POPULATION_SIZE;j++)&#123;if(!group[i][j].change)continue; for(m=n=0;m&lt;VARI_NUM;n+=encode_number[m],m++)&#123;for(k=l=0;k&lt;encode_number[m];k++)l+=group[i][j].encode[k+n]*pow(2,k);//解码 group[i][j].value[m]=lower[m]+l*real_accur[m];//printf(&quot;%d %d--value[%d]:%lf\n&quot;,i,j,m,group[i][j].value[m]);&#125;//计算适应度 group[i][j].fitness=Fitness(group[i][j].value[0],group[i][j].value[1]);//保存适应度大的个体for(k=0;k&lt;RESERVE_NUM;k++)&#123;if(group[i][j].fitness&gt;fitist[k]-&gt;fitness)&#123;for(l=k;l&lt;RESERVE_NUM-1;l++)fitist[l+1]=fitist[l];fitist[k]=&amp;group[i][j];&#125;&#125;vaild_num++;fit_sum+=group[i][j].fitness;//适应度总和计算 //printf(&quot;%d %d--fitness:%lf\n&quot;,i,j,group[i][j].fitness);&#125;&#125; //***保留优秀个体***for(i=0;i&lt;RESERVE_NUM;i++)group_temp[i]=*fitist[i];//计算比率 for(i=0;i&lt;3;i++)&#123;for(j=0;j&lt;POPULATION_SIZE;j++)&#123;if(!group[i][j].change)continue;group[i][j].fit_rate=group[i][j].fitness/fit_sum;//printf(&quot;%d %d--fit_rate:%lf\n&quot;,i,j,group[i][j].fit_rate);&#125;&#125;//轮盘赌选择for(i=RESERVE_NUM;i&lt;POPULATION_SIZE;i++)&#123;double p=1.0*rand()/RAND_MAX;//寻找所处区间double temp;for(temp=0,j=0;j&lt;3;j++)&#123;for(k=0;k&lt;POPULATION_SIZE;k++)&#123;if(!group[j][k].change)continue;temp+=group[j][k].fit_rate;if(p&lt;temp)break;&#125;if(p&lt;temp)break;&#125;//复制 if(j!=3&amp;&amp;k!=POPULATION_SIZE)group_temp[i]=group[j][k];else group_temp[i]=group[j-1][k-1];//printf(&quot;select %3d from %3d %3d--fitness:%lf--p:%lf\n&quot;,i,j,k,group_temp[i].fitness,p);&#125;  memcpy(group[0],group_temp,sizeof(v)*POPULATION_SIZE);free(group_temp);return fitist[0]; &#125;//适应度函数 double Fitness(double x1,double x2)&#123;return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);&#125;void Output_Result(v* optimization)&#123;int i;printf(&quot;最优解为:x1=%9lf x2=%9lf f(x1,x2)=%9lf 二进制编码为:&quot;,optimization-&gt;value[0],optimization-&gt;value[1],optimization-&gt;fitness); for(i=0;i&lt;encode_num;i++)printf(&quot;%d&quot;,optimization-&gt;encode[i]);printf(&quot;\n&quot;);&#125;//释放空间 void Free_space(v** group)&#123;int i;for(i=0;i&lt;3;i++)free(group[i]);free(group);&#125;</code></pre><h3 id="2-算法关键参数"><a href="#2-算法关键参数" class="headerlink" title="2.算法关键参数"></a>2.算法关键参数</h3><pre><code>#define POPULATION_SIZE 100//种群规模#define RESERVE_NUM 3//每代精英保留数 #define VARI_NUM 2//变量个数 #define ITERATION 1000//迭代次数#define END_TIMES 100//稳定终止次数 #define PC 0.6//交叉概率 #define CROSS_LEN 8//交叉长度 #define PM 0.1//变异概率 </code></pre><h3 id="3-定义种群结构体、相关变量及函数"><a href="#3-定义种群结构体、相关变量及函数" class="headerlink" title="3.定义种群结构体、相关变量及函数"></a>3.定义种群结构体、相关变量及函数</h3><pre><code>//种群结构体 typedef struct v&#123;bool encode[50];//二进制编码 double value[VARI_NUM];//解码数值 bool change;//标记是否发生交叉或变异  double fitness;//适应度double fit_rate;//适应度占比 &#125;v;double lower[VARI_NUM],upper[VARI_NUM],accur;//x1,x2上下界和精度 int encode_num,encode_number[VARI_NUM];//二进制编码位数 double real_accur[VARI_NUM];//实际精度 v optimization_popu;//最优个体 //函数声明 v Get_Optimization(void);void Init_Population(v* group);void Cross(v* group);void Mutation(v* group);v* Select(v**group);double Fitness(double x1,double x2); void Output_Result(v* optimization);void Free_space(v** group);</code></pre><h3 id="4-求解流程"><a href="#4-求解流程" class="headerlink" title="4.求解流程"></a>4.求解流程</h3><pre><code>v Get_Optimization(void)&#123;srand((unsigned)time(NULL));int i,j;double temp;v** group=(v**)malloc(3*sizeof(v*));//原始、交叉、变异种群for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);v* optimization=group[0],opt_tmep;//最优种群 //初始化种群 Init_Population(group[0]);memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);//迭代 for(i=j=0;i&lt;ITERATION;i++)&#123;//交叉Cross(group[1]); //变异Mutation(group[2]);//选择 temp=optimization-&gt;fitness;optimization=Select(group); if((optimization-&gt;fitness-temp)&lt;accur)&#123;j++;if(j&gt;=END_TIMES)break;//结果保持稳定则退出 &#125; &#125;//输出结果Output_Result(optimization); opt_tmep=*optimization;Free_space(group);return opt_tmep;&#125;</code></pre><h2 id="三-求解结果"><a href="#三-求解结果" class="headerlink" title="三.求解结果"></a>三.求解结果</h2><pre><code>    改变算法关键参数会导致求解结果不同，不同的时间下的结果也不同。可以改变主函数中for循环的结束条件多次进行实验：    //可以多次进行实验for(i=0;i&lt;1;i++)&#123;temp=Get_Optimization();if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;&#125;    笔者在一定的参数下得到了最优解：最优解为:x1=11.625358x2=5.725031f(x1,x2)=38.850261二进制编码为:111100111111101111010110100101111    对于问题二，修改适应度函数：//适应度函数 double Fitness(double x1,double x2)&#123;//return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);return 100*pow((x2-x1*x1),2)+pow((1-x1),2);&#125;    再输入变量范围及精度 ：输入样例2：-2.048 2.048 -2.048 2.048 0.0001</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ede4e3460860a1737bc72b9a592cb66.png"></p><pre><code>最优解为:x1=-2.047875 x2=-2.037187 f(x1,x2)=3891.799899 二进制编码为:01000000000000001011010100000000</code></pre><h2 id="四-相关思考"><a href="#四-相关思考" class="headerlink" title="四.相关思考"></a>四.相关思考</h2><p>1.增加精度可以增加编码长度，减少交叉变异的影响，增加搜索精度，结果可能更加靠近最优解</p><p>2.增加变异概率以产生更多新的性状（<strong>变异的概率可采用自适应概率，如果最优种个体适应度值长时间未变化，可增加变异概率</strong><br>），以及采用更复杂的交叉、变异算法</p><p>3.交叉、变异过于随机会使求解趋于“遍历”，并且算法的“朝最优解的驱动力”不足</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/136715239">https://blog.csdn.net/qq_32971095/article/details/136715239</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vitis开发二——FPGA学习笔记＜？＞</title>
      <link href="/2024/03/01/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/"/>
      <url>/2024/03/01/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p>参考：《DFZU2EG_4EV MPSoC 之嵌入式 VITIS 开发指南》——正点原子</p><h2 id="一-自定义-IP-核-呼吸灯实验"><a href="#一-自定义-IP-核-呼吸灯实验" class="headerlink" title="一.自定义 IP 核-呼吸灯实验"></a>一.自定义 IP 核-呼吸灯实验</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>   通过**创建和封装 IP 向导** 的方式来自定义 IP 核，将模块集成到 Vivado 中的 IP 库中。本 次实验选择常用的方式，即创建一个带有 AXI 接口的 IP 核，该 IP 核通过 AXI 协议实现 PS 和 PL 的数据通信。</code></pre><h4 id="硬件框图"><a href="#硬件框图" class="headerlink" title="&lt;1&gt;硬件框图"></a>&lt;1&gt;硬件框图</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7f69746d9c8b2612a562e216cbcb06d.png"></p><pre><code>    自定义一个 LED IP 核，来控制 PL LED 呈现呼吸灯的效果，并且 **PS 可以通过 AXI 接口来控制呼吸灯的开关和呼吸的频率** 。</code></pre><h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><h4 id="step1：自定义IP核"><a href="#step1：自定义IP核" class="headerlink" title="step1：自定义IP核"></a>step1：自定义IP核</h4><h5 id="创建IP核"><a href="#创建IP核" class="headerlink" title="&lt;1&gt;创建IP核"></a>&lt;1&gt;创建IP核</h5><pre><code>    在vivado进入界面点击“Tasks”栏中的“Manage IP”。在弹出的选项中选择“New IP Location...”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/75f9ff5dc9db70244cab46a870f0688d.png"></p><p>设置工程路径**“IP Location”**   和 器件**“Part”（后续可重新指定）：**</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3b1e3885d4a1f135051044efbbe1a2b.png"></p><pre><code>    工程创建完成后，运行**创建和封装 IP 向导** 。点击**菜单栏的“Tools”** ，选择**“Create and Package New IP”** ，在弹出的界面中，点击“NEXT”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4052ba288d62dba075506fe808c59d.png"></p><p>可选择封装 IP 或者创建一个带 AXI4 接口的 IP 核 ：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d966c8cd8965f275b224c4f87af580a0.png"></p><pre><code>    接下来分别设置 IP 核名称（Name）、版本号（Version）、显示名（Display name）、描述（Description） 和路径（IP location）。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb004f9d3e754f9cc51b150f9afb459d.png"></p><p>接下来对 AXI 接口进行设置：</p><p><strong>Name（名称）</strong> ：这里修改成 S0_AXI。</p><p><strong>Interface Tpye（接口类型）</strong> ：共三种接口类型可选，分别是 <strong>Lite、Full 和 Stream</strong> 。AXI4-Lite<br>接口是<strong>简化版</strong> 的 AXI4 接口，用于较少数据量的存储映射通信；AXI4-Full 接口是<strong>高性能存储映射接口</strong><br>，用于较多数据量的存储映射通信；AXI4-Stream 用于<strong>高速数据流传输</strong> ，非存储映射接口。本次实验只需少量数据的通信， 因此接口类型选择默认的<br>Lite 接口。</p><p><strong>Interface Mode（接口模式）</strong> ：接口模式有 <strong>Slave（从机）和 Master（主机）</strong> 两种模式可选，AXI<br>协议是<strong>主机和从机通过“握手”的方式建立连接</strong> ，这里选择默认的 <strong>Slave 接口模式</strong> 。</p><p><strong>Data Width（数据宽度）</strong> ：数据位宽保持默认，即 32 位位宽。</p><p><strong>Memory Size（存储器大小）</strong> ： 在 AXI4-Lite 接口模式下，该选项不可设置。</p><p><strong>Number of Registers（寄存器数量）</strong> ：用于配置 PL LED 呼吸灯寄存器的数量，这里保持默认。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91283af0eb0913bef4fd7d225f3b9a7b.png"></p><pre><code>    最后弹出封装接口的总结描述和下一步操作选项的界面。这里保持默认，即**将 IP 添加至 IP 库中** ， 点击“Finish”按钮完成 IP 核的创建和封装。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/413f0da1496d94c764828b274017a30e.png"></p><pre><code>     在 **IP Catalog 界面** 中可以看到刚刚添加的 IP 核，位于 **User Repository** 一栏中的 AXI Peripheral 下，名称 为“breath_led_ip_v1.0”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a18c63c55f085bf15281c34ab989331.png"></p><h5 id="编辑IP核"><a href="#编辑IP核" class="headerlink" title="&lt;2&gt;编辑IP核"></a>&lt;2&gt;编辑IP核</h5><pre><code>    右击 breath_led_ip_v1.0 IP 核， 选择“**Edit in IP Packager** ”，在弹出的界面中点击“OK”。此时会打开一个新的工程：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/63e543b57d5d554d9b74780351c6fb78.png"></p><pre><code>    双击 breath_led_ip_v1_0.v文件即可开始编辑代码，来添加控制 PL LED 呼吸灯所需要的参数和端口信号：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e30dec6de76b6e61b1aa50c039589999.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3f8c3ad3ebbdf5bdc9e7ad185618452.png"></p><pre><code>    在创建和封装 IP 核向导中，我们总共定义了 4 个寄存器，代码中的 slv_reg0 至 slv_reg3 是寄存器地址 0 至寄存器地址 3 对应的数据，通过例化呼吸灯模块，**将寄存器地址对应的数据和呼 吸灯模块（breath_led****） 的控制端口相连接**，即可实现对呼吸灯的控制。 </code></pre><p>breath_led_ip_v1_0.v文件：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/252b8cca44230059c49602a5452d9998.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f62dc01cb25ae99d4f697d5b7638e66.png"></p><pre><code>    breath_led_ip_v1_0_S0_AXI.v文件。 breath_led_ip_v1_0_S0_AXI 模块实现了 AXI4 协议下的读写寄存器的功能：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/425827ac7a64452aea8a0413ea593bcf.png"></p><p>时我们还需要在代码的第 401 行例化 breath_led.v 文件：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ffed17009e2230f835db7440ba21eee.png"></p><pre><code>// Add user logic here    breath_led #(        .START_FREQ_STEP(START_FREQ_STEP)    )    u_breath_led(        .sys_clk (S_AXI_ACLK),        .sys_rst_n (S_AXI_ARESETN),        .sw_ctrl (slv_reg0[0]),        .set_en (slv_reg1[31]),        .set_freq_step (slv_reg1[9:0]),        .led (led)    );// User logic ends    代码中的 **slv_reg0 和 slv_reg1 是寄存器地址 0 和寄存器地址 1 对应的数据** ，我们通过寄存器地址 0 对应 的数据来控制呼吸灯的使能（sw_ctrl），寄存器地址 1 对应数据的最高位控制呼吸灯频率的设置有效信号 （set_en），寄存器地址 1 对应数据的低 10 位控制呼吸灯频率的步长（set_freq_step）。    此时工程中缺失 breath_led.v 文件，breath_led.v 文件用于实现呼吸灯的功能。右击**“Design Sources”** ，选择**“Add Sources…”** ，在弹出的界面中选择“**Add or Create design source”** ， 点击“NEXT”；点击“**Create File ”** 创建一个新的文件，在弹出的界面输入名称 breath_led ，路径 为../**_custom_ip/ip_repo/breath_led_ip_1.0/_ hdl**，点击“OK”按钮</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e3c33e0d2c764bd425828a96898b80d.png"></p><pre><code>    在弹出的**模块定义界面中点击“OK”按钮** ，接下来在弹出的确认按钮中点击“YES”。双击 u_breath_led(breath_led.v)文件并编辑代码如下：module breath_led(    input          sys_clk        , //时钟信号    input          sys_rst_n      , //复位信号    input          sw_ctrl        , //呼吸灯开关控制信号 1：亮 0:灭    input          set_en         , //设置呼吸灯频率设置使能信号    input   [9:0]  set_freq_step  , //设置呼吸灯频率变化步长        output         led              //LED);//*****************************************************//**                  main code//*****************************************************//parameter defineparameter  START_FREQ_STEP = 10&#39;d100; //设置频率步长初始值//reg definereg  [15:0]  period_cnt  ;      //周期计数器reg  [9:0]   freq_step   ;      //呼吸灯频率间隔步长reg  [15:0]  duty_cycle  ;      //设置高电平占空比的计数点reg          inc_dec_flag;      //用于表示高电平占空比的计数值,是递增还是递减                                //为1时表示占空比递减,为0时表示占空比递增//wire definewire         led_t       ;//将周期信号计数值与占空比计数值进行比较，以输出驱动led的PWM信号assign led_t = ( period_cnt &lt;= duty_cycle ) ? 1&#39;b1 : 1&#39;b0 ;assign led = led_t &amp; sw_ctrl;//周期信号计数器在0-50_000之间计数always @ (posedge sys_clk) begin    if (!sys_rst_n)        period_cnt &lt;= 16&#39;d0;    else if(!sw_ctrl)        period_cnt &lt;= 16&#39;d0;    else if( period_cnt == 16&#39;d50_000 )        period_cnt &lt;= 16&#39;d0;    else        period_cnt &lt;= period_cnt + 16&#39;d1;end//设置频率间隔always @(posedge sys_clk) begin    if(!sys_rst_n)        freq_step &lt;= START_FREQ_STEP;    else if(set_en) begin        if(set_freq_step == 0)            freq_step &lt;= 10&#39;d1;        else if(set_freq_step &gt;= 10&#39;d1_000)            freq_step &lt;= 10&#39;d1_000;        else                freq_step &lt;= set_freq_step;    end        end//设定高电平占空比的计数值always @(posedge sys_clk) begin    if (sys_rst_n == 1&#39;b0) begin        duty_cycle &lt;= 16&#39;d0;        inc_dec_flag &lt;= 1&#39;b0;    end         else if(!sw_ctrl) begin          //呼吸灯开关关闭时，信号清零        duty_cycle &lt;= 16&#39;d0;        inc_dec_flag &lt;= 1&#39;b0;    end        //每次计数完了一个周期，就调节占空比计数值    else if( period_cnt == 16&#39;d50_000 ) begin        if( inc_dec_flag ) begin  //占空比递减            if( duty_cycle == 16&#39;d0 )                     inc_dec_flag &lt;= 1&#39;b0;            else if(duty_cycle &lt; freq_step)                duty_cycle &lt;= 16&#39;d0;            else                    duty_cycle &lt;= duty_cycle - freq_step;        end        else begin  //占空比递增            if( duty_cycle &gt;= 16&#39;d50_000 )                  inc_dec_flag &lt;= 1&#39;b1;            else                duty_cycle &lt;= duty_cycle + freq_step;        end     end     else  //未计数完一个周期时，占空比保持不变        duty_cycle &lt;= duty_cycle ;end  endmodule    模块实现了呼吸灯的功能。呼吸灯的使能由输入的端口信号 sw_ctrl 控制，呼吸灯的呼吸频率由输入的端口信号 set_en 和 set_freq_step 控制。输入的 set_freq_step 范围是 1~1000。    在左侧 Flow Navigator 导航栏中找到 SYNTHESIS，点击 该选项中的 **“Run Synthesis”** ，等待代码编译完成。</code></pre><h5 id="IP-封装"><a href="#IP-封装" class="headerlink" title="&lt;3&gt;IP 封装"></a>&lt;3&gt;IP 封装</h5><pre><code>    将界面切换至 Package IP，也可以通过 **IP-XACT** 界面下的 **component.xml** 重新打开：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1c22b4d8b6ddec5fb30e7748ee701a2.png"></p><pre><code>    Identification 这一栏的选项直接保持默认，需要注意的是，我们可以点击图 6.3.31 中 **Categories** 选项下 的“+”按钮来**修改 IP 的分类** ，这里不做修改。 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e936bc92628f578319803047bbae7cc5.png"></p><pre><code>    这里勾选“zynq”和“zynquplus”两项，表示该 IP 核支持 ZYNQ 和 ZYNQ MPSOC 器件。而 Life-cycle 表明该 IP 核当前的产品生命周期，这里选择“**Pre-Production** ”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f16af805e5acec286ff245098ff0bdf9.png"></p><pre><code>    点击 File Groups，然后点击界面上的“Merge Changes from File Groups Wizard”，此时可以在 Verilog Synthesis 一栏中查看工程中的三个模块。    点击 **Customization Parameters** ，点击界面上的“**Merge Changes from Customization Parameters Wizard”** ，此时多了 Hidden Parameters 一栏，展开这个界面，可以看到程序中自定义的参数 START_FREQ_STEP， 右击这个参数，选择“Edit Parameter…”，弹出编辑参数的界面：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0dc10a436eeb939c31cf5a88916780d3.png"></p><pre><code>    在弹出的页面中勾选“Visible in Customization GUI”，将此参数显示在 GUI 参数界面中； Format 格式改为“long”； 勾选“Specify Range”来设定此参数的范围。将 Type 改为“Range of integers”，Minimum 的值改为 1， Maximum 的值改为 1000，将 Default Value 的值改为 100，点击“OK”按钮：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7bab0fc3776af968cd45566c20131a0.png"></p><pre><code>    点击“Customization GUI”，可以在“Layout”界面拖动 Page 0 下的参数来调整参数在 GUI 显示 的位置，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c5ef7a9cd6f3c7a15449f3584ad9974.png"></p><pre><code>    点击**“Review and Package”** ，然后点击“**IP has been modified”** 更新总结界面，最后点击**“Re-Package IP”** ，如下图所示： </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d280db132f7fdb24445364a47d6a502d.png"></p><pre><code>    IP 核封装完成后，在 IP 核所在路径（...\custom_ip\ip_repo\breath_led_ip_1.0\drivers\breath_led_ip_v1_0\src） 目录下，Vivado 软件会自动生成.c 和.h 文件，方便在 VITIS 软件中对 IP 核进行操作。最后关闭工程IP核创建结束。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/161d049dd7e3bf4ca866b0d0354554ae.png"></p><h4 id="step2：创建vivado工程"><a href="#step2：创建vivado工程" class="headerlink" title="step2：创建vivado工程"></a>step2：创建vivado工程</h4><pre><code>    创建 Vivado 工程名为 user_led，具体过程见前。点击菜单栏的“Tools”， 选择“Setting”，把自定义的IP核添加至本工程的IP库中：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/62472d612e15937378ba85ce4929f62b.png"></p><pre><code>    点击“IP”一栏下的“Repository”，然后点击“+”来添加自定义的 IP 核。选择../custom_ip/**ip_repo/breath_led_ip_1.0** ，点击“Select”，点击“OK”按钮添加 IP 核：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91eae14f825c3128bdcadc291c08c7ed.png"></p><h4 id="step3：使用-IP-Integrator-创建-Processing-System"><a href="#step3：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step3：使用 IP Integrator 创建 Processing System"></a>step3：使用 IP Integrator 创建 Processing System</h4><pre><code>    在左侧导航栏（Flow Navigator）中，单击 IP Integrator 下的 Create Block Design。然后在弹出的对话框中指定所创建的 Block Design 的名称，这里使用默认的“design_1”。在 Diagram 窗口中给设计添加 IP。点击图中加号“+”，会打开 IP 目录（IP Catalog）。在搜索栏中 键入“zynq”，找到并双击“ZYNQ Ultrascale+ MPSoC”，将 MPSOC 处理系统 IP 添加到设计中。和前面搭建嵌入式最小系统不同的是，我们保留了 pl_clk0、pl_resetn0、maxihpm0_lpd_aclk 和 M_AXI_HPM0_LPD 接口，只是添加了 UART 控制器（MIO42 和 MIO43），修改 Bank 电压和修改 DDR4 控制器**（见前）** 其它保持默认。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16e20796ae329a0e1e72eb83e2676f4a.png"></p><pre><code>     接下来添加 Breath LED IP 核，点击“+”图标，在搜索框中输入“led”，即可找到之前添加的“breath_led_ip_v1.0”IP，添加此IP核，可以双击 led IP 核来设置参数，可以看到我们自定义的参数（Start Freq Step）和其它四个参数：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/89e3ce79246c6299be15abc7c427678b.png"></p><pre><code>    接下来点击**“Run Connection Automation”** 来自动连线，在弹出的窗口中勾选 **All Automation** ，然后点击 OK。此时原理图中还没有 LED 的引脚，右击 breath_led_ip_0 的 led 引脚，选择“Make External”，将引出的 led_0 改为 led：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42ab2d5ad83cb9c00869f8e240a49e7b.png"></p><h4 id="step4：生成顶层-HDL-模块"><a href="#step4：生成顶层-HDL-模块" class="headerlink" title="step4：生成顶层 HDL 模块"></a>step4：生成顶层 HDL 模块</h4><pre><code>    在 Sources 窗口中，选中 **Design Sources** 下的 design_1.bd，这就是我们刚刚完成的 Block Design 设 计。右键点击 design_1.bd，在弹出的菜单栏中选择**“Generate Output Products”** ，等待 Generate 完成。在 Sources 窗口中，右键点击 design_1.bd，在弹出的菜单栏中选择**“Create HDL Wrapper”** 。</code></pre><h4 id="step5：生成-Bitstream-文件并导出-Hardware。"><a href="#step5：生成-Bitstream-文件并导出-Hardware。" class="headerlink" title="step5：生成 Bitstream 文件并导出 Hardware。"></a>step5：生成 Bitstream 文件并导出 Hardware。</h4><pre><code>    在左侧 Flow Navigator 导航栏中找到 RTL ANALYSIS，点击该选项中的**“Open Elaborated Design”** 。在 ELABORATED DESIGN 界面下方找到 I/O Ports 一栏。如果没有找到则通过在菜单栏中点击 Layout， 然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 一栏对 PL 部分的接口进行管脚分配，led 分配至**BANK44**  的 **AE10** 引脚，该 BANK 的供电电压为**3.3V** ，因此 I/O Std 一列对应的电平也需要修改。    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“user_led”。在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的**“Generate Bitstream”** 。在连续弹出的对话框中依次点击“YES”、“OK”。然后 Vivado 工具开始依次对设计进行综合、实现、并生成 Bitstream 文件。在菜单栏中选择 File &gt; Export &gt; **Export hardware** 。在弹出的对话框中，勾选“**Include bitstream** ”，然后点 击“OK”按钮。    新建 vitis 文件夹，将 xsa 文件拷贝到里面。选择菜单 Tools-&gt;Launch Vitis。在弹出的界面中，指定路径到..\custom_ip\user_led\vitis 下，点击 “Launch”，打开 Vitis 软件。</code></pre><h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>新建vitis工程user_led，流程同前，main.c文件内容如下：</p><pre><code>#include &quot;stdio.h&quot;#include &quot;xparameters.h&quot;#include &quot;xil_printf.h&quot;#include &quot;breath_led_ip.h&quot;#include &quot;xil_io.h&quot;#include &quot;sleep.h&quot;#define  LED_IP_BASEADDR    XPAR_BREATH_LED_IP_0_S0_AXI_BASEADDR  //LED IP基地址#define  LED_IP_REG0        BREATH_LED_IP_S0_AXI_SLV_REG0_OFFSET  //LED IP寄存器地址0#define  LED_IP_REG1        BREATH_LED_IP_S0_AXI_SLV_REG1_OFFSET  //LED IP寄存器地址1//main函数int main()&#123; int freq_flag;      //定义频率状态，用于循环改变呼吸灯的呼吸频率 int led_state;      //定义LED灯的状态 xil_printf(&quot;LED User IP Test!\n\r&quot;); while(1)&#123;     //根据freq_flag的标志位,切换呼吸灯的频率     if(freq_flag == 0)&#123;     BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x800000ef);         freq_flag = 1;     &#125;     else&#123;     BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x8000002f);         freq_flag = 0;     &#125;     //获取LED当前开关状态   1:打开  0:关闭     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);     //如果开关关闭,打开呼吸灯     if(led_state == 0)&#123;     BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 1);         xil_printf(&quot;Breath LED ON\n\r&quot;);     &#125;     sleep(5);     //获取LED当前开关状态   1:打开  0:关闭     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);     //如果开关打开,关闭呼吸灯     if(led_state == 1)&#123;     BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 0);         xil_printf(&quot;Breath LED OFF\n\r&quot;);     &#125;     sleep(1); &#125;&#125;    在代码的第 8 行至第 10 行，我们对 Breath LED IP 基地址、寄存器地址 0 和寄存器地址 1 进行了宏定义。按住 Ctrl 键不放，将鼠标移动到这些参数上，单击鼠标左键，会自动跳转到定义这些参数的地方。其中 BREATH LED IP 寄存器地址 0 和寄存器地址 1 位于**breath_led_ip.h** 文件内，这个文件是系统自动为我们生成的。    程序中的 main 函数实现了每 6 秒钟（点亮 5 秒+关闭 1 秒）打开和关闭 LED 呼吸灯的开关，并切换 LED 灯呼吸频率的功能。我们通过 **BREATH_LED_IP_mReadReg()** 函数来**读取寄存器地址的数据** ，通过 **BREATH_LED_IP_mWriteReg()** 函数来**写入寄存器地址的数据** ，这两个函数同样位于 breath_led_ip.h 文件中。    在硬件设计的自定义 IP 核部分中，我们例化 breath_led 代码的时候，将寄存器 0 的数据（slv_reg0）连接至呼吸灯的开关控制信号（sw_ctrl），寄存器 1 的数据高位（slv_reg1[31]）连接至呼吸灯频率设置使能信号（set_en），寄存器 1 的数据低位（slv_reg1[9:0]）连接至呼吸灯频率间隔设置（set_freq_step）。因此，在 Vitis 应用程序中，可以很方便的**通过 Breath LED IP 寄存器地址 0 和寄存器地址 1 来控制 LED 呼吸灯的开关和频率** 。    值得一提的是，在 Vitis 中添加导出的硬件平台文件后，自**定义 IP 核的库函数也会导入进来** ，而这个 库函数是在自定义 IP 核时，由 Vivado 软件自动生成的：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b90ad057bdb4f0e9b727ccacfb8609e6.png"></p><p>接着“build project”，如果编译出现error，可以参考：</p><p><a href="https://blog.csdn.net/qq_62179548/article/details/132042828" title="Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-CSDN博客">Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-<br>CSDN博客</a></p><p>若run时出现错误：</p><p>Error while launching program: Hardaware specification file used in the launch<br>configuration ‘Debugger_user_led_ip-Default’ doesn’t exist at the location<br>…..</p><h3 id="4-下载验证"><a href="#4-下载验证" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><pre><code>    打开 Vitis Terminal 终端，设置并连接串口。在应用工程 user_led 上右击，选择**“Run As”** ，然后选择第一项**“1 Launch on Hardware (System Debugger)”** 。</code></pre><h2 id="二-程序固化实验"><a href="#二-程序固化实验" class="headerlink" title="二.程序固化实验"></a>二.程序固化实验</h2><pre><code>   之前都是通过 JTAG 接口将 FPGA 配置文件和应用程序下载到 MPSOC 器件中。接下来尝试把程序存储在非易失性存储器中，在上电或者复位时让程序自动运行，这个过程需要启动引导程序**（Boot Loader）** 的参与。**Boot Loader 会加载 FPGA 配置文件，以及运行在 ARM 中的软件应用。**</code></pre><p>**        <strong>本章的实验任务是在“AXI GPIO 按键控制 LED 实验”的基础上</strong>创建 FSBL** ，实现程序上电自启动，<strong>包括从 SD<br>卡启动，QSPI Flash 和 eMMC 启动三种方式</strong> 。</p><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.*简介"></a>1.*简介</h3><pre><code>    MPSOC 的系统启动过程由**平台管理单元**(**PMU**)和**配置安全单元**(**CSU**)管理和执行。启动过程包括三个功能阶段：**预配置阶段、配置阶段和后配置阶段** 。   _ **预配置阶段** 由**平台管理单元** 控制。平台管理单元运行 **PMU ROM** 代码以设置系统。PMU 处理所有复位和唤醒过程。_    _**在配置阶段** ，**BootROM(CSU ROM 代码的一部分)** 解释引导头以配置系统，并在安全或非安全引导模式下将处理系统(PS)的**第一阶段引导加载程序(FSBL)代码** 加载到**片上 RAM(OCM)** 中。引导头定义了许多引导参数，包括安全模式和**执行 FSBL 的处理器 MPCore** 。在引导期间，CSU 还将 **PMU 用户固件(PMU FW)** 加载到**PMU RAM** 中，以与 PMU ROM 一起提供**平台管理服务** 。对于**基于 Xilinx 的 FSBL 和系统软件，PMU FW 必须存在于大多数系统中** 。_   _  FSBL 执行开始后，CSU ROM 代码进入**后配置阶段** ，该阶段负责系统干预响应。CSU 硬件提供持续的硬件支持，以验证文件，**通过 PCAP 配置 PL，存储和管理安全密钥，解密文件** 。_</code></pre><h4 id="启动流程-Boot-Flow"><a href="#启动流程-Boot-Flow" class="headerlink" title="启动流程(Boot Flow)"></a><strong>启动流程(Boot Flow)</strong></h4><p>**         **PMU对内部寄存器、存储器等进行复位，检查电压，则验证 CSU ROM 完整性并释放对 CSU 的复位。PMU<br>负责处理主要的预引导任务和 PS 的管理，以确保系统资源的可靠通电断电。启动 PMU<br>的上电复位(POR)操作，直接或间接的释放了预期上电模块的复位。在这种情况下，PMU 需要 ROM 代码来保持初始化上电顺序。即使在启动过程之后，PMU<br>仍在运行，并且负责处理各种系统复位。在更改系统电源状态时也会使用它(例如上电、睡眠和唤醒)。在初始化启动期间，POR 将 PMU 从复位中释放，然后执行<br>PMU ROM。</p><pre><code>下面描述了 PMU 处理器在 POR 复位后，通过运行 PMU ROM 预启动代码完成的操作序列：1、 初始化 PS SYSMON 和引导单元所需的 PLL。2、 清除 PMU RAM 和 CSU RAM(仅外部 POR)。3、 验证 PLL 锁。4、 通过 PS SYSMON 单元验证 LPD、AUX 和 IO 电源范围。5、 清除低功耗和全功耗域。6、 如果前面的步骤没有错，PMU 将释放 CSU 复位并进入 PMU 服务模式。如果有错，将产生一个启动错误标志。当 CSU 复位被释放，CSU 将按照下面序列运行：1、 初始化 OCM2、 通过读取引导模式寄存器来确定启动模式。3、 CSU 继续在 OCM 中加载 FSBL，以供 RPU 或 APU 执行。然后，CSU 将 PMU 用户固件加载到 PMU RAM 中，以供 PMU 固件执行。</code></pre><h4 id="启动模式-Boot-Modes"><a href="#启动模式-Boot-Modes" class="headerlink" title="启动模式(Boot Modes)"></a><strong>启动模式(Boot Modes)</strong></h4><pre><code>    BootROM 可以通过 Quad-SPI，SD，eMMC，USB2.0 控制器 0 或 NAND 等外部设备启动系统。    MPSOC 使用多个模式引脚来决定配置器件的类型，软件的存储位置以及其他的系统设置，这些引脚共享 PS 端的 MIO 引脚。总共有 7 个模式引脚，分别为 MIO[8:2]。其中，前四个引脚定义启动模式，第五个引脚定义是否使用 PLL，第六个和第七个引脚定义上电过程中 MIO bank0 和</code></pre><p>bank1 的 bank 电压。如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7fd4d98a93ce3511d9f836a14f2f9eb9.png"></p><h4 id="整个系统的启动过程"><a href="#整个系统的启动过程" class="headerlink" title="整个系统的启动过程"></a><strong>整个系统的启动过程</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6da7cbc34256053b4b7e3b7c4ee48dc5.png"></p><p>更详细的内容可参考：<a href="https://blog.csdn.net/qq_32971095/article/details/133468006?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22133468006%22,%22source%22:%22qq_32971095%22%7D" title="嵌入式Linux_Petalinux一——三.1软件栈">嵌入式Linux_Petalinux一——三.1软件栈</a></p><h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><pre><code>    本次实验在“AXI GPIO 按键控制 LED 实验”的基础上进行，另存为本次实验工程，工程名为 axi_gpio_fsbl。    接下来对系统的硬件设计进行修改。在 Vivado 界面左侧选择 Open Block Design，然后在右侧的 Diagram 界面中双击 Zynq UltraScale+ MPSOC 模块修改其配置。    首先**使能 QSPI 外设** 。在左侧的导航栏中选择 I/O Configuration，在打开的右侧页面中，依次展开 Low Speed &gt; Memory Interfaces，然后勾选 QSPI 并在后面的下拉菜单中选择 Single，QSPI Data Mode 选择 x4， QSPI IO 默认为 MIO0..5，勾选 Feedback Clk 并选择 MIO6，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/29757f782abd8955ade80399b026870b.png"></p><pre><code>    然后**打开 SD 卡外设** 。在上一步的页面中，展开 SD 外设，勾选 SD1，在后面的菜单栏中选择 MIO46..51， Slot Type 选择 SD2.0，Data Transfer Mode 选择 4Bit，勾选**CD 用于检测 SD 卡插入** 并选择 MIO45，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/446f0a292906d77dee9052eabc0e669b.png"></p><pre><code>    最后**打开 eMMC 外设** 。在同样的页面中，勾选 SD0 并选择 MIO13..22，Slot Type 设置成 eMMC，Data Transfer Mode 选择 8bit，勾选 Reset 并选择 MIO23，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c686ddf6f2ebcb2be138150d60ba3ff9.png"></p><pre><code>    上面两幅图中具体每个外设所连接的 MIO 引脚可以通过查看开发板原理图得知，设置完成后点击“OK”。然后在 Diagram 窗口空白处右击，然后选择“Validate Design”验证设计。验证完成后弹出对话框提示 “Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键“Ctrl + S”保存设计。    接下来在 Source 窗口中右键点击 Block Design 设计文件“design_1.bd”，执行“Generate Output Products”。 最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 对设计进行综合、实现、并生成 Bitstream 文件。    在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”。    新建 vitis 文件夹，将生成的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境。在弹出的对话框中，将路径指定到新建 的 vitis 文件夹下，点击 Launch 启动 Vitis。</code></pre><h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    新建vitis工程如上，main.c代码：#include &quot;stdio.h&quot;#include &quot;xparameters.h&quot;#include &quot;xgpiops.h&quot;#include &quot;xgpio.h&quot;#include &quot;xscugic.h&quot;#include &quot;xil_exception.h&quot;#include &quot;xil_printf.h&quot;#include &quot;sleep.h&quot;//宏定义#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID#define MIO_LED      38                           //PS_LED1 连接到  MIO38#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义//函数声明void instance_init();                             //初始化器件驱动void axi_gpio_handler(void *CallbackRef);         //中断服务函数//全局变量XScuGic            scugic_inst;                   //中断控制器    驱动实例XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例int led_value = 1;                                //LED显示状态int main()&#123;printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);//初始化各器件驱动instance_init();//配置PS GPIOXGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED//配置PL AXI GPIOXGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断    //设置中断优先级和触发类型(高电平触发)    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);    //关联中断ID和中断处理函数    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);    //使能AXI GPIO中断    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);    //设置并打开中断异常处理功能    Xil_ExceptionInit();    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,    (Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);    Xil_ExceptionEnable();    while(1);    return 0;&#125;//初始化各器件驱动void instance_init()&#123;//初始化中断控制器驱动scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);//初始化PS端  GPIO驱动gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);//初始化PL端  AXI GPIO驱动XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);&#125;//PL端  AXI GPIO 中断服务(处理)函数void axi_gpio_handler(void *CallbackRef)&#123;int key_value = 1;XGpio *GpioPtr = (XGpio *)CallbackRef;print(&quot;Interrupt Detected!\n&quot;);XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据    if(key_value == 0)&#123;                                     //判断按键按下    led_value = ~led_value;    XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态    &#125;    sleep(1);                                               //延时1s 按键消抖    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断&#125;   **保存并编译工程** 后，**创建启动镜像** 。选中应用工程，右键选择**Create Boot Image。** 接下来，在弹出的界面中添加生成 boot.bin 所需的文件，然后点击“Create Image”，如图</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/372e816b5fc79bf2ae14f19e207cdfbb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a22a2517141020dac5bd2d4d4f4cce68.png"></p><pre><code>    从上图中可以看到，软件已经给我们自动添加所需的文件。首先是 **Bootloader 启动文件** ，也就是序号 4 处的**fsbl.elf** 。其次是 **FPGA 的配置文件** design_1_wrapper.**bit** ，在上图中序号 5 处。最后是**应用程序** axi_gpio_fsbl.elf 文件，上图中序号 6 处。注意这三个文件的顺序不能错。    序号 2 处的 bif 文件是生成**BOOT 的配置文件** ，序号 3 处的 **BOOT.bin** 就是我们需要的**启动文件** ，可以烧录到 QSPI Flash 或 eMMC 中，也可以放到 SD 中来启动 ZYNQ MOPSOC。            创建完成后，在指定的路径下可以看到生成的两个文件，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a4d08531d1eab8186a97364d2ed699b7.png"></p><h3 id="4-下载验证-1"><a href="#4-下载验证-1" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><h4 id="从SD卡中启动程序"><a href="#从SD卡中启动程序" class="headerlink" title="&lt;1&gt;从SD卡中启动程序"></a>&lt;1&gt;从SD卡中启动程序</h4><pre><code>    将 Micro SD 卡插入读卡器，然后在电脑上将其格式化为 FAT32 格式，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/93b44a4a8a61b36fb0f834c0b31a9c62.png"></p><pre><code>    将生成的 BOOT.bin 文件拷贝到 SD 卡根目录下，开发板启动模式改为从SD卡启动即可。</code></pre><h4 id="固化至QSPI-Flash中"><a href="#固化至QSPI-Flash中" class="headerlink" title="&lt;2&gt;固化至QSPI Flash中"></a>&lt;2&gt;固化至QSPI Flash中</h4><pre><code>    将程序固化到 QSPI Flash 需要使用 JTAG 下载器。首先我们将下载器与开发板上的 JTAG 接口连接，下载器另外一端与电脑连接。接下来将开发板上的启动模式开关设置为  JTAG 模式。    在 Vitis 软件的菜单栏中点击“Program Flash”，如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef30f083ed0db0516b72f0c5fa19d0a1.png"></p><pre><code>    在弹出的对话框中指定前面所生成的镜像文件 BOOT.bin 以及 FSBL.elf 文件，如下图中 1 和 2 处所示。 Flash Type 选择 qspi-x4-single，并勾选 Verify after flash。点击“Program”，开始对 Flash 进行编程：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/84bec15e9c53965b8eef13f5187856f4.png"></p><pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 32bit QSPI Flash 启动即可。</code></pre><h4 id="固化到-eMMC-中"><a href="#固化到-eMMC-中" class="headerlink" title="&lt;3&gt;固化到 eMMC 中"></a>&lt;3&gt;固化到 eMMC 中</h4><pre><code>    步骤和&lt;2&gt;相同，在Program Flash中的 **Flash Type 选择 emmc** ， 并勾选 Verify after flash，然后点击 Program，如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cd484d42fb06f898814fb196a4dab72.png"></p><pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 emmc 启动即可。</code></pre><h2 id="三-UART-串口中断实验"><a href="#三-UART-串口中断实验" class="headerlink" title="三.UART 串口中断实验"></a>三.UART 串口中断实验</h2><pre><code>    我们在使用 PS 的时候，通常会添加 UART 控制器，用于打印信息和调试代码。除此之外，PS 在和外部设备通信时，也会经常使用串口进行通信。进一步向大家 UART 控制器以及 UART 控制器利用中断进行通信的方法。</code></pre><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="MPSOC内UART控制器"><a href="#MPSOC内UART控制器" class="headerlink" title="&lt;1&gt;MPSOC内UART控制器"></a>&lt;1&gt;MPSOC内UART控制器</h4><pre><code>    MPSOC内UART控制器支持可编程的波特率发生器、64 字节的接收 FIFO 和发送 FIFO、产生中断、RXD 和 TXD 信号的环回模式设置以及可配置的数据位长度、停止位和校验方式等。    UART 控制器的配置以及状态的获取由**控制（Control）和状态寄存器（Status Registers）** 完成。另外， UART 控制器不仅可以连接至 MIO，也可以**映射到 EMIO** ，从而使用 **PL 的端口来实现串口通信的功能** 。    当 UART 控制器连接到 MIO 时，只有 Tx（发送）和 Rx（接收）两个引脚；而当连接 EMIO 时，除 Tx 和 Rx 引脚外，可选的还有 CTS、RTS、DSR、DCD、RI、DTR 等引脚，这些引脚用于串口的流控制。    UART 控制器采用独立的接收和发送数据路径，每个路径包含一个 **64 字节的 FIFO** ，控制器对发送和接 收 FIFO 中的数据进行**串并转** 换操作。    **FIFO 的中断标志** 支持**轮询处理** 或**中断驱动处理** 两种方式。另外，控制器中还有一个模式开关，支持 RXD 和 TXD 信号的各种环回配置。UART 控制器内部框图如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be9467098457f02d978fdaf7b35594d6.png"></p><pre><code>    UART 控制器的寄存器通过 **APB 从机接口和 PS AXI 总线** 互联，控制器的寄存器用于对 UART 控制器 进行配置和获取状态。波特率发生器（**Baud Rate Generator** ）为 UART 控制器的接收端和发送端提供位周期 时钟；中断控制器（**GIC** ）为串口的收发提供了中断服务的功能。    APB 总线接口通过**向 TxFIFO 寄存器写值** ，将数据加载到 TxFIFO 存储器中。当数据加载至 TxFIFO 后， TxFIFO 的空标志变成无效的状态，直到最后一个数据从 TxFIFO 中移出，加载至传**输移位寄存器** ，TxFIFO 恢复空的标志位。同时 TxFIFO 使用 TFULL（满中断状态）用于表示当前 TxFIFO 已经写满，并且会阻止 数据继续写入。如果此时继续执行写操作，那么会触发溢出，数据不会加载到 TxFIFO 中。    RxFIFO 存储器接收来自接收移位寄存器的数据，当接收完数据后，RxFIFO 空标志信号同样变成无效 的状态，直到所有的数据通过 APB 总线发送出去。RxFIFO 的满标志状态用于表示 RxFIFO 已经写满，并且 会阻止更多的数据写入。    模式切换（**Mode Switch** ）控制 RxD 和 TxD 的信号连接方式，总共分为四种模式，分别为： **正常模式（Normal Mode）、自动回音模式（Automatic Echo Mode）、本地环回模式（Local Loopback Mode）和远程环回模式（Remote Loopback Mode）** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a18a6641a26bc471d59113f30b2dd803.png"></p><pre><code>    如果我们只是 用串口来**打印信息** 的话，那么可以直接使用**print()或者 xil_printf()** 函数就可以了，无需在程序中对串口做配置。但是如果我们需要使用 UART 来完成某些特定功能的话，如**串口接收中断** ，那么就要了解 UART 控制器**初始化、UART 中断初始化以及 UART 常用的 API 函数** 等相关内容了。</code></pre><h4 id="UART启动和配置"><a href="#UART启动和配置" class="headerlink" title="&lt;2&gt;UART启动和配置"></a>&lt;2&gt;UART启动和配置</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ddbf21ee27e9c33362e57354d5eca70.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a310074e7bd0be3b5e5e715bd69bcec.png"></p><h4 id="收发数据"><a href="#收发数据" class="headerlink" title="&lt;3&gt;收发数据"></a>&lt;3&gt;收发数据</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/12b95a7bcc6acd13e957f41db6c99ca3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/611810d31ceb34a9530dbcfd49af8288.png"></p><h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>DDR4 中存放和运行程序、UART 实现串口通信。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9d5d8180c6ece37e8e66b243cb97514.png"></p><pre><code>    本次实验嵌入式系统的搭建和Hello World 实验完全相同，工程名为 uart_intr_loop。 _MPSOC 开发板上的 USB UART 连接的引 脚是 MIO42 和 MIO43，因此在配置界面选择的是 UART0 MIO42..MIO43_ 。图中的 Modem signals 表示是否添加**串口的流控制功能，即调制解调器** ，如果选中的话，会额外增加一些引脚，一般不勾选。需要注意的 是，串口的流控制功能只能用于**EMIO 接口** ，MIO 接口不支持此功能。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/769bdbcd35d49412cc93d1e56acb5bd4.png"></p><pre><code>    接下来，直接导出硬件，然后新建 vitis 文件夹，将导出的 xsa 文件拷贝到里面，最后打开 Vitis 软件， 并将路径指向新建的 vitis 文件夹下。</code></pre><h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    Vitis 中创建了一个名为**uart_intr_loop 的应用工程** 。展开 design_1_wrapper，找到 **platform.spr** 并双击，右面的界面中出现 **design_1_wrapper 的标签页** ，然后找到**板级支持包** 并点击，可以看到**UART 文档和导入示例:**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4761e85c7ba0a68757090675cb7507de.png"></p><pre><code>    如果我们点击**Import Examples** ，会弹出下图所示的导入示例界面，关于**UART 有 5 个示例，** 其中 xuartps_intr_example 是串口中断的示例，可供参考。    新建main.c文件，代码如下：#include &quot;xparameters.h&quot;#include &quot;xuartps.h&quot;#include &quot;xil_printf.h&quot;#include &quot;xscugic.h&quot;#include &quot;stdio.h&quot;#define UART_DEVICE_ID     XPAR_XUARTPS_0_DEVICE_ID     //串口设备ID#define INTC_DEVICE_ID     XPAR_SCUGIC_SINGLE_DEVICE_ID //中断ID#define UART_INT_IRQ_ID    XPAR_XUARTPS_0_INTR          //串口中断IDXScuGic Intc;              //中断控制器驱动程序实例XUartPs Uart_Ps;           //串口驱动程序实例//UART初始化函数int uart_init(XUartPs* uart_ps)&#123;    int status;    XUartPs_Config *uart_cfg;    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);    if (NULL == uart_cfg)        return XST_FAILURE;    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);    if (status != XST_SUCCESS)        return XST_FAILURE;    //UART设备自检    status = XUartPs_SelfTest(uart_ps);    if (status != XST_SUCCESS)        return XST_FAILURE;    //设置工作模式:正常模式    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);    //设置波特率:115200    XUartPs_SetBaudRate(uart_ps,115200);    //设置RxFIFO的中断触发等级    XUartPs_SetFifoThreshold(uart_ps, 1);    return XST_SUCCESS;&#125;//UART中断处理函数void uart_intr_handler(void *call_back_ref)&#123;    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;    u32 rec_data = 0 ;    u32 isr_status ;                           //中断状态标志    //读取中断ID寄存器，判断触发的是哪种中断    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,                   XUARTPS_IMR_OFFSET);    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,                   XUARTPS_ISR_OFFSET);    //判断中断标志位RxFIFO是否触发    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;    rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);        //清除中断标志        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;    &#125;    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);&#125;//串口中断初始化int uart_intr_init(XScuGic *intc, XUartPs *uart_ps)&#123;    int status;    //初始化中断控制器    XScuGic_Config *intc_cfg;    intc_cfg = XScuGic_LookupConfig(INTC_DEVICE_ID);    if (NULL == intc_cfg)        return XST_FAILURE;    status = XScuGic_CfgInitialize(intc, intc_cfg,            intc_cfg-&gt;CpuBaseAddress);    if (status != XST_SUCCESS)        return XST_FAILURE;    //设置并打开中断异常处理功能    Xil_ExceptionInit();    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,            (Xil_ExceptionHandler)XScuGic_InterruptHandler,            (void *)intc);    Xil_ExceptionEnable();    //为中断设置中断处理函数    XScuGic_Connect(intc, UART_INT_IRQ_ID,            (Xil_ExceptionHandler) uart_intr_handler,(void *) uart_ps);    //设置UART的中断触发方式    XUartPs_SetInterruptMask(uart_ps, XUARTPS_IXR_RXOVR);    //使能GIC中的串口中断    XScuGic_Enable(intc, UART_INT_IRQ_ID);    return XST_SUCCESS;&#125;//main函数int main(void)&#123;    int status;    status = uart_init(&amp;Uart_Ps);    //串口初始化    if (status == XST_FAILURE) &#123;        xil_printf(&quot;Uart Initial Failed\r\n&quot;);        return XST_FAILURE;    &#125;    uart_intr_init(&amp;Intc, &amp;Uart_Ps); //串口中断初始化    while (1);    return status;&#125;</code></pre><h5 id="分析："><a href="#分析：" class="headerlink" title="*分析："></a>*分析：</h5><pre><code>    XScuGic 和 XUartPs 为程序中定义的两个结构体。如果在 Vitis 软件中， 按住 Ctrl 键不放，将鼠标移动到 XScuGic 或者 XUartPs 上，当鼠标变成手指状时，单击鼠标左键，会自动 跳转到定义这两个结构体的地方。其中 **XScuGic 包含了中断控制器相关的参数和数据** ，而 **XUartPs 则包含 了串口相关的参数和数据** 。    在代码的第 15 行至第 40 行完成了对 UART 的初始化。其中代码的第 28 行 **XUartPs_SelfTest** 函数实现 了 UART 设备自检的功能，即使用 UART**本地环回** 的模式，并验证数据是否可以正确发送和接收。 **XUartPs_SetOperMode** 函数设置**串口的工作模式** ，这里输入的参数 XUARTPS_OPER_MODE_NORMAL 为 正常的工作模式。**XUartPs_SetBaudRate** 函数用于设置串口的通信**波特率** ，这里设置的波特率为 115200，如 果需要修改成其它波特率，可直接在此修改输入的参数即可。**XUartPs_SetFifoThreshold** 函数用于设置 RxFIFO 的中断触发等级，即**触发** **RxFIFO 中断的数据个数** ，**这里设置的值为 1（字节）** ，即每收到一个值就触发中断。注意，中断触发等级最大值不超过 63。    在代码的第 65 行至第 94 行完成了串口中断的初始化。程序首先对**中断控制器进行初始化** ，随后设置 并打开**中断异常处理** 的功能。接下来为串口中断设置**中断处理函数** ，通过 **XScuGic_Connect** 函数进行设置，这里设置的串口中断处理函数为 **uart_intr_handler** 。**XUartPs_SetInterruptMask** 函数用于设置 UART 的**中断触发方式** ，函数输入的参数为 **XUARTPS_IXR_RXOVR** ，**表示达到 RxFIFO 的触发等级** 时，开始触发中断，当然也可以设置成 RxFIFO 为满时触发中断或者为空时触发中断等。最后，通过 **XScuGic_Enable** 函数来**使能 GIC** 中的串口中断。    在代码的第 42 行至第 63 行为 **UART 中断处理函数** ，由于 RxFIFO 的触发等级设置为 1，因此每次接收到数据都会进入此中断函数。程序中首先**读取中断 ID 寄存器** ，判断触发的是**哪种中断** ，再读取**中断的状态** 。 当判断中断标志位为 **RxFIFO 触发中断** 时，通过 **XUartPs_RecvByte** 函数来**读取接收到的数据** ，并**清除对应的中断标志位** 。最后通过 **XUartPs_SendByte** 函数**发送接收到的数据** ，实现串口环回的功能。</code></pre><p>注：首先程序会对 UART 串口进行初始化，我们知道，当使用一些打印函数的时候（如：xil_printf()），实际上调用的还是 UART 相关的 API<br>函数，如果在<strong>初始化的过程中， 使用打印函数，或者在打印的过程中对串口进行初始化，都会导致串口助手打印信息出错。</strong></p><h2 id="四-定时器中断实验"><a href="#四-定时器中断实验" class="headerlink" title="四.定时器中断实验"></a>四.定时器中断实验</h2><pre><code>    MPSOC 中 PS 部分包含许多不同类型的定时器，包括**全局定时器、TTC 定时器、系统看门狗定时器** 等。 定时器可以不受 CPU 的干预，自己独立运行，来完成计时、定时、中断以及计算来自 MIO 或 EMIO 引脚 的信号脉冲宽度等。本章我们将向大家介绍 **TTC**(**三路定时器**)以 TTC(三路定时器)**中断** 的使用方法。</code></pre><h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/136352300">https://blog.csdn.net/qq_32971095/article/details/136352300</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xilinx Vitis API常用部分解析</title>
      <link href="/2024/02/27/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/02/27/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>注：在源代码中 “ctrl+单击” 可查看详细信息  </p><h2 id="一-头文件"><a href="#一-头文件" class="headerlink" title="一.头文件"></a>一.头文件</h2><pre><code>#include &quot;xparameters.h&quot; //器件参数信息#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义#include &quot;xil_printf.h&quot; //包含 print()函数#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数#include &quot;sleep.h&quot; //包含 sleep()函数</code></pre><h2 id="二-宏定义"><a href="#二-宏定义" class="headerlink" title="二.宏定义"></a>二.宏定义</h2><pre><code>//PS_LED1 连接到 MIO38#define MIO_LED1 38 //宏定义 GPIO_DEVICE_ID#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID</code></pre><h2 id="三-函数"><a href="#三-函数" class="headerlink" title="三.函数"></a>三.函数</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h3><h4 id="器件初始化"><a href="#器件初始化" class="headerlink" title="&lt;1&gt;器件初始化"></a>&lt;1&gt;器件初始化</h4><pre><code>//PS 端 GPIO 驱动实例XGpioPs gpiops_inst; //PS 端 GPIO 配置信息XGpioPs_Config *gpiops_cfg_ptr; //根据器件 ID 查找配置信息gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);//初始化器件驱动Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);//判断是否初始化成功if (Status != XST_SUCCESS)return XST_FAILURE;XGpioPs_Config *XGpioPs_LookupConfig(u16 DeviceId);/**** This function looks for the device configuration based on the unique device* ID. The table XGpioPs_ConfigTable[] contains the configuration information* for each device in the system.** @paramDeviceId is the unique device ID of the device being looked up.** @returnA pointer to the configuration table entry corresponding to the*given device ID, or NULL if no match is found.** @noteNone.*******************************************************************************/s32 XGpioPs_CfgInitialize(XGpioPs *InstancePtr, const XGpioPs_Config *ConfigPtr,u32 EffectiveAddr);/*****************************************************************************//**** This function initializes a XGpioPs instance/driver.* All members of the XGpioPs instance structure are initialized and* StubHandlers are assigned to the Bank Status Handlers.** @paramInstancePtr is a pointer to the XGpioPs instance.* @paramConfigPtr points to the XGpioPs device configuration structure.* @paramEffectiveAddr is the device base address in the virtual memory*address space. If the address translation is not used then the*physical address should be passed.*Unexpected errors may occur if the address mapping is changed*after this function is invoked.** @returnXST_SUCCESS always.** @noteNone.*******************************************************************************/int XGpio_Initialize(XGpio *InstancePtr, u16 DeviceId);/****************************************************************************//*** Initialize the XGpio instance provided by the caller based on the* given DeviceID.** Nothing is done except to initialize the InstancePtr.** @paramInstancePtr is a pointer to an XGpio instance. The memory the*pointer references must be pre-allocated by the caller. Further*calls to manipulate the instance/driver through the XGpio API*must be made with this pointer.* @paramDeviceId is the unique id of the device controlled by this XGpio*instance. Passing in a device id associates the generic XGpio*instance to a specific device, as chosen by the caller or*application developer.** @return*- XST_SUCCESS if the initialization was successful.*- XST_DEVICE_NOT_FOUND  if the device configuration data was not*  found for a device with the supplied device ID.** @noteNone.******************************************************************************/</code></pre><h4 id="中断配置"><a href="#中断配置" class="headerlink" title="&lt;2&gt;中断配置"></a>&lt;2&gt;中断配置</h4><pre><code>//建立中断系统，使能KEY按键的下降沿中断//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针//  @param   GpioIntrId是Gpio中断ID//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILUREint setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)&#123;    int status;    XScuGic_Config *IntcConfig;     //中断控制器配置信息    //查找中断控制器配置信息并初始化中断控制器驱动    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);    if (NULL == IntcConfig) &#123;        return XST_FAILURE;    &#125;    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,            IntcConfig-&gt;CpuBaseAddress);    if (status != XST_SUCCESS) &#123;        return XST_FAILURE;    &#125;    //设置并使能中断异常    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);    Xil_ExceptionEnable();    //为中断设置中断处理函数    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,            (Xil_ExceptionHandler) intr_handler, (void *) gpio);    if (status != XST_SUCCESS) &#123;        return status;    &#125;    //使能来自于Gpio器件的中断    XScuGic_Enable(gic_ins_ptr, GpioIntrId);    //设置KEY按键的中断类型为下降沿中断，按ctrl+单击查看其他类型    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);    //使能按键KEY中断    XGpioPs_IntrEnablePin(gpio, KEY);    return XST_SUCCESS;&#125;//设置中断优先级和触发类型(高电平触发)XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);</code></pre><p> 中断处理函数：</p><pre><code>//中断处理函数//  @param   CallBackRef是指向上层回调引用的指针static void intr_handler(void *callback_ref)&#123;    XGpioPs *gpio = (XGpioPs *) callback_ref;    //读取KEY按键引脚的中断状态，判断是否发生中断    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;        key_press = TRUE;        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断        //XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断        //XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断    &#125;&#125;</code></pre><h4 id="uart配置"><a href="#uart配置" class="headerlink" title="&lt;3&gt;uart配置"></a>&lt;3&gt;uart配置</h4><pre><code>//UART初始化函数int uart_init(XUartPs* uart_ps)&#123;    int status;    XUartPs_Config *uart_cfg;    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);    if (NULL == uart_cfg)        return XST_FAILURE;    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);    if (status != XST_SUCCESS)        return XST_FAILURE;    //UART设备自检    status = XUartPs_SelfTest(uart_ps);    if (status != XST_SUCCESS)        return XST_FAILURE;    //设置工作模式:正常模式    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);    //设置波特率:115200    XUartPs_SetBaudRate(uart_ps,115200);    //设置RxFIFO的中断触发等级    XUartPs_SetFifoThreshold(uart_ps, 1);    return XST_SUCCESS;&#125;</code></pre><p>中断函数</p><pre><code>//UART中断处理函数void uart_intr_handler(void *call_back_ref)&#123;    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;    u32 rec_data = 0 ;    u32 isr_status ;                           //中断状态标志    //读取中断ID寄存器，判断触发的是哪种中断    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,                   XUARTPS_IMR_OFFSET);    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,                   XUARTPS_ISR_OFFSET);    //判断中断标志位RxFIFO是否触发    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;    rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);        //清除中断标志        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;    &#125;    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);&#125;</code></pre><h3 id="2-GPIO操作"><a href="#2-GPIO操作" class="headerlink" title="2.GPIO操作"></a>2.GPIO操作</h3><pre><code>//设置指定引脚的方向：0 输入，1 输出XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);//使能指定引脚输出：0 禁止输出使能，1 使能输出XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);//向指定引脚写入数据：0 或 1XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); //从指定引脚读入数据XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2)//配置PL AXI GPIOXGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断</code></pre><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><pre><code>    //uart打印    print(&quot;MIO Test! \n\r&quot;);        //延时 1 秒sleep(1); </code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/136315297">https://blog.csdn.net/qq_32971095/article/details/136315297</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科大三上数据库系统概论代码合集</title>
      <link href="/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/"/>
      <url>/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E8%AF%BE%E6%9C%AC%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90">一.课本课后作业解析</a></p><p><a href="about:blank#1.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E">1.问题说明</a></p><p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p><p><a href="about:blank#2.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E">2.问题说明</a></p><p><a href="about:blank#%C2%A0%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"> &lt;1&gt;代码解析</a></p><p><a href="about:blank#%C2%A03.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"> 3.问题说明</a></p><p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p><p><a href="about:blank#%C2%A04.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"> 4.问题说明</a></p><p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p><p><a href="about:blank#%E4%BA%8C.openGauss%E5%AE%9E%E8%B7%B5%E5%B9%B3%E5%8F%B0%E5%AE%9E%E9%AA%8C">二.openGauss实践平台实验</a></p><p><a href="about:blank#1.%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0">1.关系模型描述</a></p><p><a href="about:blank#%C2%A0%3C1%3E%E6%9E%84%E5%BB%BA%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><br>&lt;1&gt;构建关系模型</a></p><p><a href="about:blank#%3C2%3E%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%C2%A0">&lt;2&gt;插入测试数据</a></p><p><a href="about:blank#2.%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90">2.问题解析</a></p><p><a href="about:blank#%E4%B8%89.%E4%B8%8A%E6%9C%BA%E4%BD%9C%E4%B8%9A">三.上机作业</a></p><p><a href="about:blank#1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">1.需求分析</a></p><p><a href="about:blank#%3C1%3E%E5%86%85%E5%AE%B9">&lt;1&gt;内容</a></p><p><a href="about:blank#%3C2%3E%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82">&lt;2&gt;基本要求</a></p><p><a href="about:blank#2.%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">2.概念结构设计</a></p><p><a href="about:blank#%3C1%3E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E4%B9%89">&lt;1&gt;数据库语义</a></p><p><a href="about:blank#%3C2%3EE-R%E5%9B%BE%E8%AE%BE%E8%AE%A1">&lt;2&gt;E-R图设计</a></p><p><a href="about:blank#3.%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">3.逻辑结构设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">（1）关系模型</a></p><p><a href="about:blank#4.%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">4.功能实现</a></p><p><a href="about:blank#%3C1%3E%E5%BB%BA%E5%BA%93%E6%97%B6%E5%BA%94%E5%BD%95%E5%85%A5%E4%B8%80%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%EF%BC%88%E4%B8%8D%E8%83%BD%E8%BF%87%E5%B0%91%EF%BC%89%E5%AD%A6%E7%94%9F%E3%80%81%E6%95%99%E5%B8%88%E3%80%81%E8%AF%BE%E7%A8%8B%E3%80%81%E6%88%90%E7%BB%A9%E7%AD%89%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息</a></p><p><a href="about:blank#%3C2%3E%E5%BD%95%E5%85%A5%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%BA%94%E5%8C%85%E5%90%AB%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%E3%80%81%E6%80%A7%E5%88%AB%E3%80%81%E5%87%BA%E7%94%9F%E5%B9%B4%E6%9C%88%E3%80%81%E7%8F%AD%E7%BA%A7%E7%AD%89%E4%BF%A1%E6%81%AF">&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息</a></p><p><a href="about:blank#%3C3%3E%E6%8C%89%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%E3%80%81%E4%B8%93%E4%B8%9A%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息</a></p><p><a href="about:blank#%3C4%3E%E5%BD%95%E5%85%A5%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E4%B8%80%E9%97%A8%E8%AF%BE%E7%9A%84%E6%88%90%E7%BB%A9">&lt;4&gt;录入一位学生一门课的成绩</a></p><p><a href="about:blank#%3C5%3E%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E6%89%80%E4%BF%AE%E7%9A%84%E8%AF%BE%E7%A8%8B%E3%80%81%E6%80%A7%E8%B4%A8%EF%BC%88%E5%BF%85%E4%BF%AE%E6%88%96%E9%80%89%E4%BF%AE%EF%BC%89%E3%80%81%E5%AD%A6%E6%9C%9F%E3%80%81%E5%AD%A6%E5%88%86%E5%8F%8A%E6%88%90%E7%BB%A9">&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩</a></p><p><a href="about:blank#%3C6%3E%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E8%A2%AB%E5%93%AA%E4%BA%9B%E6%95%99%E5%B8%88%E6%95%99%E8%BF%87%E8%AF%BE">&lt;6&gt;查询一位学生被哪些教师教过课</a></p><p><a href="about:blank#%3C7%3E%E6%9F%A5%E8%AF%A2%E5%BF%AB%E8%A6%81%E8%A2%AB%E5%BC%80%E9%99%A4%E7%9A%84%E5%AD%A6%E7%94%9F%EF%BC%88%E8%B7%9D%E8%A2%AB%E5%BC%80%E9%99%A4%E5%B7%AE3%E5%AD%A6%E5%88%86%E4%B9%8B%E5%86%85%EF%BC%89">&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）</a></p><p><a href="about:blank#5.%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3">5.主要问题及解决</a></p><p><a href="about:blank#6.%E6%80%BB%E7%BB%93">6.总结</a></p><p><a href="about:blank#7.%E9%99%84%E5%BD%95">7.附录</a></p><p><a href="about:blank#%3C1%3ETXT%E8%BD%ACSQL%20C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC">&lt;1&gt;TXT转SQL<br>C语言程序脚本</a></p><hr><h2 id="一-课本课后作业解析"><a href="#一-课本课后作业解析" class="headerlink" title="一.课本课后作业解析"></a>一.课本课后作业解析</h2><h3 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1.问题说明"></a>1.问题说明</h3><pre><code>    用SQL语句建立第2章习题6中的4个表（要求给出主码和外码约束，但无需插入记录）：</code></pre><p>设有一个SPJ数据库，包括S，P，J及SPJ4个关系模式：</p><p>S(SNO, SNAME, STATUS, CITY);</p><p>P(PNO, PNAME, COLOR, WEIGHT);</p><p>J(JNO, JNAME, CITY);</p><p>SPJ(SNO, PNO, JNO, QTY)。</p><pre><code>    供应商表S由供应商代码（SNO）、供应商姓名（SNAME）、供应商状态（STATUS）、供应商所在城市（CITY）组成。    零件表P由零件代码（PNO）、零件名（PNAME）、颜色（COLOR）、重量（WEIGHT）组成。    工程项目表J由工程项目代码（JNO）、工程项目名（JNAME）、工程项目所在城市（CITY）组成。    供应情况表SPJ由供应商代码（SNO）、零件代码（PNO）、工程项目代码（JNO）、供应数量（QTY）组成，表示某供应商供应某种零件给某工程项目的数量为QTY。</code></pre><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*-- 删除已有的表*//*-- 注意要先删除参照表（如SC），再删除被参照表（如Student，Course）*/DROP TABLE SPJ;DROP TABLE S;DROP TABLE P;DROP TABLE J;/*创建基本表*//*注意要先创建被参照表，再创建参照表*/CREATE TABLE S(SNO CHAR(10) PRIMARY KEY,/*-- 列级完整性约束的方式，定义主码*/SNAME CHAR(20),STATUS INT,CITY CHAR(10)); CREATE TABLE P(PNO CHAR(10) PRIMARY KEY,PNAME CHAR(20),COLOR CHAR(10),WEIGHT CHAR(10));CREATE TABLE J(JNO CHAR(10) PRIMARY KEY,JNAME CHAR(20),CITY CHAR(10));CREATE TABLE SPJ(SNO CHAR(10),PNO CHAR(10),JNO CHAR(10),QTY INT,PRIMARY KEY (SNO,PNO,JNO),FOREIGN KEY (SNO) REFERENCES S(SNO),/*-- 表级完整性约束的方式，定义外码；注意参照列Cpno必须加括号*/FOREIGN KEY (PNO) REFERENCES P(PNO),FOREIGN KEY (JNO) REFERENCES J(JNO));</code></pre><p>插入测试数据：</p><pre><code>/*-- 向基本表中插入数据*/INSERT INTO S VALUES (&#39;S1&#39;,&#39;精益&#39;,20,&#39;天津&#39;);INSERT INTO S VALUES (&#39;S2&#39;,&#39;盛锡&#39;,10,&#39;北京&#39;);INSERT INTO S VALUES (&#39;S3&#39;,&#39;东方红&#39;,30,&#39;北京&#39;);INSERT INTO S VALUES (&#39;S4&#39;,&#39;丰泰盛&#39;,20,&#39;天津&#39;);INSERT INTO S VALUES (&#39;S5&#39;,&#39;为民&#39;,20,&#39;上海&#39;);/*-- 如果根据参照关系表中一行参照了另外一行，应先插入被参照行（如(&#39;6&#39;,...,...,...)），后插入参照行（如(...,...,&#39;6&#39;,...)）*/INSERT INTO P VALUES (&#39;P1&#39;,&#39;螺母&#39;,&#39;红&#39;,12);INSERT INTO P VALUES (&#39;P2&#39;,&#39;螺栓&#39;,&#39;绿&#39;,17);INSERT INTO P VALUES (&#39;P3&#39;,&#39;螺丝刀&#39;,&#39;蓝&#39;,14);INSERT INTO P VALUES (&#39;P4&#39;,&#39;螺丝刀&#39;,&#39;红&#39;,14);INSERT INTO P VALUES (&#39;P5&#39;,&#39;凸轮&#39;,&#39;蓝&#39;,40);INSERT INTO P VALUES (&#39;P6&#39;,&#39;齿轮&#39;,&#39;红&#39;,30);INSERT INTO J VALUES (&#39;J1&#39;,&#39;三建&#39;,&#39;北京&#39;);INSERT INTO J VALUES (&#39;J2&#39;,&#39;一汽&#39;,&#39;长春&#39;);INSERT INTO J VALUES (&#39;J3&#39;,&#39;弹簧厂&#39;,&#39;天津&#39;);INSERT INTO J VALUES (&#39;J4&#39;,&#39;造船厂&#39;,&#39;天津&#39;);INSERT INTO J VALUES (&#39;J5&#39;,&#39;机车厂&#39;,&#39;唐山&#39;);INSERT INTO J VALUES (&#39;J6&#39;,&#39;无线电厂&#39;,&#39;常州&#39;);INSERT INTO J VALUES (&#39;J7&#39;,&#39;半导体厂&#39;,&#39;南京&#39;);INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J1&#39;,200);INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J3&#39;,100);INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J4&#39;,700);INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P2&#39;,&#39;J2&#39;,100);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J1&#39;,400);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J2&#39;,200);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J4&#39;,500);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J5&#39;,400);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P5&#39;,&#39;J1&#39;,400);INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P5&#39;,&#39;J2&#39;,100);INSERT INTO SPJ VALUES (&#39;S3&#39;,&#39;P1&#39;,&#39;J1&#39;,200);INSERT INTO SPJ VALUES (&#39;S3&#39;,&#39;P3&#39;,&#39;J1&#39;,200);INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P5&#39;,&#39;J1&#39;,100);INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P6&#39;,&#39;J3&#39;,300);INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P6&#39;,&#39;J4&#39;,200);INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P2&#39;,&#39;J4&#39;,100);INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P3&#39;,&#39;J1&#39;,200);INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P6&#39;,&#39;J2&#39;,200);INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P6&#39;,&#39;J4&#39;,500);</code></pre><h3 id="2-问题说明"><a href="#2-问题说明" class="headerlink" title="2.问题说明"></a>2.问题说明</h3><p>针对建立的4个表用SQL完成第2章习题6中的查询：</p><p>（1）求供应工程J1零件的供应商号码SNO；</p><p>（2）求供应工程J1零件P1的供应商号码SNO;</p><p>（3）求供应工程J1零件为红色的供应商号码SNO；</p><p>（4）求没有使用天津供应商生产的红色零件的工程号JNO；</p><p>（5）求至少使用了供应商S1所供应的全部零件的工程号JNO。</p><h4 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*求供应工程J1零件的供应商号码SNO*/SELECT DISTINCT SNOFROM SPJWHERE JNO=&#39;J1&#39;;/*求供应工程J1零件P1的供应商号码SNO*/SELECT DISTINCT SNOFROM SPJWHERE JNO=&#39;J1&#39; AND PNO=&#39;P1&#39;;/*求供应工程J1零件为红色的供应商号码SNO*/SELECT DISTINCT SNOFROM SPJWHERE JNO=&#39;J1&#39; AND PNO IN(    SELECT DISTINCT PNO    FROM P    WHERE COLOR=&#39;红&#39;);/*求没有使用天津供应商生产的红色零件的工程号JNO*/SELECT DISTINCT JNOFROM SPJWHERE SNO NOT IN (    SELECT SNO    FROM S    WHERE CITY=&#39;天津&#39;    ) OR PNO NOT IN(        SELECT DISTINCT PNO        FROM P        WHERE COLOR=&#39;红&#39;);/*求至少使用了供应商S1所供应的全部零件的工程号JNO*//*方法一*/SELECT DISTINCT JNOFROM SPJWHERE SNO=&#39;S1&#39;GROUP BY JNO HAVING COUNT(PNO)=(SELECT COUNT(DISTINCT PNO) FROM SPJ WHERE SNO=&#39;S1&#39;);/*方法二*/SELECT DISTINCT JNOFROM SPJ XWHERE NOT EXISTS(    SELECT DISTINCT PNO    FROM SPJ Y    WHERE SNO=&#39;S1&#39; AND NOT EXISTS(        SELECT *        FROM SPJ Z        WHERE Z.SNO=&#39;S1&#39; AND Y.PNO=Z.PNO AND X.JNO=Z.JNO    ));</code></pre><h3 id="3-问题说明"><a href="#3-问题说明" class="headerlink" title="3.问题说明"></a>3.问题说明</h3><p>针对建立的4个表用SQL完成一下各项操作：</p><p>（1）找出所有供应商的姓名和所在城市；</p><p>（2）找出所有零件的名称、颜色、重量；</p><p>（3）找出使用供应商S1所供应零件的工程号码；</p><p>（4）找出工程项目J2使用的各种零件的名称及其数量；</p><p>（5）找出上海厂商供应的所有零件号码；</p><p>（6）找出使用上海产的零件的工程名称；</p><p>（7）找出没有使用天津产的零件的工程号码；</p><p>（8）把全部红色零件的颜色改成蓝色；</p><p>（9）由S5供给J4的零件P6改为由S3供应，请作出必要的修改；</p><p>（10）从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录；</p><p>（11）请将(S2,J6,P4,200)插入供应情况关系。</p><h4 id="代码解析-2"><a href="#代码解析-2" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*找出所有供应商的姓名和所在城市*/SELECT SNAME,CITYFROM S;/*找出所有零件的名称、颜色、重量*/SELECT PNAME,COLOR,WEIGHTFROM P;/*找出使用供应商S1所供应零件的工程号码*/SELECT DISTINCT JNOFROM SPJWHERE SNO=&#39;S1&#39;;/*找出工程项目J2使用的各种零件的名称及其数量*/SELECT PNAME,QTYFROM SPJ,PWHERE SPJ.PNO=P.PNO AND JNO=&#39;J2&#39;;/*找出上海厂商供应的所有零件号码*/SELECT DISTINCT PNOFROM SPJ,SWHERE SPJ.SNO=S.SNO AND CITY=&#39;上海&#39;;/*找出使用上海产的零件的工程名称*/SELECT DISTINCT JNOFROM SPJ,SWHERE SPJ.SNO=S.SNO AND CITY=&#39;上海&#39;;/*找出没有使用天津产的零件的工程号码*/SELECT DISTINCT JNOFROM SPJ,SWHERE SPJ.SNO=S.SNO AND CITY!=&#39;天津&#39;;/*把全部红色零件的颜色改成蓝色*/UPDATE PSET COLOR=&#39;蓝&#39;WHERE COLOR=&#39;红&#39;;/*由S5供给J4的零件P6改为由S3供应，请作出必要的修改*/UPDATE SPJSET SNO=&#39;S3&#39;WHERE SNO=&#39;S5&#39; AND PNO=&#39;P6&#39; AND JNO=&#39;J4&#39;;/*从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录*/ALTER TABLE SPJ ADD FOREIGN KEY (SNO) REFERENCES S(SNO) ON DELETE CASCADE;/*添加外键，设置级联删除*/DELETE FROM S WHERE SNO=&#39;S2&#39;;/*请将(S2,J6,P4,200)插入供应情况关系*/INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J1&#39;,200);</code></pre><h3 id="4-问题说明"><a href="#4-问题说明" class="headerlink" title="4.问题说明"></a>4.问题说明</h3><pre><code>    请为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）。针对该视图完成下列查询：</code></pre><p>（1）找出三建工程项目使用的各种零件代码及其数量；</p><p>（2）找出供应商S1的供应情况。</p><h4 id="代码解析-3"><a href="#代码解析-3" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）*/CREATE VIEW PROD(SNO,PNO,QTY)ASSELECT SNO,PNO,QTYFROM SPJWHERE JNO=&#39;J1&#39;/*找出三建工程项目使用的各种零件代码及其数量*/SELECT PNO,SUM(QTY)FROM PRODGROUP BY PNO;/*找出供应商S1的供应情况*/SELECT PNO,QTYFROM PRODWHERE SNO=&#39;S1&#39;;</code></pre><h2 id="二-openGauss实践平台实验"><a href="#二-openGauss实践平台实验" class="headerlink" title="二.openGauss实践平台实验"></a>二.openGauss实践平台实验</h2><h3 id="1-关系模型描述"><a href="#1-关系模型描述" class="headerlink" title="1.关系模型描述"></a>1.关系模型描述</h3><p>学籍管理数据库有如下关系模式：</p><p>学生Student（学号Sno，姓名Sname，性别Ssex，年龄Sage，系别Sdept）；</p><p>课程Course（课程号Cno，课程名称Cname，先修课Cpno，学分Ccredit）；</p><p>成绩SC（学号Sno，课程号Cno，成绩Grade）。</p><h4 id="构建关系模型"><a href="#构建关系模型" class="headerlink" title="&lt;1&gt;构建关系模型"></a>&lt;1&gt;构建关系模型</h4><pre><code>/*构建关系模型*/CREATE TABLE Student(    Sno CHAR(10) PRIMARY KEY,/*-- 列级完整性约束的方式，定义主码*/    Sname CHAR(20),    Ssex CHAR(10),    Sage INT,    Sdept CHAR(10));CREATE TABLE Course(    Cno CHAR(10) PRIMARY KEY,/*-- 列级完整性约束的方式，定义主码*/    Cname CHAR(20),    Cpno CHAR(10),    Ccredit INT);CREATE TABLE SC(    Sno CHAR(10),    Cno CHAR(10),    Grade INT,    PRIMARY KEY (Sno,Cno),    FOREIGN KEY (Sno) REFERENCES Student(Sno),/*-- 表级完整性约束的方式，定义外码；注意参照列Cpno必须加括号*/    FOREIGN KEY (Cno) REFERENCES Course(Cno));</code></pre><h4 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="&lt;2&gt;插入测试数据"></a>&lt;2&gt;插入测试数据</h4><pre><code>/*插入示例数据*/INSERT INTO Student VALUES (&#39;1&#39;,&#39;SWQ&#39;,&#39;男&#39;,20,&#39;CS&#39;);INSERT INTO Student VALUES (&#39;2&#39;,&#39;SSS&#39;,&#39;男&#39;,19,&#39;CS&#39;);INSERT INTO Student VALUES (&#39;3&#39;,&#39;WWW&#39;,&#39;男&#39;,17,&#39;CS&#39;);INSERT INTO Student VALUES (&#39;4&#39;,&#39;QQQ&#39;,&#39;男&#39;,17,&#39;IS&#39;);INSERT INTO Course VALUES (&#39;1&#39;,&#39;OS&#39;,&#39;2&#39;,4);INSERT INTO Course VALUES (&#39;2&#39;,&#39;MATH&#39;,&#39;3&#39;,5);INSERT INTO Course VALUES (&#39;3&#39;,&#39;ENG&#39;,&#39;3&#39;,2);INSERT INTO SC VALUES (&#39;1&#39;,&#39;1&#39;,94);INSERT INTO SC VALUES (&#39;2&#39;,&#39;1&#39;,85);INSERT INTO SC VALUES (&#39;3&#39;,&#39;1&#39;,72);INSERT INTO SC VALUES (&#39;4&#39;,&#39;1&#39;,94);INSERT INTO SC VALUES (&#39;1&#39;,&#39;2&#39;,69);INSERT INTO SC VALUES (&#39;2&#39;,&#39;2&#39;,99);INSERT INTO SC VALUES (&#39;3&#39;,&#39;2&#39;,77);INSERT INTO SC VALUES (&#39;4&#39;,&#39;2&#39;,58);INSERT INTO SC VALUES (&#39;1&#39;,&#39;3&#39;,100);INSERT INTO SC VALUES (&#39;2&#39;,&#39;3&#39;,78);INSERT INTO SC VALUES (&#39;3&#39;,&#39;3&#39;,87);INSERT INTO SC VALUES (&#39;4&#39;,&#39;3&#39;,67);</code></pre><h3 id="2-问题解析"><a href="#2-问题解析" class="headerlink" title="2.问题解析"></a>2.问题解析</h3><pre><code>/*查询年龄不大于19的“女”生的学号和姓名。*/SELECT Sno,SnameFROM StudentWHERE Sage&lt;20 AND Ssex=&#39;女&#39;;/*查询所有姓“王”的学生的学号、姓名和性别。*/SELECT Sno,Sname,SsexFROM StudentWHERE Sname LIKE &#39;王%&#39;;/*查询“CS”系年龄大于本系平均年龄的学生的学号、姓名和年龄。*/SELECT Sno,Sname,SageFROM Student XWHERE Sdept=&#39;CS&#39; AND Sage&gt;(    SELECT AVG(Sage)    FROM Student    GROUP BY Sdept    HAVING Sdept=&#39;CS&#39;)/*错误写法：SELECT Sno,Sname,SageFROM StudentWHERE Sdept=&#39;CS&#39;GROUP BY SdeptHAVING Sage&gt;AVG(Sage);*//*查询每门课程的课程号、课程名、平均成绩、最低成绩和最高成绩。*/SELECT DISTINCT Course.Cno,Cname,AVG(Grade),MIN(Grade),MAX(Grade)FROM Course,SCWHERE Course.Cno=SC.CnoGROUP BY Course.Cno;/*查询至少选修了学号为“200215121”的学生所选全部课程*/SELECT SnoFROM StudentWHERE NOT EXISTS(    SELECT Cno    FROM SC X    WHERE Sno=&#39;200215121&#39; AND NOT EXISTS(        SELECT *        FROM SC Y        WHERE Y.Sno=Student.Sno AND X.Cno=Y.Cno    ));/*查询每门课程分数排名第1的学生学号、课程号和成绩。*/SELECT Sno,Cno,GradeFROM SC XWHERE NOT EXISTS(    SELECT *    FROM SC Y    WHERE X.Cno=Y.Cno AND Y.Grade&gt;X.Grade);/*查询每门课程分数排名第2的学生学号、课程号和成绩。*/SELECT Sno,Cno,GradeFROM SC XWHERE EXISTS(    SELECT Cno    FROM SC Y    WHERE X.Cno=Y.Cno AND X.Grade&lt;Y.Grade    GROUP BY Y.Cno    HAVING COUNT(Y.Sno)=1);/*将一个新学生元组（学号：200215228；姓名：陈冬；性别*/INSERTINTO Student(Sno,Sname,Ssex,Sage,Sdept)VALUES(&#39;200215228&#39;,&#39;陈冬&#39;,&#39;男&#39;,18,&#39;IS&#39;);/*将所有学生的年龄增加1岁。*/UPDATE StudentSET Sage=Sage+1;/*删除学号为“200215122”的学生的选课记录。*/DELETEFROM SCWHERE Sno=&#39;200215122&#39;;/*创建视图View_IS，找出Sdept为IS的学生的学号*/CREATE VIEW View_IS(Sno,Sname)ASSELECT Sno,SnameFROM StudentWHERE Sdept=&#39;IS&#39;;</code></pre><h2 id="三-上机作业"><a href="#三-上机作业" class="headerlink" title="三.上机作业"></a>三.上机作业</h2><h3 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h3><h4 id="内容"><a href="#内容" class="headerlink" title="&lt;1&gt;内容"></a>&lt;1&gt;内容</h4><pre><code>    为某大学设计一套学籍管理数据库系统</code></pre><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="&lt;2&gt;基本要求"></a>&lt;2&gt;基本要求</h4><p>①设计学籍管理数据库，符合给定的语义（P3），并实现一定的功能需求（P4）<br>②使用一种DBMS，如SQL Server，具体不限</p><h3 id="2-概念结构设计"><a href="#2-概念结构设计" class="headerlink" title="2.概念结构设计"></a>2.概念结构设计</h3><h4 id="数据库语义"><a href="#数据库语义" class="headerlink" title="&lt;1&gt;数据库语义"></a>&lt;1&gt;数据库语义</h4><p>①学校有若干专业，每个专业每年招若干个班，每个班有若干学生<br>②每个专业有自己的教学计划，规定了该专业相关课程的性质（必修或选修）以及授课学期；例如，数据库课程对计算机专业为必修、在大三上学期，但对数学专业可能为选修、在大三下学期，而中文专业可能不学这门课<br>③一位教师可以给多个班带课，但不能给一个班带多门课<br>④一门课程最多允许学生一次补考；学生达到如下条件之一的被开除：不及格必修课累计达10学分、或不及格选修课累计达15学分<br>⑤上述语义未涉及到的事项和细节，可自行做出合理假定</p><h4 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="&lt;2&gt;E-R图设计"></a>&lt;2&gt;E-R图设计</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/912e583d76c9b2ec0803211714b62171.png"></p><h3 id="3-逻辑结构设计"><a href="#3-逻辑结构设计" class="headerlink" title="3.逻辑结构设计"></a>3.逻辑结构设计</h3><h4 id="（1）关系模型"><a href="#（1）关系模型" class="headerlink" title="（1）关系模型"></a>（1）关系模型</h4><pre><code>DROP TABLE Schedule;DROP TABLE SC;DROP TABLE Student;DROP TABLE Teather;DROP TABLE Course;DROP TABLE Class;DROP TABLE Department;</code></pre><p>专业信息表（专业代号和专业名）：</p><pre><code>CREATE TABLE Department(    Dept CHAR(10) PRIMARY KEY,    Dname CHAR(75));</code></pre><p>班级表（班级编号和从属专业）：</p><pre><code>CREATE TABLE Class(    Class_no CHAR(10) PRIMARY KEY,    Dept CHAR(10),    FOREIGN KEY (Dept) REFERENCES Department(Dept) ON DELETE CASCADE);</code></pre><p>学生表（学号、姓名、性别、出生年月、从属班级）：</p><pre><code>CREATE TABLE Student(    Sno CHAR(10) PRIMARY KEY,    Sname CHAR(20),    Ssex CHAR(4),    Sbrith CHAR(10),    Class_no CHAR(20),    FOREIGN KEY (Class_no) REFERENCES Class(Class_no) ON DELETE CASCADE);</code></pre><p>课程表（课程号、课程名、从属专业、必&#x2F;选修、开课时间、学分）：</p><pre><code>CREATE TABLE Course(    Cno CHAR(20) PRIMARY KEY,    Cname CHAR(75),    Dept CHAR(10),    Creq CHAR(10),    Cterm CHAR(20),    Ccredit INT,    FOREIGN KEY (Dept) REFERENCES Department(Dept) ON DELETE CASCADE);</code></pre><p>教师表（编号、姓名、所带课程）：</p><pre><code>CREATE TABLE Teacher(    Tno CHAR(10) PRIMARY KEY,    Tname CHAR(20),    Cno CHAR(10),    FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE);</code></pre><p>上课表（班级、老师、课程号）：</p><pre><code>CREATE TABLE Schedule(    Class_no CHAR(10),    Cno CHAR(10),    Tno CHAR(10),    PRIMARY KEY (Class_no,Cno),    FOREIGN KEY (Class_no) REFERENCES Class(Class_no) ON DELETE CASCADE,    FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE,    FOREIGN KEY (Tno) REFERENCES Teacher(Tno) ON DELETE CASCADE);</code></pre><p>成绩表（学号、课程号、成绩）：</p><pre><code>CREATE TABLE SC(    Sno CHAR(10),    Cno CHAR(10),    Score INT,    PRIMARY KEY (Sno,Cno),    FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE,     FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE);</code></pre><p>其中相关约束条件均实现，各个编号的主码约束及引用约束。  </p><h3 id="4-功能实现"><a href="#4-功能实现" class="headerlink" title="4.功能实现"></a>4.功能实现</h3><p>*说明：由于示例数据数量庞大且与自己设计的表格结构不同，如果要在示例数据中自行添加其他信息过于繁杂，于是将课程信息表Course和学生信息表Student拆分成两部分，基本信息和细节信息表_Detail。见下面示例。<br>本数据库的功能实现采用MySQL软件实现，安装过程参考：</p><p><a href="https://blog.csdn.net/m0_64338546/article/details/127149096?spm=1001.2014.3001.5506" title="【MySQL基础】MySQL介绍及安装">【MySQL基础】MySQL介绍及安装<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/m0_64338546&#x2F;article&#x2F;details&#x2F;127149096?spm&#x3D;1001.2014.3001.5506</a>完成后进入界面如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f4aa57e5edc0f357d8688c3877bb324.png"></p><p> 建表结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/226e6c620c54190be5bd6eabc8a25a30.png"></p><p>另外可使用table_status和desc命令查看表格详细数据：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cde497672b0b674364b7e6fbc2bc75ad.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb274a08847e8854f4719fcce5fb89a4.png"></p><h4 id="建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息"><a href="#建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息" class="headerlink" title="&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息"></a>&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息</h4><p>将示例数据文件通过C语言程序导出SQL插入信息语句，如下：</p><p>示例数据：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba24a79a9bde63b6f40780345bc96984.png"></p><p>导出的SQL插入语句：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c20b757c92574505beb2946017fb2a29.png"></p><p>插入结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd918f68acfc938d9057152b7a15b0b0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3057357a7d4e952deced2417493b28d.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c6794ab2d25179d8b29f1c4bd9f6533.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c80ab3a13c2d49e9a14e3314fdfc8d47.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3db46ba539941fed33d161dc47b0762.png"></p><h4 id="录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息"><a href="#录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息" class="headerlink" title="&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息"></a>&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息</h4><pre><code>/*录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息*/INSERT INTO Student (Sno, Sname, Ssex, Sbrith, Class_no) VALUES (&#39;03051108&#39;,&#39;司武强&#39;,&#39;男&#39;,&#39;20030411&#39;,&#39;2103014&#39;);</code></pre><p>实际拆分成两部分插入：</p><pre><code>/*录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息*/INSERT INTO Student (Sno, Sname, Ssex) VALUES (&#39;03051109&#39;,&#39;司武强&#39;,&#39;男&#39;);INSERT INTO Student_Detail (Sno, Sbrith, Class_no) VALUES (&#39;03051109&#39;,&#39;20030411&#39;,&#39;210101&#39;);</code></pre><h4 id="按学号、姓名、专业三种方式查询学生基本信息"><a href="#按学号、姓名、专业三种方式查询学生基本信息" class="headerlink" title="&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息"></a>&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息</h4><pre><code>/*按学号、姓名、专业三种方式查询学生基本信息*/SELECT *FROM StudentWHERE Sno=&#39;03051108&#39;;SELECT *FROM StudentWHERE Sname=&#39;司武强&#39;;SELECT *FROM Student,ClassWHERE Student.Class_no=Class.Class_no AND Dept=&#39;CS&#39;;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f0fd577e9a6cc2cb7c09c1023cc9d8bc.png"></p><h4 id="录入一位学生一门课的成绩"><a href="#录入一位学生一门课的成绩" class="headerlink" title="&lt;4&gt;录入一位学生一门课的成绩"></a>&lt;4&gt;录入一位学生一门课的成绩</h4><pre><code>/*录入一位学生一门课的成绩*/INSERT INTO SC (Sno,Cno,Score) VALUES (&#39;03051108&#39;,&#39;CS3121014&#39;,99);</code></pre><p>录入结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98e6d06dd16ce5436e2aac93f85ad6cd.png"></p><h4 id="查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩"><a href="#查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩" class="headerlink" title="&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩"></a>&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩</h4><pre><code>SELECT Student.Sno,Sname,Cname,Creq,Cterm,ScoreFROM Course,SC,StudentWHERE Course.Cno=SC.Cno AND SC.Sno=Student.Sno AND (Student.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;);</code></pre><p>查询他的必修课平均成绩：</p><pre><code>SELECT AVG(Score)FROM SCWHERE Sno=&#39;03051108&#39; AND EXISTS(    SELECT *    FROM Course    WHERE SC.Cno=Course.Cno AND Course.Creq=&#39;必修&#39;);/*或*/SELECT Student.Sno,Sname,AVG(Score)FROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.CnoGROUP BY Student.Sno,SC.Sno,Course.CreqHAVING Course.Creq=&#39;必修&#39; AND (SC.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;);</code></pre><p> 所有课程平均成绩（平均成绩应按学分加权）：</p><pre><code>SELECT Student.Sno,Sname,SUM(Score*Ccredit)/SUM(Ccredit)FROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.CnoGROUP BY Student.SnoHAVING Student.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;;</code></pre><p>注：由于课程信息庞大，查询时皆忽略条件“必修”</p><p>查询结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c061cd1cbc43256dba341cce842c1fef.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0524d3e8e4cea528fe7d439432b449db.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bfbea01fbea4ba90344d8e8a3b4a76a5.png"></p><h4 id="查询一位学生被哪些教师教过课"><a href="#查询一位学生被哪些教师教过课" class="headerlink" title="&lt;6&gt;查询一位学生被哪些教师教过课"></a>&lt;6&gt;查询一位学生被哪些教师教过课</h4><pre><code>/*查询一位学生被哪些教师教过课*/SELECT Tname,CnameFROM Student,Schedule,Teacher,CourseWHERE Student.Class_no=Schedule.Class_no AND Schedule.Tno=Teacher.Tno AND Schedule.Cno=Course.Cno AND (Student.Sno=&#39;03051108&#39; OR Student.Sname=&#39;司武强&#39;;</code></pre><h4 id="查询快要被开除的学生（距被开除差3学分之内）"><a href="#查询快要被开除的学生（距被开除差3学分之内）" class="headerlink" title="&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）"></a>&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）</h4><pre><code>/*查询快要被开除的学生（距被开除差3学分之内）*/SELECT Sno,SnameFROM StudentWHERE 10&lt;=(    SELECT SUM(Ccredit)    FROM SC,Course    WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Creq=&#39;必修&#39; AND Score&lt;60) OR 15&lt;=(    SELECT SUM(Ccredit)    FROM SC,Course    WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Creq=&#39;选修&#39; AND Score&lt;60);</code></pre><p>查询结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/766ca586e00ab2d430092a38e54e9465.png"></p><h3 id="5-主要问题及解决"><a href="#5-主要问题及解决" class="headerlink" title="5.主要问题及解决"></a>5.主要问题及解决</h3><p>&lt;1&gt;问题：插入数据工作量庞大且繁琐，示例数据与期望表结构不同</p><pre><code>    解决：于是将课程信息表Course和学生信息表Student拆分成两部分，基本信息和细节信息表_Detail。将示例数据文件通过C语言程序导出SQL插入信息语句。    改进：利用const char数组定义某个属性的可能取值，利用random函数插入细节数据</code></pre><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><pre><code>    数据库的查询速度极快，基本在0.01s左右。但唯一的不足之处在于插入数据不便，需要用INSERT语句且符合表的结构。采用图形界面将优化这一不足。</code></pre><h3 id="7-附录"><a href="#7-附录" class="headerlink" title="7.附录"></a>7.附录</h3><h4 id="TXT转SQL-C语言程序脚本"><a href="#TXT转SQL-C语言程序脚本" class="headerlink" title="&lt;1&gt;TXT转SQL C语言程序脚本"></a>&lt;1&gt;TXT转SQL C语言程序脚本</h4><p>主程序（INSERT_SQL.c）：</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&quot;school_sql.h&quot;int main()&#123;INSERT_(&quot;Department&quot;,&quot;Department.txt&quot;, &quot;INSERT_Department.sql&quot;);INSERT_(&quot;Class&quot;,&quot;Class.txt&quot;, &quot;INSERT_Class.sql&quot;);INSERT_Course(&quot;Course&quot;, &quot;Course.txt&quot;, &quot;INSERT_Course.sql&quot;);INSERT_(&quot;Student&quot;,&quot;Student.txt&quot;, &quot;INSERT_Student.sql&quot;);INSERT_(&quot;SC&quot;,&quot;SC.txt&quot;, &quot;INSERT_SC.sql&quot;);return 0;&#125;</code></pre><p>头文件（school.h）:</p><pre><code>#ifndef SCHOOL_SQL_H#define SCHOOL_SQL_H#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const char Dept[5]=&#123;&quot;CS&quot;, &quot;IS&quot;, &quot;AI&quot;, &quot;ES&quot;, &quot;CE&quot;&#125;;const char Class_no[10]=&#123;&quot;_210101&quot;, &quot;_210102&quot;, &quot;_210103&quot;, &quot;_210204&quot;，&quot;_210305&quot;，&quot;_210406&quot;，&quot;_210407&quot;，&quot;_210508&quot;，&quot;_210509&quot;，&quot;_210510&quot;&#125;;const char Creq=&#123;    &quot;选修&quot;，&quot;必修&quot;&#125;;//函数功能：读取文本数据生成插入SQL语句 void INSERT_(char [], char [], char []);#endif</code></pre><p>插入函数（school.c）:</p><pre><code>#include&quot;school_sql.h&quot;/*@function：将文件中的数据导出成SQL插入语句@parameter：插入表的名字，数据来源文件名src，导出文件名dst@account：默认导出形式字符CHAR*/void INSERT_(char table[], char src[], char dst[])&#123;FILE* fr, * fw;char c;if ((fr = fopen(src, &quot;r&quot;)) == NULL) &#123;printf(&quot;%s File not exist\n&quot;, src);exit(0);&#125;fw = fopen(dst, &quot;w&quot;);fprintf(fw, &quot;\nINSERT INTO %s VALUES\n(&#39;&quot;,table);while (!feof(fr)) &#123;c = fgetc(fr);printf(&quot;%c&quot;, c);if (c == &#39;\n&#39;)fprintf(fw, &quot;&#39;),\n(&#39;&quot;);else if (c == &#39;,&#39;)fprintf(fw, &quot;&#39;,&#39;&quot;);else fprintf(fw, &quot;%c&quot;, c);&#125;//需手动检查结果是否正确 fprintf(fw, &quot;&#39;);&quot;);&#125;/*@function：将文件中的数据导出成SQL插入语句（定制）@parameter：插入表的名字，数据来源文件名src，导出文件名dst@account：第三个数据形式为INT（插入SQL语句第三个数据无&#39;&#39;）*/void INSERT_Course(char table[], char src[], char dst[])&#123;FILE* fr, * fw;char c;int i = 0, cnt = 0;if ((fr = fopen(src, &quot;r&quot;)) == NULL) &#123;printf(&quot;%s File not exist\n&quot;, src);exit(0);&#125;fw = fopen(dst, &quot;w&quot;);fprintf(fw, &quot;\nINSERT INTO %s VALUES\n(&#39;&quot;, table);while (!feof(fr)) &#123;c = fgetc(fr);printf(&quot;%c&quot;, c);if (c == &#39;\n&#39;) &#123;cnt = 0;fprintf(fw, &quot;),\n(&#39;&quot;);&#125;else if (c == &#39;,&#39;) &#123;cnt++;if (cnt == 2)fprintf(fw, &quot;&#39;,&quot;);else fprintf(fw, &quot;&#39;,&#39;&quot;);&#125;else fprintf(fw, &quot;%c&quot;, c);&#125;//需手动检查结果是否正确 fprintf(fw, &quot;);&quot;);&#125;</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/134984670">https://blog.csdn.net/qq_32971095/article/details/134984670</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字滤波器设计——Matlab实现数字信号处理＜1＞</title>
      <link href="/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/"/>
      <url>/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9">一.实验内容</a></p><p><a href="about:blank#%E4%BA%8C.%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">二.代码分析</a></p><p><a href="about:blank#1.%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E9%83%A8%E5%88%86">1.信号产生部分</a></p><p><a href="about:blank#2.%E5%88%A9%E7%94%A8%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%87%AA%E7%94%B1%E7%94%9F%E6%88%90%E6%89%80%E9%9C%80%E7%9A%84x%28t%29">2.利用傅立叶级数展开的方法，自由生成所需的x(t)</a></p><p><a href="about:blank#3.%E9%80%9A%E8%BF%87%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E9%87%87%E6%A0%B7%E9%97%B4%E9%9A%94T%EF%BC%88%E5%88%86%E5%88%AB%E9%80%89T%3E%E6%88%96%3C1%2F2fc%EF%BC%89%EF%BC%8C%E4%BB%8Ex%28t%29%E8%8E%B7%E5%BE%97%E7%9B%B8%E5%BA%94%E7%9A%84x%28n%29">3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)</a></p><p><a href="about:blank#3.%E5%AF%B9%E8%8E%B7%E5%BE%97%E7%9A%84%E4%B8%8D%E5%90%8Cx%28n%29%E5%88%86%E5%88%AB%E4%BD%9C%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%8C%E5%88%86%E6%9E%90%E5%85%B6%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7%EF%BC%88%E7%BB%99%E5%87%BA%E5%B9%85%E9%A2%91%E4%B8%8E%E7%9B%B8%E9%A2%91%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%EF%BC%89">3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）</a></p><p><a href="about:blank#4.%E5%88%A9%E7%94%A8%E5%B7%B4%E7%89%B9%E6%B2%83%E6%80%9D%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8">4.利用巴特沃思滤波器设计数字滤波器</a></p><p><a href="about:blank#%3C1%3E%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;1&gt;低通滤波器</a></p><p><a href="about:blank#%3C2%3E%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;2&gt;高通滤波器</a></p><p><a href="about:blank#%3C3%3E%E7%BB%98%E5%9B%BE">&lt;3&gt;绘图</a></p><p><a href="about:blank#5.%E5%88%A9%E7%94%A8%E7%AA%97%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E6%B3%95%E6%88%96%E9%A2%91%E7%8E%87%E9%87%87%E6%A0%B7%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8">5.利用窗函数设计法或频率采样法设计数字滤波器</a></p><p><a href="about:blank#%3C1%3E%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;1&gt;高通滤波器</a></p><p><a href="about:blank#%3C2%3E%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;2&gt;低通滤波器</a></p><p><a href="about:blank#%3C3%3E%E7%BB%98%E5%9B%BE">&lt;3&gt;绘图</a></p><p><a href="about:blank#%E4%B8%89.%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">三.实验结果</a></p><hr><h2 id="一-实验内容"><a href="#一-实验内容" class="headerlink" title="一.实验内容"></a>一.实验内容</h2><p>1．利用傅立叶级数展开的方法，自由生成所需的x(t)；</p><p>2．通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)（作出x(n)图形）；</p><p>3．对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）；</p><p>4．利用巴特沃思、切比雪夫或椭圆滤波器设计数字滤波器（滤波特性自定），要求通过改变滤波器参数或特性（低通、高通、带通或带阻）设计至少两种数字滤波器，分析所设计滤波器（画出频率特性曲线），并对上述给出的不同x(n)分别进行滤波（画出滤波结果），然后加以讨论；</p><p>5．利用窗函数设计法或频率采样法设计数字滤波器（滤波特性自定），要求通过改变滤波器参数或特性（低通、高通、带通或带阻等）设计至少两种数字滤波器，分析所设计滤波器（画出频率特性曲线），并对上述给出的不同x(n)分别进行滤波（画出滤波结果），然后加以讨论。</p><h2 id="二-代码分析"><a href="#二-代码分析" class="headerlink" title="二.代码分析"></a>二.代码分析</h2><h5 id="1-信号产生部分"><a href="#1-信号产生部分" class="headerlink" title="1.信号产生部分"></a>1.信号产生部分</h5><pre><code>function [signal]=signal_xt(t_length,T,f,A,u)%%  函数描述%   功能：利用傅立叶级数展开的方法，自由生成所需的x(t)（不含直流量）；%   输入参数：产生序列的长度t_length；采样间隔T；f(t)的基波频率f；傅立叶级数展开的各项幅值和相位。故最高频率为fc=length(A)*f%   使用举例：signal=signal_xt(3,0.01,1,[1,2,3,4],[0,1,0,1])%%  t,y初始化并计算t=0:T:t_length-T;t_num=t_length/T;signal=zeros(1,t_num);max=0;min=0;for i=1:t_num      for k=1:length(A)        %   计算函数值        signal(i)= signal(i) + A(k)*cos(2*pi*k*t(i)*f+u(k));        %   最大最小值记录        if max&lt;signal(i)            max=signal(i);        end        if min&gt;signal(i)            min=signal(i);        end    endend%%  结果展示figure;subplot(2,1,1);plot(t,signal);%   x，y轴范围限制及标题axis([0-0.1,t_length+0.1,min-0.5,max+0.5])title(&#39;x(t)&#39;); xlabel(&#39;t&#39;);ylabel(&#39;x(t)&#39;); grid onsubplot(2,1,2);stem(t,signal,&quot;.&quot;);%   x，y轴范围限制及标题axis([0-0.1,t_length+0.1,min-0.5,max+0.5])title(&#39;x(t)&#39;); xlabel(&#39;t&#39;);ylabel(&#39;x(t)&#39;); grid on</code></pre><p>function [signal]&#x3D;signal_xt(t_length,T,f,A,u)<br>%%  函数描述<br>%   功能：利用傅立叶级数展开的方法，自由生成所需的x(t)（不含直流量）；<br>%   输入参数：产生序列的长度t_length；采样间隔T；f(t)的基波频率f；傅立叶级数展开的各项幅值和相位。故最高频率为fc&#x3D;length(A)*f<br>%   使用举例：signal&#x3D;signal_xt(3,0.01,1,[1,2,3,4],[0,1,0,1])</p><h5 id="2-利用傅立叶级数展开的方法，自由生成所需的x-t"><a href="#2-利用傅立叶级数展开的方法，自由生成所需的x-t" class="headerlink" title="2.利用傅立叶级数展开的方法，自由生成所需的x(t)"></a>2.利用傅立叶级数展开的方法，自由生成所需的x(t)</h5><pre><code>%%  利用傅立叶级数展开的方法，自由生成所需的x(t)，即signal_origin；t_length=1;     %生成长度f=1;            %基础频率A=[3,1,1,3];    %各项幅度u=[-1,0,1,0];   %各项相位signal_origin=signal_xt(t_length,0.01,f,A,u);fc=f*length(A);</code></pre><h5 id="3-通过选择不同的采样间隔T（分别选T-或"><a href="#3-通过选择不同的采样间隔T（分别选T-或" class="headerlink" title="3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)"></a>3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)</h5><pre><code>%%  通过选择不同的采样间隔T（分别选T&gt;或&lt;1/2fc），从x(t)获得相应的x(n)；T=[1/(2*fc+1),1/fc,1/(4*fc)];N=zeros(1,length(T));for i=1:length(T)    N(i)=1/T(i);endx1=signal_xt(t_length,T(1),f,A,u);x2=signal_xt(t_length,T(2),f,A,u);x3=signal_xt(t_length,T(3),f,A,u);</code></pre><p>选取频率分别为2fc+1、fc、4fc</p><h5 id="3-对获得的不同x-n-分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）"><a href="#3-对获得的不同x-n-分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）" class="headerlink" title="3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）"></a>3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）</h5><pre><code>%%  对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）；X1=fft(x1,N(1));X2=fft(x2,N(2));X3=fft(x3,N(3));%   绘制figure;%   幅值绘制subplot(2,3,1);stem(0:N(1)-1,abs(X1),&#39;.&#39;);title(&quot;X1&quot;);grid onsubplot(2,3,2);stem(0:N(2)-1,abs(X2),&#39;.&#39;);title(&quot;X2&quot;);grid onsubplot(2,3,3);stem(0:N(3)-1,abs(X3),&#39;.&#39;);title(&quot;X3&quot;);grid on%   相位绘制subplot(2,3,4);stem(0:N(1)-1,angle(X1),&#39;.&#39;);title(&quot;X1&quot;);grid onsubplot(2,3,5);stem(0:N(2)-1,angle(X2),&#39;.&#39;);title(&quot;X2&quot;);grid onsubplot(2,3,6);stem(0:N(3)-1,angle(X3),&#39;.&#39;);title(&quot;X3&quot;);grid on</code></pre><p>使用 fft 函数进行 DFT，注意结果频率响应是复数，使用abs函数得其幅值，angle函数得其相位。</p><h5 id="4-利用巴特沃思滤波器设计数字滤波器"><a href="#4-利用巴特沃思滤波器设计数字滤波器" class="headerlink" title="4.利用巴特沃思滤波器设计数字滤波器"></a>4.利用巴特沃思滤波器设计数字滤波器</h5><h6 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="&lt;1&gt;低通滤波器"></a>&lt;1&gt;低通滤波器</h6><pre><code>%   设置低通滤波器参数wp=0.35;    %通带边界频率ws=0.7;     %阻带截止频率Rp=3;As=15;%   计算滤波器阶数N和3dB截止频率wc[Nc,wc]=buttord(wp,ws,Rp,As,&#39;s&#39;);%   计算滤波器系统函数分子分母多项式系数[Bz,Az]=butter(Nc,wc,&#39;low&#39;);wk=64;Hk=freqz(Bz,Az,wk);</code></pre><p>参数设置及函数使用参考课本《数字信号处理》</p><h6 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="&lt;2&gt;高通滤波器"></a>&lt;2&gt;高通滤波器</h6><pre><code>%   设置高通滤波器参数wp=0.75;ws=0.5;rp=3;rs=15;[Nc,wc]=buttord(wp,ws,rp,rs,&#39;s&#39;);[Bz,Az]=butter(Nc,wc,&#39;high&#39;);wk=64; Hk=freqz(Bz,Az,wk);</code></pre><h6 id="绘图"><a href="#绘图" class="headerlink" title="&lt;3&gt;绘图"></a>&lt;3&gt;绘图</h6><pre><code>%   绘图figure;subplot(2,3,1);stem(0:1/63:1,abs(Hk),&#39;.&#39;);xlabel(&#39;频率&#39;);ylabel(&#39;滤波器幅度/dB&#39;);grid on%   滤波后结果m1=filter(Bz,Az,x1);m2=filter(Bz,Az,x2);m3=filter(Bz,Az,x3);Y1=fft(m1,N(1));Y2=fft(m2,N(2));Y3=fft(m3,N(3));%   绘图subplot(2,3,4);stem(0:N(1)-1,abs(Y1),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid onsubplot(2,3,5);stem(0:N(2)-1,abs(Y2),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid onsubplot(2,3,6);stem(0:N(3)-1,abs(Y3),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid on</code></pre><h5 id="5-利用窗函数设计法或频率采样法设计数字滤波器"><a href="#5-利用窗函数设计法或频率采样法设计数字滤波器" class="headerlink" title="5.利用窗函数设计法或频率采样法设计数字滤波器"></a>5.利用窗函数设计法或频率采样法设计数字滤波器</h5><h6 id="高通滤波器-1"><a href="#高通滤波器-1" class="headerlink" title="&lt;1&gt;高通滤波器"></a>&lt;1&gt;高通滤波器</h6><pre><code>%   设置高通滤波器参数wp=pi/2;ws=pi/4;Bt=wp-ws;   %过渡带宽度N0=ceil(6.2*pi/Bt); %汉宁窗计算所需h(n)长度N0Nn=N0+mod(N0+1,2);  %确保h(n)长度为奇数wc=(wp+ws)/2/pi;    %理想高通滤波器通带截止频率hn=fir1(Nn-1,wc,&#39;HIGH&#39;,hanning(Nn));%   高通滤波器频率响应Hk=fft(hn,length(hn));</code></pre><h6 id="低通滤波器-1"><a href="#低通滤波器-1" class="headerlink" title="&lt;2&gt;低通滤波器"></a>&lt;2&gt;低通滤波器</h6><pre><code>%   设置低通滤波器参数wp=pi/4;ws=pi/2;Bt=abs(wp-ws);   %过渡带宽度N0=ceil(6.2*pi/Bt); %汉宁窗计算所需h(n)长度N0Nn=N0+mod(N0+1,2);  %确保h(n)长度为奇数wc=(wp+ws)/2/pi;    %理想高通滤波器通带截止频率hn=fir1(Nn-1,wc,&#39;LOW&#39;,hanning(Nn));%   低通滤波器频率响应Hk=fft(hn,length(hn));</code></pre><h6 id="绘图-1"><a href="#绘图-1" class="headerlink" title="&lt;3&gt;绘图"></a>&lt;3&gt;绘图</h6><pre><code>%   滤波结果y1=conv(hn,x1);y2=conv(hn,x2);y3=conv(hn,x3);n1=length(y1);n2=length(y2);n3=length(y3);Y1=fft(y1,n1);Y2=fft(y2,n2);Y3=fft(y3,n3);%   绘图figure;subplot(2,3,1);stem(0:Nn-1,hn,&#39;.&#39;);xlabel(&#39;n&#39;);ylabel(&#39;h(n)&#39;);grid onsubplot(2,3,2);stem(0:Nn-1,abs(Hk),&#39;.&#39;);xlabel(&#39;k&#39;);ylabel(&#39;H(k)&#39;);grid onsubplot(2,3,4);stem(0:n1-1,abs(Y1),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid onsubplot(2,3,5);stem(0:n2-1,abs(Y2),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid onsubplot(2,3,6);stem(0:n3-1,abs(Y3),&#39;.&#39;);title(&#39;滤波后Y频率特性&#39;);grid on</code></pre><h2 id="三-实验结果"><a href="#三-实验结果" class="headerlink" title="三.实验结果"></a>三.实验结果</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e404226ec441727c6370000e1fe978b0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d098f58a0b1f335d62fc631ac9bf1b8.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aaf3e4f6a8465e5e2a158ebfd1c1b9cf.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3fc4cd9d29dc56cd60409b4c12728d90.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c551894f0d504e9663311db49f1e796b.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d1539ef72b30697b76fb425b6b10928a.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/134966834">https://blog.csdn.net/qq_32971095/article/details/134966834</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> matlab </tag>
            
            <tag> 信号处理 </tag>
            
            <tag> 上机实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年FPGA创新大赛记录</title>
      <link href="/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">一.基本信息</a></p><p><a href="about:blank#%E4%BA%8C.%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95">二.设计记录</a></p><p><a href="about:blank#1.%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3">1.任务分解</a></p><p><a href="about:blank#2.%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">2.模块设计</a></p><p><a href="about:blank#%E4%B8%89.%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">三.设计实践</a></p><p><a href="about:blank#1.adc_stm32%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E6%A8%A1%E5%9D%97">1.adc_stm32<br>信号采集模块</a></p><p><a href="about:blank#2.proc_fpga%20FPGA%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97">2.proc_fpga<br>FPGA主体模块</a></p><p><a href="about:blank#%3C1%3Euart%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94uart_rx">&lt;1&gt;uart协议数据接收模块——uart_rx</a></p><p><a href="about:blank#%3C2%3E%E4%B8%B2%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94decoder">&lt;2&gt;串行数据解码模块——decoder</a></p><p><a href="about:blank#%3C3%3E%20%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">&lt;3&gt; 顶层模块</a></p><p><a href="about:blank#3.signal_proc%20%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97">3.signal_proc<br>信号处理模块</a></p><p><a href="about:blank#%E5%9B%9B.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A">四.注意事项</a></p><hr><h2 id="一-基本信息"><a href="#一-基本信息" class="headerlink" title="一.基本信息"></a>一.基本信息</h2><p>参赛厂商：AMD</p><p>参赛平台：基于AMD的FPGA&#x2F;Zynq&#x2F;Versal器件（无资源限制）</p><p>开发方向：基于AMD板卡的综合类赛道</p><p>开发平台：正点原子 DFZU2EG MPSoc 开发板</p><p>平台资源：</p><table><thead><tr><th>Application Processing Unit</th><th>Quad-core Arm® Cortex®-A53 MPCore™ up to 1.5GHz</th></tr></thead><tbody><tr><td>Real-Time Processing Unit</td><td>Dual-core Arm Cortex-R5F MPCore™ up to 600MHz</td></tr><tr><td>Graphics Processing Unit</td><td>Arm Mali™-400 MP2 up to 667MHz</td></tr><tr><td>Dynamic Memory Interface</td><td>DDR4, LPDDR4, DDR3, DDR3L, LPDDR3</td></tr><tr><td>High-Speed Peripherals</td><td>PCIe® Gen2, USB3.0, SATA 3.1, DisplayPort, Gigabit</td></tr><tr><td>Ethernet</td><td></td></tr></tbody></table><p>103k System Logic Cells，6.5MB Total RAM，240 DSP Slices，252 Maximum I&#x2F;O Pins</p><p>作品名称：基于FPGA的图神经网络传感器系统</p><p>作品简介：</p><pre><code>    对传感器系统进行建模，生成图模型并利用图神经网络对传感器系统运行状态进行评估。作品首先采集大量传感器数据，并根据事先对传感器群建模成图的模型，将传感器输出信号进行分析，主要分析图网络频域特性，进行初步判断然后用深度学习训练数据集，分析系统的状态。应用场景比如复杂环境因素影响下的农作物种植情况分析，工厂机械臂分析运行出错过热，太空站或基地的外壳完整性检测等。   </code></pre><h2 id="二-设计记录"><a href="#二-设计记录" class="headerlink" title="二.设计记录"></a>二.设计记录</h2><h3 id="1-任务分解"><a href="#1-任务分解" class="headerlink" title="1.任务分解"></a>1.任务分解</h3><pre><code>    信号采集接口（多路信号采集、多种信号类型接口：通信协议接口、电压接口），数据打包模块，上层数据处理，结果显示模块。</code></pre><h3 id="2-模块设计"><a href="#2-模块设计" class="headerlink" title="2.模块设计"></a>2.模块设计</h3><p>&lt;1&gt;ADC模块</p><p>输入：多路电压采集</p><p>输出：采用通信协议进行串行&#x2F;时分复用并行输出</p><p>实现：利用stm32的ADC通道采集多路传感器信息，利用usart发送数据。</p><p>&lt;2&gt;数据接收模块</p><p>输入：下位机（stm32）usart串行输入数据</p><p>输出：每字节数据及数据有效位</p><p>实现：Verillog编写usart解码模块</p><p>&lt;3&gt;数据解包模块</p><p>输入：数据接收模块输出的每字节数据及数据有效位</p><p>输出：10个传感器并行的120位数据</p><p>实现：解析数据流识别数据包头（“FF”）和有效数据</p><p>&lt;4&gt;数据处理模块</p><p>输入：10个传感器并行的120位数据</p><p>输出：10bit的10个传感器异常与否判断</p><p>实现：利用HLS综合C语言算法实现输入到输出的转换函数（IP 核）</p><h2 id="三-设计实践"><a href="#三-设计实践" class="headerlink" title="三.设计实践"></a>三.设计实践</h2><h3 id="1-adc-stm32-信号采集模块"><a href="#1-adc-stm32-信号采集模块" class="headerlink" title="1.adc_stm32 信号采集模块"></a>1.adc_stm32 信号采集模块</h3><pre><code>    利用 stm32 最小系统板上 ADC1 的 10 个通道资源，利用 DMA1 数据转运，通过1路 usart 串行发送出去。</code></pre><p> stm32关键代码：</p><p>（1）初始化stm32的多个ADC外设并启用DMA转运</p><pre><code>void AD_Init(void)&#123;RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);RCC_ADCCLKConfig(RCC_PCLK2_Div6);//72M/6=12,ADC最大时间不能超过14MGPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;//设置模拟输入模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOA, &amp;GPIO_InitStructure);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;//GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//ADC1,ADC通道x,规则采样顺序值为y,采样时间为55.5周期ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 5, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 6, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 7, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 8, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 9, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 10, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 11, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 12, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 13, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 14, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 15, ADC_SampleTime_55Cycles5);//ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 16, ADC_SampleTime_55Cycles5);ADC_InitTypeDef ADC_InitStructure;ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;//ADC工作在独立模式ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//外部触发转换关闭ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//模数转换工作在连续转换模式ADC_InitStructure.ADC_ScanConvMode = ENABLE;//是否使用扫描模式ADC_InitStructure.ADC_NbrOfChannel = CHANNEL_NUM;//顺序进行规则转换的ADC通道的数目ADC_Init(ADC1, &amp;ADC_InitStructure);//DMA初始化DMA_InitTypeDef DMA_InitStructure;DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&amp;ADC1-&gt;DR;//DMA外设ADC基地址DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//数据宽度为16位DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址寄存器不变DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value;//DMA外设ADC基地址DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//数据宽度为16位DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//内存地址寄存器递增DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;//内存作为数据传输的目的地DMA_InitStructure.DMA_BufferSize = CHANNEL_NUM;//DMA通道的DMA缓存的大小DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//工作在循环缓存模式//M2M是否使用软件触发DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;//DMA通道x没有设置为内存到内存传输DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;//DMA通道 x拥有中优先级DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);//外设使能DMA_Cmd(DMA1_Channel1, ENABLE);ADC_DMACmd(ADC1, ENABLE);ADC_Cmd(ADC1, ENABLE);//复位校准寄存器ADC_ResetCalibration(ADC1);while (ADC_GetResetCalibrationStatus(ADC1) == SET);ADC_StartCalibration(ADC1);while (ADC_GetCalibrationStatus(ADC1) == SET);ADC_SoftwareStartConvCmd(ADC1, ENABLE);&#125;</code></pre><p>（2）初始化stm32的多个ADC外设并启用DMA转运</p><pre><code>void Get_Voltage()&#123;int i=0;//数据包起始标志Usart_TransmitByte(0xFF);Usart_TransmitByte(0xFF); for(i=0;i&lt;CHANNEL_NUM;i++)&#123;Usart_TransmitByte(AD_Value[i]&gt;&gt;8);Usart_TransmitByte(AD_Value[i]&amp;0x00FF);&#125;&#125;</code></pre><h3 id="2-proc-fpga-FPGA主体模块"><a href="#2-proc-fpga-FPGA主体模块" class="headerlink" title="2.proc_fpga FPGA主体模块"></a>2.proc_fpga FPGA主体模块</h3><p>利用 xilinx zynq 接收 stm32 发送的数据并进行处理。</p><p>系统框图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f595c2dc3bd9102257bbf9596af891d6.png"></p><p>实际本体是uart_rx——decoder——signal_proc三部分，rs232与电脑通信测试时使用。</p><h4 id="uart协议数据接收模块——uart-rx"><a href="#uart协议数据接收模块——uart-rx" class="headerlink" title="&lt;1&gt;uart协议数据接收模块——uart_rx"></a>&lt;1&gt;uart协议数据接收模块——uart_rx</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98f598971dff58761f4758e9f27128c6.png"></p><p> 这里uart_rx、uart_tx、rs232模块代码沿用之前学习代码。</p><h4 id="串行数据解码模块——decoder"><a href="#串行数据解码模块——decoder" class="headerlink" title="&lt;2&gt;串行数据解码模块——decoder"></a>&lt;2&gt;串行数据解码模块——decoder</h4><p> 代码解析：</p><pre><code>`timescale 1ns / 1psmodule decoder#(    parameter   CHANNEL_NUM =   4&#39;d10    //传感器通道数)(    input   wire            sys_rst_n       ,    input   wire    [7:0]   data_serial     ,    input   wire            in_flag         ,    output  reg     [119:0]  data_parallel ,    output  reg             out_flag    );reg [3:0]   channel_cnt ;reg         byte_cnt    ;reg         r_en        ;//r_en串行数据解码标志always@(posedge in_flag or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        r_en &lt;= 1&#39;b0;    else if(data_serial == 8&#39;hFF &amp;&amp; byte_cnt == 1&#39;b1)        r_en &lt;= 1&#39;b1;    else if(channel_cnt &gt; CHANNEL_NUM)        r_en &lt;= 1&#39;b0;    else        r_en &lt;= r_en;        //byte_cnt数据高低字节计数always@(posedge in_flag or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        byte_cnt &lt;= 1&#39;b0;    else if(r_en == 1&#39;b1)        byte_cnt &lt;= ~byte_cnt;    else if(r_en == 1&#39;b0&amp;&amp;data_serial == 8&#39;hFF)        byte_cnt &lt;= 1&#39;b1;    else        byte_cnt &lt;= 1&#39;b0;//channel_cnt处理通道数计数always@(negedge byte_cnt or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        channel_cnt &lt;= 1&#39;b0;    else if(channel_cnt &gt; CHANNEL_NUM)        channel_cnt &lt;= 1&#39;b0;    else if(r_en == 1&#39;b1&amp;&amp;channel_cnt &lt;= CHANNEL_NUM)        channel_cnt &lt;= channel_cnt+1;    else        channel_cnt &lt;= 1&#39;b0;        //串转并输出always@(negedge in_flag or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_parallel &lt;= 120&#39;b0;    else if(r_en == 1&#39;b1)        if(byte_cnt == 1&#39;b0)            case(channel_cnt)                4&#39;b0001:data_parallel[7 :0]         &lt;=  data_serial[7:0];                4&#39;b0010:data_parallel[19:12]        &lt;=  data_serial[7:0];                4&#39;b0011:data_parallel[31:24]        &lt;=  data_serial[7:0];                4&#39;b0100:data_parallel[43:36]        &lt;=  data_serial[7:0];                4&#39;b0101:data_parallel[55:48]        &lt;=  data_serial[7:0];                4&#39;b0110:data_parallel[67:60]        &lt;=  data_serial[7:0];                4&#39;b0111:data_parallel[79:72]        &lt;=  data_serial[7:0];                4&#39;b1000:data_parallel[91:84]        &lt;=  data_serial[7:0];                4&#39;b1001:data_parallel[103:96]       &lt;=  data_serial[7:0];                4&#39;b1010:data_parallel[115:108]      &lt;=  data_serial[7:0];                default:data_parallel &lt;= data_parallel;            endcase        else            case(channel_cnt)                4&#39;b0001:data_parallel[11:7  +1]  &lt;= data_serial[3:0];                4&#39;b0010:data_parallel[23:19 +1]  &lt;= data_serial[3:0];                4&#39;b0011:data_parallel[35:31 +1]  &lt;= data_serial[3:0];                4&#39;b0100:data_parallel[47:43 +1]  &lt;= data_serial[3:0];                4&#39;b0101:data_parallel[58:55 +1]  &lt;= data_serial[3:0];                4&#39;b0110:data_parallel[71:67 +1]  &lt;= data_serial[3:0];                4&#39;b0111:data_parallel[83:79 +1]  &lt;= data_serial[3:0];                4&#39;b1000:data_parallel[95:91 +1]  &lt;= data_serial[3:0];                4&#39;b1001:data_parallel[107:103+1]  &lt;= data_serial[3:0];                4&#39;b1010:data_parallel[119:115+1]  &lt;= data_serial[3:0];                default:data_parallel &lt;= data_parallel;            endcase    else        data_parallel &lt;= data_parallel;//out_flag转换成功标志位always@(posedge channel_cnt or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        out_flag &lt;= 1&#39;b0;    else if(channel_cnt ==  CHANNEL_NUM)        out_flag &lt;= 1&#39;b1;    else        out_flag &lt;= 1&#39;b0;endmodule</code></pre><p> 波形图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/46d0090f8addb62c8be3ca925881e31a.png"></p><pre><code>     decode 模块检测到两个连续的 FF 后 r_en 使能开始记录数据，数据的高低字节用 byte_cnt 加以区分，每记录两个字节使 channel_cnt 加一，超出 CHANNEL_NUM 结束记录， data_parallel 输出120为并行数据。</code></pre><p>仿真代码：</p><pre><code>`timescale 1us / 1nsmodule  tb_decoder(); //********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire     [119:0] data_parallel  ;wire             out_flag       ;// wire     [3:0]   channel_cnt    ;// wire             byte_cnt       ;// wire             r_en           ;reg     [7:0]   data_serial;reg             in_flag;reg             sys_rst_n;            //********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位和输入信号initial begin    in_flag = 1&#39;b0;    sys_rst_n = 1&#39;b0;    #100    sys_rst_n = 1&#39;b1;end //调用任务rx_byteinitial begin    #200    rx_data();end //创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7task    rx_data();  //因为不需要外部传递参数，所以括号中没有输入    integerj;    for(j=0; j&lt;255; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化255        rx_serial();endtask //创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来task    rx_serial();    integer i;    for(i=0; i&lt;22; i=i+1)   begin        case(i)            0: data_serial &lt;= 8&#39;hFF ;            1: data_serial &lt;= 8&#39;hFF ;            2: data_serial &lt;= 8&#39;d1  ;            3: data_serial &lt;= 8&#39;d0  ;            4: data_serial &lt;= 8&#39;d2  ;            5: data_serial &lt;= 8&#39;d0  ;            6: data_serial &lt;= 8&#39;d3  ;            7: data_serial &lt;= 8&#39;d0  ;            8: data_serial &lt;= 8&#39;d4  ;            9: data_serial &lt;= 8&#39;d0  ;            10: data_serial &lt;= 8&#39;d5  ;            11: data_serial &lt;= 8&#39;d0  ;            12: data_serial &lt;= 8&#39;d6  ;            13: data_serial &lt;= 8&#39;d0  ;            14: data_serial &lt;= 8&#39;d7  ;            15: data_serial &lt;= 8&#39;d0  ;            16: data_serial &lt;= 8&#39;d8  ;            17: data_serial &lt;= 8&#39;b0  ;            18: data_serial &lt;= 8&#39;d9  ;            19: data_serial &lt;= 8&#39;d0  ;            20: data_serial &lt;= 8&#39;d10 ;            21: data_serial &lt;= 8&#39;d0  ;        endcase        in_flag &lt;= 1&#39;b1;        #0.001;        in_flag &lt;= 1&#39;b0;        #10;    endendtask //********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------ rs232_inst ------------------------decoder #(    .CHANNEL_NUM    (4&#39;d10)    //传感器通道数)decoder_inst(    .sys_rst_n      (sys_rst_n    ),    .data_serial    (data_serial  ),    .in_flag        (in_flag      ),    .data_parallel  (data_parallel),    .out_flag       (out_flag     )        // .channel_cnt    (channel_cnt  ),    // .byte_cnt       (byte_cnt     ),    // .r_en           (r_en         )); endmodule  </code></pre><h4 id="顶层模块"><a href="#顶层模块" class="headerlink" title="&lt;3&gt; 顶层模块"></a>&lt;3&gt; 顶层模块</h4><p>代码解析：</p><pre><code>`timescale 1ns / 1psmodule proc_fpga(    input   wire      clk_in1_p     ,    input   wire      clk_in1_n     ,    input   wire      sys_rst_n     ,        //发送数据线    output  wire     pc_tx           ,      //数据发送线    // input   wire     [7:0]   tx_data ,      //发送的一字节数据    // input   wire             tx_flag ,      //发送数据就位标志        //接收数据线    input   wire     pc_rx           ,     //数据接收线    // output  wire     [7:0]   rx_data ,      //接受的一字节数据    // output  wire             rx_flag ,      //一字节数据接收完成标志    input   wire     s1_rx           ,          input   wire     s2_rx           ,          output  wire    [15:0]      result                 );wire clk_100M;wire locked;      wire     [7:0]   sensor1_data ;wire             sensor1_flag ;wire     s2_rx                ;    wire     [7:0]   sensor2_data ;wire             sensor2_flag ;//wire     s3_rx                ,    //wire     [7:0]   sensor3_data ,//wire             sensor3_flag wire    [119:0] data1_parallel   ;wire    out1_flag        ;wire    [119:0] data2_parallel   ;wire    out2_flag        ;//回环测试线wire     [7:0]   pc_data ;wire             pc_flag ;wire     [7:0]   result_low;wire [11:0]  b1  ;   wire [11:0]  b2  ;wire [11:0]  b3  ;wire [11:0]  b4  ;wire [11:0]  b5  ;wire [11:0]  b6  ;wire [11:0]  b7  ;wire [11:0]  b8  ;wire [11:0]  b9  ;wire [11:0]  b10 ;wire [11:0]  b11 ;wire [11:0]  b12 ;wire [11:0]  b13 ;wire [11:0]  b14 ;wire [11:0]  b15 ;wire [11:0]  b16 ;assign data1_parallel[11:0]     = b1       ;assign data1_parallel[23:12]    = b2       ;assign data1_parallel[35:24]    = b3       ;assign data1_parallel[47:36]    = b4       ;assign data1_parallel[59:48]    = b5       ;assign data1_parallel[71:60]    = b6       ;assign data1_parallel[83:72]    = b7       ;assign data1_parallel[95:84]    = b8       ;assign data1_parallel[107:96]   = b9       ;assign data1_parallel[119:108]  = b10      ;assign data2_parallel[11:0]     = b11      ;assign data2_parallel[23:12]    = b12      ;assign data2_parallel[35:24]    = b13      ;assign data2_parallel[47:36]    = b14      ;assign data2_parallel[59:48]    = b15      ;assign data2_parallel[71:60]    = b16      ;//pll时钟产生模块clk_pll clk_pll_inst   (    // Clock out ports    .clk_100M(clk_100M),     // output clk_100M    // Status and control signals    .reset(~sys_rst_n), // input reset    .locked(locked),       // output locked   // Clock in ports    .clk_in1_p(clk_in1_p),    // input clk_in1_p    .clk_in1_n(clk_in1_n)    // input clk_in1_n);//usart通信模块rs232 rs232_pc_inst(    .sys_clk(clk_100M),    .sys_rst_n(sys_rst_n),    .rx_data    (pc_data    ),  //output    [7:0]   rx_data    .rx_flag    (pc_flag    ),  //output            rx_flag    .tx_data    (pc_data    ),    .tx_flag    (pc_flag    ),    .rx(pc_rx),    .tx(pc_tx));//传感器数据接收uart_rx uart_rx_sensor1_inst(    .sys_clk(clk_100M),    .sys_rst_n(sys_rst_n),   .po_data    (sensor1_data    ),  //output    [7:0]   rx_data   .po_flag    (sensor1_flag    ),  //output            rx_flag    // .po_data    (pc_data    ),  //回环测试    // .po_flag    (pc_flag    ),  //回环测试        .rx(s1_rx));uart_rx uart_rx_sensor2_inst(    .sys_clk(clk_100M),    .sys_rst_n(sys_rst_n),    .po_data    (sensor2_data    ),  //output    [7:0]   rx_data    .po_flag    (sensor2_flag    ),  //output            rx_flag`    .rx(s2_rx));// uart_rx uart_rx_sensor3_inst// (    // .sys_clk(clk_100M),    // .sys_rst_n(sys_rst_n),    // .po_data    (sensor3_data    ),  //output    [7:0]   rx_data    // .po_flag    (sensor3_flag    ),  //output            rx_flag    // .rx(s3_rx)// );decoder decoder1_inst(    .sys_rst_n     (sys_rst_n)      ,    .data_serial   (sensor1_data)   ,    .in_flag       (sensor1_flag)   ,    .data_parallel (data1_parallel) ,    .out_flag      (out1_flag));decoder decoder2_inst(    .sys_rst_n     (sys_rst_n)      ,    .data_serial   (sensor2_data)   ,    .in_flag       (sensor2_flag)   ,    .data_parallel (data2_parallel) ,    .out_flag      (out2_flag));signal_proc_inst signal_proc_inst_inst(    .ap_clk     (clk_100M)                  ,    .ap_rst     (sys_rst_n)                 ,    .a1         (b1 )    ,    .a2         (b2 )    ,    .a3         (b3 )    ,    .a4         (b4 )    ,    .a5         (b5 )    ,    .a6         (b6 )    ,    .a7         (b7 )    ,    .a8         (b8 )    ,    .a9         (b9 )    ,    .a10        (b10)    ,    .a11        (b11)    ,    .a12        (b12)    ,    .a13        (b13)    ,    .a14        (b14)    ,    .a15        (b15)    ,    .a16        (b16)    ,    .c1         (result[0])                 ,    .c2         (result[1])                 ,    .c3         (result[2])                 ,    .c4         (result[3])                 ,    .c5         (result[4])                 ,    .c6         (result[5])                 ,    .c7         (result[6])                 ,    .c8         (result[7])                 ,    .c9         (result[8])                 ,    .c10        (result[9])                 ,    .c11        (result[10])                ,    .c12        (result[11])                ,    .c13        (result[12])                ,    .c14        (result[13])                ,    .c15        (result[14])                ,    .c16        (result[15])    );endmodule</code></pre><p>仿真代码：</p><pre><code>`timescale 1ns / 1psmodule  tb_proc_fpga(); //********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire    tx          ;reg     rx          ;wire     [7:0]   rx_data;wire             rx_flag;//reg   definewire     [7:0]   tx_data;wire             tx_flag;reg     clk_in1_p;reg     clk_in1_n;reg     sys_rst_n;always #5 clk_in1_p = ~clk_in1_p;always #5 clk_in1_n = ~clk_in1_n;assign tx_data=rx_data;assign tx_flag=rx_flag;  parameter   UART_BPS    =   20&#39;d115200        ,   //比特率            CLK_FREQ    =   28&#39;d100_000_000  ;   //时钟频率            //********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位和输入信号initial begin    clk_in1_p = 1&#39;b0;    clk_in1_n = 1&#39;b1;    rx        &lt;= 1&#39;b1;    sys_rst_n = 1&#39;b0;    #100    sys_rst_n = 1&#39;b1;end //调用任务rx_byteinitial begin    #200    rx_byte();end //创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7task    rx_byte();  //因为不需要外部传递参数，所以括号中没有输入    integerj;    for(j=0; j&lt;255; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化255        rx_bit(j);endtask //创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来task    rx_bit(    input   [7:0]   data);    integer i;    for(i=0; i&lt;10; i=i+1)   begin        case(i)            0: rx &lt;= 1&#39;b0;            1: rx &lt;= data[0];            2: rx &lt;= data[1];            3: rx &lt;= data[2];            4: rx &lt;= data[3];            5: rx &lt;= data[4];            6: rx &lt;= data[5];            7: rx &lt;= data[6];            8: rx &lt;= data[7];            9: rx &lt;= 1&#39;b1;        endcase        #(1000000000/UART_BPS); //每发送1位数据延时    endendtask //********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------ rs232_inst ------------------------proc_fpga   proc_fpga_inst(    .clk_in1_p        (clk_in1_p        ),    .clk_in1_n        (clk_in1_n        ),    .sys_rst_n        (sys_rst_n        ),    // .rx_data          (rx_data),  //output    [7:0]   rx_data    // .rx_flag          (rx_flag),  //output            rx_flag    // .tx_data          (tx_data),    // .tx_flag          (tx_flag),    .s1_rx               (rx               ),    .pc_tx               (tx               )); endmodule  </code></pre><h3 id="3-signal-proc-信号处理模块"><a href="#3-signal-proc-信号处理模块" class="headerlink" title="3.signal_proc 信号处理模块"></a>3.signal_proc 信号处理模块</h3><p>HLS工程代码解析：</p><pre><code>#include &lt;ap_cint.h&gt;#include &lt;math.h&gt;void signal_proc(uint12 a1,uint12 a2,uint12 a3,uint12 a4,uint12 a5,uint12 a6,uint12 a7,uint12 a8,uint12 a9,uint12 a10,uint12 a11,uint12 a12,uint12 a13,uint12 a14,uint12 a15,uint12 a16,uint1 *c1,uint1 *c2,uint1 *c3,uint1 *c4,uint1 *c5,uint1 *c6,uint1 *c7,uint1 *c8,uint1 *c9,uint1 *c10,uint1 *c11,uint1 *c12,uint1 *c13,uint1 *c14,uint1 *c15,uint1 *c16)&#123;#pragma HLS INTERFACE ap_none port=a1#pragma HLS INTERFACE ap_none port=a2#pragma HLS INTERFACE ap_none port=a3#pragma HLS INTERFACE ap_none port=a4#pragma HLS INTERFACE ap_none port=a5#pragma HLS INTERFACE ap_none port=a6#pragma HLS INTERFACE ap_none port=a7#pragma HLS INTERFACE ap_none port=a8#pragma HLS INTERFACE ap_none port=a9#pragma HLS INTERFACE ap_none port=a10#pragma HLS INTERFACE ap_none port=a11#pragma HLS INTERFACE ap_none port=a12#pragma HLS INTERFACE ap_none port=a13#pragma HLS INTERFACE ap_none port=a14#pragma HLS INTERFACE ap_none port=a15#pragma HLS INTERFACE ap_none port=a16#pragma HLS INTERFACE ap_none port=c1#pragma HLS INTERFACE ap_none port=c2#pragma HLS INTERFACE ap_none port=c3#pragma HLS INTERFACE ap_none port=c4#pragma HLS INTERFACE ap_none port=c5#pragma HLS INTERFACE ap_none port=c6#pragma HLS INTERFACE ap_none port=c7#pragma HLS INTERFACE ap_none port=c8#pragma HLS INTERFACE ap_none port=c9#pragma HLS INTERFACE ap_none port=c10#pragma HLS INTERFACE ap_none port=c11#pragma HLS INTERFACE ap_none port=c12#pragma HLS INTERFACE ap_none port=c13#pragma HLS INTERFACE ap_none port=c14#pragma HLS INTERFACE ap_none port=c15#pragma HLS INTERFACE ap_none port=c16#pragma HLS INTERFACE ap_ctrl_none port=returnuint5 i;uint12 b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16;uint2 time=0;uint16 xzuo[16]=&#123;1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4&#125;;uint16 yzuo[16]=&#123;1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4&#125;;double A[256];for(i=0;i&lt;=15;i++)    for(int j=0;j&lt;=15;j++)    &#123;    A[i*16+j]=sqrt((xzuo[i]-xzuo[j])*(xzuo[i]-xzuo[j])+(yzuo[i]-yzuo[j])*(yzuo[i]-yzuo[j]));    A[i*16+j]=(1.0)/(A[i*16+j]*A[i*16+j]*A[i*16+j]);&#125;    for(i=0;i&lt;=15;i++)    &#123;    A[17*i]=0;&#125;while(1)&#123;if(time==0)&#123;b1=a1;b2=a2;b3=a3;b4=a4;b5=a5;b6=a6;b7=a7;b8=a8;b9=a9;b10=a10;b11=a11;b12=a12;b13=a13;b14=a14;b15=a15;b16=a16;time++;&#125;else&#123;uint5 i,j;double yuzhi=0.01;uint12 graphsig[16];uint12 graphsigq[16];double Bian,jiubian,xinbian;/* 此处假设该图信号的邻接矩阵不变，所以前面的只算一次 */graphsig[0] = a1;graphsig[1] = a2;graphsig[2] = a3;graphsig[3] = a4;graphsig[4] = a5;graphsig[5] = a6;graphsig[6] = a7;graphsig[7] = a8;graphsig[8] = a9;graphsig[9] = a10;graphsig[10] = a11;graphsig[11] = a12;graphsig[12] = a13;graphsig[13] = a14;graphsig[14] = a15;graphsig[15] = a16;/* 现在时刻图信号 */graphsigq[0] = b1;graphsigq[1] = b2;graphsigq[2] = b3;graphsigq[3] = b4;graphsigq[4] = b5;graphsigq[5] = b6;graphsigq[6] = b7;graphsigq[7] = b8;graphsigq[8] = b9;graphsigq[9] = b10;graphsigq[10] = b11;graphsigq[11] = b12;graphsigq[12] = b13;graphsigq[13] = b14;graphsigq[14] = b15;graphsigq[15] = b16;double dianbianhe[16];for(i=0;i&lt;=15;i++)&#123;Bian=0;for(j=0;j&lt;=15;j++)&#123;jiubian=((graphsigq[i]-graphsigq[j])*(graphsigq[i]-graphsigq[j]));xinbian=((graphsig[i]-graphsig[j])*(graphsig[i]-graphsig[j]));Bian=Bian+(xinbian-jiubian)*(xinbian-jiubian)*A[i*16+j];&#125;dianbianhe[i]=Bian;&#125;for(i=0;i&lt;=15;i++)&#123;if(dianbianhe[i]&gt;=yuzhi)&#123;if(i==0) *c1=1;else if(i==1) *c2=1;else if(i==2) *c3=1;else if(i==3) *c4=1;else if(i==4) *c5=1;else if(i==5) *c6=1;else if(i==6) *c7=1;else if(i==7) *c8=1;else if(i==8) *c9=1;else if(i==9) *c10=1;else if(i==10) *c11=1;else if(i==11) *c12=1;else if(i==12) *c13=1;else if(i==13) *c14=1;else if(i==14) *c15=1;else if(i==15) *c16=1;&#125;&#125;b1=a1;b2=a2;b3=a3;b4=a4;b5=a5;b6=a6;b7=a7;b8=a8;b9=a9;b10=a10;b11=a11;b12=a12;b13=a13;b14=a14;b15=a15;b16=a16;&#125;&#125;&#125;</code></pre><p>综合后 IP 核 ：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc63d71546b24ba8b8aafcf1a9c565ee.png"></p><h2 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四.注意事项"></a>四.注意事项</h2><p>&lt;1&gt;实例化时注意各个模块的时序，检查代码使用的时钟频率及各参数是否正确；实例化时连接线的运用，不能重复对一变量赋值！；注意实例调用时名称统一。</p><p>&lt;2&gt;编写好仿真文件进行仿真后再下载。</p><p>&lt;3&gt;报错：[DRC MDRV-1] Multiple Driver Nets</p><p>[Vivado综合报multi-driven<br>nets的错误的解决方法](<a href="https://blog.csdn.net/wordwarwordwar/article/details/80428358?ops_request_misc=&request_id=&biz_id=102&utm_term=multiple%20driver%20nets&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/wordwarwordwar/article/details/80428358?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=multiple%20driver%20nets&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduweb~default-0-80428358.nonecase&amp;spm&#x3D;1018.2226.3001.4187<br>“Vivado综合报multi-driven nets的错误的解决方法”)</p><p>[Vivado编译过程中出现[DRC MDRV-1] Multiple Driver<br>Nets](<a href="https://blog.csdn.net/jk_101/article/details/131824877?ops_request_misc=&request_id=&biz_id=102&utm_term=multiple%20driver%20nets&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/jk_101/article/details/131824877?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=multiple%20driver%20nets&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-<br>blog-2<del>all</del>sobaiduweb~default-1-131824877.nonecase&amp;spm&#x3D;1018.2226.3001.4187<br>“Vivado编译过程中出现[DRC MDRV-1] Multiple Driver Nets”)</p><p>&lt;4&gt;未使用的输入输出不要定义，定义后生成比特流前必须绑定引脚</p><p>&lt;5&gt;按照官方推荐的配套工具软件，比如Vivado 2023.1对应Vitis HLS<br>2023.1，如果使用不配套版本，HLS导出的IP核Vivado可能无法完全识别，报错“missing<br>Source”（全部展开IP核显示有缺少模块说明，如下图：）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50188b6c5223368c01c9481331d5b841.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133853116">https://blog.csdn.net/qq_32971095/article/details/133853116</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶设计一（DDR3）——FPGA学习笔记＜？＞</title>
      <link href="/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/"/>
      <url>/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><pre><code>    DDR3 SDRAM，以其单位存储量大、高数据带宽、读写速度快、价格相对便宜等优点 吸引了大批客户，占领市场较大份额。同时，作为内存条中不可缺少的一部分，DDR3 SDRAM 在计算机领域也占有一席之地。    要掌握 DDR3 SDRAM 的基本概念、数据存取原理、操作命令以及操作时序等相关知识。在掌 握 DDR3 SDRAM 的相关理论知识后，讲解 AXI4 接口，并且使用该接口配置 Xilinx 的 MIG IP 核，设计一个可进行读写操作的 DDR3 SDRAM 控制器，并上板验证。</code></pre><h3 id="1-DDR3-SDRAM基础概念"><a href="#1-DDR3-SDRAM基础概念" class="headerlink" title="1.DDR3 SDRAM基础概念"></a>1.DDR3 SDRAM基础概念</h3><pre><code>    DDR3 SDRAM 英 文 全 称 “ **Double-Data-Rate Three Synchronous Dynamic Random Access Memory** ”，译为“第三代**双倍速率同步动态随机存取** 内存”或“同步动态随机存储 器”，是动态随机存储器(Dynamic Random Access Memory，简称 DRAM)的一类。 同步、动态、随机是其性能特点的外在说明。    **双倍速率(Double-Data-Rate)** ：DDR3 SDRAM 存储器与 SDRAM 有一个很大的不同， DDR3 SDRAM 或者说带 DDR 开头的。包括 DDR1、DDR2、DDR3、DDR4、DDR4，他们都有一个很大的相似点，就是**双边沿输出输入数据** ，通俗来讲就是在一个周期内输出 2 次 数据，上升沿输出一次数据，下降沿输出一次数据。而 SDRAM 则是在一个周期内的上升 沿输出一次数据，下降沿不输出，所以同频率的 DDR3 SDRAM 与 SDRAM 相比速度快一 倍。    **同步(Synchronous)** ：与通常的异步 DRAM 不同，DDR3 SDRAM 存在一个同步接口， 其工作时钟的时钟频率与对应控制器(CPU/FPGA)的时钟频率相同，并且 SDRAM 内部的命 令发送与数据传输均以此时钟为基准，实现指令或数据的同步操作；    **动态(Dynamic)** ：DDR3 SDRAM 需要不断的刷新来保证存储阵列内数据不丢失；   **  随机(Random)**：数据在 DDR3 SDRAM 中并不是按照线性依次存储，而是可以自由指定地址进行数据的读写。    第一代 SDR SDRAM 采用单端时钟信号，SDRAM 只在时钟的上升沿进行数据采样； 而后面的四代 SDRAM 由于工作频率比较快，所以采用可降低干扰的**差分时钟信号** 作为同步时钟，双沿采样，速度更快，且功耗更低。同时技术的不断发展、制造工艺的不断提 高，使得五代 SDRAM 的更新过程中，集成度越来越高、内核电压越来越低(SDR:3.3V、 DDR:2.5V、DDR2:1.8V、DDR3:1.5V、DDR4:1.2V)，这也是 SDRAM 速度提高、功耗降低的重要原因。    由于 DDR3 SDRAM 需要不断刷新来保证数据的可靠性，**以及行列地址线分时复用等原因，使其对操作时序的 要求较为严格，进而导致控制逻辑较为复杂。**</code></pre><h3 id="2-DDR3-SDRAM存取原理"><a href="#2-DDR3-SDRAM存取原理" class="headerlink" title="2.DDR3 SDRAM存取原理"></a>2.DDR3 SDRAM存取原理</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1f3e93d3d6e3e3edeb231ab5b8c0ae5.png"></p><pre><code>    对于 DDR3 SDRAM，我们将类比于单元格的存储空间称之为存储单元，N(行列个数乘积)个存储单元构成一个存储阵列，这个存储阵列我们称之为一个逻辑Bank(LogicalBank）简称 L-Bank、Bank)。DDR3 SDRAM 内部并不是一个全容量的 L-Bank，而是**分割为若干个 L-Bank** ，目前大多为 4 个。若干 L-Bank 的分割，原因有二，一是技术、成本等诸多因素；二是由于 DDR3 SDRAM 的工作原理限制，单一 L-Bank 可能会造成非常严重的寻址冲突，大幅度降低内存效率。    这样一来，在对 DDR3 SDRAM 进行数据存取时，要**先确定 L-Bank 地址** ，定位到指定 逻辑 Bank，**再依次确定行地址和列地址** ，选中存储单元，进而进行数据的存取操作，而且 一次只能对一个 L-Bank 的一个存储单元进行操作。    DDR3 SDRAM 的基本存储单位是存储单元，而一个存储单元的容量为若干个 Bit，对 于 DDR3 SDRAM 而言就是芯片的位宽，每个 Bit 存放于一个单独的**存储体** 中，存储体是利 用电容能够保持电荷以及可充放电的特性制成，主要由行选通三极管、列选通三极管、存 储电容以及刷新放大器构成。电容所存储的电荷会随时间慢慢释放，这就需要不断刷新为 电容充电，以保证存储数据可靠性。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/866e1ed63d8f65a8cdcd7109c64133cc.png"></p><pre><code>    将每个存储单元简化为单 Bit 的存储体，再将若干存储体排列为矩阵，同一行将行地 址线相连，同一列将列地址线相连，就构成了一个存储阵列的简化模型。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f9736f70fea11026c66c77c690af13c.png"></p><h3 id="3-DDR3-SDRAM器件引脚"><a href="#3-DDR3-SDRAM器件引脚" class="headerlink" title="3.DDR3 SDRAM器件引脚"></a>3.DDR3 SDRAM器件引脚</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f27df221f173245d0ec20805d218f20.png"></p><p>注：x4、x8、x16 分别表示位宽 4bit、8bit、16bit；<strong>＃符号表示信号为低电平有效</strong> ；短 划线-表示 x8 和 x4<br>引脚功能相同，x16 引脚功能相同与前者不同，我们的是 x16。</p><pre><code>    我们以镁光公司生产的、容量为 4Megx16x4Banks 的 DDR3 SDRAM 芯片为例，对其做一下功能介绍。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c4e2e22141c5a36927e70daaaf76459e.png"></p><pre><code>    注：表格中某些信号只介绍了后文设计实验中所涉及到的功能，更多功能介绍请查阅 芯片对应数据手册。</code></pre><p>SDRAM 内部功能框图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e728de47fc70dff996003930f8c53c2f.png"></p><pre><code>    DDR3 SDRAM 内部包含一个逻辑控制单元，内部包含模式寄存器和 命令解码器。外部通过 CS_N、RAC_N、CAS_N、WE_N 以及地址总线向逻辑控制单元输 入命令，命令经过命令解码器进行译码后，将控制参数保存到模式寄存器中，逻辑控制单 元进而控制逻辑运行。    外部通过地址总线输入地址信息，地址信息在逻辑控制单元进行逻辑控制时起到辅助 作用，除此之外，复用的地址总线与 Bank 控制逻辑、行地址复用器、列地址计数锁存 器、列地址解码器等内部器件共同作用，精确选定存储阵列中与行列地址相对应的存储单 元，进而进行数据存取操作。</code></pre><p>容量计算方法可简化为： 存储容量(Bit)&#x3D;L-Bank 存储单元数×数据位宽(Bit)×L-Bank 个数</p><p>SDRAM 芯片的另一个概念：速度等级。DDR3 SDRAM 速度等级相关参数截图，具体见图</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/60e0374fc53606c56859b380fda22e26.png"></p><pre><code>    包括速度等级在内的 6 个相关参数。时钟频率(Clock Frequency)，单位 MHz，所列举的具体参数为 SDRAM 正常工作的最高时钟频率，SDRAM 工作时只能**等于 或低于这一时钟频率** ；tRCD 表示写入**自激活命令到开始进行数据读写，中间所需的等待时 间** ，列举的数值表示等待时间的最小值，单位为 ns；tRP 表示自预充电指令写入到预充电完成 所 需 的 等 待 时 间 ， 列 举 的 数 值 表 示 等 待 时 间 的 最 小 值 ， 单 位 为 ns ；**CL(CAS(READ)latency)列选通潜伏期，表示自数据读指令写入到第一个有效数据输出所需 等待时间** ，单位 ns；TargettRCD-tRP-CL 表示最大工作频率下，tRCD、tRP、CL 等待的最小时 钟周期数。</code></pre><h3 id="4-AXI-接口概述"><a href="#4-AXI-接口概述" class="headerlink" title="4.AXI 接口概述"></a>4.AXI 接口概述</h3><pre><code>    Advancede Xtensible Interface，即高级可扩展接口，它是 **ARM 公司 所提出的 AMBA（Advanced Microcontroller Bus Architecture）协议的一部分** 。之所以要采 用 AXI4 接口对 ddr 进行读写是因为 Xilinx 的 mig ddr Ip 核，无论是 6 系列还是 7 系列还是 最新的 FPGA，都集成了 AXI4 接口，为了采用 AXI4 接口进行读写，后续可以兼容 xilinx 的其他 fpga，可复用性更强。</code></pre><p>AXI 协议是一种高性能、高带宽、低延迟的片内总线，具有如下特点：</p><p>1、总线的地址&#x2F;控制和数据通道是分离的；</p><p>2、支持不对齐的数据传输；</p><p>3、支持突发传输，突发传输过程中只需要首地址；</p><p>4、具有分离的读&#x2F;写数据通道；</p><p>5、支持显著传输访问和乱序访问；</p><p>6、更加容易进行时序收敛。</p><p>AXI4 协议支持以下三种类型的接口：</p><p>1、AXI4：高性能存储映射接口。</p><p>2、AXI4-Lite：简化版的 AXI4 接口，用于较少数据量的存储映射通信。</p><p>3、AXI4-Stream：用于高速数据流传输，非存储映射接口。</p><pre><code>    在这里我们首先解释一下**存储映射（MeamoryMap）** 这一概念。如果一个协议是存储 映射的，那么主机所发出的会话（无论读或写）就会**标明一个地址** 。这个地址对应于系统 存储空间中的一个地址，表明是针对该存储空间的读写操作。**AXI4 协议支持突发传输** ，主 要用于处理器访问存储器等需要指定地址的高速数据传输场景。AXI-Lite 为外设提供单个 数据传输，主要用于访问一些低速外设中的寄存器。**而 AXI-Stream 接口则像 FIFO 一样， 数据传输时不需要地址，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接口等需要高速数据传输的场合。**</code></pre><h3 id="5-AXI4-接口讲解"><a href="#5-AXI4-接口讲解" class="headerlink" title="5.AXI4 接口讲解"></a>5.AXI4 接口讲解</h3><p>在本章我们重点介绍 AXI4 接口，它由五个独立的通道构成：</p><p>1、读地址 2、读数据 3、写地址 4、写数据 5、写响应</p><p>下面是使用读地址和读数据通道实现<strong>读传输过程</strong> 的示意图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cda28565b6a3cceaaefa7d089061712e.png"></p><pre><code>    从上图中可以看到，在一个读传输过程中，主机首先在**读地址通道** 给出**读地址和控制 信号** ，然后从机由**读数据通道返回读出的数据** 。另外我们需要注意的是，这是一次**突发读操作** ，主机只给出一个地址，从该地址连**续突发读出四个数据** 。</code></pre><p>写传输过程如下图所示，它用到了写地址、写数据和写响应三个通道：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3cacdc3809b6780897b8925b49a1d79f.png"></p><pre><code>    主机在写地址 通道给出写地址和控制信号，然后在写数据通道连续**突发写四个数据** 。从机在接收数据之 后，在写响应通道给出响应信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f2a8579995320eff3cbae1852918c33.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a8c880c2210b35bf29c9ffd20109d563.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1eab0ea821db4da4963da6f3f55e7d96.png"></p><p><strong>突发写时序：</strong></p><pre><code>    AXI4 突发写可以分为 7 个状态，写空闲，写通道写地址等待，写通道写地址，写数据 等待，写数据循环，接受写应答，写结束这 7 种状态。**之所以划分为 7 个状态是为了后续 写程序的状态机做准备。**</code></pre><p><strong>写空闲</strong> ：等待触发突发信号。</p><p><strong>写通道写地址等待</strong> ：准备好写地址 AWADDR，然后拉高 AWVALID。</p><p><strong>写通道写地址</strong> ：从机接受到 AWVALID，发出 AWREADY。</p><p><strong>写数据等待</strong> ：准备好数据 WDATA，拉高 WVALID。</p><p><strong>写数据循环</strong> ：从机接受 WVALID ，确认数据 WDATA 有 效 并 且接 受 ， 发 出 WREADY，AXI 是突发传输：循环该操作到接受到<br>WLAST 最后一个数据标志位。</p><p><strong>接受写应答</strong> ：接受到从机发出的 BVALID，主机发出 BREADY。</p><p><strong>写结束</strong> ：拉低未拉低的信号，进入写空闲。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a0f06fb6a50995ff5c2cbe2d97b5402.png"></p><p><strong>突发读时序：</strong></p><pre><code>    AXI4 突发读可以分为 6 个状态，读空闲，读通道写地址等待，读通道写地址，读数据 等待，读数据循环，读结束这 6 种状态。之所以划分为 6 个状态是为了后续写程序的状态 机做准备。</code></pre><p><strong>读空闲</strong> ：等待触发突发信号。</p><p><strong>读通道写地址等待</strong> ：准备好写地址 ARADDR，然后拉高 ARVALID。</p><p><strong>读通道写地址</strong> ：从机接受到 ARVALID，发出 ARREADY。</p><p><strong>读数据等待</strong> ：从机器准备好数据 WDATA，从机拉高 RVALID。</p><p><strong>读数据循环</strong> ：主机接受 RVALID，确认数据 RDATA 有效并且接受，发出 RREADY 给 从机，AXI 是突发传输：循环该操作到接受到<br>RLAST 最后一个数据标志位。</p><p><strong>读结束</strong> ：拉低未拉低的信号，进入读空闲。</p><p>从上面的时序图与时序分析可知两种关系必须被保持：</p><p>（1）读数据必须总是跟在与其数据相关联的地址之后。</p><p>（2）写响应必须总是跟在与其相关联的写事务的最后出现。</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133984011">https://blog.csdn.net/qq_32971095/article/details/133984011</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux_Petalinux二——FPGA学习笔记＜？＞</title>
      <link href="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/"/>
      <url>/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p>前置学习：<a href="https://blog.csdn.net/qq_32971095/article/details/133468006?spm=1001.2014.3001.5502" title="嵌入式Linux_Petalinux一">嵌入式Linux_Petalinux一</a></p><p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p><p>关于<a href="https://zhuanlan.zhihu.com/p/451782049" title="SecureCRT中如何配置颜色">SecureCRT 中如何配置颜色</a></p><h2 id="一-Linux-基础外设的使用"><a href="#一-Linux-基础外设的使用" class="headerlink" title="一.Linux 基础外设的使用"></a>一.Linux 基础外设的使用</h2><pre><code>    之前使用 Petalinux 搭建了 Linux 系统，有了系统就可以在系统上使用相应外设以及运行应用程序。本章我们学习如何通过 Linux 系统控制开发板上的基础外设，如 LED、按键、EEPROM、以太网等。这些外设都可以**在终端通过 Shell 来控制** 。</code></pre><p>输入以下命名查看系统：</p><pre><code>cat /proc/version                                       #查看内核版本信息top                                                     #检测资源使用情况</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df37df1a05bea06ea851e839d48f5a45.png"></p><p>Linux version 5.4.0 (cx@cx-ubtu) (gcc version 9.2.0 (GCC)) #11 SMP Mon Nov 14<br>13:40:04 CST 2022</p><h3 id="1-GPIO-之-LED-的使用"><a href="#1-GPIO-之-LED-的使用" class="headerlink" title="1.GPIO 之 LED 的使用"></a>1.GPIO 之 LED 的使用</h3><pre><code>    GPIO 驱动程序通过 **sysfs 文件** 系统提供了用户空间对 GPIO 的访问，因而通过终端控制 LED 极其方便。我们启动开发板，进入之前定制的 Linux 系统后在串口终端中输入如下命令**进入到 sysfs 文件系统的 leds 接口处** ：cd /sys/class/ledsls</code></pre><p>通过 ls 命令可以看到我们在设备树中配置的 led，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eff74364cc7414a63dba7718a405969d.png"></p><p>我们先来看下 led 下的内容，以 ps_led1 为例，输入 ls -l ps_led1，执行结果如下图 所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0968615b0a3d479ce6a50411c038ed5d.png"></p><pre><code>    可以看到有 brightness 和 trigger。Brightness 可以控制 led 灯的亮灭，trigger 可以选择触发方式。我们向 ps_led1 的 brightness 写入 0，即输入命令:cd ./ps_led1echo 0 &gt; brightness</code></pre><p>或者用下面命令查看brightness的当前值，再用vim修改：</p><pre><code>cat brightnessvim brightness</code></pre><p>对应开发板上led灯的亮灭。</p><p>然后输入命令查看led灯的触发方式：</p><pre><code>cat trigger</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae8ef58e273543418e7c98f64fc27d91.png"></p><pre><code>    可以看到触发方式非常多，**其中“[ ]”中的内容表示当前触发方式** 。可知当前触发方式为 none，也就是表示无任何触发反应。</code></pre><p>想设置使用某种触发方式输入 echo 命令如上，如：</p><pre><code>echo heartbeat &gt; trigger    需要提醒的是并不是所有的触发方式都能有反应，必须满足触发条件并且 brightness 值为 1 才行。</code></pre><h3 id="2-GPIO-之按键的使用"><a href="#2-GPIO-之按键的使用" class="headerlink" title="2.GPIO 之按键的使用"></a>2.GPIO 之按键的使用</h3><pre><code>    GPIO 按键的使用非常简单，通过读取文件/dev/input/event0 可以获取由 GPIO 按键生成 的按键事件。在串口终端中输入命令：cat /dev/input/event0 | hexdump</code></pre><p>然后按下一个 按键，输入事件将打印到控制台</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db2e1f071232d45000b84c0bad2afe08.png"></p><h3 id="3-EEPROM-的使用"><a href="#3-EEPROM-的使用" class="headerlink" title="3.EEPROM 的使用"></a>3.EEPROM 的使用</h3><pre><code>    配置设备树的时候，我们在设备树文件中配置了一个 EEPROM 的 I2C 外设， 我们来看下如何读写 EEPROM。        </code></pre><p>在 <strong>&#x2F;sys&#x2F;class&#x2F;i2c-adapter</strong> 目录下有三个 <strong>I2C 总线控制器</strong> ，相关操作如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5601bd79a638177ee7ef566139bc685a.png"></p><pre><code>    可以看到**器件地址 50 对应的文件夹 0-0050，对应 eeprom** 。 进入到 0-0050/目录下，可以看到该目录有一个 eeprom 文件，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/71633056d776965dd23fd591be34ffbd.png"></p><pre><code>cd /sys/class/i2c-adapterlscd i2c-0lscd 0-0050lsecho &quot;hello world&quot; &gt; eepromhead -1 eeprom</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/75d85c1547d2f818686853e002923d8a.png"></p><h3 id="4-RTC-的使用"><a href="#4-RTC-的使用" class="headerlink" title="4.RTC 的使用"></a>4.RTC 的使用</h3><pre><code>    对于 RTC，linux 有一个专用的命令：hwclock。    在 Linux 中有**硬件时钟与系统时钟** 两种时钟。硬件时钟是指电路板上的时钟设备（包括主 控芯片内的时钟模块），也就是通常可在 **BIOS 画面设定的时钟** 。系统时钟则是指 **kernel 中的时钟** 。当 Linux 启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有 Linux 相关指令与函数都是**读取系统时钟的设定** 。    使用 date 和 hwclock 命令可分别查看和设定系统时钟和硬件时钟。 在串口终端中输入下面的指令查看系统时间：datehwclock</code></pre><p>输入下面的指令将系统时间设置为当前日期和时间:</p><pre><code>date -s &quot;2023-10-9 14:39:00&quot;</code></pre><p>在串口终端中输入下面的命令将系统时间写入 RTC 时钟芯片中:</p><pre><code>hwclock -w</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9223fa2dc1aa34fdf217d48e9aac1243.png"></p><h3 id="5-miniDP-接口的使用"><a href="#5-miniDP-接口的使用" class="headerlink" title="5.miniDP 接口的使用"></a>5.miniDP 接口的使用</h3><pre><code>    开发板带有一个 miniDP 接口，可以接显示器显示。一般显示使用的是 DP 接口或者 HDMI 接口，与开发板的 miniDP 接口不同，所以还需要一根 miniDP 转 DP 线或者 miniDP 转 HDMI 线。下面分别展示不同接口显示器的线材接口。    1\. DP 接口显示器：使用公对公的 mini DP 转 DP 线连接开发板和 DP 显示器即可，线材接 口如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07a72fa907063d261bf71257b8497f61.png"></p><pre><code>    2\. HDMI接口显示器：需要使用主动式miniDP转HDMI线来连接开发板和HDMI显示器。 需要注意的是并不是市面上所有的 miniDP 转 HDMI 线都可以使用，至于原因，Xilinx 官方也 只是说由于历史原因，但并未透露更多细节。笔者在购买市面上大量的 miniDP 转 HDMI 线并 进行测试后发现，** _有些线 linux 系统下能显示，但是裸机 Vitis 下不能显示或显示有问题，有些线无法使用_** ，最终测试发现有一根线 linux 和 Vitis 下都能正常显示。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/141936bb09289673f07c3a351763d89e.png"></p><pre><code>    使用转接线将开发板的 miniDP 与显示器连接后，按 PS 的复位按键重启开发板，重启后会在显示器显示控制台终端。</code></pre><h3 id="6-USB-的使用"><a href="#6-USB-的使用" class="headerlink" title="6.USB 的使用"></a>6.USB 的使用</h3><p>将 USB 接口的设备接到开发板的 USB 接口，在串口中断中会打印如下信息：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1dbb118230d5c36a3b5ea2e8bd9f90a.png"></p><p>显示的“Product: USB Keyboard”表明检测到插入的设备是 USB 键盘。</p><h3 id="7-以太网的使用"><a href="#7-以太网的使用" class="headerlink" title="7.以太网的使用"></a>7.以太网的使用</h3><pre><code>    DFZU2EG_4EV MPSoC开发板有两路千兆以太网接口，PL_ETH和PS_ETH；由于PL_ETH 网口使用了 PL 端 IO 资源，而 PS_ETH 使用了 PS 端 IO 资源，所以这里也把 PL_ETH 网口称 为 PL 网口、而把 PS_ETH 网口称为 PS 网口。</code></pre><p>注：连接网口的网线要使用千兆网线，譬如 CAT-5E 类网线或 CAT-6 类网线，笔者在实 际测试当中，发现 CAT-5E<br>类网线并不稳定，所以这里推荐使用 CAT-6 类网线进行测试。</p><h4 id="1、查看网络设备"><a href="#1、查看网络设备" class="headerlink" title="1、查看网络设备"></a>1、查看网络设备</h4><p> 在串口终端执行下面这条命令可以<strong>查看系统中的所有网络设备</strong> ，如下所示：</p><pre><code>ip -s a#或者ifconfig -a</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a8a98f0b7c13331ab6701a4e43b83186.png"></p><pre><code>    其中 eth0 表示开发板上的 PL_ETH 网口、 而 eth1 则表示开发板上的 PS_ETH 网口。还可以直接使用 **ifconfig** 命令不加任何选项查看当前系统**已经激活（打开）的网络设备** （等同于命令 **ip link show up** ），如下图所示：ifconfig或ip link show up</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/53a9bd3bd086937144b1035f4db021fe.png"></p><pre><code>    系统默认只激活了 eth0，而 eth1 并没有激活，上图中的 eth0 就是开发板上的 PL 网口，可 以通过 ifconfig 命令或者 ip 命令来关闭或激活对应的网口。 ifconfig 命令打开或关闭 PL 网口的命令如下所示：ifconfig eth0 down //关闭 eth0（PL 网口）ifconfig eth0 up //打开 eth0（PL 网口）</code></pre><p>如果是用 ip 命令，则对应命令如下：</p><pre><code>ip link set eth1 down //关闭 eth1（PS 网口）ip link set eth1 up //打开 eth1（PS 网口）    下面我们在使用 PS 网口的时候，需要先把 PL 网口给关闭，只打开 PS 网口；同理使用 PL 网口的时候，需要把 PS 网口给关闭，只打开 PL 网口；在后面的使用当中，笔者以 PL 网 口为例进行介绍，PS 网口使用方式相同。</code></pre><h4 id="2、外网连接测试（有路由器）"><a href="#2、外网连接测试（有路由器）" class="headerlink" title="2、外网连接测试（有路由器）"></a>2、外网连接测试（有路由器）</h4><p>执行下面的命令打开开发板的 PL 网口，并且关闭 PS 网口：</p><pre><code>ip link set eth1 down //关闭 PS 网口ip link set eth0 up //打开 PL 网口ip link show up</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5fc18910c9637d0ca383f9393ef6f18.png"></p><pre><code>    接下来我们需要给 PL 网口分配一个 IP 地址，使用 udhcpc 命令从 DHCP 服务器中动态 获取一个 IP 地址，如下所示：udhcpc -i eth0 //eth0 动态获取 IP 地址</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c576aa9c09612f23d4a89791951fd1a.png"></p><pre><code>    可以看到，笔者这里 PL 网口动态获取得到的 IP 地址为 192.168.2.219。获 取到 IP 地址之后，接下来我们需要测试下开发板是不是能够上网，也就是测试开发板 PL 网 口是否工作正常、是否能够连接外网。当然首先确定开发板 PL 网口连接到的路由器是能够连 接外网的，我们可以使用 ping 命令来测试开发板与另一台主机的网络连接是否通畅。    ping 命令是基于 **ICMP** （Internet Control Message Protocol）协议来工作的，执行 ping 命令 本地主机会向目标主机发送一份 ICMP 回显请求报文，并等待目标主机返回 ICMP 应答；因为 ICMP 协议会要求目标主机收到消息之后，必须返回 ICMP 应答消息给本地主机，如果本地主 机收到了目标主机的应答，则表示两台主机之间的网络运行、网络连接是正常的。ping -c 10 www.baidu.com //测试开发板与百度服务器之间网络连接情    从上图可以知道，我们通过开发板对百度服务器主机（IP 地址：14.215.177.39）发送了 10 次应答请求，并且每次都收到了它的应答消息（64 字节数据），并且没有数据丢失，说明 开发板与百度服务器主机之间的网络运行、网络连接是 OK 的，也就意味着我们的开发板与外 网是连通的。 PS 网口的外网连接测试同理。</code></pre><h4 id="3、电脑直连测试（无路由器）"><a href="#3、电脑直连测试（无路由器）" class="headerlink" title="3、电脑直连测试（无路由器）"></a>3、电脑直连测试（无路由器）</h4><pre><code>    在开发过程中，电脑和开发板互相访问是经常需要的，这可以通过路由器来实现，连接到 同一路由器的设备是可以互相访问的，如果没有路由器，也可以使用网线将开发板 PS 网口或 者 PL 网口直接连接到电脑的以太网接口上，也就是电脑直连，不过这种方式不能访问外网。 笔者以 PL 网口为例，用网线将开发板的 PL 网口和电脑的以太网接口相连接。</code></pre><p>连接好网线之后，需要设置电脑以太网的 IP 地址，可参考：<a href="https://www.bilibili.com/video/BV1QJ411v7xk/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="Linux开发板网络直连电脑的设置方法">Linux开发板网络直连电脑的设置方法<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://www.bilibili.com/video/BV1QJ411v7xk/?spm_id_from&#x3D;333.999.0.0&amp;vd_source&#x3D;01cde8042a76495bf513aa4407a56cd6</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b17f18975241cf0242477f6467254f7a.png"></p><p>配置完成后，在串口终端中执行下面这些命令打开开发板的 PL 网口，并且关闭 PS 网口：</p><pre><code>ip link set eth1 down //关闭 PS 网口ip link set eth0 up //打开 PL 网口ip link show up</code></pre><p>执行下面的命令设置开发板 eth0 网口的静态 IP 地址为 192.168.2.88：</p><pre><code>ip addr add 192.168.2.88/24 dev eth0    将开发板的静态 IP 地址设置为 192.168.2.88，这样开发板的 IP 地址和电脑的 IP 就在同一 网段。设置完开发板的静态 IP 地址后，进行 Ping 测试，看开发板和电脑能不能相互 Ping 通。 首先开发板 ping 电脑，命令如下：ping -c4 192.168.2.89</code></pre><p>如果 Ping 不通电脑，请关闭电脑的防火墙后再尝试。</p><p>电脑 ping 开发板。首先打开电脑的 cmd 命令提示符，然后输入如下命令：</p><pre><code>ping 192.168.2.88</code></pre><h3 id="8-eMMC-的使用"><a href="#8-eMMC-的使用" class="headerlink" title="8.eMMC 的使用"></a>8.eMMC 的使用</h3><pre><code>    注意，由于 2019.2 版本 petalinux 内核中驱动的问题，在做本实验前需要将出厂的 vivado 工程中 SDIO0，就也就是 **eMMC 的工作时钟由 200M 改为 100M** ，如下图所示，然后编译并导 出 xsa 文件，使用新导出的文件配置 petalinux 工程。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/32649bd1f2f18ee4d548e60910182177.png"></p><pre><code>    开发板板载 8GB eMMC，接下来通过简单的读写来学习 eMMC 的使用。 开发板成功启动后，进入系统，输入“df -Th”命令，**查看挂载的文件系统** ，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d608ed53f1af767c4baaad973372d7a.png"></p><pre><code>     其中“/dev/mmcblk0p1” 和“/dev/mmcblk0p2”就是 eMMC 设备，代表 eMMC 的两个分区，分别挂载在**“/media/mmcblk0p1”和“/media/mmcblk0p2”** 两个挂载点。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19ccb7804f2f10db4c0d4c188bc7ef0c.png"></p><p>可以先看一下emmc中的内容：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ccba3740912f31afd6976e11bb50c9c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f488e3936031b5c3e89806e80ca9b35.png"></p><p>可以看到里面是之前用 petalinux 制作好的启动镜像文件和 linux 系统文件。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2883eb35f130294a656b388174b84e41.png"></p><p>接下来参考制作 SD 启动卡的步骤，将 eMMC 格式化成一个分区。</p><p>分别执行下面两个命令，先使用 umount 指令从挂载点<strong>卸载 eMMC</strong> ，再使用 fdisk 指令对 eMMC 分区，结果如下图所示：</p><pre><code>umount /run/media/mmcblk0p1 /run/media/mmcblk0p2fdisk /dev/mmcblk0</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5873fb2cafd89a8736490f399460fad8.png"></p><p>执行后输入“p”，结果如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/56895f538457aefd068f703d8191458f.png"></p><pre><code>    可以看到 eMMC 有 p1 和 p2 两个分区，输入“d”删除分区，在接下来的分区序号选择命令行中，输入“1”，选择删除第一个分区，再次输入“d”，删除第二个分区，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/914da14b57ed5701b3dded0fbee04e49.png"></p><pre><code>    接下来**输入“n”创建1个新分区** ，输入“p”选择创建主分区，按回车键，然后选择“1”， 接下来的设置按回车，选择默认即可，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/234bec0c77ee3c952f7b2eda8eab4395.png"></p><p>输入“p”检查分区表，可以看到新建的分区，如果没有问题，输入“w”保存并退出， 如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce229eb7c62cd552353c9d4dd0bb73c0.png"></p><pre><code>    输入 echo “www.openedv.com” &gt; /media/mmcblk0p1/test.txt 命令在 eMMC 中创建名为 test.txt 的文本文件，并向文件中写入内容为“www.openedv.com”的文本内容，然后使用 cat /run/media/mmcblk0p1/test.txt 命令，将文件中的内容打印出来，可以看到写入和读出的内容相 同。</code></pre><h2 id="二-使用-Vitis-开发-Linux-应用"><a href="#二-使用-Vitis-开发-Linux-应用" class="headerlink" title="二.使用 Vitis 开发 Linux 应用"></a>二.使用 Vitis 开发 Linux 应用</h2><pre><code>    本章我们以创建 “Hello World”工程为例学习如何**使用 Vitis 开发 Linux 应用** 以及如何让应用程序运行在 Petalinux 搭建的 Linux 系统上。运行方式本章介绍了三种，可根据个人喜好选择。</code></pre><h3 id="1-创建基于-Vitis-的-Linux-平台工程"><a href="#1-创建基于-Vitis-的-Linux-平台工程" class="headerlink" title="1.创建基于 Vitis 的 Linux 平台工程"></a>1.创建基于 Vitis 的 Linux 平台工程</h3><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133674422">https://blog.csdn.net/qq_32971095/article/details/133674422</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统——OS学习笔记＜1＞</title>
      <link href="/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/"/>
      <url>/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">一.Ubuntu<br>系统入门</a></p><p><a href="about:blank#1.VMware%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%81%E7%A8%8B">1.VMware<br>创建虚拟机流程</a></p><p><a href="about:blank#2.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">2.Ubuntu 系统入门</a></p><p><a href="about:blank#%3C1%3EShell%20%E5%91%BD%E4%BB%A4">&lt;1&gt;Shell 命令</a></p><p><a href="about:blank#1%E3%80%81%E7%9B%AE%E5%BD%95%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20ls">1、目录信息查看命令<br>ls</a></p><p><a href="about:blank#2%E3%80%81%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E5%91%BD%E4%BB%A4%20cd">2、目录切换命令<br>cd</a></p><p><a href="about:blank#3%E3%80%81%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%20pwd">3、当前路径显示命令<br>pwd</a></p><p><a href="about:blank#4%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20uname">4、系统信息查看命令<br>uname</a></p><p><a href="about:blank#5%E3%80%81%E6%B8%85%E5%B1%8F%E5%91%BD%E4%BB%A4%20clear">5、清屏命令<br>clear</a></p><p><a href="about:blank#6%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%BA%AB%E4%BB%BD%E5%91%BD%E4%BB%A4%20sudo">6、切换用户执行身份命令<br>sudo</a></p><p><a href="about:blank#7%E3%80%81%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20adduser">7、添加用户命令<br>adduser</a></p><p><a href="about:blank#8%E3%80%81%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20deluser">8、删除用户命令<br>deluser</a></p><p><a href="about:blank#9%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20su">9、切换用户命令<br>su</a></p><p><a href="about:blank#10%E3%80%81%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%91%BD%E4%BB%A4%20cat">10、显示文件内容命令<br>cat</a></p><p><a href="about:blank#11%E3%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4%20ifconfig">11、显示和配置网络属性命令<br>ifconfig</a></p><p><a href="about:blank#12%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%20man">12、系统帮助命令<br>man</a></p><p><a href="about:blank#13%E3%80%81%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%20reboot">13、 系统重启命令<br>reboot</a></p><p><a href="about:blank#14%E3%80%81%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%97%AD%E5%91%BD%E4%BB%A4%20poweroff">14、系统关闭命令<br>poweroff</a></p><p><a href="about:blank#15%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%20install">15、软件安装命令<br>install</a></p><p><a href="about:blank#%3C2%3EAPT%20%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7">&lt;2&gt;APT 下载工具</a></p><p><a href="about:blank#1%E3%80%81%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93">1、更新本地数据库</a></p><p><a href="about:blank#2%E3%80%81%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">2、检查依赖关系</a></p><p><a href="about:blank#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">3、软件安装</a></p><p><a href="about:blank#4%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0">4、软件更新</a></p><p><a href="about:blank#5%E3%80%81%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6">5、卸载软件</a></p><p><a href="about:blank#%3C3%3EUbuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91">&lt;3&gt;Ubuntu<br>下文本编辑</a></p><p><a href="about:blank#%3C4%3E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">&lt;4&gt;文件系统</a></p><p><a href="about:blank#1.Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">1.Linux<br>文件系统结构</a></p><p><a href="about:blank#2.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">2.文件操作命令</a></p><p><a href="about:blank#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E2%80%94touch">1、创建新文件命令—touch</a></p><p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir">2、文件夹创建命令—mkdir</a></p><p><a href="about:blank#3%E3%80%81%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rm">3、文件及目录删除命令—rm</a></p><p><a href="about:blank#4%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%28%E7%9B%AE%E5%BD%95%29%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rmdir">4、文件夹(目录)删除命令—rmdir</a></p><p><a href="about:blank#5%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4%E2%80%94cp">5、文件复制命令—cp</a></p><p><a href="about:blank#6%E3%80%81%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%91%BD%E4%BB%A4%E2%80%94mv">6、文件移动命令—mv</a></p><p><a href="about:blank#3.%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">3.文件压缩和解压缩</a></p><p><a href="about:blank#1%E3%80%81%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">1、图形化压缩和解压缩</a></p><p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">2、命令行进行文件的压缩和解压缩</a></p><p><a href="about:blank#%E2%91%A0%E5%91%BD%E4%BB%A4%20zip">①命令 zip</a></p><p><a href="about:blank#%E2%91%A1%E5%91%BD%E4%BB%A4%20unzip">②命令 unzip</a></p><p><a href="about:blank#%E2%91%A2%E5%91%BD%E4%BB%A4%20tar">③命令 tar</a></p><p><a href="about:blank#4.%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2">4.文件查询和搜索</a></p><p><a href="about:blank#1%E3%80%81%E5%91%BD%E4%BB%A4%20find">1、命令 find</a></p><p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%20grep">2、命令 grep</a></p><p><a href="about:blank#5.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">5.文件类型</a></p><p><a href="about:blank#%3C5%3ELinux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">&lt;5&gt;Linux<br>用户权限管理</a></p><p><a href="about:blank#1.Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F">1.Ubuntu 用户系统</a></p><p><a href="about:blank#2.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">2.权限管理</a></p><p><a href="about:blank#3.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">3.权限管理命令</a></p><p><a href="about:blank#1%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chmod">1、权限修改命令<br>chmod</a></p><p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%BD%92%E5%B1%9E%E8%80%85%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chown">2、文件归属者修改命令<br>chown</a></p><p><a href="about:blank#%3C6%3ELinux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86">&lt;6&gt;Linux<br>磁盘管理</a></p><p><a href="about:blank#1.Linux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.Linux<br>磁盘管理基本概念</a></p><p><a href="about:blank#2.%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2.磁盘管理命令</a></p><p><a href="about:blank#1%E3%80%81%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20fdisk">1、磁盘分区命令<br>fdisk</a></p><p><a href="about:blank#2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%91%BD%E4%BB%A4%20mkfs">2、格式化命令<br>mkfs</a></p><p><a href="about:blank#3%E3%80%81%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20mount">3、挂载分区命令<br>mount</a></p><p><a href="about:blank#4%E3%80%81%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4%20umount">4、卸载命令<br>umount</a></p><p><a href="about:blank#3.Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8">3.Linux C<br>编程入门</a></p><p><a href="about:blank#%3C1%3E%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">&lt;1&gt;编写代码</a></p><p><a href="about:blank#%3C2%3E%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">&lt;2&gt;编译代码</a></p><p><a href="about:blank#%3C3%3EGCC%20%E7%BC%96%E8%AF%91%E5%99%A8">&lt;3&gt;GCC 编译器</a></p><p><a href="about:blank#1%E3%80%81gcc%20%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">1、gcc<br>命令格式如下：</a></p><p><a href="about:blank#2%E3%80%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B">2、编译流程</a></p><p><a href="about:blank#%3C4%3EMakefile%20%E5%9F%BA%E7%A1%80">&lt;4&gt;Makefile 基础</a></p><p><a href="about:blank#1%E3%80%81Makefile%20%E7%AE%80%E4%BB%8B">1、Makefile 简介</a></p><p><a href="about:blank#2%E3%80%81Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5">2、Makefile 的引入</a></p><p><a href="about:blank#3%E3%80%81Makefile%20%E8%AF%AD%E6%B3%95">3、Makefile 语法</a></p><p><a href="about:blank#%E2%91%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F">①Makefile<br>规则格式</a></p><p><a href="about:blank#%E2%91%A1Makefile%20%E5%8F%98%E9%87%8F">②Makefile 变量</a></p><p><a href="about:blank#%E2%91%A2Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">③Makefile<br>模式规则</a></p><p><a href="about:blank#%E2%91%A3Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F">④Makefile<br>自动化变量</a></p><p><a href="about:blank#%E2%91%A4Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87">⑤Makefile 伪目标</a></p><p><a href="about:blank#%E2%91%A5Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">⑥Makefile<br>条件判断</a></p><p><a href="about:blank#%E2%91%A6Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">⑦Makefile<br>函数使用</a></p><hr><p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p><h2 id="一-Ubuntu-系统入门"><a href="#一-Ubuntu-系统入门" class="headerlink" title="一.Ubuntu 系统入门"></a>一.Ubuntu 系统入门</h2><pre><code>    在虚拟机上安装 Ubuntu 操作系统，安装好以后 Ubuntu 的设置、基本操作。想详细的学习 Ubuntu 系统的话可以参考《鸟哥的 linux 私房菜》这本书使用的 CentOS 操作系统，但是 Ubuntu 下完全可以使用。当 Ubuntu 系统入门以后，我们重点要学的就是如何在 Linux 下进行 C 语言开发，如何 使用 gcc 编译器、如何编写 Makefile 文件等等。如果此前已经使用过 Ubuntu 操作系统，并且从事过 Linux C 编程工作的话本篇就不需要看了。</code></pre><h3 id="1-VMware-创建虚拟机流程"><a href="#1-VMware-创建虚拟机流程" class="headerlink" title="1.VMware 创建虚拟机流程"></a>1.VMware 创建虚拟机流程</h3><h3 id="2-Ubuntu-系统入门"><a href="#2-Ubuntu-系统入门" class="headerlink" title="2.Ubuntu 系统入门"></a>2.Ubuntu 系统入门</h3><pre><code>    本章的主要目的是教会读者掌握后续嵌入式开发所需的 Ubuntu 基本技能，比如**系统的基本设置、常用的 shell 命令、vim 编辑器的基本操作** 等等，如果想详 细的学习 Ubuntu 操作系统请参考其它更为详细的书籍，本章参考了《Ubuntu Linux 从入门到 精通》</code></pre><h4 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="&lt;1&gt;Shell 命令"></a>&lt;1&gt;Shell 命令</h4><pre><code>    将多个 Shell 命令按照一定的格式放到一个文本中，那么这个文本就叫做 Shell 脚本。严格意义上来讲，Shell 是一个应用程序，它负责接收用户输入的命令，然后根据命令做出相应的动作，**Shell 负责将应用层或者用户输入的命令传递给系统内核，由操作系统内核来完成相应的工作，然后将结果反馈给应用层或者用户。**</code></pre><p><strong>Shell 命令的格式</strong> 如下：</p><pre><code>command -options [argument]</code></pre><p><strong>command</strong> : Shell 命令名称。</p><p><strong>options</strong> ：选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。</p><p><strong>argument</strong> ：Shell 命令是可以带参数的，也可以不带参数运行。</p><pre><code>    Shell 命令是**支持自动补全功能** 的，因为 Shell 命令非常多，如果不作自动补全的话就需要用户去记忆这些命令的全部字母。使用自动补全功能以后我们只需要输入命令的前面一部分字母，然后按下 **TAB 键** ，如果只有一个命令匹配的话就会自动补全这个命令剩下的字母。</code></pre><p><strong>常用 Shell 命令：</strong></p><h5 id="1、目录信息查看命令-ls"><a href="#1、目录信息查看命令-ls" class="headerlink" title="1、目录信息查看命令 ls"></a><strong>1、目录信息查看命令 ls</strong></h5><pre><code>ls [选项] [路径]主要参数有：-a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。-l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。-t 将文件按照创建时间排序列出。-A 和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。-R 递归列出所有文件，包括子目录中的文件。    Shell 命令里面的参数是可以组合在一起用的，比如组合“-al”就是显示所有文件的详细 信息，包括以“.”开头的隐藏文件。</code></pre><h5 id="2、目录切换命令-cd"><a href="#2、目录切换命令-cd" class="headerlink" title="2、目录切换命令 cd"></a><strong>2、目录切换命令 cd</strong></h5><pre><code>cd [路径]示例：cd / //进入到根目录“/”下，Linux 系统的根目录为“/”,cd /usr //进入到目录“/usr”里面。cd .. //进入到上一级目录。cd ~ //切换到当前用户主目录</code></pre><h5 id="3、当前路径显示命令-pwd"><a href="#3、当前路径显示命令-pwd" class="headerlink" title="3、当前路径显示命令 pwd"></a><strong>3、当前路径显示命令 pwd</strong></h5><h5 id="4、系统信息查看命令-uname"><a href="#4、系统信息查看命令-uname" class="headerlink" title="4、系统信息查看命令 uname"></a><strong>4、系统信息查看命令 uname</strong></h5><pre><code>uname [选项]可选的选项参数如下：-r 列出当前系统的具体内核版本号。-s 列出系统内核名称。-o 列出系统信息。</code></pre><h5 id="5、清屏命令-clear"><a href="#5、清屏命令-clear" class="headerlink" title="5、清屏命令 clear"></a><strong>5、清屏命令 clear</strong></h5><h5 id="6、切换用户执行身份命令-sudo"><a href="#6、切换用户执行身份命令-sudo" class="headerlink" title="6、切换用户执行身份命令 sudo"></a><strong>6、切换用户执行身份命令 sudo</strong></h5><pre><code>    Ubuntu(Linux)是一个允许多用户的操作系统，其中权限最大的就是**超级用户 root** ，有时候 我们执行一些操作的时候是需要用 root 用户身份才能执行，比如安装软件。通过 sudo 命令可以使我们暂时将身份切换到 root 用户。当使用 sudo 命令的时候是需要输入密码的，这里要注 意输入密码的时候是没有任何提示的！命令格式如下：sudo [选项] [命令]选项主要参数如下：-h 显示帮助信息。-l 列出当前用户可执行与不可执行的命令-p 改变询问密码的提示符。    假如我们现在要**创建一个新的用户 test** ，创建新用户的命令为“**adduser** ”，创建新用户的权限只有 root 用户才有，我们在装系统的时候创建的那个用户是没有这个权限的，比如我的 “zuozhongkai”用户。所以创建新用户的话需要使用“sudo”命令以 root 用户执行“adduser” 这个命令，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c242489236851475c5f139aaf39a0d35.png"></p><h5 id="7、添加用户命令-adduser"><a href="#7、添加用户命令-adduser" class="headerlink" title="7、添加用户命令 adduser"></a><strong>7、添加用户命令 adduser</strong></h5><pre><code>adduser [参数] [用户名]常用的参数如下：-system 添加一个系统用户-home DIR DIR 表示用户的主目录路径-uid ID ID 表示用户的 uid。-ingroup GRP 表示用户所属的组名。</code></pre><h5 id="8、删除用户命令-deluser"><a href="#8、删除用户命令-deluser" class="headerlink" title="8、删除用户命令 deluser"></a><strong>8、删除用户命令 deluser</strong></h5><pre><code>deluser [参数] [用户名]主要参数有：-system 当用户是一个系统用户的时候才能删除。-remove-home 删除用户的主目录-remove-all-files 删除与用户有关的所有文件。-backup 备份用户信息</code></pre><h5 id="9、切换用户命令-su"><a href="#9、切换用户命令-su" class="headerlink" title="9、切换用户命令 su"></a><strong>9、切换用户命令 su</strong></h5><pre><code>    **命令“su” 可以直接将当前用户切换为 root 用户** ，切换到 root 用户以后获得系统最高权限，在 root 用户下，所有的命令都可以无障碍执行，不需要在 前面加上“sudo”，“su”命令格式如下：su [选项] [用户名]常用选项参数如下：-c –command 执行指定的命令，执行完毕以后回复原用户身份。-login 改变用户身份，同时改变工作目录和 PATH 环境变量。-m 改变用户身份的时候不改变环境变量-h 显示帮助信息</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/06fd80a8ca5c2c4e5ad67b6fd8deac4c.png"></p><pre><code>    使用命令“sudo su”切换到 root 用户，su 命令不写明用户名的话默认 切换到 root 用户。然后输入密码，密码正确的话就会切换到 root 用户，可以看到切换到 root 用户以后提示符的“@”符号前面的用户名变成了“root”，表示当前的用户是 root 用户。并 且以“#”结束。    注意！！由于 **root 用户权限太大，稍微不注意就可能删除掉系统文件，导致系统奔溃** ， 因此强烈建议大家，**不要以 root 用户运行 Ubuntu** 。当要用到 root 身份执行某些命令的时候使用“sudo”命令即可。    要**切换回原来的用户** ，使用命令“**sudo su 用户名** ”即可。</code></pre><h5 id="10、显示文件内容命令-cat"><a href="#10、显示文件内容命令-cat" class="headerlink" title="10、显示文件内容命令 cat"></a><strong>10、显示文件内容命令 cat</strong></h5><pre><code>cat [选项] [文件]选项主要参数如下：-n 由 1 开始对所有输出的行进行编号。-b 和-n 类似，但是不对空白行编号。-s 当遇到连续两个行以上空白行的话就合并为一个行空白行。</code></pre><h5 id="11、显示和配置网络属性命令-ifconfig"><a href="#11、显示和配置网络属性命令-ifconfig" class="headerlink" title="11、显示和配置网络属性命令 ifconfig"></a><strong>11、显示和配置网络属性命令 ifconfig</strong></h5><pre><code>ifconfig interface options | address主要参数如下：interface 网络接口名称，比如 eth0 等。up 开启网络设备。down 关闭网络设备。add IP 地址，设置网络 IP 地址。netmask add 子网掩码。    在图中有两个网卡：ens33 和 lo，ens33 是我的电脑实际使用的网卡，lo 是回测网 卡。可以看出网卡 ens33 的 IP 地址为 192.168.31.235，我们使用命令“ifconfig”将网卡 ens33 的 IP 地址改为 192.168.31.20，操作如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7f7e119e714d7803c899b06b145c47c7.png"></p><h5 id="12、系统帮助命令-man"><a href="#12、系统帮助命令-man" class="headerlink" title="12、系统帮助命令 man"></a><strong>12、系统帮助命令 man</strong></h5><pre><code>man [命令名]</code></pre><p>按“q”键退出到终端。</p><h5 id="13、-系统重启命令-reboot"><a href="#13、-系统重启命令-reboot" class="headerlink" title="13、 系统重启命令 reboot"></a><strong>13、 系统重启命令 reboot</strong></h5><h5 id="14、系统关闭命令-poweroff"><a href="#14、系统关闭命令-poweroff" class="headerlink" title="14、系统关闭命令 poweroff"></a><strong>14、系统关闭命令 poweroff</strong></h5><h5 id="15、软件安装命令-install"><a href="#15、软件安装命令-install" class="headerlink" title="15、软件安装命令 install"></a><strong>15、软件安装命令 install</strong></h5><pre><code>格式如下：install [选项]... [-T] 源文件 目标文件或：install [选项]... 源文件... 目录或：install [选项]... -t 目录 源文件...或：install [选项]... -d 目录...    截至目前，我们都没有讲过 Ubuntu 下如何安装软件，因为 Ubuntu 安装软件不像 Windows 下那样，直接双击.exe 文件就开始安装了。Ubuntu 下很多软件是需要**先自行下载源码** ，下载源码以后**自行编译** ，**编译完成以后使用命令“intsall”来安装** 。当然 Ubuntu 下也有其它的软件安装方法，但是用的最多的就是自行编译源码然后安装，尤其是嵌入式Linux开发。    “install”命令是将文件(通常是编译后的文件)**复制到目的位置** ，在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录中同时设置其所有权和权限模式。在第四种形式会创建指定的目录。命令“install”通常和命令“apt-get”组合在一起使用的。</code></pre><h4 id="APT-下载工具"><a href="#APT-下载工具" class="headerlink" title="&lt;2&gt;APT 下载工具"></a>&lt;2&gt;APT 下载工具</h4><pre><code>    对于长时间使用 Windows 的我们，下载安装软件非常容易，Windows 下有很多的下载软 件，Ubuntu 同样有不少的下载软件，本节我们讲解 Ubuntu 下我们用的最多的下载工具：APT 下载工具，APT 下载工具可以实现软件**自动下载、配置、安装二进制或者源码** 的功能。APT 下载工具和我们前面讲解的“install”命令结合在一起构成了 Ubuntu 下最常用的下载和安装软件方法。它解决了 Linux 平台下一安装软件的一个缺陷，即**软件之间相互依赖** 。    APT 采用的 **C/S 模式** ，也就是**客户端/服务器模式** ，我们的 PC 机作为客户端，当需要下载软件的时候就向服务器请求，因此我们需要知道服务器的地址，也叫做安装源或者更新源。</code></pre><p>打开“软件和更新”设置，打开方式如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/523881d52264434de75ee6b79f8c8361.png"></p><pre><code>    在上图中的“Ubuntu 软件”选项卡下面的“下载自”就是 **APT 工具的安装源** ，因为我们是在中国，所以需要选择中国的服务器，否则的话可能会导致下载失败！这个也就是网上说的 Ubuntu 安装成功以后要更新源。    在我们使用 APT 工具下载安装或者更新软件的时候，首先会在下载列表中**与本机软件对比** ，看一下需要下载哪些软件，或者升级哪些软件，默认情况下 APT 会下载最新的软件包， 被安装的软件包**所依赖的其它软件也会被下载安装** 。说了这么多，APT 下载工具究竟怎么用呢？APT 工具常用的命令如下：</code></pre><h5 id="1、更新本地数据库"><a href="#1、更新本地数据库" class="headerlink" title="1、更新本地数据库"></a><strong>1、更新本地数据库</strong></h5><pre><code>sudo apt-get update</code></pre><p>这个命令会<strong>访问源地址，并且获取软件列表</strong> 并保存在本电脑上。如果想查看<strong>本地哪些软件可以更新</strong> 的话可以使用如下命令。</p><h5 id="2、检查依赖关系"><a href="#2、检查依赖关系" class="headerlink" title="2、检查依赖关系"></a><strong>2、检查依赖关系</strong></h5><pre><code>sudo apt-get check    有时候本地某些软件可能存在依赖关系，所谓依赖关系就是 A 软件依赖于 B 软件。通过 如下命令可以查看依赖关系，如果存在依赖关系的话 APT 会提出解决方案。</code></pre><h5 id="3、软件安装"><a href="#3、软件安装" class="headerlink" title="3、软件安装"></a><strong>3、软件安装</strong></h5><pre><code>sudo apt-get install package-name</code></pre><p>注：<strong>推荐使用 apt 替代 apt-get</strong></p><h5 id="4、软件更新"><a href="#4、软件更新" class="headerlink" title="4、软件更新"></a><strong>4、软件更新</strong></h5><pre><code>sudo apt-get upgrade package-name</code></pre><h5 id="5、卸载软件"><a href="#5、卸载软件" class="headerlink" title="5、卸载软件"></a><strong>5、卸载软件</strong></h5><pre><code>sudo apt-get remove package-name</code></pre><h4 id="Ubuntu-下文本编辑"><a href="#Ubuntu-下文本编辑" class="headerlink" title="&lt;3&gt;Ubuntu 下文本编辑"></a>&lt;3&gt;Ubuntu 下文本编辑</h4><pre><code>    Ubuut 下有一个自带的文本编辑器，那就是 Gedit。Gedit 是一个窗口式的编辑器，本节我们重点讲解的是另外一 个编辑器：VI/VIM 编辑器。    我们如果要在**终端模式下进行文本编辑** 或者修改文件就可以使用 VI/VIM 编辑器，Ubuntu 自带了 VI 编辑器。VIM 编辑 器是 VI 编辑器升级版本，VI/VIM 编辑器都是一种**基于指令式的编辑器** ，不需要鼠标，也没有菜单，仅仅**使用键盘来完成所有的编辑** 工作。</code></pre><p>安装 VIM 编辑器，命令如下：</p><pre><code>sudo apt-get install vim    VIM 编辑器有 3 中工作模式：**输入模式、指令 模式和底行模式** ，通过切换不同的模式可以完成不同的功能。    打开终端，输入命令：vi test.txt 。在终端中输入上图中所示的命令以后就会创建一个 test.txt 文档，并且用 VIM 打开了。VIM **默认是以只读模式打开的文档** ，因此我们要**切换到输入模式** ，切换到输入模式的命令如下：i 在当前光标所在字符的前面，转为输入模式I 在当前光标所在行的行首转换为输入模式a 在当前光标所在字符的后面，转为输入模式A 在光标所在行的行尾，转换为输入模式o 在当前光标所在行的下方，新建一行，并转为输入模式O 在当前光标所在行的上方，新建一行，并转为输入模式s 删除光标所在字符。 r 替换光标处字符    但是不能使用快捷键 Ctrl+S 来保存，这是因为在 Ubuntu 下 Ctrl+S 快捷 键不是用来完成保存的功能的，而是暂停该终端！所以你一旦在使用终端的时候按下 Ctrl+S 快捷键，那么你的终端肯定不会再有任何反应，如果你按下 **Ctrl+S 关闭了当前终端可以 按下 Ctrl+Q 来重新打开终端** 。    我们需要从 VIM 现在的**输入模式切换到指令模式** ，方式就是按下键盘的 **ESC** 键    指令模式顾名思义就是输入指令的模式，这些 指令是控制文本的指令，我们将这些指令进行分类，如下所示：1、移动光标指令：h(或左方向键) 光标左移一个字符。l(或右方向键) 光标右移一个字符。j(或下方向键) 光标下移一行。k(或上方向键) 光标上移一行。nG 光标移动到第 n 行首。n+ 光标下移 n 行。n- 光标上移 n 行。2、屏幕翻滚指令Ctrl+f 屏幕向下翻一页，相当于下一页。Ctrl+b 屏幕向上翻一页，相当于上一页。3、复制、删除和粘贴指令cc 删除整行，并且修改整行内容。dd 删除改行，不提供修改功能。ndd 删除当前行向下 n 行。x 删除光标所在的字符。X 删除光标前面的一个字符。nyy 复制当前行及其下面 n 行。p 粘贴最近复制的内容。    保存文档的命令是在**底行模式** 中，我们要先进入到指令模式，进入底行模式的方式是**先进入指令模式 下，然后在指令模式下输入“：”进入底行模式**</code></pre><p>常用的命令如下：</p><pre><code>x 保存当前文档并且退出。q 退出。w 保存文档。q! 退出 VI/VIM，不保存文档。</code></pre><p>如果我们要退出并保存文本的话需要在“：”底行模式下输入“wq”</p><pre><code>    还可以 在指令模式下**输入“/”进入底行模式** ，在“/”后面输入要**搜索** 的内容，然后按下回车键就会找到与字符串匹配的部分</code></pre><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="&lt;4&gt;文件系统"></a>&lt;4&gt;文件系统</h4><pre><code>    Linux 有多种文件系统，不同的文件系统支持不同的体系。文件系统是管理数 据的，而可以存储数据的物理设备有硬盘、U 盘、SD 卡、NAND FLASH、NOR FLASH、网 络存储设备等。不同的存储设备其物理结构不同，不同的物理结构就需要不同的文件系统去管 理，比如管理 NAND FLASH 的话使用 YAFFS 文件系统，管理硬盘、SD 卡的话就是 ext 文件 系统等等。    Windows 下一般有 FAT、NTFS 和 exFAT 这些文件系统。同样的，在 Linux 下我们使用 fdisk 创建好分区以后也是要先在创建好的分区 上面创建文件系统，也就是格式化。 在 Windows 下有磁盘分区的概念，比如 C，D，E 盘等，在 Linux 下没有这个概念，因此 Linux 下你找不到像 C、D、E 盘这样的东西。前面我们说了 Linux 下可以给磁盘分割，在 Linux 下创建一个分区并且格式化好以后我们要将 其“挂载”到一个目录下才能访问这个分区。Windows 的文件系统挂载过程是其内部完成的， 用户是看不到的，Linux 下我们使用 mount 命令来挂载磁盘。挂载磁盘的时候是需要确定挂载 点的，也就是你的这个磁盘要挂载到哪个目录下。    Linux 下的文件系统主要有 ext2、ext3、ext4 等文件系统。Linux 还支持其 他的 UNIX 文件系统，比如 XFS、JFS、UFS 等，也支持 Windows 的 FAT 文件系统和网络文 件系统 NFS 等。这里我们主要讲一下 Linux 自带的 ext2、ext3 和 ext4 文件系统。</code></pre><p>在终端中输入如下命令来查询当前磁盘挂载的是什么文件系统：</p><pre><code>df -T –h</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5e5c67fe02fe10eb124ecd486b2765bb.png"></p><h5 id="1-Linux-文件系统结构"><a href="#1-Linux-文件系统结构" class="headerlink" title="1.Linux 文件系统结构"></a>1.Linux 文件系统结构</h5><pre><code>    Linux 只有一个根目录“/”。Ubuntu 是支持多用户的，Ubuntu 为每个用户创建了一个根目录，只要你创建了一个用户，那么系统就会在/home 这个目录下创建一个以这个用户名命名的文件 夹，这个文件夹就是这个用户的根目录。</code></pre><p>我们来看一下根目录“&#x2F;”中的 一些重要的文件夹：</p><pre><code>/bin 存储一些二进制可执行命令文件，/usr/bin 也存放了一些基于用户的命令文件。/sbin 存储了很多系统命令，/usr/sbin 也存储了许多系统命令。/root 超级用户 root 的根目录文件。/home 普通用户默认目录，在该目录下，每个用户都有一个以本用户名命名的文件夹。/boot 存放 Ubuntu 系统内核和系统启动文件。/mnt 通常包括系统引导后被挂载的文件系统的挂载点。/dev 存放设备文件，我们后面学习 Linux 驱动主要是跟这个文件夹打交道的。/etc 保存系统管理所需的配置文件和目录。/lib 保存系统程序运行所需的库文件，/usr/lib 下存放了一些用于普通用户的库文件。/lost+found 一般为空，当系统非正常关机以后，此文件夹会保存一些零散文件。/var 存储一些不断变化的文件，比如日志文件/usr 包括与系统用户直接有关的文件和目录，比如应用程序和所需的库文件。/media 存放 Ubuntu 系统自动挂载的设备文件。/proc 虚拟目录，不实际存储在磁盘上，通常用来保存系统信息和进程信息。/tmp 存储系统和用户的临时文件，该文件夹对所有的用户都提供读写权限。/opt 可选文件和程序的存放目录。/sys 系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。</code></pre><h5 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h5><h6 id="1、创建新文件命令—touch"><a href="#1、创建新文件命令—touch" class="headerlink" title="1、创建新文件命令—touch"></a><strong>1、创建新文件命令—touch</strong></h6><pre><code>touch [参数] [文件名]使用 touch 创建文件的时候，如果[文件名]的文件不存在，那就直接创建一个以[文件名]命名的文件，如果[文件名]文件存在的话就仅仅修改一下此文件的最后修改日期，常用的命令参数如下：-a 只更改存取时间。-c 不建立任何文件。-d&lt;日期&gt; 使用指定的日期，而并非现在日期。-t&lt;时间&gt; 使用指定的时间，而并非现在时间。</code></pre><h6 id="2、文件夹创建命令—mkdir"><a href="#2、文件夹创建命令—mkdir" class="headerlink" title="2、文件夹创建命令—mkdir"></a>2、文件夹创建命令—mkdir</h6><pre><code>mkdir [参数] [文件夹名目录名]主要参数如下：-p 如所要创建的目录其上层目录目前还未创建，那么会一起创建上层目录。</code></pre><h6 id="3、文件及目录删除命令—rm"><a href="#3、文件及目录删除命令—rm" class="headerlink" title="3、文件及目录删除命令—rm"></a>3、文件及目录删除命令—rm</h6><pre><code>    要删除一个文件或者文件夹可以使用 命令“rm”，此命令可以完成删除一个文件或者多个文件及文件夹，它可以实现递归删除。 对于链接文件，只删除链接，原文件保持不变，所谓的链接文件，其实就是 Windows 下的快 捷方式文件，此命令格式如下：rm [参数] [目的文件或文件夹目录名]命令主要参数如下：-d 直接把要删除的目录的硬连接数据删成 0，删除该目录。-f 强制删除文件和文件夹(目录)。-i 删除文件或者文件夹(目录)之前先询问用户.-r 递归删除，指定文件夹(目录)下的所有文件和子文件夹全部删除掉。-v 显示删除过程。    直接使用命令“rm”是无法删除文件夹(目录)的，我们需要加上 参数“-rf”，也就是强制递归删除文件夹(目录)</code></pre><h6 id="4、文件夹-目录-删除命令—rmdir"><a href="#4、文件夹-目录-删除命令—rmdir" class="headerlink" title="4、文件夹(目录)删除命令—rmdir"></a>4、文件夹(目录)删除命令—rmdir</h6><p>它可以不加任何参数的删除掉指定的文件夹(目 录)，命令格式如下：</p><pre><code>rmdir [参数] [文件夹(目录)]命令主要参数如下：-p 删除指定的文件夹(目录)以后，若上层文件夹(目录)为空文件夹(目录)的话就将其一起删除。</code></pre><h6 id="5、文件复制命令—cp"><a href="#5、文件复制命令—cp" class="headerlink" title="5、文件复制命令—cp"></a>5、文件复制命令—cp</h6><pre><code>cp [参数] [源地址] [目的地址]主要参数描述如下：-a 此参数和同时指定“-dpR”参数相同-d 在复制有符号连接的文件时，保留原始的连接。-f 强行复制文件，不管要复制的文件是否已经存在于目标目录。-I 覆盖现有文件之前询问用户。-p 保留源文件或者目录的属性。-r 或-R递归处理，将指定目录下的文件及子目录一并处理</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fdd2b97a66de0166f090b556b64996c4.png"></p><pre><code>    通配符“*”，“*.c”就表示 test1 下的所有以“.c”结尾的文件，也就是 a.c 和 b.c。“../test2”中的“../”表示上级目录，因此“../test2”就是上级目录下的 test2 文件夹。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9edd7298f52909aee3caad55eb8418d.png"></p><h6 id="6、文件移动命令—mv"><a href="#6、文件移动命令—mv" class="headerlink" title="6、文件移动命令—mv"></a>6、文件移动命令—mv</h6><pre><code>mv [参数] [源地址] [目的地址]主要参数描述如下：-b 如果要覆盖文件的话覆盖前先进行备份。-f 若目标文件或目录与现在的文件重复，直接覆盖目标文件或目录。-I 在覆盖之前询问用户。</code></pre><h5 id="3-文件压缩和解压缩"><a href="#3-文件压缩和解压缩" class="headerlink" title="3.文件压缩和解压缩"></a>3.文件压缩和解压缩</h5><p>Ubuntu 下图形化以及命 令行这两种压缩和解压缩操作:</p><h6 id="1、图形化压缩和解压缩"><a href="#1、图形化压缩和解压缩" class="headerlink" title="1、图形化压缩和解压缩"></a>1、图形化压缩和解压缩</h6><p>在要压缩或者解压的文件上点击鼠标右键， 然后选择要进行的操作——压缩&#x2F;提取</p><h6 id="2、命令行进行文件的压缩和解压缩"><a href="#2、命令行进行文件的压缩和解压缩" class="headerlink" title="2、命令行进行文件的压缩和解压缩"></a>2、命令行进行文件的压缩和解压缩</h6><p>命令行下进行压缩和解压缩常用的命令有三个：zip、unzip 和 tar：</p><h6 id="①命令-zip"><a href="#①命令-zip" class="headerlink" title="①命令 zip"></a>①命令 zip</h6><p>zip 命令是针对.zip 文件的，用于将一个或者多个文件压缩成一个.zip 结尾的文件，格式如下：</p><pre><code>zip [参数] [压缩文件名.zip] [被压缩的文件]主要参数函数如下：-b&lt;工作目录&gt; 指定暂时存放文件的目录。-d 从 zip 文件中删除一个文件。-F 尝试修复已经损毁的压缩文件。-g 将文件压缩入现有的压缩文件中，不需要新建压缩文件。-h 帮助。-j 只保存文件的名，不保存目录。-m 压缩完成以后删除源文件。-n&lt;字尾符号&gt; 不压缩特定扩展名的文件。-q 不显示压缩命令执行过程。-r 递归压缩，将指定目录下的所有文件和子目录一起压缩。-v 显示指令执行过程。-num 压缩率，为 1~9 的数值。</code></pre><p>使用 zip 命令进行 test2 文件夹的压缩，我们使用的命令如下： zip -rv test2.zip test2</p><h6 id="②命令-unzip"><a href="#②命令-unzip" class="headerlink" title="②命令 unzip"></a>②命令 unzip</h6><pre><code>unzip [参数] [压缩文件名.zip]主要参数如下：-l 显示压缩文件内所包含的文件。-t 检查压缩文件是否损坏，但不解压。-v 显示命令显示的执行过程。-Z 只显示压缩文件的注解。-C 压缩文件中的文件名称区分大小写。-j 不处理压缩文件中的原有目录路径。-L 将压缩文件中的全部文件名改为小写。-n 解压缩时不要覆盖原有文件。-P&lt;密码&gt; 解压密码。-q 静默执行，不显示任何信息。-x&lt;文件列表&gt; 指定不要处理.zip 中的哪些文件。-d&lt;目录&gt; 把压缩文件解到指定目录下。</code></pre><h6 id="③命令-tar"><a href="#③命令-tar" class="headerlink" title="③命令 tar"></a>③命令 tar</h6><pre><code>    Linux 下最常用的.bz2 和.gz 这两种压缩格式。其它格式的压缩和解压使用 命令 tar，tar 将压缩和解压缩集合在一起，使用不同的参数即可，命令格式如下：tar [参数] [压缩文件名] [被压缩文件名]常用参数如下：-c 创建新的压缩文件。-C&lt;目的目录&gt; 切换到指定的目录。-f&lt;备份文件&gt; 指定压缩文件。-j 用 tar 生成压缩文件，然后用 bzip2 进行压缩。-k 解开备份文件时，不覆盖已有的文件。-m 还原文件时，不变更文件的更改时间。-r 新增文件到已存在的备份文件的结尾部分。-t 列出备份文件内容。-v 显示指令执行过程。-w 遭遇问题时先询问用户。-x 从备份文件中释放文件，也就是解压缩文件。-z 用 tar 生成压缩文件，用 gzip 压缩。-Z 用 tar 生成压缩文件，用 compress 压缩。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e5e7cf4b3d0a2d1d46d57f90bd86a38.png"></p><p>在上面命令中，-vcjf 表示创建 bz2 格式的压缩文件，-vczf 表示创建.gz 格式的压缩文 件。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cac42b4dab88584feb7f441772bd694.png"></p><pre><code>    上述两行命令中，-vxjf 用来完成.bz2 格式压缩文件的解压，-vxzf 用来完成.gz 格式压缩文 件的解压。要熟练掌握使用 tar 命令来完成.bz2 和.gz 格式的文件压缩和解压缩。</code></pre><h5 id="4-文件查询和搜索"><a href="#4-文件查询和搜索" class="headerlink" title="4.文件查询和搜索"></a>4.文件查询和搜索</h5><pre><code>    在嵌入式 Linux 开发中常常需要在 Linux 源码文件中查询某个**文件是否存在** ，或者搜索哪些文件都**调用了某个函数** 等等。本节我们就讲解两个最 常用的文件查询和搜索命令：**find** 和 **grep** 。</code></pre><h6 id="1、命令-find"><a href="#1、命令-find" class="headerlink" title="1、命令 find"></a>1、命令 find</h6><p>find 命令用于在目录结构中查找文件，其命令格式如下：</p><pre><code>find [路径] [参数] [关键字]路径是要查找的目录路径，如果不写的话表示在当前目录下查找，关键字是文件名的一部分，主要参数如下：-name&lt;filename&gt; 按照文件名称查找，查找与 filename 匹配的文件，可使用通配符。-depth 从指定目录下的最深层的子目录开始查找。-gid&lt;群组识别码&gt; 查找符合指定的群组识别码的文件或目录。-group&lt;群组名称&gt; 查找符合指定的群组名称的文件或目录。-size&lt;文件大小&gt; 查找符合指定文件大小的文件。-type&lt;文件类型&gt; 查找符合指定文件类型的文件。-user&lt;拥有者名称&gt;查找符合指定的拥有者名称的文件或目录。find 命令的参数有很多，常用的就这些，关于其它的参数大家可以自行上网查找</code></pre><h6 id="2、命令-grep"><a href="#2、命令-grep" class="headerlink" title="2、命令 grep"></a>2、命令 grep</h6><pre><code>    **在文件中搜索一串关键字** ，grep 就是完 成这个功能的，grep 命令用于查找包含指定关键字的文件，如果发现某个文件的内容包含所指 定的关键字，grep 命令就会把包含指定关键字的这一行标记出来，grep 命令格式如下：grep [参数] 关键字 文件列表grep 命令一次只能查一个关键字，主要参数如下：-b 在显示符合关键字的那一列前，标记处该列第 1 个字符的位编号。-c 计算符合关键字的列数。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用此参数！否则 grep 指令将回报信息并停止搜索。-i 忽略字符大小写。-v 反转查找，只显示不匹配的行。-r 在指定目录中递归查找。</code></pre><h5 id="5-文件类型"><a href="#5-文件类型" class="headerlink" title="5.文件类型"></a>5.文件类型</h5><p>使用命令“ls -l”来查看用户根目录下所有文件的详细信息</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9775c00441c48eb60dac4172e8a138aa.png"></p><p>在上图中，每个文件的详细信息占一行，每行最前面都是一个符号就标记了当前文件类型， 比如 test1 的第一个字符是“d”，test1.tar.bz2<br>文件第一个字符是“-”。这些字符表示的文件类型如下：</p><pre><code>- 普通文件，一些应用程序创建的，比如文档、图片、音乐等等。d 目录文件。c 字符设备文件，Linux 驱动里面的字符设备驱动，比如串口设备，音频设备等。b 块设备文件，存储设备驱动，比如硬盘，U 盘等。l 符号连接文件，相当于 Windwos 下的快捷方式。s 套接字文件。p 管道文件，主要指 FIFO 文件。</code></pre><p>后面学习 <strong>Linux 驱动开发</strong> 的时候基本是在和<strong>字符设备文件</strong> 和<strong>块设备文件</strong> 打交道。</p><h4 id="Linux-用户权限管理"><a href="#Linux-用户权限管理" class="headerlink" title="&lt;5&gt;Linux 用户权限管理"></a>&lt;5&gt;Linux 用户权限管理</h4><h6 id="1-Ubuntu-用户系统"><a href="#1-Ubuntu-用户系统" class="headerlink" title="1.Ubuntu 用户系统"></a>1.Ubuntu 用户系统</h6><pre><code>    装系统的时候创建的用户其权限比后面创建的用户大一点，但是没有 root 用户权限大， Ubuntu 下用户类型分为以下 3 类：</code></pre><p>● 初次创建的用户，此用户可以完成比普通用户更多的功能。</p><p>● root 用户，系统管理员，拥有所有权利。</p><p>● 普通用户，安装完操作系统以后被创建的用户。</p><pre><code>    以上三种用户，每个用户都有一个 ID 号，称为 UID，操作系统通过 UID 来识别是哪个用 户，用户相关信息可以在文件/etc/passwd 中查看到</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/771a5136f3710899083fa41699d937ad.png"></p><pre><code>    从配置文件 passwd 中可以看到，每个用户名后面都有两个数字，比如用户“zuozhongkai” 后面“1000:1000”，第一个数字是用户的 ID，另一个是用户的 GID，也就是用户组 ID。Ubuntu 里面每个用户都属于一个用户组里面，用户组就是一组有相同属性的用户集合。</code></pre><h6 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h6><pre><code>    对于嵌入式开发一般不关注**用户的权限问题** ，因为嵌入式基本是单用户，做嵌入式开发重点关注的是**文件的权限问题** 。 对于一个文件通常有三种权限：**读(r)、写(w)和执行(x)** ，使用命令“**ls -l** ”可以查看某个目 录下所有文件的权限信息，如：-rw-rw-r-- 1 zuozhongkai zuozhongkai 0 12 月 25 20:44 test.c    其中“-rw-rw-r--”表示**文件权限与用户和用户组之间的关系** ，第一位表示文件类型，上一 小节已经说了。剩下的 9 位**以 3 位为一组** ，**分别表示文件拥有者的权限，文件拥有者所在用户组的权限以及其它用户权限** 。后面的**“zuozhongkai zuozhongkai”分别代表文件拥有者(用户) 和该用户所在的用户组** ，因此文件 test.c 的权限情况如下：    ①、文件 test.c 的拥有者是用户 zuozhongkai，其对文件 tesst.c 的权限是“rw-”，也就是 对该文件拥有读和写两种权限。    ②、用户 zuozhongkai 所在的用户组也叫做 zuozhongkai，其组内用户对于文件 test.c 的权 限是“rw-”，也是拥有读和写这两种权限。             ③、其它用户对于文件 test.c 的权限是“r--”，也就是只读权限。 对于文件，可读权限表示可以打开查看文件内容，可写权限表示可以对文件进行修改，可执行权限就是可以运行此文件(如果是软件的话)。对于文件夹，拥有可读权限才可以使用命令 ls 查看文件夹中的内容，**拥有可执行权限才能进入到文件夹内部** 。    除了用 r、w 和 x 表示以外， 我们也可以使用二进制数表示，三种权限就可以使用 3 位二进制数来表示，一种权限对应一个 二进制位，如果该位为 1 就表示具备此权限，如果该位为 0 就表示没不具备此权限，如下表所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f81b8eae64f7d2e4f654d3232de0e342.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/15a31e64d77cb241198b539487d3ea6c.png"></p><pre><code>    前面的文件 test.c 其权限为“rw-rw-r--”，因此其十进制表示就是：664。    另外我们也开始使用 a、u、g 和 o 表示文件的归属关系，用=、+和-表示文件权限的变化， 如下表所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3ca28a83c1229c2b850b18f568c0c362.png"></p><pre><code>    对于文件 test.c，我们想要修改其归属用户(zuozhongkai)对其拥有可执行权限，那么就可以 使用：u+x。如果希望设置归属用户及其所在的用户组都对其拥有可执行权限就可以使用：gu+x。</code></pre><h6 id="3-权限管理命令"><a href="#3-权限管理命令" class="headerlink" title="3.权限管理命令"></a>3.权限管理命令</h6><pre><code>    可以使用 Shell 来操作文件的权限管理，主要用到“chmod”和“chown”这两个命令：</code></pre><h6 id="1、权限修改命令-chmod"><a href="#1、权限修改命令-chmod" class="headerlink" title="1、权限修改命令 chmod"></a>1、权限修改命令 chmod</h6><pre><code>    命令“chmod”用于修改**文件或者文件夹的权限** ，权限可以使用前面讲的数字表示也可以 使用字母表示，命令格式如下：chmod [参数] [文件名/目录名]主要参数如下：-c 效果类似“-v”参数，但仅回显更改的部分。-f 不显示错误信息。-R 递归处理，指定目录下的所有文件及其子文件目录一起处理。-v 显示指令的执行过程。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3045966479f706fd2acc5cde644c1850.png"></p><pre><code>    在上图中，我们修改文件 test 的权限为 766，修改完成以后的 test 文件权限为“rwxrw-rw-”， 和我们设置的一样，说明权限修改成功。上面我们是通过数字来修改权限的，我们接下来使用字母来修改权限，操作如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bd35ca1b6e1e1629e108c746630441f.png"></p><pre><code>    上面两个例子都是修改文件的权限，接下来我们修改文件夹的权限，新建一个 test 文件夹， 在文件夹 test 里面创建 a.c、b.c 和 c.c 三个文件，test 文件夹下的文件 a.c、b.c 和 c.c 的权限均为“rw-rw-r--”，我们将 test 文件夹 下的所有文件权限都改为“rwxrwxrwx”，也就是数字 777，操作如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f7b16b3540313a758a86add48c277a8.png"></p><h6 id="2、文件归属者修改命令-chown"><a href="#2、文件归属者修改命令-chown" class="headerlink" title="2、文件归属者修改命令 chown"></a>2、文件归属者修改命令 chown</h6><p>命令 chown 用来修改某个文件或者目录的归属者用户或者用户组，命令格式如下：</p><pre><code>chown [参数] [用户名.&lt;组名&gt;] [文件名/目录]其中[用户名.&lt;组名&gt;]表示要将文件或者目录改为哪一个用户或者用户组，用户名和组名用“.”隔开，其中用户名和组名中的任何一个都可以省略，命令主要参数如下：-c 效果同-v 类似，但仅回显更改的部分。-f 不显示错误信息。-h 只对符号连接的文件做修改，不改动其它任何相关的文件。-R 递归处理，将指定的目录下的所有文件和子目录一起处理。-v 显示处理过程。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7241a6cc8931d0f72cc27bb10effe8c.png"></p><h4 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="&lt;6&gt;Linux 磁盘管理"></a>&lt;6&gt;Linux 磁盘管理</h4><h5 id="1-Linux-磁盘管理基本概念"><a href="#1-Linux-磁盘管理基本概念" class="headerlink" title="1.Linux 磁盘管理基本概念"></a>1.Linux 磁盘管理基本概念</h5><pre><code>    Linux 的磁盘管理体系和 Windows 有很大的区别，在 Windows 下经常会遇到“分区”这个概念，在 Linux 中一般不叫“分区”而叫**“挂载点”** 。 “挂载点”就是将一个硬盘的一部 分做成文件夹的形式，这个文件夹的名字就是“挂载点”，不管在哪个发行版的 Linux 中，用 户是绝对看到不到 C 盘、D 盘这样的概念的，只能看到以文件夹形式存在的“挂载点”。</code></pre><p>文件&#x2F;etc&#x2F;fstab 详细的记录了 Ubuntu 中硬盘分区的情况：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a3bc3e97a3d219def7e1c541dbed467.png"></p><pre><code>    “/ was on /dev/sda1 during installation”，意思是根目录“/”是在/dev/sda1 上的，其中“/”是挂载点，**“/dev/sda1”就是我们装 Ubuntu 系统的硬盘** 。由于我们的系统是安装在虚拟机中的，因此图 中没有出现实际的硬盘。可以通过如下命令查看当前系统中的磁盘：ls /dev/sd*</code></pre><p>上述命令就是打印出所有以&#x2F;dev&#x2F;sd 开头的设备文件</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cec4bbd0cada4073445feeeb68007f2f.png"></p><pre><code>    在图中有四个磁盘设备文件，其中**sd 表示是 SATA 硬盘或者其它外部设备** ，最后面的数字表示该**硬盘上的第 n 个分区** ，比如/dev/sda1 就表示磁盘 sda 上的第一个分区。图中都是以/dev/sda 开头的，说明当前只有一个硬盘。如果再插上 U 盘、SD 卡啥的就可能会出 现/dev/sdb，/dev/sdc 等等。如果你的 U 盘有两个分区那么可能就会出现/dev/sdb1、dev/sdb2 这 样的设备文件。比如我现在插入我的 U 盘，插入 U 盘会提示 U 盘是接到主机还是虚拟机</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7293b9ea5d13716ed4cf99bf1a73f2a0.png"></p><h5 id="2-磁盘管理命令"><a href="#2-磁盘管理命令" class="headerlink" title="2.磁盘管理命令"></a>2.磁盘管理命令</h5><h6 id="1、磁盘分区命令-fdisk"><a href="#1、磁盘分区命令-fdisk" class="headerlink" title="1、磁盘分区命令 fdisk"></a>1、磁盘分区命令 fdisk</h6><p>如果要对某个磁盘进行分区，可以使用命令 fdisk，命令格如下：</p><pre><code>fdisk [参数]主要参数如下：-b&lt;分区大小&gt; 指定每个分区的大小。-l 列出指定设备的分区表。-s&lt;分区编号&gt; 将指定的分区大小输出到标准的输出上，单位为块。-u 搭配“-l”参数，会用分区数目取代柱面数目，来表示每个分区的起始地址。    比如我要对 U 盘进行分区，**千万不要对自己装 Ubuntu 系统进行分区！！！** 可以使用如下命令：sudo fdisk /dev/sdb</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b79740fbfb552d056496462ceab27102.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42ca5bc370ae284b9d794f1b74a1eff.png"></p><p>p 显示现有的分区</p><p>n 建立新分区</p><p>t 更改分区类型</p><p>d 删除现有的分区</p><p>a 更改分区启动标志</p><p>w 对分区的更改写入到硬盘或者存储器中</p><p>q 不保存退出</p><h6 id="2、格式化命令-mkfs"><a href="#2、格式化命令-mkfs" class="headerlink" title="2、格式化命令 mkfs"></a>2、格式化命令 mkfs</h6><pre><code>    使用命令 fdisk 创建好一个分区以后，我们需要对其格式化，也就是在这个分区上创建一 个文件系统，Linux 下的格式化命令为 mkfs，命令格式如下：mkfs [参数] [-t 文件系统类型] [分区名称]主要参数如下：fs 指定建立文件系统时的参数-V 显示版本信息和简要的使用方法。-v 显示版本信息和详细的使用方法。</code></pre><p>比如我们要格式化 U 盘的分区&#x2F;dev&#x2F;sdb1 为 FAT 格式，那么就可以使用如下命令：</p><pre><code>mkfs –t vfat /dev/sdb1</code></pre><h6 id="3、挂载分区命令-mount"><a href="#3、挂载分区命令-mount" class="headerlink" title="3、挂载分区命令 mount"></a>3、挂载分区命令 mount</h6><pre><code>    我们需要将/dev/sdb1 这个**分区挂载到一个文件夹中，然后通过这个文件访问 U 盘** ， 磁盘挂载命令为 mount，命令格式如下：mount [参数] -t [类型] [设备名称] [目的文件夹]命令主要参数有：-V 显示程序版本。-h 显示辅助信息。-v 显示执行过程详细信息。-o ro 只读模式挂载。-o rw 读写模式挂载。-s-r 等于-o ro。-w 等于-o rw。    一般我们把挂载点放到“/mnt” 目录下，在“/mnt”下创建一个 tmp 文件夹，然后将 U 盘的/dev/sdb1 分区挂载到/mnt/tmp 文 件夹里面，操作如图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07d3a057fe42131964d315015bc0a845.png"></p><h6 id="4、卸载命令-umount"><a href="#4、卸载命令-umount" class="headerlink" title="4、卸载命令 umount"></a>4、卸载命令 umount</h6><pre><code>    当我们不在需要访问已经挂载的 U 盘，可以通过 umount 将其从卸载点卸除，命令格式如下：umount [参数] -t [文件系统类型] [设备名称]-a 卸载/etc/mtab 中的所有文件系统。-h 显示帮助。-n 卸载时不要将信息存入到/etc/mtab 文件中-r 如果无法成功卸载，则尝试以只读的方式重新挂载。-t &lt;文件系统类型&gt; 仅卸载选项中指定的文件系统。-v 显示执行过程。    上面我们将 U 盘挂载到了文件夹/mnt/tmp 里面，这里我们使用命令 umount 将其卸载掉， 操作如图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4d8dc86df68eec73b0027777819655.png"></p><h3 id="3-Linux-C-编程入门"><a href="#3-Linux-C-编程入门" class="headerlink" title="3.Linux C 编程入门"></a>3.Linux C 编程入门</h3><pre><code>    Ubuntu 下也有一些可以进行编程的工具，但是大多都只是编辑 器，也就是只能进行代码编辑，如果要编译的话就需要用到 **GCC 编译器** ，使用 GCC 编译器 肯定就要接触到 **Makefile** 。本章就讲解如何在 Ubuntu 下进行 C 语言的编辑和编译、GCC 和 Makefile 的使用和编写。    代码编写工具很多，比如 VIM 编辑器、Emacs 编辑器、VScode 编辑器等等，本教程使用 Ubuntu 自带的 VIM 编辑器。</code></pre><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="&lt;1&gt;编写代码"></a>&lt;1&gt;编写代码</h4><p>首先设置 TAB 键为 4 字节</p><pre><code>    VI 编辑器默认 TAB 键为 8 空格，我们改成 4 空格，用 vi 打开文件/etc/vim/vimrc，在此文件最后面输入如下代码：set ts=4</code></pre><p>接着设置 VIM 编辑器显示行号：</p><pre><code>set nu</code></pre><p>然后使用vim编写代码保存。</p><h4 id="编译代码"><a href="#编译代码" class="headerlink" title="&lt;2&gt;编译代码"></a>&lt;2&gt;编译代码</h4><p>Ubuntu 下的 C 语言编译器是 GCC，GCC 编译器在我们安装 Ubuntu 的时候就已经默认安 装好了，可以通过如下命令查看 GCC<br>编译器的版本号：</p><pre><code>gcc -v    如果输入命令“gcc -v”命令以后，你的终端输出信息，那么说明你 的电脑已经有 GCC 编译器了。最后下面的“gcc version 5.4.0”说明本机的 GCC 编译器版本为 5.4.0 的。注意观察在图 3.1.2.1 中有**“Target: x86_64-linux-gnu”** 一行，这说明 Ubuntu 自带的 GCC 编译器是针对 X86 架构的，因此只能编译在 X86 架构 CPU 上运行的程序。如果想要编译在 ARM 上运行的程序就需要针对 ARM 架构的 GCC 编译器，也就是**交叉编译器** ！我们进行 ARM 开发，因此肯定要安装**针对 ARM 架构的 GCC 交叉编译器** ，当然了，这是后面的事， 现在我们不用管这些，只要知道不同的目标架构，其 GCC 编译器是不同的。    如何使用 GCC 编译器来编译 main.c 文件呢？GCC 编译器是命令模式的，因此需要输入命 令来使用 gcc 编译器来编译文件，输入如下命令：gcc main.c -o main    我们使用“gcc main.c –o main”来编译 main.c 文件，使用参数“-o”来指 定编译生成的可执行文件名字。</code></pre><h4 id="GCC-编译器"><a href="#GCC-编译器" class="headerlink" title="&lt;3&gt;GCC 编译器"></a>&lt;3&gt;GCC 编译器</h4><h5 id="1、gcc-命令格式如下："><a href="#1、gcc-命令格式如下：" class="headerlink" title="1、gcc 命令格式如下："></a>1、gcc 命令格式如下：</h5><pre><code>gcc [选项] [文件名字]主要选项如下：-c 只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。-o&lt;输出文件名&gt; 用来指定编译结束以后的输出文件名，如果不使用这个选项的话 GCC默认编译出来的可执行文件名字为 a.out。-g 添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编译的时候生成调试所需的符号信息。-O 对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进行优化，这样产生的可执行文件执行效率就高。-O2 比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。</code></pre><h5 id="2、编译流程"><a href="#2、编译流程" class="headerlink" title="2、编译流程"></a>2、编译流程</h5><pre><code>    GCC 编译器的编译流程是：**预处理、汇编、编译和链接** 。预处理就是对程序中的宏定义等相关的内容先进行前期的处理。汇编是先将 C 文件转换为汇编文件。当 C 文件转换为汇编文件以后就是文件编译了，**编译过程就是将 C 源文件编译成.o 结尾的目标文件** 。编译生成的.o 文件不能直接执行，而是需要最后的链接，如果你的工程有很多个 c 源文件的话最终就会有很多.o 文件，将这些**.o 文件链接在一起形成完整的一个可执行文件** 。</code></pre><h4 id="Makefile-基础"><a href="#Makefile-基础" class="headerlink" title="&lt;4&gt;Makefile 基础"></a>&lt;4&gt;Makefile 基础</h4><h6 id="1、Makefile-简介"><a href="#1、Makefile-简介" class="headerlink" title="1、Makefile 简介"></a>1、Makefile 简介</h6><pre><code>    当文件数量很多时用终端输入 GCC 命令的方法显然是不现实的。编写一个文件，这个文件描述了编译哪些源码文件、如何编译，每次需要编译工程的时只需要使用这个文件就行了，为此提出了一个 解决**大工程编译的工具** ：**Make** ，**描述哪些文件需要编译、哪些需要重新编译的文件** 就叫做 **Makefile** ，Makefile 就跟脚本文件一样，Makefile 里面还可以执行系统命令。使用的时候只需要一个 make 命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。如果大家以 前一直使用 IDE 来编写 C 语言的话肯定没有听说过 Makefile 这个东西，其实这些 IDE 是有的， 只不过这些 **IDE 对其进行了封装** ，提供给大家的是已经经过封装后的图形界面了，我们在 IDE 中添加要编译的 C 文件，然后点击按钮就完成了编译。在 Linux 下用的最多的是 GCC 编译器， 这是个没有 UI 的编译器，因此 Makefile 就需要我们自己来编写了。作为一个专业的程序员， 是一定要懂得 Makefile 的，一是因为在 Linux 下你不得不懂 Makefile，再就是通过 Makefile 你就能了解整个工程的处理过程。如果想详细的研究 Makefile，推荐阅读《跟我一起写 Makefile》这份文档。</code></pre><h6 id="2、Makefile-的引入"><a href="#2、Makefile-的引入" class="headerlink" title="2、Makefile 的引入"></a>2、Makefile 的引入</h6><pre><code>    我们完成这样一个小工程，在这个工程中我们有 main.c、input.c 和 calcu.c 这三个 C 文件和 input.h、calcu.h 这两个头文件。其中 main.c 是主体。接下来使用 gcc 的方法来对其进行编译， 在终端输入如下命令：gcc main.c calcu.c input.c -o main   如果有一个文件被修改了，使用上面的命令编译的时候所有的文件都会重新编译。最好的办法肯定是哪个文件被修改了，只编译这个修改的文件即可，其它没有修改的文件就不需要再次重新编译了，为此我们改变我们的编译方法，如果第一次编译工程，我们先将工程中的文件都编译一遍，然后后面修改了哪个文件就编译哪个文件， 命令如下：gcc -c main.cgcc -c input.cgcc -c calcu.cgcc main.o input.o calcu.o -o main    上述命令前三行分别是将 main.c、input.c 和 calcu.c 编译成对应的.o 文件，所以使用了“-c” 选项，**“-c”选项我们上面说了，是只编译不链接** 。最后一行命令是将编译出来的所有.o 文件链接成可执行文件 main。假如我们现在修改了 calcu.c 这个文件，**只需要将 caclue.c 这一个文 件重新编译成.o 文件，然后再将所有的.o 文件链接成可执行文件** ，只需要下面两条命令即可：gcc -c calcu.cgcc main.o input.o calcu.o -o main    但是这样就又有一个问题，如果修改的文件一多，会非常麻烦，为此我们需要这样一个工具：</code></pre><p>1、如果工程没有编译过，那么工程中的所有.c 文件都要被编译并且链接成可执行程序。</p><p>2、如果工程中只有个别 C 文件<strong>被修改</strong> 了，那么<strong>只编译这些被修改的 C 文件即可</strong> 。</p><p>3、如果工程的<strong>头文件被修改了，那么我们需要编译所有引用这个头文件的 C 文件</strong> ，并且 链接成可执行文件。</p><pre><code>    很明显，能够完成这个功能的就是 Makefile 了，在工程目录下创建名为“Makefile”的文件， 文件名**一定要叫做“Makefile”！！！区分大小写** ！    Makefile 和 C 文件可以处于同一个目录的，在 Makefile 文件中输入如下代码：main: main.o input.o calcu.o    gcc -o main main.o input.o calcu.omain.o: main.c    gcc -c main.cinput.o: input.c    gcc -c input.ccalcu.o: calcu.c    gcc -c calcu.cclean:    rm *.o    rm main    上述代码中所有行首需要空出来的地方一定要**使用“TAB”键！不要使用空格键！** 这是 Makefile 的语法要求。**（可以看出这里的Makefile文件类似于脚本，把所有文件编译指令集合）**    Makefile 编写好以后我们就可以使用 Make 命令来编译我们的工程了，直接在命令行中输 入“make”即可，Make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在 的话就会按照 Makefile 里面定义的编译方式进行编译。    使用命令“Make”编译完成以后就会在当前工程目录下生成各种.o 和可执行文件，说明我们编译成功了。使用 make 命令编译工程的时候可能会提示如图所示错误:</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/272c8273e54202132793b1944a9cab74.png"></p><p>错误来源一般有两点:</p><p>1、Makefile 中命令缩进没有使用 TAB 键！</p><p>2、VI&#x2F;VIM 编辑器使用空格代替了 TAB 键，修改文件&#x2F;etc&#x2F;vim&#x2F;vimrc，在文件最后面加上 如下所示代码：</p><pre><code>set noexpandtab    之后再输入make指令只会重新编译被修改的文件和最后的可执行文件，其它没有修改过的文件就没有编译。</code></pre><h6 id="3、Makefile-语法"><a href="#3、Makefile-语法" class="headerlink" title="3、Makefile 语法"></a>3、Makefile 语法</h6><h6 id="①Makefile-规则格式"><a href="#①Makefile-规则格式" class="headerlink" title="①Makefile 规则格式"></a>①Makefile 规则格式</h6><p>Makefile 里面是由一系列的<strong>规则</strong> 组成的，这些规则格式如下：</p><pre><code>目标…... : 依赖文件集合……    命令 1    命令 2    ……</code></pre><p>比如下面这条规则：</p><pre><code>main : main.o input.o calcu.o    gcc -o main main.o input.o calcu.o    这条规则的**目标** 是 main，main.o、input.o 和 calcu.o 是生成 main 的**依赖文件** ，如果要更新 目标 main，就必须要先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目 标也必须更新，“更新”就是执行一遍规则中的**命令列表** 。    命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ make 命令会为 Makefile 中的每个**以 TAB 开始的命令创建一个 Shell 进程去执行** 。    在之前的代码中一共有 5 条规则，1~2 行为第一条规则，3~4 行为第二条规则，5~6 行为第三 条规则，7~8 行为第四条规则，10~12 为第五条规则，make 命令在执行这个 Makefile 的时候其执行步骤如下：   **  首先更新第一条规则中的 main**，第一条规则的目标成为**默认目标** ，**只要默认目标更新了那么就完成了 Makefile 的工作** ，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行。    第一条规则依赖于文件 main.o、input.o 和 calcu.o 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make 会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为**“gcc –c main.c”** ，这行命令很熟悉了 吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。    最后一个规则目标是 clean， 它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令**“make clean”** ，**执行以后就会删除当前目录下所有的.o 文件以及 main** ，因此 clean 的功能就是完成**工程的清理** 。</code></pre><p>我们在来总结一下 Make 的执行过程：</p><ol><li><p>make 命令会在当前目录下查找以 Makefile(makefile 其实也可以)命名的文件。</p></li><li><p>当找到 Makefile 文件以后就会<strong>按照 Makefile 中定义的规则去编译</strong> 生成最终的目标文件。</p></li><li><p>当发现目标文件<strong>不存在</strong> ，或者目标<strong>所依赖的文件比目标文件新</strong>(也就是最后修改时间比目标文件晚)的话就会<strong>执行后面的命令来更新目标</strong> 。</p><pre><code> **除了 Makefile 的“终极目标”所在的规则以外，其它规则的顺序在 Makefile 中是没有意义的** ，“终极目标”就是指在使用 make 命令的时候没有指定具体的目标时，make 默认的那个目标，它是 Makefile 文件中**第一个规则** 的目标，如果 Makefile 中的第一个规则有多个目标， 那么这些目标中的**第一个目标** 就是 make 的“终极目标”。</code></pre></li></ol><h6 id="②Makefile-变量"><a href="#②Makefile-变量" class="headerlink" title="②Makefile 变量"></a>②Makefile 变量</h6><p>跟 C 语言一样 Makefile 也支持变量的，先看一下前面的例子：</p><pre><code> main: main.o input.o calcu.o     gcc -o main main.o input.o calcu.o    上述 Makefile 语句中，main.o input.o 和 calcue.o 这三个依赖文件，我们输入了两遍，我们 这个 Makefile 比较小，如果 Makefile 复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile 加入了**变量支持** 。Makefile 中的变量都是**字符串** ！**类似 C 语言中的宏** 。使用变量将上面的代码修改，修改以后如下所示：#Makefile 变量的使用objects = main.o input.o calcu.omain: $(objects)    gcc -o main $(objects)    第 1 行是注释，Makefile 中可以写注释，**注释开头要用符号“#”** ，第 2 行我们定义了一个变量 objects， 并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行使用到了变 量 objects，Makefile 中**变量的引用方法是“$(变量名)”** ，比如本例中的“$(objects)”就是使用 变量 objects。    在“示例代码中我们在定义变量 objects 的时候使用**“=”** 对其进行了赋值，Makefile 变量的赋值符还有其它两个**“:=”和“?=”** ，我们来看一下这三种赋值符的区别：</code></pre><p><strong>1、赋值符“&#x3D;”</strong></p><pre><code>    使用“=”在给变量的赋值的时候，**不一定要用已经定义好的值，也可以使用后面定义的值** ，比如如下代码：name = zzkcurname = $(name)name = zuozhongkaiprint:@echo curname: $(curname)    我们来分析一下上述代码，第 1 行定义了一个变量 name，变量值为“zzk”，第 2 行也定义了一个变量 curname，curname 的变量值引用了变量 name，按照我们 C 写语言的经验此时 curname 的值就是“zzk”。第 3 行将变量 name 的值改为了“zuozhongkai”，第 5、6 行是输 出变量 curname 的值。在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf” 一样，第 6 行中的“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，**在命令前面加上“@”的话就不会输出命令执行过程** ，大家可以测试一下不加“@” 的效果。使用命令**“make print”** 来执行上述代码。借助另外一个变量，可以将变量的真实值推到后面去定义。也就是**变量的真实值取决于它所引用的变量的最后一次有效值** 。</code></pre><p><strong>2、赋值符“:&#x3D;”</strong></p><pre><code>    修改上述代码第 2 行，将 其中的“=”改为“:=”。此时的 curname 是 zzk，不是 zuozhongkai 了。这是因为**赋值符“:=” 不会使用后面定义的变量** ，只能使用前面已经定义好的，这就是“=”和“:=”两个的区别。</code></pre><p><strong>3、赋值符“?&#x3D;”</strong></p><pre><code>    **如果变量 curname 前面没有被赋值，那么此变量就是“zuozhongkai”** ， **如果前面已经赋过值了，那么就使用前面赋的值** 。</code></pre><p><strong>4、变量追加“+&#x3D;”</strong></p><pre><code>    Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量**添加一些字符串进 去** ，此时就要使用到符号“+=”，比如如下所示代码：    objects = main.o inpiut.o    objects += calcu.o</code></pre><p>一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此 变量 objects<br>变成了“main.o input.o calcu.o”，这个就是变量的追加。</p><h6 id="③Makefile-模式规则"><a href="#③Makefile-模式规则" class="headerlink" title="③Makefile 模式规则"></a>③Makefile 模式规则</h6><pre><code>    上述 Makefile 中第 3~8 行是将对应的.c 源文件编译为.o 文件，每一个 C 文件都要写一个对应的规则，如果工程中 C 文件很多的话显然不能这么做。为此，我们可以使用 Makefile 中的**模式规则** ，通过模式规则我们就可以**使用一条规则来将所有的.c 文件编译为对应的.o 文件** 。    模式规则中，**至少在规则的目标定定义中要包涵“%”，否则就是一般规则** ，目标中的**“%” 表示对 文件名的匹配**，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾 的文件，**类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件** 。    当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值，使用 方法如下：%.o : %.c    命令objects = main.o input.o calcu.omain: $(objects)gcc -o main $(objects)%.o : %.c#命令clean:rm *.o rm main    修改以后的 Makefile 还不能运行，因为第 6 行的命令还没写，第 6 行的命令我们需要借助另外一种强大的变量—**自动化变量** 。</code></pre><h6 id="④Makefile-自动化变量"><a href="#④Makefile-自动化变量" class="headerlink" title="④Makefile 自动化变量"></a>④Makefile 自动化变量</h6><pre><code>    上面讲的模式规则中，**目标和依赖都是一系列的文件** ，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而命令只有一行，如何通过一行命令来从不同的依赖文件中生成对应的目标呢？自动化变量就是完成这个功能的！所谓自动化变量就是这种变量会**把模式中所定义的一系列的文件自动的挨个取出** ，**直至所有的符合模式的文件都取完** ，自动化变量**只应该出现在规则的命令中** ，常用的自动化变量如表所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdafd022717f6cc1113bf86481167cbf.png"></p><pre><code>    表中的 7 个自动化变量中，常用的三种：**$@、$ &lt;和$^**，我们使用自动化变量来完 成“示例代码中的 Makefile，最终的完整代码如下所示：objects = main.o input.o calcu.omain: $(objects)gcc -o main $(objects)%.o : %.cgcc -c $&lt;clean:rm *.o rm main</code></pre><h6 id="⑤Makefile-伪目标"><a href="#⑤Makefile-伪目标" class="headerlink" title="⑤Makefile 伪目标"></a>⑤Makefile 伪目标</h6><pre><code>    Makefile 有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而**伪目标不代表真正的目标名** ，在执行 make 命令的时候通过**指定这个伪目标来执行其所在规则的定义的命令** 。    使用伪目标的主要是为了避免 Makefile 中定义的只**执行命令的目标 和工作目录下的实际文件出现名字冲突**，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面代码规则“clean”代码用来完成清理工程的功能。    上述规则中并没有创建文件 clean 的命令，因此工作目录下永远都**不会存在文件 clean** ，当 我们输入**“make clean”** 以后，后面的“rm *.o”和“rm main”总是会执行。可是如果我们“手贱”，在工作目录下**创建一个名为“clean”的文件** ，那就不一样了，当执行“make clean”的 时候，**规则因为没有依赖文件，所以目标被认为是最新的，因此后面的 rm 命令也就不会执行** ， 我们预先设想的清理工程的功能也就无法完成。为了避免这个问题，我们可以将 clean 声明为 伪目标，声明方式如下：.PHONY : cleanobjects = main.o input.o calcu.omain: $(objects)gcc -o main $(objects).PHONY : clean%.o : %.cgcc -c $&lt;clean:rm *.o rm main    上述代码第 5 行声明 clean 为伪目标，声明 clean 为伪目标以后不管当前目录下是否存在名为“clean”的文件，**输入 “make clean”的话规则后面的 rm 命令都会执行**。</code></pre><h6 id="⑥Makefile-条件判断"><a href="#⑥Makefile-条件判断" class="headerlink" title="⑥Makefile 条件判断"></a>⑥Makefile 条件判断</h6><p>语法有两种如下：</p><pre><code>&lt;条件关键字&gt;    &lt;条件为真时执行的语句&gt;endif以及：&lt;条件关键字&gt;    &lt;条件为真时执行的语句&gt;else    &lt;条件为假时执行的语句&gt;endif    其中条件关键字有 4 个：**ifeq、ifneq、ifdef 和 ifndef** ，这四个关键字其实分为两对、ifeq 与 ifneq、ifdef 与 ifndef，先来看一下 ifeq 和 ifneq，ifeq 用来判断是否相等，ifneq 就是判断是 否不相等，ifeq 用法如下：ifeq (&lt;参数 1&gt;, &lt;参数 2&gt;)ifeq ‘&lt;参数 1 &gt;’，‘&lt;参数 2&gt;’ ifeq “&lt;参数 1&gt;”，“&lt;参数 2&gt;”ifeq “&lt;参数 1&gt;”，‘&lt;参数 2&gt;’ifeq ‘&lt;参数 1&gt;’, “&lt;参数 2&gt;”    上述用法中都是用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1” 和“参数 2”可以为函数返回值。ifneq 的用法类似，只不过 ifneq 是用来了比较“参数 1”和 “参数 2”是否不相等，如果不相等的话就为真。    ifdef 和 ifndef 的用法如下：ifndef &lt;变量名&gt;    如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以 是一个函数的返回值。ifndef 用法类似，但是含义与 ifdef 相反。</code></pre><h6 id="⑦Makefile-函数使用"><a href="#⑦Makefile-函数使用" class="headerlink" title="⑦Makefile 函数使用"></a>⑦Makefile 函数使用</h6><pre><code>    Makefile 支持函数，类似 C 语言一样，Makefile 中的函数是已经定义好的，我们直接使用， 不支持我们自定义函数。make 所支持的函数不多，但是绝对够我们使用了，函数的用法如下：$(函数名 参数集合)或者$&#123;函数名 参数集合&#125;    可以看出，**调用 函数和调用普通变量一样，使用符号“$”来标识**。参数集合是函数的多个参数，**参数之间以逗号“,”隔开** ，**函数名和参数之间以“空格”分隔开** ，函数的调用以“$” 开头。接下来我们介绍几个常用的函数，其它的函数大家可以参考《跟我一起写 Makefile》这份文档。</code></pre><p><strong>1、函数 subst</strong></p><p>函数 subst 用来完成<strong>字符串替换</strong> ，调用形式如下：</p><pre><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></pre><p><strong>2、函数 patsubst</strong></p><p>函数 patsubst 用来完成<strong>模式字符串替换</strong> ，使用方法如下：</p><pre><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)    此函数查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来  </code></pre><p>替换掉，<pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换<br>后的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern><br>中的那个“%”所代表的字符串，比如：</pattern></replacement></replacement></pattern></p><pre><code>$(patsubst %.c,%.o,a.c b.c c.c)    将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的 字符串为“a.o b.o c.o”。</code></pre><p><strong>3、函数 dir</strong></p><p>函数 dir 用来获取目录，使用方法如下：</p><pre><code>$(dir &lt;names…&gt;    此函数用来从文件名序列中提取出目录部分，返回值是文件名序列的目 录部分，比如：$(dir &lt;/src/a.c&gt;)    提取文件“/src/a.c”的目录部分，也就是“/src”。</code></pre><p><strong>4、函数 notdir</strong></p><p>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：</p><pre><code>$(notdir &lt;names…&gt;)    上个例子“dir”改成“notdir”结果是文件名“a.c”。</code></pre><p><strong>5、函数 foreach</strong></p><p>foreach 函数用来完成循环，用法如下：</p><pre><code>$(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)    此函数的意思就是把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;  </code></pre><p>所包含的表达式。每次<text>都会返回一个字符串，循环的过程中，<text>中所包含的每个字<br>符串会以空格隔开，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串<br>将会是函数 foreach 函数的返回值。</text></text></text></p><p><strong>6、函数 wildcard</strong></p><pre><code>    通配符“%”只能用在规则中，只有在规则中它才会展开，**如果 在变量定义和函数使用时， 通配符不会自动展开，这个时候就要用到函数 wildcard**，使用方法如下：$(wildcard PATTERN…)</code></pre><p>比如：</p><pre><code>$(wildcard *.c)    上面的代码是用来获取当前目录下所有的.c 文件，类似“%”。</code></pre><h3 id="4-其他资料"><a href="#4-其他资料" class="headerlink" title="4.其他资料"></a>4.其他资料</h3><p><a href="https://zhuanlan.zhihu.com/p/29235669" title="9个Linux系统常用监控命令">9个Linux系统常用监控命令<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://zhuanlan.zhihu.com/p/29235669</a></p><p><a href="https://blog.csdn.net/renfufei/article/details/105851728" title="Linux系统命令 - 查看内存使用情况">Linux系统命令 - 查看内存使用情况<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/renfufei/article/details/105851728</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131511658" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）">图像识别小车（jetson nano部分）——电赛学习笔记（3）<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;131511658</a></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133484963">https://blog.csdn.net/qq_32971095/article/details/133484963</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux_Petalinux一——FPGA学习笔记＜？＞</title>
      <link href="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/"/>
      <url>/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">一.开发环境搭建</a></p><p><a href="about:blank#1.Ubuntu%20%E5%92%8C%20Windows%20%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0">1.Ubuntu 和 Windows<br>文件互传</a></p><p><a href="about:blank#1%E3%80%81%E5%BC%80%E5%90%AF%20Ubuntu%20%E4%B8%8B%E7%9A%84%20FTP%20%E6%9C%8D%E5%8A%A1">1、开启 Ubuntu 下的 FTP<br>服务</a></p><p><a href="about:blank#2%E3%80%81Windows%20%E4%B8%8B%20FTP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85">2、Windows 下 FTP<br>客户端安装</a></p><p><a href="about:blank#2.Ubuntu%20%E5%92%8C%20Windows%20%E6%96%87%E4%BB%B6%E6%9C%AC%E5%9C%B0%E5%85%B1%E4%BA%AB">2.Ubuntu 和 Windows<br>文件本地共享</a></p><p><a href="about:blank#3.Ubuntu%20%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%20tftp%20%E6%9C%8D%E5%8A%A1%E5%99%A8">3.Ubuntu 系统搭建 tftp<br>服务器</a></p><p><a href="about:blank#4.Ubuntu%20%E4%B8%8B%20NFS%20%E5%92%8C%20SSH%20%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF">4.Ubuntu 下 NFS 和 SSH<br>服务开启</a></p><p><a href="about:blank#5.Source%20Insight%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">5.Source Insight<br>软件安装和使用</a></p><p><a href="about:blank#6.Visual%20Studio%20Code%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">6.Visual Studio Code<br>软件的安装和使用</a></p><p><a href="about:blank#7.SecureCRT%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">7.SecureCRT<br>软件安装和使用</a></p><p><a href="about:blank#8.Putty%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">8.Putty<br>软件的安装和使用</a></p><p><a href="about:blank#%E4%BA%8C.Petalinux%20%E7%9A%84%E5%AE%89%E8%A3%85">二.Petalinux<br>的安装</a></p><p><a href="about:blank#1.Petalinux%20%E7%AE%80%E4%BB%8B">1.Petalinux 简介</a></p><p><a href="about:blank#2.%E5%AE%89%E8%A3%85%C2%A0Petalinux">2.安装 Petalinux</a></p><p><a href="about:blank#1%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93%E4%BB%A5%E5%8F%8A%E8%BD%AF%E4%BB%B6">1、安装依赖库以及软件</a></p><p><a href="about:blank#2%E3%80%81%E4%BF%AE%E6%94%B9%20bash">2、修改 bash</a></p><p><a href="about:blank#3%E3%80%81%E5%AE%89%E8%A3%85%20Petalinux">3、安装 Petalinux</a></p><p><a href="about:blank#4%E3%80%81%E8%AE%BE%E7%BD%AE%20Petalinux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">4、设置 Petalinux<br>环境变量</a></p><p><a href="about:blank#5%E3%80%81Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%20JTAG%20cable%20%E9%A9%B1%E5%8A%A8">5、Linux 系统安装 JTAG cable<br>驱动</a></p><p><a href="about:blank#%E4%B8%89.Petalinux%20%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98">三.Petalinux<br>设计流程实战</a></p><p><a href="about:blank#1.Zynq%20UltraScale%2B%20MPSoC%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%A0%88%E6%A6%82%E8%BF%B0">1.Zynq UltraScale+ MPSoC<br>嵌入式软件栈概述</a></p><p><a href="about:blank#1%E3%80%81FSBL">1、FSBL</a></p><p><a href="about:blank#2%E3%80%81Platform%20Management%20Unit%20%28PMU%29%20Firmware">2、Platform Management Unit (PMU)<br>Firmware</a></p><p><a href="about:blank#3%E3%80%81ARM%20Trusted%20Firmware">3、ARM Trusted Firmware</a></p><p><a href="about:blank#4%E3%80%81U-Boot">4、U-Boot</a></p><p><a href="about:blank#5%E3%80%81Hypervisor%20%28Optional%EF%BC%8C%E5%8F%AF%E9%80%89%29">5、Hypervisor<br>(Optional，可选)</a></p><p><a href="about:blank#6%E3%80%81Linux">6、Linux</a></p><p><a href="about:blank#2.%E4%BD%BF%E7%94%A8%20Petalinux%20%E5%AE%9A%E5%88%B6%20Linux%20%E7%B3%BB%E7%BB%9F">2.使用 Petalinux 定制 Linux<br>系统</a></p><p><a href="about:blank#1%E3%80%81%E5%88%9B%E5%BB%BA%20Vivado%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0">1、创建 Vivado<br>硬件平台</a></p><p><a href="about:blank#2%E3%80%81%E8%AE%BE%E7%BD%AE%20Petalinux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">2、设置 Petalinux<br>环境变量</a></p><p><a href="about:blank#3%E3%80%81%E5%88%9B%E5%BB%BA%20petalinux%20%E5%B7%A5%E7%A8%8B">3、创建 petalinux<br>工程</a></p><p><a href="about:blank#4%E3%80%81%E9%85%8D%E7%BD%AE%20petalinux%20%E5%B7%A5%E7%A8%8B">4、配置 petalinux<br>工程</a></p><p><a href="about:blank#5%E3%80%81%E9%85%8D%E7%BD%AE%20Linux%20%E5%86%85%E6%A0%B8">5、配置 Linux<br>内核</a></p><p><a href="about:blank#6%E3%80%81%E9%85%8D%E7%BD%AE%20Linux%20%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">6、配置 Linux<br>根文件系统</a></p><p><a href="about:blank#7%E3%80%81%E9%85%8D%E7%BD%AE%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6">7、配置设备树文件</a></p><p><a href="about:blank#8%E3%80%81%E7%BC%96%E8%AF%91%20Petalinux%20%E5%B7%A5%E7%A8%8B">8、编译 Petalinux<br>工程</a></p><p><a href="about:blank#9%E3%80%81%E5%88%B6%E4%BD%9C%20BOOT.BIN%20%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6">9、制作 BOOT.BIN<br>启动文件</a></p><p><a href="about:blank#10%E3%80%81%E5%88%B6%E4%BD%9C%20SD%20%E5%90%AF%E5%8A%A8%E5%8D%A1">10、制作 SD<br>启动卡</a></p><p><a href="about:blank#11%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%AE%BE%E7%BD%AE">11、开发板启动模式设置</a></p><hr><p>前置学习：<a href="https://blog.csdn.net/qq_32971095/article/details/133484963" title="Linux系统——OS学习笔记＜1＞">Linux系统——OS学习笔记＜1＞</a></p><p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p><pre><code>     “PetaLinux 工具提供在 Xilinx 处理系统上定制、构建和调配嵌入式 Linux 解决方案所需的所有组件。该解决方案旨在提升设计生产力，可与 Xilinx 硬件设计工具配合使用，以简化针对 Versal、Zynq UltraScale MPSoC、Zynq 7000 SoC 和 MicroBlaze 的 Linux 系统开发。”</code></pre><h2 id="一-开发环境搭建"><a href="#一-开发环境搭建" class="headerlink" title="一.开发环境搭建"></a>一.开发环境搭建</h2><pre><code>    要进行 ZYNQ MPSoC 开发肯定要先搭建好开发环境，我们在开始学习 STM32 的时候肯  </code></pre><p>定需要安装一堆的软件，比如 MDK、IAR、串口调试助手等等，这个就是 STM32 的开发环境<br>搭建。同样的，要想在 Ubuntu 下进行 ZYNQ MPSoC 开发也需要安装一些软件，也就是网上<br>说的开发环境搭建，环境搭建好以后我们就可以进行开发了。环境搭建分为 Ubuntu 和 Windows，<br>因为我们最熟悉 Windows，所以代码编写、查找资料啥的肯定是在 Windows 下进行的。但是<br>Linux 开发又必须在 Ubuntu 下进行，所以还需要搭建 Ubuntu 下的开发环境。本章我们就分为<br>Ubuntu 和 Windows，讲解这两种操作系统下的环境搭建。</p><h3 id="1-Ubuntu-和-Windows-文件互传"><a href="#1-Ubuntu-和-Windows-文件互传" class="headerlink" title="1.Ubuntu 和 Windows 文件互传"></a>1.Ubuntu 和 Windows 文件互传</h3><p>Windows 和 Ubuntu 下的文件互传我们需要使用 FTP 服务，设置方法如下：</p><h4 id="1、开启-Ubuntu-下的-FTP-服务"><a href="#1、开启-Ubuntu-下的-FTP-服务" class="headerlink" title="1、开启 Ubuntu 下的 FTP 服务"></a>1、开启 Ubuntu 下的 FTP 服务</h4><p>打开 Ubuntu 的终端窗口，然后执行如下命令来安装 FTP 服务：</p><pre><code>sudo apt-get install vsftpd</code></pre><p>等待软件自动安装，安装完成以后使用如下 VI 命令打开&#x2F;etc&#x2F;vsftpd.conf，命令如下：</p><pre><code>sudo vi /etc/vsftpd.conf</code></pre><p>打开以后 vsftpd.conf 文件以后找到如下两行：</p><pre><code>local_enable=YES write_enable=YES</code></pre><p>确保上面两行前面没有“#”，有的话就取消掉</p><h4 id="2、Windows-下-FTP-客户端安装"><a href="#2、Windows-下-FTP-客户端安装" class="headerlink" title="2、Windows 下 FTP 客户端安装"></a>2、Windows 下 FTP 客户端安装</h4><pre><code>    Windows 下 FTP 客户端我们使用 FileZilla。打开站点管理器，点击：文件-&gt;站点管理器。点击“新站点(N)”按钮来创建站点，新建站点以后就会在“我的站点”下出现新建的这个站点，站点的名称可以自行修改，比如我将新的站点命名为“Ubuntu”。选中新创建的“Ubuntu”站点，然后对站点的“常规”进行设置：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/02634e9c629de10763b97adf4cbd4ee5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7214388928d08a58386aaf640745d802.png"></p><pre><code>    如果要将 Windows 下的文件或文件夹拷贝到 Ubuntu 中，只需要在左侧的 Windows 区域选中要拷贝的文件或者文件夹，然后**直接拖到右侧** 的 Ubuntu 中指定的目录即可。 将 Ubuntu 中的文件或者文件夹拷贝到 Windows 中也是**直接拖放** 。</code></pre><h3 id="2-Ubuntu-和-Windows-文件本地共享"><a href="#2-Ubuntu-和-Windows-文件本地共享" class="headerlink" title="2.Ubuntu 和 Windows 文件本地共享"></a>2.Ubuntu 和 Windows 文件本地共享</h3><pre><code>    Ubuntu 和 Windows 文件互传可以使用本地共享的方式。这种共享的方式极大的免除了不同系统文件 之间的文件复制和磁盘空间的双重占用。下面笔者将介绍如何使用 Vmware 虚拟机来实现 Ubuntu 和 Windows 文件之间的共享。    在 Vmware 的菜单栏中，选择“设置(S)”，在弹出的菜单中，选择“选项”，在该界面中，单击“共享文件夹”，在右边界面中选择 “总是启用(E)”，添加共享的文件夹，默认勾选“启用此共享”。    该文件夹在 Ubuntu 系统中对应的是**/mnt/hgfs/share/目录** ，我们在终端中输入命令：ll /mnt/hgfs/share/</code></pre><p>可以看到该文件夹为空。如果需要从 Ubuntu 系统向 Windows 传递文件，可 以用 cp 命令或 mv 命令文件到该目录。</p><h3 id="3-Ubuntu-系统搭建-tftp-服务器"><a href="#3-Ubuntu-系统搭建-tftp-服务器" class="headerlink" title="3.Ubuntu 系统搭建 tftp 服务器"></a>3.Ubuntu 系统搭建 tftp 服务器</h3><pre><code>    TFTP 作为一种**简单的文件传输协议** ，在嵌入式开发中会经常使用到，而且后面我们在**安装 Petalinux 工具时也会提示需要 tftp 服务** ，所以我们需要**在 Ubuntu 上搭建 TFTP 服务器** 。需要**安装 tftp-hpa（客户端软件包，如果不用可不装）和 tftpd-hpa 软件包** ，命令如下：sudo apt install tftp-hpa tftpd-hpa    TFTP 需要一个文件夹来存放文件，我们在根目录下新建一个/tftpboot 目录做为 TFTP 文 件存储目录，之所以使用该目录是因为后面使用的 Petalinux 工具默认使用该目录，省得我们 每次建 Petalinux 工程的时候手动修改。创建/tftpboot 目录命令如下：sudo mkdir -p /tftpboot sudo chmod 777 /tftpboot    这样笔者就在电脑上创建了一个名为 tftpboot 的目录(文件夹)，路径为/tftpboot。需要注意 的是我们要**给 tftpboot 文件夹权限，否则的话后面在使用过程中会遇到问题，所以使用了 chmod 777 命令** 。 最后配置 tftp。打开/etc/default/tftpd-hpa 文件，将其内容修改如下：# /etc/default/tftpd-hp                       TFTP_USERNAME=&quot;tftp&quot;   TFTP_DIRECTORY=&quot;/tftpboTFTP_ADDRESS=&quot;:69&quot;     TFTP_OPTIONS=&quot;-l -c -s&quot;</code></pre><p>最后输入如下命令，重启 tftp 服务器：</p><pre><code>sudo service tftpd-hpa restart</code></pre><h3 id="4-Ubuntu-下-NFS-和-SSH-服务开启"><a href="#4-Ubuntu-下-NFS-和-SSH-服务开启" class="headerlink" title="4.Ubuntu 下 NFS 和 SSH 服务开启"></a>4.Ubuntu 下 NFS 和 SSH 服务开启</h3><pre><code>    后面进行 **Linux 驱动开发** 的时候**需要 NFS 启动** ，因此要先安装并开启 Ubuntu 中的 NFS 服务，使用如下命令安装 NFS 服务：sudo apt install nfs-kernel-server</code></pre><p>等待安装完成。安装完成以后在<strong>用户根目录</strong> 下创建一个名为“workspace&#x2F;nfs”的文件夹， 命令如下：</p><pre><code>cdmkdir -p workspace/nfscd workspace/nfspwd</code></pre><p>以后所有需要使用 nfs 的东西都放到这个“nfs”文件夹里面。</p><pre><code>    上面创建的 nfs 文件夹供 nfs 服务器使用，以后我们可以在开发板上**通过网络文件系统来访问 nfs 文件夹** 。    使用前需要先**配置 nfs** 。NFS 允许挂载的目录及权限**在文件/etc/exports 中进行定义** ，使用 如下命令打开 nfs 配置文件/etc/exports，打开/etc/exports 以后在后面添加如下所示内容：/home/&lt;用户名&gt;/workspace/nfs *(rw,sync,no_root_squash)    * 代表允许所有的网络段访问，rw 是可读写权限，sync 是文件同步写入存储器，no_root_squash 是 nfs 客户端分享目录使用者的权限。如果客户端使用的是 root 用户，那么对于该共享目录而 言，该客户端就具有 root 权限。</code></pre><p>重启 NFS 服务，使用如下命令：</p><pre><code>sudo systemctl start nfs-kernel-server.service</code></pre><p>此时可以运行以下命令来显示共享的目录：</p><pre><code>showmount -e</code></pre><p>在 nfs 运行的过程中，修改了&#x2F;etc&#x2F;exports 配置文件，可以使用 exportfs 命令使改动生效， 具体命令：</p><pre><code>sudo exportfs -rv    开启 Ubuntu 的 SSH 服务以后我们就可以在 Windwos 下使用终端软件登陆到 Ubuntu，比 如使用 SecureCRT，**Ubuntu 下使用如下命令开启 SSH 服务** ：sudo apt install openssh-server</code></pre><p>上述命令安装 ssh 服务，ssh 的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config，使用默认配置即可。</p><h3 id="5-Source-Insight-软件安装和使用"><a href="#5-Source-Insight-软件安装和使用" class="headerlink" title="5.Source Insight 软件安装和使用"></a>5.Source Insight 软件安装和使用</h3><pre><code>    Source Insight 是一款功能强大的代码编辑、阅读工具，工作在 Windows 下，我们可以用 Source Insight 来进行代码编写和阅读，编写完成以后将代码拷贝到 Ubuntu 中去编译即可。</code></pre><h3 id="6-Visual-Studio-Code-软件的安装和使用"><a href="#6-Visual-Studio-Code-软件的安装和使用" class="headerlink" title="6.Visual Studio Code 软件的安装和使用"></a>6.Visual Studio Code 软件的安装和使用</h3><pre><code>    Visual Stuio Code 和 Source Insight 一样，都是编辑器，Visual Studio Sode 本教程以后就简 称为 VSCode，VSCode 是微软出的一款编辑器，但是免费的。VSCode 有 Windows、Linux 和 macOS三个版本的，是一个跨平台的编辑器。</code></pre><p>我们需要按照的插件有下面几个：</p><p>1)、C&#x2F;C++。</p><p>2)、C&#x2F;C++ Snippets，即 C&#x2F;C++重用代码块。</p><p>3)、C&#x2F;C++ Advanced Lint,即 C&#x2F;C++静态检测。</p><p>4)、Code Runner，即代码运行。</p><p>5)、Include AutoComplete，即自动头文件包含。</p><p>6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。</p><p>7)、One Dark Pro，VSCode 的主题。</p><p>8)、GBKtoUTF8，将 GBK 转换为 UTF8。</p><p>9)、ARM，即支持 ARM 汇编语法高亮显示。</p><p>10)、Chinese(Simplified)，即中文环境。</p><p>11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。</p><p>12)、compareit，比较插件，可以用于比较两个文件的差异。</p><p>13)、DeviceTree，设备树语法插件。</p><pre><code>    新建文件后，按下“Ctrl+Shift+P”打开搜索框，然后**输入“Edit configurations”， 选择“C/C++:Edit configurations…”。C/C++的配置文件是个 json 文件** ，json 中的变量“includePath”用于指定工程中的头文件路径，但是“stdio.h” 是 C 语言库文件，而**VSCode 只是个编辑器，没有编译器** ，所以肯定是没有 stdio.h 的，除非 我们自行安装一个编译器，比如 CygWin，然后**在 includePath 中添加编译器的头文件** 。这里我 们就不添加了，因为我们不会使用 VSCode 来编译程序，这里主要知道如何指定头文件路径就 可以了，后面有实际需要的时候再来讲。</code></pre><h3 id="7-SecureCRT-软件安装和使用"><a href="#7-SecureCRT-软件安装和使用" class="headerlink" title="7.SecureCRT 软件安装和使用"></a>7.SecureCRT 软件安装和使用</h3><pre><code>    在后续的开发过程中我们需要在Windows下使用串口终端，用来查看信息以及进行操作。 常用的串口终端有 SecureCRT、Putty 和 MobaXterm。    SecureCRT 功能很强大，支持 SSH，可以用来远程登陆；支持串口，可以用来作为 Linux 开发板的串口终端。我们用的最多的就是将 **SecureCRT 作为串口终端来使用** 。    我们以串口连接为例讲解如何使用 SecureCRT，我们需要准备好一个能进行**串口通信** 的设 备，我们的 DFZU2EG_4EV MPSoC 开发板就可以。DFZU2EG_4EV MPSoC 开发板出厂已经 烧写了 Linux 系统，Linux 系统在运行的过程中会通过串口输出信息，**通过串口可以实现 Linux 命令行交互操作** ，就和 Ubuntu 里面的终端一样，使用方法如下：</code></pre><p>打开 SecureCRT，然 后点击 File-&gt;Quick Connect…，按照下图所示进行设置：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/71d3ee33ee6a727e48d723243b0e893a.png"></p><pre><code>    左侧是会话列表，保存着历史会话，会显示出所有曾经连接的串口，这个在关闭 SecureCRT 以后会被保存起来，下次重新打开 SecureCRT 就可以直接使用这个串口会话连接进行快速连接。比如我们关闭 SecureCRT，在关闭 SecureCRT 之前要先关闭所有的会话(串口)，重新打开 SecureCRT。上图中重新打开的 SecureCRT 保存这上次关闭之前建立的会话(串口)“serial-com8”，通 过双击“serial-com8”可以重新连接会话(串口)，不需要再使用快速连接对话框进行连接设置。 开发板默认出厂烧写了 Linux 系统，所以如果连接上 SecureCRT 以后会将串口作为终端， 会输出 Linux 系统启动信息，并且可以通过 SecureCRT 来操作开发板中的 Linux 系统，此时 SecureCRT 就是开发板的终端，和 Ubuntu 中的终端一样。</code></pre><p><strong>关于：<a href="https://zhuanlan.zhihu.com/p/451782049" title="SecureCRT中如何配置颜色">SecureCRT 中如何配置颜色</a></strong></p><h3 id="8-Putty-软件的安装和使用"><a href="#8-Putty-软件的安装和使用" class="headerlink" title="8.Putty 软件的安装和使用"></a>8.Putty 软件的安装和使用</h3><pre><code>    Putty 和 SecureCRT 是类似的软件，都是用来作为 SSH 或者串口终端的，区别在于 SecureCRT 是付费软件，而 Putty 是免费的。虽然 Putty 没有 SecureCRT 功能强大，但是 Putty 用来作为嵌入式 Linux 的串口终端是绰绰有余的，而且**在 Ubuntu 下安装 Putty 十分方便** ，只需 一条命令即可：sudo apt install putty    使用 USB 线将开发板串口和电脑连接起来，打开 Putty 软件，打开以后是配置界面，如下 图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3df9f9690aa123582d4a68ed4dced51.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/68fe6694ea97c256c66129782272be07.png"></p><h2 id="二-Petalinux-的安装"><a href="#二-Petalinux-的安装" class="headerlink" title="二.Petalinux 的安装"></a>二.Petalinux 的安装</h2><pre><code>    安装 Petalinux 开发工具在 Ubuntu 操作系统中，在虚拟机中安装了 Ubuntu 18.04 64 位操作系统，这也是官方推荐的版本。</code></pre><h3 id="1-Petalinux-简介"><a href="#1-Petalinux-简介" class="headerlink" title="1.Petalinux 简介"></a>1.Petalinux 简介</h3><pre><code>    Petalinux 工具是 Xilinx 公司推出的嵌入式 Linux 开发套件，包括了 **u-boot、Linux Kernel、 device-tree、rootfs 等源码和库** ，以及 **Yocto recipes** ，可以让客户很方便的生成、配置、编译及 自定义 Linux 系统。Petalinux 支持 Versal 、Zynq UltraScale+ MPSoC、Zynq-7000 SoC 以及 MicroBlaze，可与 Xilinx 硬件设计工具 Vivado 协同工作，大大简化了 Linux 系统的开发工作。</code></pre><p>官方网站：[PetaLinux 工具 (xilinx.com)](<a href="https://china.xilinx.com/products/design-">https://china.xilinx.com/products/design-</a><br>tools&#x2F;embedded-software&#x2F;petalinux-sdk.html “PetaLinux 工具 (xilinx.com)“)</p><p>下载途径：[下载<br>(xilinx.com)](<a href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-">https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-</a><br>design-tools&#x2F;2023-1.html “下载 (xilinx.com)“)</p><p><strong>注意 Petalinux 的版本 要求与 Vivado 的版本一致</strong></p><h3 id="2-安装-Petalinux"><a href="#2-安装-Petalinux" class="headerlink" title="2.安装 Petalinux"></a>2.安装 Petalinux</h3><pre><code>    首先将 petalinux 安装包文件 petalinux-v2019.2-final-installer.run 拷贝到 share 共享目录，，在 Ubuntu 系统中，打开终端，切换到 /mnt/hgfs/share/目录，可以看到 petalinux 的安装文件 petalinux-v2019.2-final-installer.run 已在该目录，可直接访问。</code></pre><h4 id="1、安装依赖库以及软件"><a href="#1、安装依赖库以及软件" class="headerlink" title="1、安装依赖库以及软件"></a>1、安装依赖库以及软件</h4><pre><code>    Xilinx 提供了安装脚本 plnx-env-setup.sh。将下载后的脚本拷贝到 Ubuntu 虚拟机中，打开 Ubuntu Terminal 终端执行输入如下命令以 执行此脚本：sudo ./plnx-env-setup.sh</code></pre><p>如果上面的命令不行，可以使用下面的方式替代，对与 Ubuntu 而言，两种方式是等效的。</p><pre><code>sudo apt install iproute2 gawk python3 python build-essential gcc git make net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib automake zlib1g:i386 screen pax gzip cpio python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3</code></pre><h4 id="2、修改-bash"><a href="#2、修改-bash" class="headerlink" title="2、修改 bash"></a>2、修改 bash</h4><pre><code>    Petalinux 工具需要主机系统的/bin/sh 是 bash，而 Ubuntu 默认的/bin/sh 是 dash，所以这里 需要进行更改，运行 sudo dpkg-reconfigure dash 命令，如下：sudo dpkg-reconfigure dash</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/659079b3f0270a474f4242ced2ac97b8.png"></p><p>**选择“No”按下回车即可。  **</p><h4 id="3、安装-Petalinux"><a href="#3、安装-Petalinux" class="headerlink" title="3、安装 Petalinux"></a>3、安装 Petalinux</h4><pre><code>    安装 Petalinux 就要考虑安装位置了，对于 Petalinux 这种体积庞大的工具，我们将其放在 /opt 目录下。在/opt 目录下新建专门存放 Petalinux 的文件夹，如/opt/pkg/petalinux/2019.2，在 终端输入以下命令即可：sudo chown -R $USER:$USER /optmkdir -p /opt/pkg/petalinux/2023.1    **chown命令将/opt 目录的属主和属组更改为当前的用户名** ，如笔者的 Ubuntu 用户名为 cx， 执行的 chown 命令就相当于“sudo chown -R cx:cx /opt”，然后通过 mkdir 创建安装目录。现在我们将 petalinux 安装在/opt/pkg/petalinux/2023.1 目录下，在终端中输入如下命令：./petalinux-v2023.1-05012318-installer.run -d /opt/pkg/petalinux/2023.1</code></pre><p>运行上述命令后，需要等待一段时间，当出现“Press Enter to display the license agreements”<br>字样的时候，从显示的意思可以知道，让我们按下回车键显示软件许可协议，按下键盘上的回车键<br>Enter，这些内容如果你感兴趣可以看看，此处我们就不详细看了，直接按下键盘上的 Q 键退出， 回到之前的界面之后会出现一个选择项，询问我们是否接受<br>xilinx 最终用户协议。这个显然是没得选，必须接受，否则无法进行下面的安装；输入 y 按回车接受。除了 xilinx<br>最终用户协议之外，还有两个协议也需要大家接受，会依次显示在终端上，同理也是输入 Y 按下回车接受。接受所有协议之后 Petalinux<br>安装工具便会继续安装，直到安装完成。</p><h4 id="4、设置-Petalinux-环境变量"><a href="#4、设置-Petalinux-环境变量" class="headerlink" title="4、设置 Petalinux 环境变量"></a>4、设置 Petalinux 环境变量</h4><pre><code>    在正式使用 petalinux 工具之前，需要先运行 petalinux 安装目录下的 settings.sh 脚本文件 设置 petalinux 工作环境，settings.sh 脚本用于 bash，还有一个 settings.csh 用于 C shell。    一般默认情况下，我们使用 bash作为登录 shell，所以 source 脚本文件 settings.sh对 petalinux 所需的运行环境进行配置，命令如下：source settings.sh    需要注意的是该命令**只对当前终端有效** ，重新打开终端后需要重新执行这一步。执行结果 如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00f3abd28725993d07f8ef21603c139b.png"></p><p> 我们来验证下工作环境是否已设置，在终端输入如下命令：</p><pre><code>echo $PETALINUX</code></pre><p>显示 Petalinux 的安装目录，表明工作环境已设置。现在可以使用 Petalinux 工具了。</p><pre><code>    鉴于每次打开终端使用 Petalinux 都需要设置相应的环境变量，我们为了方便，**将设置 Petalinux 环境变量的命令设置成别名**，这样我们使用起来就方便些。设置别名方法的很简单， 在终端输入如下命令：echo &quot;alias sptl=&#39;source $PETALINUX/settings.sh&#39;&quot; &gt;&gt; ~/.bashrc    以后我们打开终端后，**输入 sptl** 就可以设置 Petalinux 的环境变量了，无需输入长长的路 径。sptl 的记忆法是 Source PeTaLinux 的环境变量。提醒：在使用 linux 的时候要善用别名但不要滥用别名。</code></pre><h4 id="5、Linux-系统安装-JTAG-cable-驱动"><a href="#5、Linux-系统安装-JTAG-cable-驱动" class="headerlink" title="5、Linux 系统安装 JTAG cable 驱动"></a>5、Linux 系统安装 JTAG cable 驱动</h4><pre><code>    在嵌入式开发中，我们都是通过在线 jtag 进行调试的，这种调试方式方便快捷，在使用 Petalinux 进行 Linux 开发中，其实也是可以使用 JTAG 的，不过对于 Linux 系统，**由于安装驱动程序需要 root 或 sudo 访问权限，因此从 Vivado 2015.4 版本开始，默认不安装 jtag 驱动。这 样 Vivado 安装程序和 Petalinux 安装程序可以在没有 root 或 sudo 特权的 Linux 系统上运行。** 这也导致了在 linux 系统中，jtag 驱动需要手动安装。    下面我们介绍如何在 Ubuntu 主机中（其 他 Linux 系统同样适用）安装 jtag 驱动。 需要注意的是在安装 jtag 驱动之前，请**不要将 jtag 下载器连接到电脑** ，已经接到电脑的， 最好先拔掉。下面开始安装。    在 Ubuntu 系统中，打开终端，以普通用户运行即可。进入到 petalinux 安装目录。可以看到有一个名为“tools”的目录，jtag 驱动程序在该目录下，我们输入以下命令进入 到 jtag 驱动程序所在位置：cd tools/xsct/data/xicom/cable_drivers/lin64/install_script/install_drivers    可以看到该目录下有一个名为“install_drivers”的文件，输入如下命令，以 root 权限执行该文件，安装 jtag 驱动程序：sudo ./install_drivers    可以看到 jtag 驱动安装成功。对于最下面一行的警告，如果已经拔掉 jtag 下载器与电脑的 连接就可以不用看。至此 jtag 驱动程序就安装完成了。    下面说下在遇到 jtag 驱动问题时，**如何删除 jtag 驱动。注意如无特需情况，请不要执行下 面的命令：**sudo rm -f /etc/udev/rules.d/52-xilinx-digilent-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-ftdi-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-pcusb.rules</code></pre><h2 id="三-Petalinux-设计流程实战"><a href="#三-Petalinux-设计流程实战" class="headerlink" title="三.Petalinux 设计流程实战"></a>三.Petalinux 设计流程实战</h2><pre><code>    PetaLinux 工具提供了**在 Xilinx 处理系统上自定义、构建和部署嵌入式 Linux 解决方案** 所需的一切。该解决方案旨在提高设计生产力，可**与 Xilinx 硬件设计工具一起使用** ，以**简化针对 Zynq SoC 的 Linux 系统的开发** 。本章我们以使用 Petalinux 定制 Linux 系统为例，实战 Petalinux 的设计流程，看下 Petalinux 如何简化 Linux 系统的开发。</code></pre><h3 id="1-Zynq-UltraScale-MPSoC-嵌入式软件栈概述"><a href="#1-Zynq-UltraScale-MPSoC-嵌入式软件栈概述" class="headerlink" title="1.Zynq UltraScale+ MPSoC 嵌入式软件栈概述"></a>1.Zynq UltraScale+ MPSoC 嵌入式软件栈概述</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41be0b13c8944f0eb38505481be59e1d.png"></p><pre><code>    在 Zynq UltraScale+ MPSoC 设备中，有一个 **BootROM** 用于设备的初始启动。配置和安全 部件 CSU(Configuration and Security Unit)处理器使用 BootROM 中的代码。在这个配置阶段， BootROM(CSU ROM 代码的一部分)**解释引导头部（boot header）来配置系统** ，并以安全或者非安全引导模式将处理系统(PS，processing system)的第一阶段**引导加载程序(FSBL，first-stage boot loader)** 代码加载到**片上 RAM(OCM，on-chip RAM)**中。引导头部定义了许多引导参数，包 括安全模式和应该执行 FSBL 的处理器。引导头部参数可以在 Zynq UltraScale+器件手册 [UG1085](https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/Fallback &quot;UG1085&quot;) 中找到。在启动过程中，CSU 还将 **PMU** 用户固件(PMU FW)加载到 PMU RAM 中， 与 PMU ROM 一起提供平台管理服务。对于基于 xilinx 的 FSBL 和系统软件，大多数系统中都 必须有 PMU FW。在 PMU 固件加载前加载 FBSL 是默认配置。有些系统会切换顺序，首先加 载 PMU 固件。    在[Vitis开发二——FPGA学习笔记——二程序固化实验](https://blog.csdn.net/qq_32971095/article/details/136352300?spm=1001.2014.3001.5501 &quot;Vitis开发二——FPGA学习笔记——二程序固化实验&quot;)中也涉及到相关内容，不过产生的BOOT文件不涉及linux操作系统。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbd6bdbe41a447d061533a88e8bad8a9.png"></p><p>Boot Image Format with FSBL and PMU Firmware</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f4287d5b2c5f05a44d171346851eac3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2692d111454983b13f1ffa3594f56311.png"></p><p>可以参考《xilinx zynq soc与嵌入式Linux设计实战指南》——第三章 zynq启动流程及镜像制作</p><p>及[PMU Processor • Zynq UltraScale+ Device Technical Reference Manual<br>(UG1085)](<a href="https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/PMU-">https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/PMU-</a><br>Processor “PMU Processor • Zynq UltraScale+ Device Technical Reference Manual<br>(UG1085)“)</p><h4 id="1、FSBL"><a href="#1、FSBL" class="headerlink" title="1、FSBL"></a>1、FSBL</h4><pre><code>    FSBL 是 Zynq UltraScale + MPSoC 的**第一阶段引导加载程序** ，由 BootROM 引导加载到片上 RAM 中并启动，用于**配置 FPGA** （使用 bitstream，如果存在的话）和**从非易失性 Flash(SD/eMMC/NAND/QSPI)加载裸机镜像或者操作系统的第二阶段引导加载程序镜像到内存(DDR/OCM)。**</code></pre><h4 id="2、Platform-Management-Unit-PMU-Firmware"><a href="#2、Platform-Management-Unit-PMU-Firmware" class="headerlink" title="2、Platform Management Unit (PMU) Firmware"></a>2、Platform Management Unit (PMU) Firmware</h4><pre><code>    PMU 控制系统的上电、复位和监控系统内的资源。Zynq MPSoC 中的平台管理单元(PMU) 有一个带有 32KB ROM 和 128 KB RAM 的 Microblaze。启动时，ROM 被 PMU Boot ROM (PBR)预加载，PBR 用于执行预启动任务，进入服务模式。有关 **PMU、PBR 和 PMUFW 加载顺序** 的更多细节，请参阅 Zynq UltraScale+器件手册 UG1085 中的平台管理单元(第 6 章)。PMU RAM 可以在运行时加载固件(PMU Firmware)，并可用于扩展或定制 PMU 的功能。</code></pre><p>PMU System Diagram</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/08e512168278cfd6995aa5bcc935df18.png"></p><p>官方给出PMU的用处：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e2c1939bb02498a21be1dc76171241a.png"></p><h4 id="3、ARM-Trusted-Firmware"><a href="#3、ARM-Trusted-Firmware" class="headerlink" title="3、ARM Trusted Firmware"></a>3、ARM Trusted Firmware</h4><pre><code>    ARM Trusted Firmware(ATF)为 ARMv8-A 架构的安全软件提供了参考，它提供了各种接 口标准的实现，如 PSCI(Power State Coordination Interface，电源状态协调接口)和用于与 Normal world software 接口的安全监控代码。</code></pre><h4 id="4、U-Boot"><a href="#4、U-Boot" class="headerlink" title="4、U-Boot"></a>4、U-Boot</h4><pre><code>    U-Boot 是 **Universal Boot Loader** 的简称，是一个开源的、主要的引导加载程序，**用于嵌入 式设备中引导设备的操作系统内核** ，在 Linux 社区中经常使用。**Xilinx 在 Zynq Ultrascale+设备 中使用 U-Boot 作为 第二阶段引导加载程序**。</code></pre><h4 id="5、Hypervisor-Optional，可选"><a href="#5、Hypervisor-Optional，可选" class="headerlink" title="5、Hypervisor (Optional，可选)"></a>5、Hypervisor (Optional，可选)</h4><pre><code>    **在 Zynq UltraScale+设备上** ，可以**使用 hypervisor 运行多个虚拟机** 。Zynq UltraScale+设备 上支持几种 hypervisor，该榜单可在 [Embedded Software EcoSystem](https://www.xilinx.com/products/design-tools/embedded-software.html#rtos &quot;Embedded Software EcoSystem&quot;) 上找到。</code></pre><h4 id="6、Linux"><a href="#6、Linux" class="headerlink" title="6、Linux"></a>6、Linux</h4><pre><code>    Linux，全称 GNU/Linux，是一种免费使用和自由传播的类 UNIX 操作系统，是我们本开发指南的重点。    Zynq UltraScale+ MPSoC 上电后，**首先由 BootROM 对 zynq 设备进行初始启动，然后引导加载 fsbl 到 OCM 并启动 fsbl；fsbl 启动后加载 PMU Firmware，然后加载 ARM Trusted Firmware，配置 DDR，最后将 uboot 加载到 DDR 并启动 uboot；uboot 启动后可选的加 载 hypervisor，并在 hypervisor 上运行 linux 系统，一般我们不使用 hypervisor，而是直接使用 uboot 加载 linux 系统镜像到 DDR 并启动 linux，至此整个 linux 系统启动完成。**    综上，就是需要在 Zynq UltraScale+ MPSoC 运行 linux 系统所需要搭建的软件栈。如果这 些软件栈由我们一个个手工搭建，任务量极其庞大，所幸的是，**Xilinx 推出了 Petalinux 开发工 具，可以让我们方便快捷的完成这些软件栈的搭建，从而加快 linux 的使用和开发** 。    注：上面介绍了那么多软件栈，并不需要我们全部了解。以 uboot 为分界线，uboot 以下 的是跟 zynq 芯片密切相关的，是很底层的内容，一般不需要额外配置，让 Petalinux 工具自动 适配即可。**从 uboot 开始，跟 zynq 芯片的关联就弱了很多，uboot 和 linux 内核可以适用与其 他芯片平台，其知识点是通用的，也是我们需要关注的。**</code></pre><h3 id="2-使用-Petalinux-定制-Linux-系统"><a href="#2-使用-Petalinux-定制-Linux-系统" class="headerlink" title="2.使用 Petalinux 定制 Linux 系统"></a>2.使用 Petalinux 定制 Linux 系统</h3><h4 id="1、创建-Vivado-硬件平台"><a href="#1、创建-Vivado-硬件平台" class="headerlink" title="1、创建 Vivado 硬件平台"></a>1、创建 Vivado 硬件平台</h4><pre><code>    system_wrapper.xsa 文件，该文件包含着 Vivado 工程所对应的硬件平台信 息，Petalinux 根据这些信息来配置 fsbl、uboot、内核等。 将该文件拷贝到 Ubuntu 系统下。在 share 文件夹下创建一个 xsa 文 件夹，并将 system_wrapper.xsa 文件复制到该文件夹下。</code></pre><h4 id="2、设置-Petalinux-环境变量"><a href="#2、设置-Petalinux-环境变量" class="headerlink" title="2、设置 Petalinux 环境变量"></a>2、设置 Petalinux 环境变量</h4><pre><code>source /opt/pkg/petalinux/2019.2/settings.sh#或者sptl</code></pre><h4 id="3、创建-petalinux-工程"><a href="#3、创建-petalinux-工程" class="headerlink" title="3、创建 petalinux 工程"></a>3、创建 petalinux 工程</h4><pre><code>    为了方便工程的管理，我们在使用的用户的家目录下新建一个 workspace/petalinux 目录， 作为 petalinux 的工程目录。在终端中输入如下命令新建 workspace/petalinux 目录并切换到该目 录：cdmkdir -p workspace/petalinux/cd workspace/petalinux/</code></pre><p>现在我们创建一个名为“ALIENTEK-ZYNQ”的 Petalinux 工程，在终端中输入如下命令：</p><pre><code>petalinux-create -t project --template zynqMP -n ALIENTEK-ZYNQ    template 参数表明创建的 petalinux 工程使用的平台模板，此处的 zynqMP 表明使用的是 zynqMP Soc 平台模板的 petalinux 工程，用于 Zynq UltraScale+ MPSoC 系列的芯片。name 参数 （此处简写为“-n”）后接的是 petalinux 工程名，如此处的“ALIENTEK-ZYNQ”</code></pre><h4 id="4、配置-petalinux-工程"><a href="#4、配置-petalinux-工程" class="headerlink" title="4、配置 petalinux 工程"></a>4、配置 petalinux 工程</h4><pre><code>    首次配置 Petalinux 工程是将 xsa 文件导入到 Petalinux 工程中，Petalinux 工具会解析 xsa 文件并弹出配置窗口。在终端中输入如下命令配置 Petalinux 工程：cd ALIENTEK-ZYNQpetalinux-config --get-hw-description /mnt/hgfs/shared_folder/xsa/</code></pre><p>弹出 petalinux 工程配置窗口，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a83dff710bfdce1cc89fd50c9b6dbfa8.png"></p><pre><code>    需要注意的是该窗口不可以使用鼠标操作，只能通过键盘操作，界面上方的英文就是简单 的操作说明，操作方法如下：    通过键盘上的**“↑”和“↓”键来选择要配置的菜单** ，**按下“Enter”键进入子菜单** 。菜单中高亮的字母就是此菜单的**热键** ，在键盘上按下此高亮字母对应的键可以快速选中对应的菜单。选中子菜单以后**按下“Y”键就会将相应的配置选项写入配置文件中，菜单前面变为“ &lt; * &gt;”**。 **按下“N”键不编译相应的代码，按下“M”键就会将相应的代码编译为模块，菜单前面变为“ &lt; M &gt;”**。按两下“Esc”键退出，也就是返回到上一级，按下“?”键查看此菜单的帮助信 息，按下“/”键打开搜索框，可以在搜索框输入要搜索的内容。</code></pre><p>在配置界面下方会有五个按钮，这五个按钮的功能如下：<br><Select>：选中按钮，和“Enter”键的功能相同，负责选中并进入某个菜单。<br><Exit>：退出按钮，和按两下“Esc”键功能相同，退出当前菜单，返回到上一级。<br><Help>：帮助按钮，查看选中菜单的帮助信息。<br><Save>：保存按钮，保存修改后的配置文件。<br><Load>：加载按钮，加载指定的配置文件。<br>        本实验我们无需更改该窗口的配置信息。不过由于该窗口菜单不多，我们就从上到下的简单地介绍下这些菜单。</Load></Save></Help></Exit></Select></p><pre><code>    首先按键盘上的下方向键移动到“Linux Components Selection”，然后按键盘上的“Enter” 进入子菜单，子菜单内容如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0f9a188e5df166fb919bd2fe2140b59.png"></p><pre><code>    括号里的“*”表示为已使能配置。前两个选项表示会**自动生成我们在《DFZU2EG_4EV MPSoC 之嵌入式 Vitis 开发指南》程序固化实验中的 fsbl.elf 文件和自动更新 ps_init** 。下面两个选项用来配置 u-boot 和 linux-kernel 的来源，本实验保持默认来源配置，不做改动，后面的实验需要更改的时候再做介绍。按键盘上的“Esc”按键连按两次退出该子菜单。    “Auto Config Settings”菜单主要就是**选择是否使能 fsbl、pmufw、Device tree、Kernel 和 u-boot 的自动配置** ，默认为自动配置，无需更改</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5b1497c082712b5d5d6eeee59e31bfed.png"></p><pre><code>     其中**“SD/SDIO Settings”配置项用于配置开发板的首要启动媒介** ，即是从**SD 卡启动还是从 eMMC 启动** 。一般我们调试使用都 是通过 SD 卡启动，因为 SD 卡读写文件方便，从而方便调试；eMMC 一般是程序测试稳定后 上市时使用，不会像 SD 卡那样因碰摔造成的松动。对于 DFZU2EG_4EV MPSoC 开发板来说， 这里需要修改一下，因为 DFZU2EG_4EV MPSoC 开发板的 SD 卡接在 PS 的 SD1 控制器，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/612b60cb984a3d8cdfd6721695f4de26.png"></p><p>首先光标移动到该配置项按回车进入，如下所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/739a10b29b1a3f63cacb77f6a26d8cba.png"></p><pre><code>    在“Primary SD/SDIO”配置项中需要将其修改为 psu_sd_1。**psu_sd_1 对应的就是 SD 卡** 。 修改完成之后连按两次 ESC 键回到上一级菜单。    在“Advanced bootable images storage Settings”菜单中可**配置启动引导镜像和内核镜像的存储媒介** ，默认为 Primary SD，这里保持默认即可。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/250ec972a312abf03c984011b05c5a97.png"></p><pre><code>    返回到主界面（按四次“ESC”按键），**设备树设置菜单“DTG Settings”和 ATF 配置菜 单“ARM Trusted Firmware Compilation Configuration”** 等一般保持默认即可。    我们进入“Image Packaging Configuration”子菜单，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd7ba58cf04b6494b487a1ca6ac860e4.png"></p><pre><code>    第一个选项便是**根文件系统的类型的配置，默认为 INITRAMFS** ，一般默认即可，如果我们需要运行 Ubuntu 或 Debian 的 根文件系统时 ， 就需要配置成 **EXT(SD/eMMC/QSPI/SATA/USB)** ，**NFS 挂载启动需要配置成 NFS** 。另外从该界面我们可以看 到，有**“Copy final images to tftpboot”** 选项，**当在 Ubuntu 的根文件下创建一个名为 tftpboot 的文件夹时，工程生成镜像后会自动将相关文件复制到/tftpboot 目录中** 。    回到主界面，“Firmware Version Configuration”可以用来修改定制的 linux 系统的主机名 和产品名，默认与该 Petalinux 工程同名，如果需要可修改。    “Yocto Settings”进行与 Yocto 相关的设置，这里就不做介绍了，一般保持默认即可。    按键盘上的右方向键（即右箭头），移动到底部的“Save”，按键盘上的“Enter”键， 进入如下图所示的保存配置文件界面：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3399fe22dabcc8eaa76210724169701f.png"></p><p>按键盘上的“Enter”键确认，进入下图所示界面：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/87556f5dc05d0572c4cca94feb61c9f1.png"></p><pre><code>    再次按键盘上的“Enter”键确认，返会到原界面，按两次键盘上的“Esc”退出配置窗口。 如果后面想重新配置，只需输入“petalinux-config”命令即可重新配置。    这一步可能需要几分钟才能完成。这是因为 PetaLinux 会根据“Auto Config Settings ---&gt;‖ 和―Subsystem AUTO Hardware Settings ---&gt;‖来解析 xsa 文件，以获取更新设备树、U-Boot 配置 文件和内核配置文件所需的硬件信息。等待一段时间后，完成 petalinux 工程的配置，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cf586be08fbacafa3baab0d324db1191.png"></p><h4 id="5、配置-Linux-内核"><a href="#5、配置-Linux-内核" class="headerlink" title="5、配置 Linux 内核"></a>5、配置 Linux 内核</h4><p>现在我们开始定制 Linux 内核，在终端输入如下命令：</p><pre><code>petalinux-config -c kernel    等一段时间后会在终端中创建一个名为“linux-xlnx Configuration”的标签页，也就是 Linux 内核的配置界面，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd81a7ed1a3fb7ed7810ece777525c84.png"></p><pre><code>    可以看到 Petalinux 默认使用的**内核版本为 4.19.0** ，当然也可以换成其它版本的内核,不过 修改起来比较麻烦，Petalinux 对内核版本有要求，读者如需使用其他的内核版本可以在网上查 找关于 Petalinux 使用非默认内核版本的方法。一般使用默认内核版本就可以了。    这里使用的内核 Xilinx 官方已经做好了基础配置，如无特定需求，无需更改。另外关于 Linux 内核的配置在后面的 Linux 内核移植章节进行讲解，此处就不多做介绍了。这里采用 Xilinx 官方的默认配置即可，保存配置并退出。</code></pre><h4 id="6、配置-Linux-根文件系统"><a href="#6、配置-Linux-根文件系统" class="headerlink" title="6、配置 Linux 根文件系统"></a>6、配置 Linux 根文件系统</h4><p>在终端输入下面的命令可配置根文件系统，如果不需要配置可不执行该命令：</p><pre><code>petalinux-config -c rootfs</code></pre><p>下图就是根文件系统的配置界面：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a0d6802881da29584983e23d05d264c0.png"></p><pre><code>    默认配置可满足一般使用，也可以根据需求来定制根文件系统，本实验保持默认配置。需要说明的是**“PetaLinux RootFS Settings”可以用来设置 root 用户的密码，默认为“root”** 。后面登录的时候会用到。 保存配置并退出。</code></pre><h4 id="7、配置设备树文件"><a href="#7、配置设备树文件" class="headerlink" title="7、配置设备树文件"></a>7、配置设备树文件</h4><pre><code>    设备树的概念源自于 Linux 内核当中，当然其实在 U-Boot 当中也已经使用了。如果需要配置设备树，可以编辑当前 petalinux 工程目录下的 **project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi** 文件。    我们可以打开这个文件进行编辑，将一些简单外设添加到系统当中，譬如按键、led 和 IIC 设备。设备树用于保存 Linux 系统中的各种设备信息，内核在启动过程当中会去解析设备树文 件，获取设备所需的配置信息完成设备的初始化工作。    **设备树的概念以及相关配置、语法涉及到了 Linux 内核驱动相关知识** ，并不是本篇学习的 重点，所以这里并不会去深入给大家介绍，将会**在 Linux 驱动部分** 的章节做详细解说。</code></pre><p>使用 vi 命令打开 system-user.dtsi 文件，如下所示：</p><pre><code>vi project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi</code></pre><p>默认的文件内容如下，可见该文件需要我们自己手动配置。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c470de2e4f70cee868c21189f201842.png"></p><pre><code>/include/ &quot;system-conf.dtsi&quot;#include &lt;dt-bindings/gpio/gpio.h&gt;#include &lt;dt-bindings/input/input.h&gt;/ &#123;model = &quot;Alientek Zynq MpSoc Development Board&quot;;leds &#123;compatible = &quot;gpio-leds&quot;;gpio-led0 &#123;label = &quot;ps_led1&quot;;gpios = &lt;&amp;gpio 38 GPIO_ACTIVE_HIGH&gt;;linux,default-trigger = &quot;timer&quot;;&#125;;gpio-led1 &#123;label = &quot;ps_led2&quot;;gpios = &lt;&amp;gpio 39 GPIO_ACTIVE_HIGH&gt;;default-state = &quot;on&quot;;&#125;;gpio-led2 &#123;label = &quot;pl_led1&quot;;gpios = &lt;&amp;axi_gpio_0 0 0 GPIO_ACTIVE_HIGH&gt;;linux,default-trigger = &quot;timer&quot;;&#125;;gpio-led3 &#123;label = &quot;pl_led2&quot;;gpios = &lt;&amp;axi_gpio_0 1 0 GPIO_ACTIVE_HIGH&gt;;default-state = &quot;on&quot;;&#125;; &#125;;keys &#123;compatible = &quot;gpio-keys&quot;;autorepeat;gpio-key,wakeup;gpio-key1 &#123;label = &quot;ps_key1&quot;;gpios = &lt;&amp;gpio 40 GPIO_ACTIVE_LOW&gt;;linux,code = &lt;KEY_UP&gt;;&#125;;gpio-key2 &#123;label = &quot;ps_key2&quot;;gpios = &lt;&amp;gpio 41 GPIO_ACTIVE_LOW&gt;;linux,code = &lt;KEY_DOWN&gt;;&#125;;gpio-key3 &#123;label = &quot;pl_key1&quot;;gpios = &lt;&amp;gpio 78 GPIO_ACTIVE_LOW&gt;;linux,code = &lt;KEY_LEFT&gt;; &#125;;gpio-key4 &#123;label = &quot;pl_key2&quot;;gpios = &lt;&amp;gpio 79 GPIO_ACTIVE_LOW&gt;;linux,code = &lt;KEY_RIGHT&gt;; &#125;;&#125;;&#125;;&amp;gem3 &#123;phy-handle = &lt;&amp;ethernet_phy&gt;;local-mac-address = [00 0a 35 00 1e 53];ethernet_phy: ethernet-phy@7 &#123; reg = &lt;0x7&gt;;&#125;;&#125;;&amp;gem0 &#123;psu_ethernet_0_mdio: mdio &#123;#address-cells = &lt;1&gt;;#size-cells = &lt;0&gt;;phy1:phy@4 &#123;reg = &lt;0x4&gt;; /* YT8521 phy address */&#125;;gmii_to_rgmii_0: gmii_to_rgmii_0@0 &#123;compatible = &quot;xlnx,gmii-to-rgmii-1.0&quot;;phy-handle = &lt;&amp;phy1&gt;;reg = &lt;0&gt;;&#125;;&#125;;&#125;;&amp;sdhci0 &#123;mmc-hs200-1_8v;bus-width = &lt;0x8&gt;;non-removable;&#125;;&amp;sdhci1 &#123;disable-wp;no-1-8-v;&#125;;&amp;i2c0 &#123;clock-frequency = &lt;400000&gt;;eeprom@50 &#123;compatible = &quot;24c64&quot;;reg = &lt;0x50&gt;;pagesize = &lt;32&gt;;&#125;;&#125;;&amp;dwc3_0 &#123;dr_mode = &quot;host&quot;;maximum-speed = &quot;super-speed&quot;;&#125;;&amp;usb0 &#123;dr_mode = &quot;host&quot;;&#125;;    设备树文件当中配置了 4 个 gpio led 灯，4 个按键、i2c0 和 usb0，以及 PS 和 PL 的以太网。 下面简单的讲解下 gpio led 的配置。    4 个 gpio led 灯分别对应开发板的 4 个 led 灯，配置信息主要包括 **compatible（用于与内核 驱动匹配的名字）、label（名字）、gpios（对应的 GPIO 管脚）、默认状态以及触发状态** 。 例如 linux,default-trigger = &quot; timer &quot;表示默认的触发状态是 timer 模式，也可以改为 heartbeat 模式，可以用来判断系统是否还在运行。除此之外，还有其他一些内核定义好的触发状态； default-state = &quot;on&quot;表示默认 led 灯是亮着的；gpios = 表示该 led 的控制管脚是 gpio_38，GPIO_ACTIVE_HIGH 表示高电平有效（也就是高电平的时候 led 灯才会亮）。</code></pre><h4 id="8、编译-Petalinux-工程"><a href="#8、编译-Petalinux-工程" class="headerlink" title="8、编译 Petalinux 工程"></a>8、编译 Petalinux 工程</h4><p>现在我们就可以编译整个 Petalinux 工程了，在终端输入如下命令：</p><pre><code>petalinux-build    该命令将**生成设备树 DTB 文件、fsbl 文件、U-Boot 文件，Linux 内核和根文件系统映像** 。 编译完成后，生成的映像将**位于工程的 images 目录下** 。需要说明的是 fsbl、U-Boot 这两个我们在工程中并没有配置，这是因为 Petalinux 会根据 xsa 文件和配置 petalinux 工程**自动配置 fsbl 和 uboot** ，如无特需要求，不需要再手动配置。</code></pre><p>执行结果如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42ccb5a43617856eaa2539ffecdf6cd.png"></p><h4 id="9、制作-BOOT-BIN-启动文件"><a href="#9、制作-BOOT-BIN-启动文件" class="headerlink" title="9、制作 BOOT.BIN 启动文件"></a>9、制作 BOOT.BIN 启动文件</h4><pre><code>    Petalinux 提供了 petalinux-package 命令将 PetaLinux 项目打包为适合部署的格式，其中 “petalinux-package --boot”命令生成可引导映像，该映像可直接与 Zynq 系列设备（包括 Zynq-7000 和 Zynq UltraScale + MPSoC）或基于 MicroBlaze 的 FPGA 设计一起使用。对于 Zynq 系列设备，可引导格式为 BOOT.BIN，可以从 SD 卡引导启动。对于基于 MicroBlaze 的设计， 默认格式为 MCS PROM 文件，适用于通过 Vivado 或其他 PROM 编程器进行编程。    ZYNQ 的启动文件 BOOT.BIN 一般包含 fsbl 文件、bitstream 文件和 uboot 文件。使用下面 的命令可生成 BOOT.BIN 文件：petalinux-package --boot --fsbl --fpga --u-boot --force    选项“--fsbl”用于指定 fsbl 文件所在位置，后面接文件对应的路径信息，如果不指定文 件位置，默认对应的是 images/linux/zynqmp_fsbl.elf；选项“--fpga”用于指定 bitstream 文件所 在位置，后面接该文件对应的路径信息，默认对应的是 images/linux/system.bit，实际可能有区 别；选项“--u-boot”用于指定 U-Boot 文件所在位置，后面接该文件所在路径信息，默认为 images/linux/u-boot.elf。这里笔者均没有指定对应的文件的路径信息，那么 Petalinux 会自动使用默认文件。</code></pre><p>执行结果如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bab0f3bbb3cedfb9db39f0ebb9722b0.png"></p><pre><code>    可以看到 Petalinux **自动将 PMU（Platform Management Unit） firmware 文件 pmufw.elf 和 ATF（Arm trusted firmware）文件 bl31.elf 包含进 BOOT.BIN** 。    生成的 BOOT.BIN 文件放在 Petalinux 工程的 **images/linux 目录下** ，上一小节编译 Petalinux 工程生成的文件同样存放在 images/linux 目录下，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/84819ba0e2bd27d842fded323f1ab75c.png"></p><h4 id="10、制作-SD-启动卡"><a href="#10、制作-SD-启动卡" class="headerlink" title="10、制作 SD 启动卡"></a>10、制作 SD 启动卡</h4><pre><code>    如果使用 SD 卡引导 linux系统启动，一般需要在 SD 卡上有 2 个分区。**一个分区使用 FAT32 文件系统，用于放置启动镜像文件（如 BOOT.BIN，linux 镜像等），另一分区使用 EXT4 文件系统，用于存放根文件系统**。    需要说明的是在配置 petalinux 工程中，“Image Packaging Configuration”子菜单根文件系统的类型的配置使用的是默认的 **INITRAMFS** ，所以**只需要一个使用 FAT32 文件系统** 的分区就可以了。**当设置为“EXT”则需要另一个存放根文件系统的分区** 。        先讲解 SD 卡的分区和格式化，然后说明将哪些文件复制到 SD 卡中。 注：在使用 SD 卡前需要先将 sd 卡中的数据做备份，否则会丢失 SD 卡中的数据。            将 SD 卡插入到读卡器中、并将读卡器插入电脑并连接到 Ubuntu 系统，**在 Ubuntu 系统中 找到 SD 卡所对应的设备节点** ，笔者插入的 SD 卡对应的设备节点为/dev/sdc。在终端中输入如 下命令：umount /dev/sdc*sudo fdisk /dev/sdc</code></pre><p>输入“p”执行结果如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f484804a452873f0fe3ee8feca88b623.png"></p><pre><code>    可以看到当前的分区表，有一个 FAT32 的分区。在开始新分区之前需要将以前的分区删 除，键入“d”，删除该分区，再次键入“d”时会出现下图所示的红色字体提示，表明已无存 在的分区。如果 SD 卡存在多个分区，需要全部删除，存在多个分区的情况下，键入“d”时 会提示选择需要删除的分区编号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e9aa6374c3a77fca52b1d9d384269193.png"></p><pre><code>    下面开始新建分区。输入“n”创建一个新分区。通过选择&#39;p&#39;使其为主，使用默认分区号 1 和第一个扇区 2048。设置最后一个扇区，也就是设置第一个分区的大小，一般设置 500M 足 够了，通过输入“+ 500M”，为该分区预留 500MB，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8afd8a1d3ce98b0b1b82e824a6d6de0c.png"></p><p>现在设置分区类型，输入“t”，然后输入“c”，设置为“W95 FAT32 (LBA)”，如下图 所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b11e58ae1db75c75fd7ad406c31468e5.png"></p><p>输入“a”，设为引导分区，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3125a80ec08f73e61b9b25c76bf4639.png"></p><p>第一个分区就创建好了，开始创建第二个分区。</p><p>通过键入“n”来创建根文件系统分区。后面一路默认就可以了，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba3bcfc72b47d681b7789eff23bc5737.png"></p><pre><code>    如果现在输入“p”检查分区表，会看到刚刚创建的 2 个分区。如果没问题，键入“w” 以写入到 SD 卡并退出。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42da38677d629d0ddd576397d6829da6.png"></p><p>完成了分区创建后，就可以格式化分区了。在终端输入如下命令：</p><pre><code>sudo mkfs.vfat -F 32 -n boot /dev/sdc1sudo mkfs.ext4 -L rootfs /dev/sdc2    将第一个分区格式化成 FAT32 分区并命名为 boot，将第二个分区格式化成 ext4 分区并命 名为 rootfs。执行结果如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6cb68099ed50588483a706cd2d4037fc.png"></p><pre><code>    格式化分区之后就可以挂载分区了（重新插拔读卡器或者使用 mount 命令进行挂载）。挂 载完成后，我们将该工程 image/linux 目录下的 BOOT.BIN 和 image.ub 文件拷贝到名为 boot 的分区也即/dev/sdc1 分区中。然后就可以卸载 SD 卡了。</code></pre><h4 id="11、开发板启动模式设置"><a href="#11、开发板启动模式设置" class="headerlink" title="11、开发板启动模式设置"></a>11、开发板启动模式设置</h4><pre><code>    将 SD 卡插入 SD 卡槽，接下来将启动模式开关 BOOT MODE 的四个开关的第二个与第四个开关拨到下面（置为 OFF），即设置为从 SD 卡启动。打开 MobaXterm 串口上位机或其它串口上位机。上位机打印 Linux 启动信息如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/74a3e0bd0b3903e51125cc56adb311cd.png"></p><pre><code>    停留在登录处，此处使用 root 用户登录，登录密码为“root”（去掉双引号），登录进去 后，界面如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1213533746cf2f88aa42270ade1e6f7.png"></p><pre><code>    如果我们把视线移到开发板，会看到板上的 LED 灯全都是亮的，其中，底板上的 PL_LED1 和 PS_LED1 同频闪烁，这是设备树配置文件产生的结果。    Petalinux 的功能远不止如此，其他功能读者有兴趣可进行探索，建议参考 ug1144 参考 手册，也就是 Xilinx 官方编写的 PetaLinux 工具使用说明文档。</code></pre><p><strong>支持文档</strong> ：[Xilinx Wiki - Confluence (atlassian.net)](<a href="https://xilinx-/">https://xilinx-</a><br>wiki.atlassian.net&#x2F;wiki&#x2F;spaces&#x2F;A&#x2F;overview “Xilinx Wiki - Confluence<br>(atlassian.net)“)</p><pre><code>    特别说明：以后我们使用主机终端指代电脑上 Ubuntu 系统的终端，串口终端指代通过串 口线连接到开发板显示在串口上位机中的终端。</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133468006">https://blog.csdn.net/qq_32971095/article/details/133468006</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边缘检测——Matlab实现计算机视觉＜1＞</title>
      <link href="/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/"/>
      <url>/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%BD%9C%E4%B8%9A%E6%A6%82%E8%BF%B0%EF%BC%9A">作业概述：</a></p><p><a href="about:blank#%E4%B8%80.%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Sobel%E7%AE%97%E5%AD%90">一.一阶导数算子——Sobel算子</a></p><p><a href="about:blank#%E4%BA%8C.%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Canny%E7%AE%97%E5%AD%90">二.二阶导数算子——Canny算子</a></p><p><a href="about:blank#%E9%99%84%E5%BD%95%EF%BC%9A">附录：</a></p><p><a href="about:blank#1.%E4%BD%BF%E7%94%A8%E7%9A%84sobel%E7%AE%97%E5%AD%90">1.使用的sobel算子</a></p><p><a href="about:blank#2.%E4%BD%BF%E7%94%A8%E7%9A%845*5%E9%AB%98%E6%96%AF%E5%B9%B3%E6%BB%91%E6%A8%A1%E7%89%88">2.使用的5*5高斯平滑模版</a></p><p><a href="about:blank#3.%E6%BA%90%E4%BB%A3%E7%A0%81">3.源代码</a></p><hr><p>西安电子科技大学_计算机视觉_作业一_边缘检测</p><h2 id="作业概述："><a href="#作业概述：" class="headerlink" title="作业概述："></a>作业概述：</h2><p>作业 1：边缘检测 编程语言：Matlab（推荐） 或 Python（可能需要使用 OpenCV）</p><p>题目内容：</p><p>自选一张图像，编程实现以下操作：</p><p>• 分别采用 Sobel 算子和 Canny 算子滤波，进行边缘提取；</p><p>• 显示原始图像以及不同滤波器滤波后的结果</p><p>• 对于 Sobel 滤波结果，显示 x 方向的梯度、y 方向的梯度、梯度幅度、梯 度角度等</p><p>• 对于 Canny 算子滤波，显示滤波后边缘检测结果 并分析不同滤波结果的差异。</p><p>说明：</p><p>（1）基于原理，自行实现，进行计算（禁止使用自带函数进行滤波）。各种滤 波函数应进行封装，并在统一的 test 文件（test.m or<br>test.py）中调用使用。</p><p>（2） 所得各图像，按照子图样式显示(subplot)，并标注(title)</p><p>（3） 打包文件夹，包含代码和文档，文档中应包含上述结果的截图及最终分 析。</p><p>要求：内容完备（包含计算过程），结构清晰、排版美观。</p><h2 id="一-一阶导数算子——Sobel算子"><a href="#一-一阶导数算子——Sobel算子" class="headerlink" title="一.一阶导数算子——Sobel算子"></a>一.一阶导数算子——Sobel算子</h2><p>通过求导可以得到边缘，边缘像素变化快，导数绝对值大。在离散点中则使用差分近似，通过与特定的卷积核卷积实现差分运算，并近似出该点导数。</p><p>而Sobel算子分为x轴方向和y轴方向，分别卷积获得各像素点x、y轴梯度x_g和y_g。梯度幅值用x_g和y_g的2-范数（平方和开根）求得（也可用1-范数[绝对值求和]近似，减少运算量），相位用arctan求得。</p><p><strong>测试结果：</strong></p><p>原图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f089df392b290c82c2217105c8da4e7f.jpeg"></p><p>sobel滤波：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8b9d8d83a6334aa1992c110a768b94f4.jpeg"></p><p>x方向梯度：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e38d99b56bbf67908f656b8eadabd2f.jpeg"></p><p>y方向梯度：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/087357e370b158b125a780536caff592.jpeg"></p><p>从图中可以清晰看到x轴方向和y轴方向的Sobel算子检测结果的差异。梯度的幅度和相位保存在mat文件中。</p><h2 id="二-二阶导数算子——Canny算子"><a href="#二-二阶导数算子——Canny算子" class="headerlink" title="二.二阶导数算子——Canny算子"></a>二.二阶导数算子——Canny算子</h2><p>Canny边缘检测算法包括以下步骤[1]：</p><p>1.高斯平滑，滤除噪声</p><p>2.计算梯度强度和方向</p><p>3.应用非极大值抑制法（Nom-Maximum Suppression，NMS），以消除杂散效应</p><p>4.应用滞后阈值法检测边缘</p><p>（5.边缘跟踪得到单像素宽度的边缘图像）</p><p>这里主要说明第3步：</p><pre><code>    图像梯度矩阵中的元素值大，不能直接用来判断该点为边缘。NMS可以剔除伪边缘信息。如果该像素满足梯度局部最大值，则判断该像素为边缘，并对其余像素的相关信息进行抑制。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ca59c955dc405d499ac1b357d0cce8c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e8cafc9ef237158894971f55f7c810c.jpeg"></p><pre><code>    中心点周围有8个领域点，但做中心点梯度方向的直线的交点并不一定的8-领域点，根据交点所在的区域可以将领域划分为4块，交点PM、PN的值通过线性插值计算。    最后放大保留下来的像素点，这里简单地将满足双阈值间的点灰度设置为255。</code></pre><p><strong>测试结果：</strong></p><p>高斯平滑：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9399bb1b0692b68d6e2be51c27872fb9.jpeg"></p><p>高斯平滑后sobel滤波：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f203482fda90f8be278e727cc58328f0.jpeg"></p><p>非极大值抑制：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/622487c3dba1ca0f1f6324d30ded53d1.jpeg"></p><p>双阈值处理：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07e60e31a5360caee06a12687e923136.jpeg"></p><p>可以通过调整双阈值来调整最终结果保留细节的多少</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb56bf290e418556ec6cdf1684206f85.jpeg"></p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><h3 id="1-使用的sobel算子"><a href="#1-使用的sobel算子" class="headerlink" title="1.使用的sobel算子"></a>1.使用的sobel算子</h3><p>s_x&#x3D;1&#x2F;8*[1,0,-1;2,0,-2;1,0,-1];</p><p>s_y&#x3D;1&#x2F;8*[-1,-2,-1;0,0,0;1,2,1];</p><h3 id="2-使用的5-5高斯平滑模版"><a href="#2-使用的5-5高斯平滑模版" class="headerlink" title="2.使用的5*5高斯平滑模版"></a>2.使用的5*5高斯平滑模版</h3><p>gs&#x3D;1&#x2F;159*[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];</p><h3 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3.源代码"></a>3.源代码</h3><pre><code>function []=Sobel_Canny_Filter(Src_img)%% 输入参数：同路径下照片名。使用举例：Sobel_Canny_filter(&#39;Test.jpg&#39;)%%  一阶导数——Sobel算子。F=imread(Src_img);f=double(rgb2gray(F));[row,col]=size(f);%   Sobel核处理结果X_grad=zeros(row,col);Y_grad=zeros(row,col);S_dir=zeros(row,col);Output_img=zeros(row,col);%   Sobel核s_x=[1,0,-1;2,0,-2;1,0,-1];s_y=[-1,-2,-1;0,0,0;1,2,1];for i=2:row-1    for j=2:col-1        %   卷积运算        fx=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];        fy=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];        Sx=0.125*s_x.*fx;        Sy=0.125*s_y.*fy;        x_g=sum(Sx,&#39;all&#39;);        y_g=sum(Sy,&#39;all&#39;);                %   关键数值求解        S_dir(i,j)=atan2(y_g,x_g);                A=sqrt(x_g^2+y_g^2);        X_grad(i,j)=abs(x_g);        Y_grad(i,j)=abs(y_g);        Output_img(i,j)=A;    endend%%   绘图figure(8);%   原图subplot(2,4,1);imshow(F);title(&#39;source&#39;);%   sober滤波后图subplot(2,4,2);imshow(Output_img,[]);title(&#39;sobel-filter&#39;);imwrite(uint8(Output_img),&#39;sobel_filter.jpg&#39;);%   x方向梯度subplot(2,4,3);imshow(X_grad,[]);title(&#39;x-grad&#39;);imwrite(uint8(X_grad),&#39;X_grad.jpg&#39;);%   y方向梯度subplot(2,4,4);imshow(Y_grad,[]);title(&#39;y-grad&#39;);imwrite(uint8(Y_grad),&#39;Y_grad.jpg&#39;);%   保存梯度的幅度和相位save(&#39;Amplitude.mat&#39;,&quot;A&quot;);save(&#39;dir.mat&#39;,&quot;S_dir&quot;);%% 二阶导数——Canny算子。%%   高斯滤波  Gs=zeros(row,col);Gs_sobel=zeros(row,col);Canny_temp=zeros(row,col);Canny=zeros(row,col);%   5*5高斯核gs=[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];for i=3:row-2    for j=3:col-2        gg=[f(i-2,j-2),f(i-2,j-1),f(i-2,j),f(i-2,j+1),f(i-2,j+2);f(i-1,j-2),f(i-1,j-1),f(i-1,j),f(i-1,j+1),f(i-1,j+2);f(i,j-2),f(i,j-1),f(i,j),f(i,j+1),f(i,j+2);f(i+1,j-2),f(i+1,j-1),f(i+1,j),f(i+1,j+1),f(i+1,j+2);f(i+2,j-2),f(i+2,j-1),f(i+2,j),f(i+2,j+1),f(i+2,j+2)];        s_g=gs.*gg/159;        Gs(i,j)=sum(s_g,&#39;all&#39;);    endend%%   高斯平滑for i=3:row-2    for j=3:col-2        gsx=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];        gsy=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];        Sx=0.125*s_x.*gsx;        Sy=0.125*s_y.*gsy;        gsx_g=sum(Sx,&#39;all&#39;);        gsy_g=sum(Sy,&#39;all&#39;);                GSS_dir(i,j)=atan(gsx_g/gsy_g);                GSA=sqrt(gsx_g^2+gsy_g^2);        GSX_grad(i,j)=abs(x_g);        GSY_grad(i,j)=abs(y_g);        Gs_sobel(i,j)=GSA;    endend%%   高斯平滑后sobel滤波for i=3:row-2    for j=3:col-2        k=abs(tan(GSS_dir(i,j)));        %   非极大值抑制        %   判断领域点(非8-领域点可划分为4部分)并进行相应线性插值并判断是否为局部大优点（进行保留）        if (GSS_dir(i,j)&gt;=0 &amp;&amp; GSS_dir(i,j)&lt;pi/4) || (GSS_dir(i,j)&gt;=-pi &amp;&amp; GSS_dir(i,j)&lt;-3*pi/4)            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j+1)+(Gs_sobel(i+1,j+1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j-1)+(Gs_sobel(i-1,j-1)-Gs_sobel(i-1,j))/k             Canny_temp(i, j) = Gs_sobel(i, j);            end                elseif (GSS_dir(i,j)&gt;=pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi/2) || (GSS_dir(i,j)&gt;=-3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;-pi/2)            if Gs(i,j) &gt;= (Gs_sobel(i-1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i-1,j-1))/k) &amp;&amp; Gs_sobel(i,j) &gt;= (Gs_sobel(i+1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i+1,j+1))/k)             Canny_temp(i, j) = Gs_sobel(i, j);            end        elseif (GSS_dir(i,j)&gt;=pi/2 &amp;&amp; GSS_dir(i,j)&lt;3*pi/4) || (GSS_dir(i,j)&gt;=-pi/2 &amp;&amp; GSS_dir(i,j)&lt;-pi/4)            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i+1,j-1))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i-1,j+1))/k             Canny_temp(i, j) = Gs_sobel(i, j);            end        elseif (GSS_dir(i,j)&gt;=3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi) || (GSS_dir(i,j)&gt;=-pi/4 &amp;&amp; GSS_dir(i,j)&lt;0)            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i+1,j-1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i-1,j+1)-Gs_sobel(i-1,j))/k             Canny_temp(i, j) = Gs_sobel(i, j);            end        end    endend%%   双阈值变换lowTh  = 0.02 *max(max(Canny_temp));%高阈值higtTh = 1 *max(max(Canny_temp));%低阈值for i = 3 : row-2    for j = 3 : col-2        %   灵活设置保留值        if Canny_temp(i,j) &gt;=lowTh &amp;&amp; Canny_temp(i,j) &lt;= higtTh            %Canny(i,j) = Canny_temp(i,j);            Canny(i,j) = 255;        end    endend%% 绘图%   高斯平滑结果subplot(2,4,5);imshow(Gs,[]);title(&#39;gauss-filter&#39;);imwrite(uint8(Gs),&#39;gauss_filter.jpg&#39;);%   高斯平滑后sobel滤波结果subplot(2,4,6);imshow(Gs_sobel,[]);title(&#39;gauss-sobel-filter&#39;);imwrite(uint8(Gs_sobel),&#39;Gs_sobel_filter.jpg&#39;);%   非极大值抑制后结果subplot(2,4,7);imshow(Canny_temp,[]);title(&#39;Canny-temp&#39;);imwrite(uint8(Canny_temp),&#39;Canny_temp.jpg&#39;);%   阈值间处理subplot(2,4,8);imshow(Canny,[]);title(&#39;Canny-filter&#39;);imwrite(uint8(Canny),&#39;Canny_filter.jpg&#39;);%保存结果saveas(8,&#39;result.jpg&#39;); end</code></pre><p>参考文献</p><p>[1]柳林.基于OpenCV的数字图像处理技术[M].杭州:浙江大学出版社，2020：202-203.</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133420554">https://blog.csdn.net/qq_32971095/article/details/133420554</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vitis开发一——FPGA学习笔记＜8＞</title>
      <link href="/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/"/>
      <url>/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.Hello%20World%20%E5%AE%9E%E9%AA%8C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">一.Hello World 实验</a></p><p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">1.硬件设计</a></p><p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p><p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p><p><a href="about:blank#%3C1%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20UART">&lt;1&gt;配置 PS 的<br>UART</a></p><p><a href="about:blank#%3C2%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20DDR4%20%E6%8E%A7%E5%88%B6%E5%99%A8">&lt;2&gt;配置 PS 的 DDR4<br>控制器</a></p><p><a href="about:blank#%3C3%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%E6%97%B6%E9%92%9F">&lt;3&gt;配置 PS<br>的时钟</a></p><p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL%20%E6%A8%A1%E5%9D%97">step3：生成顶层 HDL<br>模块</a></p><p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p><p><a href="about:blank#2.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.软件设计</a></p><p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p><p><a href="about:blank#3.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">3.下载验证</a></p><p><a href="about:blank#step6%EF%BC%9A%E6%9D%BF%E7%BA%A7%E9%AA%8C%E8%AF%81">step6：板级验证</a></p><p><a href="about:blank#%E4%BA%8C.GPIO%20%E4%B9%8B%20MIO%20%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">二.GPIO 之 MIO 控制 LED<br>实验</a></p><p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p><p><a href="about:blank#2.%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4">2.实验步骤</a></p><p><a href="about:blank#3.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.硬件设计</a></p><p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p><p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p><p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL">step3：生成顶层<br>HDL</a></p><p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p><p><a href="about:blank#4.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">4.软件设计</a></p><p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p><p><a href="about:blank#5.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">5.下载验证</a></p><p><a href="about:blank#%E4%B8%89.GPIO%20%E4%B9%8B%20EMIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">三.GPIO 之 EMIO 按键控制 LED<br>实验</a></p><p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p><p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p><p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p><p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p><p><a href="about:blank#%E5%9B%9B.GPIO%E4%B9%8BMIO%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C">四.GPIO之MIO按键中断实验</a></p><p><a href="about:blank#%C2%A01.%E7%AE%80%E4%BB%8B"> 1.简介</a></p><p><a href="about:blank#%3C1%3E.%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B">&lt;1&gt;.处理器中断类型</a></p><p><a href="about:blank#%3C2%3E%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8GIC">&lt;2&gt;中断控制器GIC</a></p><p><a href="about:blank#%3C3%3EGPIO%20%E7%9A%84%20MIO%20%E7%9A%84%E4%B8%AD%E6%96%AD">&lt;3&gt;GPIO 的 MIO<br>的中断</a></p><p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p><p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p><p><a href="about:blank#%E4%BA%94.AXI%20GPIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">五.AXI GPIO 按键控制 LED<br>实验</a></p><p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p><p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p><p><a href="about:blank#step2%3Avivado%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0">step2:vivado硬件平台</a></p><p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p><p><a href="about:blank#4.%E8%A1%A5%E5%85%85">4.补充</a></p><hr><h2 id="一-Hello-World-实验"><a href="#一-Hello-World-实验" class="headerlink" title="一.Hello World 实验"></a>一.Hello World 实验</h2><pre><code>    在MPSOC开发板上搭建MPSOC嵌入式最小系统，并使用串口打印“Hello World” 信息。通过本次实验我们将了解 **MPSOC 嵌入式系统的开发流程** ，熟悉 **MPSOC 嵌入式最小系统的搭建**。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/66ab6afbb3d420e1b7089143e4466727.png"></p><pre><code>    如上图所示，开发流程大体可以分为 6 步。其中 step1 至 step4 为硬件设计部分，在 Vivado 软件中实现； step5 为软件设计部分，在 Vitis 软件中实现；step6 为功能的验证。复杂的程序还涉及 Debug，这个也是在 Vitis 软件中实施。    嵌入式最小系统的概念包括以下两个方面：一、它是使系统正常工作的最小条件；二、它是其他系统建立的基础。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d830912c59cd7970e89dc798be2e099d.png"></p><pre><code>    以 ARM Cortex 为核心、DDR 为内存，加上传输信息使用的 UART 串口就构成了 MPSOC 嵌入式最小系统。可以看到，这个最小系统只包括了 MPSOC 中的 PS 部分。</code></pre><h3 id="1-硬件设计"><a href="#1-硬件设计" class="headerlink" title="1.硬件设计"></a>1.硬件设计</h3><h4 id="step1：创建-Vivado-工程"><a href="#step1：创建-Vivado-工程" class="headerlink" title="step1：创建 Vivado 工程"></a><strong>step1：创建 Vivado 工程</strong></h4><pre><code>    注意project type界面选择rtl project并且“Do not specify sources at this time”；器件型号选择“xczu2eg-sfvc784-2-i”；</code></pre><h4 id="step2：使用-IP-Integrator-创建-Processing-System"><a href="#step2：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a><strong>step2：使用 IP Integrator 创建 Processing System</strong></h4><pre><code>    在左侧导航栏（**Flow Navigator）** 中，单击 **IP Integrator** 下的 **Create Block Design** ；接下来在 Diagram 窗口中给设计添加 IP。点击上图中箭头所指示的加号(两个任选一个)“+”，会 打开 IP 目录（IP Catalog）。也可以通过快捷键 Ctrl + I，或者右键点击 Diagram 工作区中的空白位置，然后选择“ADD IP”；打开 IP 目录后，在搜索栏中键入“ZYNQ”，找到并双击**“Zynq UltraScale+MPSOC”** ，将 Zynq UltraScale+MPSOC IP 添加到设计中。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff638c73b44ed84dd4f13a3e9db79fab.png"></p><pre><code>    双击所添加的 Zynq UltraScale+MPSOC 模块，进入处理系统的配置界面。界面左侧为页面导航面板， 右侧为配置信息面板。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac3239cf0f859b989c7d926f407b66f5.png"></p><p>下面我们简要地介绍一下页面导航面板中各个页面的作用：</p><p><strong>PS UltraScale+ Block Design</strong> 页面显示了 zynq 硬核的整体架构图，其中绿色部分是可配置模块，可以点<br>击进入相应的编辑界面进行配置，当然也可以在左侧导航栏选择相应的编辑界面。</p><p><strong>I&#x2F;O Configuration</strong> 页面可以选择不同的 I&#x2F;O 外设并进行相应的配置。</p><p><strong>Clock Configuration</strong> 页面分为 Input Clocks 和 Output Clocks 两个标签页，用来配置 PS<br>输入时钟、外设 时钟，以及 DDR 和 CPU 时钟等。</p><p><strong>DDR Configuration</strong> 页面用于设置 DDR 控制器配置信息。</p><p><strong>PS-PL Configuration</strong> 用于 PS 和 PL 交互的相关配置，包括常用的中断、复位信号和数据接口。</p><h5 id="配置-PS-的-UART"><a href="#配置-PS-的-UART" class="headerlink" title="&lt;1&gt;配置 PS 的 UART"></a>&lt;1&gt;配置 PS 的 UART</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00b2930a9fea37d61d892e33ef7cfc19.png"></p><pre><code>    点击导航面板中 I/O Configuration，PS 和外部设备之间的连接主要是通过复用的输入/输出**（Multiplexed Input/Output，MIO）** 来实现的。**BANK501 中的 MIO42 和 MIO43 被用作 UART 串口通信的引脚，并最终与开发板上的 USB 转串口芯片 CH340 连接** 。因此，为了实现串口 通信的功能，我们需要在 PS 中将 MIO42 和 MIO43 配置成 UART0 模块的接口引脚。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9253bb0e6120f4d7752df56866af224e.png"></p><h5 id="配置-PS-的-DDR4-控制器"><a href="#配置-PS-的-DDR4-控制器" class="headerlink" title="&lt;2&gt;配置 PS 的 DDR4 控制器"></a>&lt;2&gt;配置 PS 的 DDR4 控制器</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/86cb4773d4bce9fa668f8588f3fc7151.png"></p><h5 id="配置-PS-的时钟"><a href="#配置-PS-的时钟" class="headerlink" title="&lt;3&gt;配置 PS 的时钟"></a>&lt;3&gt;配置 PS 的时钟</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dde78d189b9ec8cdb96dfb848af3aee2.png"></p><pre><code>    点击左侧 Clock Configuration 打开时钟配置页面，该界面主要是配置 MPSOC PS 中的时钟频率。比如 输入时钟默认是 33.33333Mhz，这与我们开发板上的 PS 端输入时钟频率相同。对于 CPU 的时钟、DDR 的 时钟以及其它外设的时钟，我们直接保持默认设置即可。    因为本实验是**搭建 MPSOC 的嵌入式最小系统，只需要使用 MPSOC 中的 PS 端。因此我们将 PS 中与 PL 端交互的接口信号移除。**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b22291cae6354b595278fd575ac76.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcbef3d3c3dcc0ebeb8c1b682b5ff426.png"></p><pre><code>    返回到 Vivado 界面后，在 Diagram 中可以看到 ZYNQ UltraScale+ MPSOC IP 模块变化，该模块少了四组接口，这正是因为我们在配置该 IP 核的过程中**移除了与 PL 相关的接口信号** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df81e05298566f091c3790ff47385a18.png"></p><p>点击下图中箭头所指示的按钮“validate design”，对我们配置的 IP 核进行验证</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/77b0703425768c83045ffcca779129a2.png"></p><h4 id="step3：生成顶层-HDL-模块"><a href="#step3：生成顶层-HDL-模块" class="headerlink" title="step3：生成顶层 HDL 模块"></a><strong>step3：生成顶层 HDL 模块</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/073a28eee47c2b6b618081420d2e35e3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d2b3b14a1a9f8a64a8dfe31c7a52bdf.png"></p><pre><code>    在对话框中，Synthesis Options 选择 Out of context per IP，这里我们保持默认；Run Setings 用于设置生 成过程中要使用的处理器的线程数，进行多线程处理，保持默认或设置为个人电脑处理器最大可使用线程 数都可以，一般选择最大可使用线程数。然后点击“Generate”来生成设计的综合、实现和仿真文件。    在“Generate”过程中会为设计生成所有需要的输出结果。比如 Vivado 工具会自动生成处理系统的 XDC 约束文件，因此我们不需要手动对 MPSOC PS 引出的接口（DDR 和 FIXED_IO）进行管脚分配。    Generate 完成后，在弹出的对话框中点击“OK”。    在 Sources 窗口中，点击“IP Source”标签页，可以看到 Generate 过程生成的输出结果。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9460672d014aabbdfd341cc584c1458e.png"></p><p>在“Hierarchy”标签页再次右键点击 system.bd，然后选择“Create HDL Wrapper”。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/096595aeafc1562dc64f78ee57d7a9d6.png"></p><p>在弹出的对话框中确认勾选“Let Vivado manage wrapper and auto-update”，然后点击“OK”。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04b4162c472bae880b5b708ef1df3bff.png"></p><pre><code>    design_1_wrapper.v 为创建的 Verilog 文件，箭头所指的“品”字形图标指示当前模块为顶层模块。该模 块使用 Verilog HDL 对设计进行封装，主要完成了对 block design 的例化，大家也可以双击打开该文件查看 其中的内容。    另外我们勾选了“Let Vivado manage wrapper and auto-update”，这样我们在修改了 Block Design 之后就不需要再重新生成顶层模块，**Vivado 工具会自动更新该文件** 。</code></pre><h4 id="step4：生成-Bitstream-文件并导出-Hardware"><a href="#step4：生成-Bitstream-文件并导出-Hardware" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    **如果设计中使用了 PL 的资源，则需要添加引脚约束并对该设计进行综合、实现并生成 Bitstream 文件。** 本次实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需将硬件导出。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/84d183341bcdf40ec8db6c00d6a74a7d.png"></p><pre><code>    在弹出的对话框中，因为没有生成 bitstream 文件，所以无需勾选“Include bitstream”，直接点击“OK” 按钮。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/552ed376805a0dbd4f0ec780a3273a85.png"></p><pre><code>    上图中，XSA file name 一栏是产生的硬件信息文件的文件名，这里我们保持默认。Export to 后面的路 径是生成的包含硬件信息文件的路径，生成的文件如下所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b2274963b330c10cb807b4ed637907e.png"></p><p>新建 vitis 文件夹，将xsa文件移入备用，后续作为 vitis 软件开发存储路径。</p><p>在菜单栏中选择 T<strong>ools &gt; Launch Vitis，启动 Vitis 开发环境</strong>。如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a4c3976d15c6c83da2f8fb04b618df2.png"></p><p>在弹出的对话框中，<strong>我们将工程路径指定到新建的 vitis 文件夹下</strong> ，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d79b59e6a49e77327e778f9e71f0ab45.png"></p><pre><code>    到这里，我们已经完成了 MPSOC 嵌入式系统的硬件设计部分。接下来需要到 Vitis 软件中进行应用程 序开发，也就是软件设计部分。</code></pre><h3 id="2-软件设计"><a href="#2-软件设计" class="headerlink" title="2.软件设计"></a>2.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程"><a href="#step5：在-Vitis-中创建应用工程" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><p>在菜单栏选择 File &gt; New &gt; Application Project, 新建一个 vitis 应用工程</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f33bd6da382274b4e043b9c2b8bd96fb.png"></p><p>在弹出的对话框中，输入工程名“hello_world”，其它选项保持默认，点击“Next”，如下图 所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0198478b7f07905b054d257837434c1a.png"></p><p>打开 Create a new platform from hardware(XSA)标签页，<strong>点击“+”添加 xsa 文件</strong> ，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca8dc52ec3036fad0de51d0e881659c.png"></p><p>添加之前生成的xca文件，添加 xsa 文件后后点击 next。</p><p>在弹出的页面中有一个 Generate boot components 选项，如果勾选，软件会自动生成 fsbl 工程，这 里我们选择默认勾选，然后点击<br>next，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/288d2ba5ef4342f13cc8d63a597b4e5b.png"></p><p>在弹出的工程模板选择页面里，我们选择已有的 Hello World 模板，然后点击 Finish</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbca540ff2514ca9d5a8846fed7eee51.png"></p><pre><code>    工程建立完成后的页面如下图所示，我看可以看到生成了两个工程，一个是硬件平台工程，即 **platform 工程** ，一个是**应用工程** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/117f8abd36ad2af8f6b1d02788b749e6.png"></p><pre><code>    双击打开 hello_world/src 工程目录下 helloworld.c 文件，可以看到源代码。    可以看到程序中主函数调用了 3 个函数，分别是 **init_platform()、cleanup_platform()和 print()** 函数。我们将鼠标停留在各个函数名上，vitis 就会显示该函数的声明。如果想查看函数的定义，可以**按住 Ctrl 键不放， 用鼠标点击相应的函数，就会跳转到其定义的地方** 。    可以看到 init_platform 函数的作用是使能 caches 和初始化 uart；cleanup_platform 函数的作用是取消使 能 caches。实际上这两个函数在该工程中并没有启动任何作用，因为这两个函数是针对于特定平台如 Microblaze 的，对于我们使用的 MPSOC 平台而言是不起作用的，所以 main 函数中只需包含第 9 行的 print 语句就可以了，出于平台的通用性和可移植性，此处我们保留这两个函数。    另外需要注意程序中打印字符串“Hello World”使用的是 **print()** 函数，而不是 C 语言里的 **printf()** 函数。 print()函数是 Xilinx 定义的一个用于打印字符串的函数，调用该函数需要包含头文件**“xil_printf.h”。**</code></pre><p>选中应用工程，右键 Build Project 对工程进行编译。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/27b2222431094b40193d6127c4c5b66c.png"></p><pre><code>    编译进度可以在工具下方的控制台面板（Console）中进行查看，编译完成后显示“Finished building： hello_world.elf”，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bfb4630e5ba6a99f44351730d5dd7bde.png"></p><h3 id="3-下载验证"><a href="#3-下载验证" class="headerlink" title="3.下载验证"></a>3.下载验证</h3><pre><code>    首先我们将下载器与 MPSOC 开发板上的 **JTAG 接口连接** ，下载器另外一端与电脑连接。使用 USB 连接线将开发板 **USB_UART ( PS_PORT)**接口与电脑连接，用于串口通信。接下来将开发板上四个启动模式开关均置为 ON，即**设置为 JTAG 模式** 。最后连接开发板电源给开发板上电。    注意第一次连接开发板 USB_UART 接口时，需要安装 CH340 驱动(USB 串口驱动)。</code></pre><h4 id="step6：板级验证"><a href="#step6：板级验证" class="headerlink" title="step6：板级验证"></a>step6：板级验证</h4><pre><code>    在 Vitis 软件的下方，找到 Terminal 窗口。如果界面中没有找到该窗口，或者操作过程中把该窗口 给关闭了，则可以通过在菜单栏中选择 Window &gt; Show View &gt; Other，在 Show View窗口中搜索添加 Terminal。</code></pre><p>添加 Terminal 后如下图所示，点击箭头处的图标对串口进行设置。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/170e4143f360ea63e740c76d3b806da9.png"></p><p>在弹出的窗口中，Choose terminal 一栏中，下拉选择 Serial Terminal<br>串口终端，选择串口终端后，接下来需要对串口设置。这里设置波特率为 “115200”，数据位为 8 位，停止位为 1 位，然后点击 OK，如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3f622888054796bdd0a2450834d5f07b.png"></p><p>配置完成，连接成功后如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fee5583261c8e02c05908b44d905ac77.png"></p><p>右键 hello_world 工程，选择**“Run As”** ，选择**“Run Confagurations…”** ， 下载程序：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7378853644c71f828f51c56cf93f0dbc.png"></p><pre><code>    在打开的下载页面中，没有出现下载选项，这时需要双击左侧列表中 Single Application Debug 一项，双击后，该项下面出现新的项 Debugger_hello_world-default，同时在右侧出现的页面中选择 Target Setup 标签 页，**勾选复位** ，然后点击 run 下载程序，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ac2948aee4eca8357489df5e2904f51.png"></p><pre><code>    下载完成后，应用程序会将字符串“Hello World”通过 MPSOC PS 端的串口模块发送出去。在 Terminal 窗口可以看到上位机接收到的字符串，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1069bf74b114b8f0a8ecf6565c000d3c.png"></p><h2 id="二-GPIO-之-MIO-控制-LED-实验"><a href="#二-GPIO-之-MIO-控制-LED-实验" class="headerlink" title="二.GPIO 之 MIO 控制 LED 实验"></a>二.GPIO 之 MIO 控制 LED 实验</h2><pre><code>    GPIO 可以通过 **MIO** 连接到 **PS** 端的引脚，也可以通过 **EMIO** 连接到 **PL** 。本章将介绍如何使用 GPIO 外设通过 MIO 控制 PS 端的 LED。</code></pre><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    MPSOC 分为 PS 和 PL 两部分，那么器件的引脚（Pin）资源同样也分成了两部分。MPSOC PS 中的外设可以通过 MIO（Multiuse I/O，多用输入/输出）模块连接到 PS 端的引脚上，也可以通过 EMIO 连接到 PL 端的引脚。MPSOC 系列芯片一般有 78 个 MIO。    图是 GPIO 的框图，从中我们可以看到 GPIO 分为 6 个 Bank，其中 **Bank0、Bank1 和 Bank2 连接到 MIO；而 Bank3、Bank4 和 Bank5 连接到 EMIO** 。Bank0、Bank1 和 Bank2 分别有 26bit，总共 78bit，也就是说有 78 个 MIO。Bank3、Bank4 和 Bank5 分 别有 32bit，也就是说 PS 端可以使用 96 个 EMIO。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/32042201490b2369989d7e8ca0fac313.png"></p><pre><code>    PS 所有的外设都可以通过 MIO 访问，这些外设也是与 MIO 进行连接，每个 MIO 虽然可以独立控制， 以及独立驱动单个引脚的外设，但对于 QSPI、USB、以太网等这些外设，对于 MIO 的连接有着特殊的要求， 如图 2.1.2 所示，对于以太网而言，要与 MIO26~37、MIO38~49、MIO52~63 和 MIO64~75 引脚连接，而且 以太网与 MIO26 连接的引脚只能作为以太网的 tx_clk 使用，可见当其作为以太网的接口引脚时，相应的 MIO 的功能就已经确定下来了。从图中 MIO 一览表中我们可以看到 **MIO 一但选定，引脚位置就已经确定下来了，不需要添加引脚约束** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/caa5d520533e9acf50023b1178d6daab.png"></p><pre><code>    MIO 与 PS 是如何连接的？ 图展示 PS 的 IO 外设。PS 外设的大多数 I/O 信号可以通过 MIO 路由到 PS 引脚，或通过 EMIO 路由到 PL 引脚。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/287affef4a19c843b014f61d1d6bdd42.png"></p><pre><code>    这里我们重点介绍外设系统图中箭头所指的部分。**PS 通过 APB 总线对 控制、状态寄存器的读写实现对 GPIO 的驱动**，具体可以参见下图。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6a0f8cbf358581c776ffb063389cf74.png"></p><pre><code>    左边的一列是寄存器，上半部分是关于中断的，这部分我们在涉及到中断的时候会讲解，这里 我们重点介绍下红色框圈出的下半部分。    **DATA_RO** 是数据只读寄存器，通过该寄存器能够观察器件引脚上的值。如果 GPIO 信号配置为**输出** ， 则通常会反映输出上驱动的值，**写入此寄存器将被忽略** 。    **DATA** 是**数据寄存器** ，该寄存器控制 GPIO 信号**配置为输出时要输出的值** 。该寄存器的所有 **32 位** 都是一次写入的。读取该寄存器返回写入 **DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;** 的先前值，它不会返回器件引脚上的当前值。    MASK_DATA_LSW 和 MASK_DATA_MSW 是**数据掩码寄存器** ，该寄存器使软件能够有选择地一次更改所需的输出值。可以写入最多 16 位的任意组合，MASK_DATA_LSW 控制 Bank 的低 16 位， MASK_DATA_MSW 控制高 16 位。未写入的那些位保持不变并保持其先前的值。读取该寄存器返回写入 DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;的先前值;它不会返回器件引脚上的当前值。该寄存器避免了对未更改位的读-修改-写序列的需要。 **DIRM** 是**方向模式寄存器** ，用于控制 I/O 引脚是用作**输入还是输出** 。当 **DIRM [x] == 0** 时，**输出驱动器被禁用** ，该引脚作为**输入引脚** 使用。 **OEN** 是使能**输出寄存器** 。将 I/O 配置为输出时，该寄存器控制是否启用输出。**禁用输出时，引脚为 3 态** 。当 **OEN [x] == 0** 时，**输出被禁用** 。    从这些寄存器中我们可以看到，如果配置引脚为输出，不仅需要**设置方向，还要使能输出** 。关于这些寄存器的具体介绍，可参考 ug1085 手册。需要说明的是我们在程序中操作 MIO 时直接调用 **Xilinx 官方提供的函数** 即可，无需直接操作这些寄存器。    另外需要说明的是 MIO 信号对 PL 部分是不可用的，所以**对 MIO 的操作是纯 PS 的操作** ，且每个 GPIO 都可独立动态编程为输入、输出或中断检测。    **从上面看出，Zynq  的 PS 部分就像 stm32 一样，本质都是配置外设的寄存器，利用开发商或者其他提供的友好接口的库函数对寄存器进行配置开发。 stm32 使用 ARM公司提供的cortex-M3内核，通过下载器将机器码下载至存储器代码段。**</code></pre><p>**         此时再回过头来看 stm32 的 SoC 架构和总线系统相比 Zynq 的也容易看了许多，之后再看stm32<br>的数据手册也多了一些理解。还有之后的 stm32 的学习，可以使用 keil5 的调试功能，检查各个寄存器的值和执行的汇编语言，从而更深层面了解微机原理和<br>CPU 的运作。**</p><h3 id="2-实验步骤"><a href="#2-实验步骤" class="headerlink" title="2.实验步骤"></a>2.实验步骤</h3><pre><code>    本章的实验任务是使用 GPIO 通过 MIO 控制 PS 端 LED 的亮灭，实现 LED 闪烁的效果。    从实验任务我们可以画出如下的系统框图，DDR4 中**存放和运行程序** 、UART 打印信息、MIO 驱动 LED 外设。虽然本实验可以不需要 UART，不过为了方便打印一些信息，此处我们加上 UART。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/15845bb43a515dafb87742974f7da7e1.png"></p><p><strong>注意养成绘制系统框图的习惯，帮助理解系统架构</strong></p><h3 id="3-硬件设计"><a href="#3-硬件设计" class="headerlink" title="3.硬件设计"></a><strong>3.硬件设计</strong></h3><h4 id="step1：创建-Vivado-工程-1"><a href="#step1：创建-Vivado-工程-1" class="headerlink" title="step1：创建 Vivado 工程"></a>step1：创建 Vivado 工程</h4><pre><code>    此处介绍如何在**先前工程的基础上继续实验** 而不破坏先前的工程。    先打开《第一章 Hello World》实验的 Vivado 工程，打开后选择菜单栏的 File-&gt; Project-&gt;**Save As...。** 在弹出的另存为界面中可以输入新的工程名或更改保存位置，此处我们输入新的工程名“gpio_mio”， 工程位置保持默认即可，然后**取消勾选 Include run results** ，最后点击“OK”。（ _注意：文件所在路径不能过长，最多280个字符，如果保存失败修改存储路径；**另外之前的“Creat_Block_Design”之所以选择默认的“design_1”而不是特定的“hello_world”是因为这个名字设定之后便不可修改，另存之后仍是之前的名字**_ ）</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a300da9bfaa27e3b089ee32f0c5ce58e.png"></p><h4 id="step2：使用-IP-Integrator-创建-Processing-System-1"><a href="#step2：使用-IP-Integrator-创建-Processing-System-1" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a>step2：使用 IP Integrator 创建 Processing System</h4><pre><code>    在 Flow Navigator 中，点击 IP INTEGRATOR 下的 Open Block Design，在打开的下图 Diagram 窗口，双击打开 Zynq UltraScale+ MPSOC 重定义窗口。    在下图所示的重定义窗口，点击左侧的 I/O Configuration，在右侧的界面中展开 Low Speed，展开 I/O Peripherals，展开 GPIO，然后**勾选 GPIO0 MIO 和 GPIO1 MIO** 。另外开发板上的 Bank0 即原理图中的 BANK500 为 1.8V，所以我们将 5 处的 **Bank0、6 处的 bank2 电压设置为 LVCOMS 1.8V** ，最后点击 OK。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/22d22a4f6b00a858b25620f9107a6e89.png"></p><pre><code>    实际用到的 GPIO_MIO 与原理图相关。为了方便大家的查找和使用，MPSOC PS 端 IO 引脚分配我们都列在了资料盘开发板原理图文件夹下的 IO 引脚分配总表中，我们摘录部分如下图</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/06d6440e02418eff773e87c0e910e21a.png"></p><p>按 Ctrl+S 快捷键保存 Diagram。</p><h4 id="step3：生成顶层-HDL"><a href="#step3：生成顶层-HDL" class="headerlink" title="step3：生成顶层 HDL"></a>step3：生成顶层 HDL</h4><pre><code>    在弹出的下图中，Synthesis Options 选择 Global，Run Setings 保持默认选择，然后点击 Generate。</code></pre><p>注意与实验一区别，实验一是“Out of context per IP”，这里是“Global”。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/789eafaaea99b49efbeba278724a37c7.png"></p><pre><code>    创建顶层 HDL Wrapper 因为我们在创建 Hello World 实验时创建顶层 HDL Wrapper 使用的是下图所示的 Let Vivado manage wrapper and auto-update选项，所以此处无**需再创建顶层HDL Wrapper** ，Vivado会**自动更新** 顶层HDL Wrapper。 此时第三步完成。</code></pre><h4 id="step4：生成-Bitstream-文件并导出-Hardware-1"><a href="#step4：生成-Bitstream-文件并导出-Hardware-1" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    由于本实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需导出 hardware 即可。步骤和实验一相同。</code></pre><h3 id="4-软件设计"><a href="#4-软件设计" class="headerlink" title="4.软件设计"></a>4.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程-1"><a href="#step5：在-Vitis-中创建应用工程-1" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><pre><code>    基本与实验一相同。工程名改为“gpio_mio”；选择工程模版“Empty Application”，本章将自行创建工程文件，故选择空模板，然后点击“Finish” 按钮，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff2d68a7c22fa4b09d43e81130318de6.png"></p><pre><code>    双击硬件平台目录下 **platform.spr** 文件，找到点击板级支持包“Board_Support_Package”，点击展开 “Peripheral Drivers”，右侧有相关文档和示例。找到 GPIO，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f3d3d587cd53c95f702a694e8f53a48.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50988f6dd1c1fbc068ae09865a09fcab.png"></p><pre><code>    点击 **Documentation** 将在浏览器窗口打开 GPIO 的 API 文档，里面有关于 GPIO 的详细信息，想了解 GPIO 的，可以仔细浏览其中的信息。    导入示例。如果我们点击 I**mport Examples（Documentation 旁边的按钮）** ，会弹出下图所示的导入示例界面，关于 GPIO 有两个示 例，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f685cd0fd33c4130ea055d933944d57.png"></p><pre><code>    这两个示例的介绍可以在刚才打开的**API 文档** 中看到。在 API 文档中点击左侧的 **Examples** ，右侧出现 这两个示例的介绍信息，如图所示： xgpiops_intr_example.c 包含有关如何**直接使用 XGpiops** 驱动程序的示例。此示例显示了**中断模式下驱动程序** 的用法，并使用 GPIO 的中断功能检测按钮事件，根据输入控制 LED 输出。xgpiops_polled_example.c 同样包含有关如何直接使用 XGpiops 驱动程序的示例。此示例提供了用于**读取/写入各个引脚** 的 API 的用法。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8162740976bf76b39eb8589e7b500a26.png"></p><pre><code>    们因为本实验暂未使用到中断，所以应该选择 xgpiops_polled_example 示例。选择 好示例后，点击“OK”按钮。    在 **Explorer 中，新增了 xgpiops_polled_example_1 目录** ，我们打开其 src 目录下的 xgpiops_polled_example.c 文件。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/072ba1557df31687c6828beaba8efd56.png"></p><pre><code>    显示行数。此处我们说一下如何显示代码的行数，在下图所示的 **1 处箭头** 所指的上或下方点击鼠标右键，在弹出的菜单中选择 2 处的 **Show Line Numbers** ，就会显示代码的行数。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b9b755efab66ebd848ace23a8d60d223.png"></p><pre><code>    xgpiops_polled_example.c 文件有四个函数，其中 **GpioInputExample** 函数由于我们本实验只用 MIO 输出所以未用到。该文件代码虽然是为特定开发板使用的，不过我们稍作修改也可以拿来使用。有两个 LED 分别接到 PS 的 MIO38 和 MIO39，这里我们使用 PS_LED1，即连接 MIO38。 我们修改该文件第 193 行的 Output_Pin 为 38，保存该文件，然后编译，编译完成后下载到开发板会看到板 上的 LED1 灯闪烁，闪烁时间约为 2 秒，随后 LED 灯熄灭。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e37cf706e4506426aa0b2ecddfaba1b7.png"></p><pre><code>    现在我们自己动手写一个驱动 MIO 的代码。    新建源文件。首先我们在 **gpio_mio/src** 目录上右键，选择 **New- &gt; File**，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/96a7b91131fcef0da025feaca171ac69.png"></p><pre><code>    在添加源文件界面中，File name 一栏我们输入文件名“main.c”，然后点击“Finish”按钮。输入源代码。我们在新建的 main.c 文件中输入以下代码：#include &quot;xparameters.h&quot; //器件参数信息#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义#include &quot;xil_printf.h&quot; //包含 print()函数#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数#include &quot;sleep.h&quot; //包含 sleep()函数//宏定义 GPIO_DEVICE_ID#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID//连接到 MIO 的 LED#define MIOLED0 38 //连接到 MIO38#define MIOLED1 39 //连接到 MIO39 XGpioPs Gpio; // GPIO 设备的驱动程序实例 int main() &#123;int Status;XGpioPs_Config *ConfigPtr;print(&quot;MIO Test! \n\r&quot;);ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);if (Status != XST_SUCCESS)&#123;return XST_FAILURE;&#125;//设置指定引脚的方向：0 输入，1 输出XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED1, 1);//使能指定引脚输出：0 禁止输出使能，1 使能输出XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED1, 1);while (1) &#123;XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); //向指定引脚写入数据：0 或 1XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x0);sleep(1); //延时 1 秒XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x1);XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x1);sleep(1);&#125;return XST_SUCCESS; &#125;    该代码实现了 LED 灯每隔 1 秒闪一次的功能。    代码第 8 行我们宏定义了 **GPIO_DEVICE_ID** ，使其为 **XPAR_XGPIOPS_0_DEVICE_ID** ，如果在 Vitis 软件中，按住 Ctrl 键不放，将鼠标移动到 XPAR_XGPIOPS_0_DEVICE_ID 上，当鼠标变成手指状时，单击 鼠标左键，会自动跳转到 **xparameters.h** 文件中，该文件定义了各个外设的基地址、器件 ID、中断等，我们 这里重新宏定义 XPAR_XGPIOPS_0_DEVICE_ID 是为了以后方便修改。    代码第 10 行宏定义了 **MIOLED0** ，其值为 38，因为其连接到 PS 的 MIO38 引脚。一般对于这种 MIO 的 使用，驱动某一引脚，在代码中使用该引脚对应的 MIO 数字标号即可。    代码第 21 行至 26 行是**获取 GPIO 的 ID 和基址信息并初始化其配置** ，以及判断是否初始化成功。代码第 28 行的 **XGpioPs_SetDirectionPin** 和 31 行 **XGpioPs_SetOutputEnablePin** 函数分别是设置 **GPIO 的方向（输 入还是输出）** 函数和**使能输出函数** ，代码第 35 行的 **XGpioPs_WritePin** 是向指定 **GPIO 引脚写入数据的函数** ， 关于这三个函数的具体使用可以查看其定义。查看其定义的简便方法是在 VITIS 软件中，按住 Ctrl 键不放， 将鼠标移动到想查看定义的函数名上，当鼠标变成手指状时，单击鼠标左键，即可跳转到定义或声明的地方。    代码第 37 和第 40 行的 sleep 函数为秒延时函数，延时 m 秒就使用 sleep(m)语句。还有一个微秒延时函数 usleep(m)，延时 m 微秒。    编译工程。保存 main.c 文件，右键点击应用工程 gpio_mio，在弹出的菜单中选择 **Build Project** ， 如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9e8f14d55907d0b645cf585020c1c212.png"></p><p>编译完成后，生成 elf 文件，</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4acd636a64b21b3d624d428a56fa75bb.png"></p><h3 id="5-下载验证"><a href="#5-下载验证" class="headerlink" title="5.下载验证"></a>5.下载验证</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fc2a33922f6e87d7a4af525f2d2b3bed.png"></p><h2 id="三-GPIO-之-EMIO-按键控制-LED-实验"><a href="#三-GPIO-之-EMIO-按键控制-LED-实验" class="headerlink" title="三.GPIO 之 EMIO 按键控制 LED 实验"></a>三.GPIO 之 EMIO 按键控制 LED 实验</h2><pre><code>    PS 和外部设备之间的通信主要是通过**复用的输入/输出（Multiplexed Input/Output，MIO）** 实现的。除此之外，PS 还可以通过扩展的**MIO（Extended MIO，EMIO）** 来实现与外部设备的连接。**EMIO 使用了 PL 的 I/O 资源** ，当 PS 需要扩展**超过 78 个引脚的时候可以用 EMIO** ，也可以用它来**连接 PL 中实现的 IP 模块** 。</code></pre><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    在大多数情况下，PS 端经由 EMIO 引出的接口会直接连接到 PL 端的器件引脚上，**通过 IO 管脚约束来指定所连接 PL 引脚的位置** 。通过这种方式，EMIO 可以为 PS 端实现**额外的 96 个输入引脚或 96 个带有输出使能的输出引脚** 。EMIO 还有一种使用方式，就是**用于连接 PL 内实现的功能模块（IP 核）** ，此时 PL 端 的 IP 作为 PS 端的一个外部设备。    本章的实验任务是使用 MPSOC 开发板上的两个 **PS 端按键控制 PL 端 LED 亮灭** ，**两个 PL 端按键去控 制 PS 端 LED 的亮灭** 。</code></pre><h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b00b29d17bda34dc8e2021d19b3da5c7.png"></p><pre><code>    在配置界面中，点击左侧的 I/O Configuration。然后在右侧展开 GPIO 一栏，勾选 GPIO EMIO，并设置**位宽为 4** 。该设置将通过 EMIO 扩展一个 4 位的 GPIO 接口信号，此信号将用于连接 PL 端的引脚。注意这里 GPIO0 和 GPIO1 已经勾选。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f91ebcf53451f5c237c47a5fee50e1a7.png"></p><pre><code>    完成配置后，点击右下角的“OK”按钮。然后在 Diagram 窗口中可以看到 Zynq UltraScale+ MPSoC 多 了一个 GPIO_0 端口，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6db0239064ee56374c85381472489777.png"></p><pre><code>    将光标移动到上图中箭头所指示的位置，会发现光标变成了铅笔的样式。点击选中该端口，然后点击 鼠标右键，在弹出的列表中选择“**Make External** ”。点击选中该接口，在左侧 External Interface Properties 一栏中将该接口的名称修改为 GPIO_EMIO。如下 图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/87308bc75d7d72d6921777208d4fd904.png"></p><pre><code>    在 Sources 窗口中展开 Design Sources，然后右键点击 design_1_wrapper 下的 design_1.bd，在弹出 的菜单中选择 Generate Output Products（在之前的实验中，我们创建顶层模块时选择了“Let Vivado manage wrapper and auto-update”选项，所以 此处无需再创建顶层 HDL Wrapper，Vivado 会自动更新顶层 HDL Wrapper。）</code></pre><h4 id="step4：生成-Bitstream-文件并导出-Hardware-2"><a href="#step4：生成-Bitstream-文件并导出-Hardware-2" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    在左侧**Flow Navigator 导航栏** 中找到 **RTL ANALYSIS** ，点击该选项中的“**Open Elaborated Design** ”。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed28803feaff06157fb29b7ac79959b0.png"></p><p>注意：如果出现闪退<a href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513?spm=1001.2014.3001.5506" title="Vivado RTL 闪退问题的解决办法">Vivado RTL<br>闪退问题的解决办法</a></p><pre><code>    在 ELABORATED DESIGN 界面下方找到 I/O Ports 窗口。如果没有找到 I/O Ports 一栏则通过在菜单栏 中点击 Layout，然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 窗口中对 PL 部分的接口进行管 脚分配。PS 端的管脚约束文件，在图 3.3.12 中选择“Generate Output Products”之后，Vivado 工具会自动创建。    在本次实验中，EMIO 扩展了四个 GPIO 的接口信号，即上图中的 GPIO_EMIO_tri_io[0]， GPIO_EMIO_tri_io[1]，GPIO_EMIO_tri_io[2]，GPIO_EMIO_tri_io[3]。这里，我们将 GPIO_EMIO_tri_io[0] 接到 PL_KEY1 引脚，GPIO_EMIO_tri_io[1]接到 PL_KEY2 引脚，GPIO_EMIO_tri_io[2]接到 PL_LED1 引脚， GPIO_EMIO_tri_io[3]接到 PL_LED2 引脚。 查看原理图可知，这四个引脚的管脚约束分别是，PL_KEY1 为 AD11，PL_KEY2 为 AD10，PL_LED1 为 AE10，PL_LED2 为 AF10，且都在 BANK44 上，该 BANK 电压为 3.3V。接下来在软件中进行管脚分配， I/O Std 一列对应的电平也需要修改。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae0e2d2e82480a55119adb7ff3b0fcb2.png"></p><pre><code>    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“pin”，最后点击“OK”。    在左侧Flow Navigator 导航栏中找到PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 然后在连续弹出的对话框中依次点击“YES”、“OK”。此时，Vivado 工具开始对设计进行综合、实现、并生 成 Bitstream 文件。生成 Bitstream 完成后，在弹出的对话框中选择“Open Implemented Design”。点击“OK”，如果弹出对话框提示关闭 Elaborated Design，则点击“YES”。 在 IMPLEMENTED DESIGN 界面我们可以查看设计对 PL 资源的使用情况。在左侧 Flow Navigator 导 航栏中找到 **IMPLEMENTATION** ，点击该选项中的“**Report Utilization** ”，然后在弹出的对话框中点击“OK”。    在界面下方的 Utilization 标签页中，选择左侧的 Summary，然后在右侧会以表格和柱状图两种方式显 示当前 PL 资源的使用情况。在我们本次实验中，只消耗了 PL 端 4 个 LUT 和 4 个 IO 资源，这个 IO 就是 PS 通过 EMIO 扩展 GPIO 接口信号时所使用的 PL 引脚。如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/36d3b2fa130b81b99840523163257bd8.png"></p><pre><code>    在菜单栏中选择 File &gt; Export &gt; Export hardware。 在弹出的对话框中，**勾选“Include bitstream”** ，然后点击“OK”按钮。在此处需要注意，如果我们的设计使用了 PL 的资源，比如使用了 PL 的引脚，或者在 PL 内实现了部 分功能模块，那么我们就需要生成 Bitstream 文件，并在导出硬件的时候包含该文件。</code></pre><h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>#include &quot;stdio.h&quot;#include &quot;xparameters.h&quot;#include &quot;xgpiops.h&quot; #define GPIOPS_ID XPAR_XGPIOPS_0_DEVICE_ID //PS 端 GPIO 器件 ID#define MIO_LED1 38 //PS_LED1 连接到 MIO38#define MIO_LED2 39 //PS_LED2 连接到 MIO39#define MIO_KEY1 40 //PS_KEY1 连接到 MIO40#define MIO_KEY2 41 //PS_LEY2 连接到 MIO41#define EMIO_KEY1 78 //PL_KEY1 连接到 EMIO0#define EMIO_KEY2 79 //PL_KEY2 连接到 EMIO1#define EMIO_LED1 80 //PL_LED1 连接到 EMIO2#define EMIO_LED2 81 //PL_LED2 连接到 EMIO3int main()&#123;printf(&quot;EMIO TEST!\n&quot;);XGpioPs gpiops_inst; //PS 端 GPIO 驱动实例XGpioPs_Config *gpiops_cfg_ptr; //PS 端 GPIO 配置信息//根据器件 ID 查找配置信息gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);//初始化器件驱动XGpioPs_CfgInitialize(&amp;gpiops_inst,gpiops_cfg_ptr,gpiops_cfg_ptr-&gt;BaseAddr);//设置 LED 为输出XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED1, 1);XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED2, 1);XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED1, 1);XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED2, 1);//使能 LED 输出XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED1, 1);XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED2, 1);XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED1, 1);XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED2, 1);//设置 KEY 为输入XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY1, 0);XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY2, 0);XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY1, 0);XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY2, 0);//读取按键状态，控制 LED 亮灭while(1)&#123;XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED1,~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY1));XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED2,~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY2));XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED1,~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY1));XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED2,~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2));&#125;return 0;&#125;    在代码的第 7 至 10 行，我们指定了 PS 端输出 LED 和输入 KEY 的 MIO 编号，这些编号可以从 MPSOC 开 发板的原理图中查到。在代码的 11 至 14 行指定了 PL 端 LED 和按键 KEY 的 EMIO 编号。    在本章的简介部分我们提到过，MPSOC 的 GPIO 被分成了 6 组，其中通过 EMIO 扩展的 GPIO 接口位于 BANK3 至 BANK5 中。在本次实验中我们通过 EMIO 扩展了 4 个 GPIO 信号，即 BANK3 的 EMIO0，EMIO1，EMIO2，EMIO3，由于 GPIO 的 BANK0，BANK1，BANK2 分别有 26 个信号，即 MIO 共有 78 个信号，**所以 BANK3 的 EMIO0 是第 79 个信号，编号为 78（从 0 开始编号）。**    我们按住 Ctrl 键，然后点击代码开头处所引用的头文件“xgpiops.h”以打开该文件。在 xgpiops.h 文件第 162 行给出了 MPSOC 器件 GPIO 最大的引脚数目，共 174 个，分别位于 6 个 Bank 中。在下面的注释中则分别列出了各 Bank 的引脚编号范围，同样可以看到 Bank3 的第一个引脚编号为 78。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a05a2ccf9124d96bc86553e3879682d.png"></p><h2 id="四-GPIO之MIO按键中断实验"><a href="#四-GPIO之MIO按键中断实验" class="headerlink" title="四.GPIO之MIO按键中断实验"></a>四.GPIO之MIO按键中断实验</h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="处理器中断类型"><a href="#处理器中断类型" class="headerlink" title="&lt;1&gt;.处理器中断类型"></a>&lt;1&gt;.处理器中断类型</h4><p>• 可屏蔽中断（Maskable Interrupts，IRQ)</p><p>• 不可屏蔽中断（Non-Maskable Interrupts，NMI)</p><p>• <strong>处理器间中断（Inter-Processor Interrupts，IPI)</strong><br>：—在多处理器系统中，一个处理器可能需要中断另一个处理器的操作。在这种情况下，就会产生一个 IPI，以便于处理器间通信或同步。</p><h4 id="中断控制器GIC"><a href="#中断控制器GIC" class="headerlink" title="&lt;2&gt;中断控制器GIC"></a>&lt;2&gt;中断控制器GIC</h4><pre><code>    ARM SOC 系统中 CPU 的中断信号仲裁器件：**GIC** （**general interrupt controller** ， 通用中断控制器） _**【功能和结构上类似于《微机原理》中的可编程中断控制器8259】**_    当对应的中断源有效时，GIC 根据该中断源的配置，决定是否将该中断信号，发送给 CPU。如果有多 个中断源有效，那么 GIC 还会进行仲裁，选择最高优先级中断，发送给 CPU。 当 CPU 接受到 GIC 发送的中断，通过读取 GIC 的寄存器，就可以知道中断的来源来自于哪里，从而可以做相应的处理。 当 CPU 处理完中断之后访问 GIC 的寄存器，该中断处理完毕。GIC 接受到该信息后，将该中断源取消，避免又重新发送该中断给 CPU 以及允许中断抢占。    Zynq Ultrascale+ MPSOC 包含两个中断控制器(GIC)，分别是符合 GICv2 架构规范的 Arm GIC-400 通用中断控制器 APU GIC 和符合 GICv1 架构规范的 Arm PL-390 通用中断控制器(PL390)。中断控制器框图如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/afde86e7494ef3caa5c1ecc3c4445dc8.png"></p><p>上图中 GIC-400 是 APU 中断控制器，其功能划分如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/796c758bb3becf08035866a7a7deb2c8.png"></p><p>详细功能：  </p><pre><code>    APU 中断控制器被分为两部分，第一部分是分发器(Distributor)，用来登记传送进来的中断并对它们进行排序，然后将中断送到正确的目标 CPU。distributor 对中断提供以下的功能：–全局中断使能 –每个中断的使能 –中断的优先级 –中断的分组 –中断的目的 core –中断触发方式 –对于 SGI 中断，传输中断到指定的 core –每个中断的状态管理 –提供软件，可以修改中断的 pending 状态    中断控制器第二部分(CPU Interface)和每个 CPU 的中断线连接，用来触发相关 Cortex-A53 的中断。 cpu interface 提供了一下的功能：–将中断请求发送给 cpu –对中断进行认可（acknowledging an interrupt） –中断完成识别(indicating completion of an interrupt) –设置中断优先级屏蔽 –定义中断抢占策略 –决定当前处于 pending 状态最高优先级中断     每个 Cortex-A53 有**四个中断线** 作为输入，分别是**普通优先级中断 nIRQ，高优先级（或快速）中断 nFIQ， 普通优先级虚拟中断 nVIRQ，高优先级（或快速）虚拟中断 nFIQ**    APU 中断控制器处理三种类型中断：1**6 个软件产生的中断(SGI)，7 个私有外设中断(PPI)，92 个共享外设中断(SPI)**    每个 CPU 都可以使用软件生成的中断来中断自身、另一个 CPU 或同时中断两个 CPU。有 16 个软件生成中断，具体见表。向软件产生的中断寄存器（GICD_SGIR）写入 SGI 中断编号并指定目标 CPU（或 两个 CPU），就产生了一个 SGI。该写操作通过 CPU 自己的专用（私有）总线进行。**每个 CPU 都有自己 的一组 SGI 寄存器** ，用于生成 16 个软件生成的中断中的一个或多个。所有的 SGI 都是边沿触发的，且其敏感性类型是固定的，不能修改。      每个 CPU 核连接到了一个有七个外设中断的私有组上，这七个外设中断见表。需要注意的是：**来自 PL 的快速中断（FIQ）信号和中断（IRQ）信号** 在发送给中断控制器之前，会在传输给 PS 的时候被**反转** 。因此，这些信号因此**在 PL 内低电平有效，在 PS-PL 接口处高电平有效** 。 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc3fc6a7da9253c672f49890520b37d4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fa3a98c687d4b1476298098bdd3e11d.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/232e30f977e6357aeb48fc33afd0f8a4.png"></p><pre><code>    共享外设中断(SPI)是一种可以被分配器路由到任意指定处理器的外设中断。这些送到 GIC 的线性中断源来自各种中断源。    所有的中断请求，**无论是 PPI、SGI 还是 SPI，都分配了一个唯一的 ID 编号，以用于中断控制器的仲裁。**    中断分配器具有中断、处理器和活跃信息的中央列表，并负责触发 CPU 的软件中断。为了给每个处理器提供单独的副本，SGI 和 PPI 分派器寄存器是分组的。硬件确保针对**多个 CPU 的中断同一时间只能被一个 CPU 获取** 。</code></pre><p>RPU 中断控制器框图如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be784b536668403f3377da54da3b1333.png"></p><h4 id="GPIO-的-MIO-的中断"><a href="#GPIO-的-MIO-的中断" class="headerlink" title="&lt;3&gt;GPIO 的 MIO 的中断"></a>&lt;3&gt;GPIO 的 MIO 的中断</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/adf3469ae6c2d955307f37538bd069af.png"></p><p>寄存器说明：</p><pre><code>INT_MASK：这个寄存器是只读的，显示哪些位当前被屏蔽，哪些位未被屏蔽/启用。INT_EN：向该寄存器的任何位写入 1，可以启用/解除中断信号的掩码。从该寄存器读取将返回一个不可预测的值。INT_DIS：向该寄存器的任何位写入 1 都会屏蔽该中断信号。从该寄存器读取会返回不可预测的值。INT_STAT：该寄存器显示是否发生了中断事件。将 1 写入该寄存器中的某个位可清除该位的中断状态。将 0 写入该寄存器中的某个位将被忽略。INT_TYPE：该寄存器控制中断是边沿敏感还是电平敏感。INT_POLARITY：该寄存器控制中断是低电平有效还是高电平有效（或下降沿敏感或上升沿敏感）。INT _ANY：如果 INT_TYPE 设置为边沿敏感，则该寄存器在上升沿和下降沿都会启用中断事件。如果INT_TYPE 设置为电平敏感，则忽略该寄存器。    如果检测到中断，中断检测逻辑将 GPIO 的 **INT_STAT** 状态设置为真。如果中断未屏蔽，则 中断传输到一个或电路（图中未画出）。该或电路将**四个 BANK 中所有 GPIO 的所有中断组合成一个输出 （IRQ ID＃48）**到中断控制器。如果中断被禁止（屏蔽），则 INT_STAT 状态将保持直到被清除，但它**不会传输到中断控制器** ，除非稍后写入**INT_EN** 以禁用屏蔽。    如果 GPIO 中断是边沿触发的，则 INT 状态由检测逻辑锁存。通过**向 INT_STAT 寄存器写入 1 来清除 INT 锁存器** 。对于电平触发的中断，必须**清零 GPIO 中断输入源** ，以清除中断信号。或者，软件可以使用 **INT_DIS 寄存器屏蔽该输入** 。    **如果 INT_STAT = 1 且 INT_MASK = 0，则该中断信号有效。**</code></pre><h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d39702d5ebb5e0669f52c86ede2c349.png"></p><p>沿用二中使用的硬件平台</p><h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>导入硬件平台后在选择模版时选择**“Empty Application”**<strong>自行创建工程文件</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a45e282be5173c86ff34d81074f56dba.png"></p><p> 添加main.c文件后输入代码：</p><pre><code>/***************************** Include Files *********************************/#include &quot;xparameters.h&quot;#include &quot;xgpiops.h&quot;#include &quot;xscugic.h&quot;#include &quot;xil_exception.h&quot;#include &quot;xplatform_info.h&quot;#include &lt;xil_printf.h&gt;#include &quot;sleep.h&quot;/************************** Constant Definitions *****************************///以下常量映射到xparameters.h文件#define GPIO_DEVICE_ID      XPAR_XGPIOPS_0_DEVICE_ID      //PS端GPIO器件ID#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID  //通用中断控制器ID#define GPIO_INTERRUPT_ID   XPAR_XGPIOPS_0_INTR           //PS端GPIO中断ID//定义使用到的MIO引脚号#define KEY  40         //PS_KEY1 连接到 MIO40#define LED  38         //PS_LED1 连接到 MIO38#define LED2 39         //PS_LED2 连接到 MIO39/************************** Function Prototypes ******************************/static void intr_handler(void *callback_ref);int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId);/**************************Global Variable Definitions ***********************/XGpioPs gpio;   //PS端GPIO驱动实例XScuGic intc;   //通用中断控制器驱动实例u32 key_press;  //KEY按键按下的标志u32 key_val;    //用于控制LED的键值/************************** Function Definitions *****************************/int main(void)&#123;    int status;    XGpioPs_Config *ConfigPtr;     //PS 端GPIO配置信息    xil_printf(&quot;Gpio interrupt test \r\n&quot;);    //根据器件ID查找配置信息    ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);    if (ConfigPtr == NULL) &#123;        return XST_FAILURE;    &#125;    //初始化Gpio driver    XGpioPs_CfgInitialize(&amp;gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);    //设置KEY所连接的MIO引脚的方向为输入    XGpioPs_SetDirectionPin(&amp;gpio, KEY, 0);    //设置LED所连接的MIO引脚的方向为输出并使能输出    XGpioPs_SetDirectionPin(&amp;gpio, LED, 1);    XGpioPs_SetOutputEnablePin(&amp;gpio, LED, 1);    XGpioPs_WritePin(&amp;gpio, LED, 0x0);    //设置LED2连接的MIO引脚方向为输出并使能输出    XGpioPs_SetDirectionPin(&amp;gpio, LED2, 1);    XGpioPs_SetOutputEnablePin(&amp;gpio, LED2, 1);    XGpioPs_WritePin(&amp;gpio, LED2, 0x0);             //PS_LED2默认关闭；    //建立中断,出现错误则打印信息并退出    status = setup_interrupt_system(&amp;intc, &amp;gpio, GPIO_INTERRUPT_ID);    if (status != XST_SUCCESS) &#123;        xil_printf(&quot;Setup interrupt system failed\r\n&quot;);        return XST_FAILURE;    &#125;    //中断触发时，key_press为TURE，延时一段时间后判断按键是否按下，是则反转LED    while (1) &#123;        if (key_press) &#123;            usleep(20000);            if (XGpioPs_ReadPin(&amp;gpio, KEY) == 0) &#123;                key_val = ~key_val;                XGpioPs_WritePin(&amp;gpio, LED, key_val);            &#125;            key_press = FALSE;            XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断            XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断        &#125;    &#125;    return XST_SUCCESS;&#125;</code></pre><p>中断服务程序：</p><pre><code>//中断处理函数//  @param   CallBackRef是指向上层回调引用的指针static void intr_handler(void *callback_ref)&#123;    XGpioPs *gpio = (XGpioPs *) callback_ref;    //读取KEY按键引脚的中断状态，判断是否发生中断    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;        key_press = TRUE;        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断    &#125;&#125;</code></pre><p>**         由于所有 GPIO 共享相同的中断，因此软件必须同时考虑 INT_MASK 和 INT_STAT 以确定哪个 GPIO<br>导致中断**。这与stm32单片机每个端口使用一个中断号是不同的，<strong>因此中断服务程序也有很大区别</strong> 。</p><p>中断配置：</p><pre><code>//建立中断系统，使能KEY按键的下降沿中断//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针//  @param   GpioIntrId是Gpio中断ID//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILUREint setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)&#123;    int status;    XScuGic_Config *IntcConfig;     //中断控制器配置信息    //查找中断控制器配置信息并初始化中断控制器驱动    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);    if (NULL == IntcConfig) &#123;        return XST_FAILURE;    &#125;    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,            IntcConfig-&gt;CpuBaseAddress);    if (status != XST_SUCCESS) &#123;        return XST_FAILURE;    &#125;    //设置并使能中断异常    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);    Xil_ExceptionEnable();    //为中断设置中断处理函数    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,            (Xil_ExceptionHandler) intr_handler, (void *) gpio);    if (status != XST_SUCCESS) &#123;        return status;    &#125;    //使能来自于Gpio器件的中断    XScuGic_Enable(gic_ins_ptr, GpioIntrId);    //设置KEY按键的中断类型为下降沿中断    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);    //使能按键KEY中断    XGpioPs_IntrEnablePin(gpio, KEY);    return XST_SUCCESS;&#125;</code></pre><p> <strong>类比stm32的中断配置过程</strong> ：</p><pre><code>GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource13);EXTI_InitTypeDef EXTI_InitStructure;EXTI_InitStructure.EXTI_Line = EXTI_Line13;EXTI_InitStructure.EXTI_LineCmd = ENABLE;EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;EXTI_Init(&amp;EXTI_InitStructure);NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);NVIC_InitTypeDef NVIC_InitStructure;NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;NVIC_Init(&amp;NVIC_InitStructure);</code></pre><h2 id="五-AXI-GPIO-按键控制-LED-实验"><a href="#五-AXI-GPIO-按键控制-LED-实验" class="headerlink" title="五.AXI GPIO 按键控制 LED 实验"></a>五.AXI GPIO 按键控制 LED 实验</h2><pre><code>    在 PL 端**调用 AXI GPIO IP 核** ，并通过 AXI4-Lite 接口实现 PS 与 **PL 中 AXI GPIO 模块**的通信。</code></pre><h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    AXI GPIO IP 核为 AXI 接口提供了一个通用的输入/输出接口。与 PS 端的 GPIO 不同，AXI GPIO 是一个软核（Soft IP），即 MPSOC 芯片在出厂时并不存在这样的一个硬件电路，而是由用户通过配置 PL 端的逻辑资源来实现的一个功能模块。而 PS 端的 GPIO 是一个硬核（Hard IP），它是一个生产时在硅片中实现的功能电路。    AXI GPIO 可以配置成**单通道或者双通道** ，每个通道的**位宽** 可以单独设置。另外通过打开或者关闭三态缓冲器，AXI GPIO 的端口还可以被动态地配置成**输入或者输出接口** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcfd77f0e7a867a66966b28080460fab.png"></p><pre><code>    从图中可以看到，模块的左侧实现了一个 _**32 位的 AXI4-Lite 从接口**_ ，用于主机访问 AXI GPIO 内部各通道的寄存器。当右侧接口输入的信号发生变化时，模块还能向主机产生中断信号。不过只有在配置 IP 核时选择“使能中断”，才会启用模块的中断控制功能。</code></pre><h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>系统框图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c51cad0adcbc38820dac88214135fe29.png"></p><pre><code>    在图中，PS 端的 M_AXI_HPM 作为主端口，与 PL 端的 AXI GPIO IP 核以 AXI4-Lite 总线相连接。 其中，**AXI 互联 IP（AXI Interconnect）用于连接 AXI 存储器映射（memory-mapped）的主器件和从器件** 。 </code></pre><h4 id="step2-vivado硬件平台"><a href="#step2-vivado硬件平台" class="headerlink" title="step2:vivado硬件平台"></a>step2:vivado硬件平台</h4><p>增加PS到PL的全局复位信号及axi接口：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a6dafe34ae5d0e1778d7f04193aecdad.png"></p><p>增加PS到PL的时钟：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe48d12f2f77f094e6b3719c06695d57.png"></p><p>在二的基础上增加PL端中断及PS段端口，如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39009b1c2ebe277967b7791935f49940.png"></p><pre><code>    另外我们还要用到 PS 端的 LED，因此需要在 I/O Configuration 界面勾选“GPIO1 MIO”，并设置 Bank0， Bank2 电压为 1.8V</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ae3c0baeb2513a1632d8da9312b1247.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f44edc425ad3ffe47efb17b246ba2931.png"></p><pre><code>    **M_AXI_HPM0_LPD 是通用（General Purpose）AXI 接口** ，它包含了一组信号。首字母 M 表示 PS 作 为主机（Master），PL 中的外设作为从机（Slave）。而左侧的 **maxihpm0_lpd_aclk 是这个接口的全局时钟信号** ，它是一个输入信号，M_AXI_HPM0_LPD 接口的所有信号都是在这个全局时钟的上升沿采样的。    **pl_clk0 是 PS 输出的时钟信号** ，它将作为 PL 中外设模块的时钟源。在配置 MPSOC 的时候，该时钟默认为 100MHz。    **pl_resetn0 是由 PS 输出到 PL 的全局复位信号** ，低电平有效。   **  pl_ps_irq0[0:0]是由 PL 输出到 PS 的中断信号**。    接下来我们要在 Block Design 中**添加 PL 端的 AXI GPIO IP 核** ，在 Diagram 窗口空白位置右击，然后选 择“Add IP”。在弹出的 IP 目录中搜索“AXI GPIO”，最后双击搜索结果中的“AXI GPIO”将其添加到设计中。</code></pre><p>并双击进行配置：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b35bda5f46246c70ce0f5d793b90b9d0.png"></p><pre><code>    GPIO **接口的位宽“GPIO Width”，最大可以支持 32 位** 。这里我们只需要连接一个按键，因此将其设置为 1。另外我们还需要使能其中断功能， 所以需要勾选“Enable Interrupt”。    我们也可以通过勾选图中的“All Inputs”或者“All Outputs”将 GPIO 指定为输入或者输出接口。这两个选项默认是没有勾选的，这样我们**可以在程序中将其动态地配置成输入或者输出接口** 。    箭头 1 所指示的参数“**Default Tri State Value** ”，它配置 GPIO **默认情况下的输入输出模式** ，当其为 0xFFFFFFFF 时，表明 GPIO 所有的位默认为输入模式。    另外勾选箭头 2 所指示的选项可以使能 GPIO 通道 2，GPIO 2 的配置与 GPIO 完全相同。该选项默认没有勾选，即该 IP 工作在单通道模式下。    按住左键将中断接口“ip2intc_irpt”与 Zynq UltraScale+ MPSOC 的中断接口“pl_ps_irq0[0:0]”连接起来。鼠标指针放到 GPIO 接口上，右击选择 Make External。修改 AXI GPIO IP 核引出的 GPIO 端口的名称。点击引出的 GPIO_0 端口，在左侧外部端口属性一栏中 将其名称修改为“AXI_GPIO_KEY”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a865cb250e683464ce34579721b2fe85.png"></p><pre><code>    接下来点击上图中箭头所指示的 _**Run Connection Automation**_ ，在弹出的对话框左侧确认勾选 All Automation，下面列出了会自动连接的模块及其接口，点击“OK”，工具会自动连接 AXI GPIO IP 核的 S_AXI 接口。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd461f7dc04e37cc5487f425c7087cd8.png"></p><pre><code>    从上图中可以看到，在执行了自动连接之后，工具自动添加了两个 IP 核，分别是 **AXI 互联（AXI Interconnect）和处理器系统复位（Processor System Reseet）** 。AXI Interconnect IP 核用于将一个（或多个）AXI 存储器映射的主器件连接到一个（或多个）存储器映射的从器件。    Processor System Reseet IP 核为整个处理器系统提供复位信号。它会处理输入端的各种复位条件，并在输出端产生相应的复位信号。在本次实验中，Processor System Reseet 接收 Zynq UltraScale+ MPSOC 输出的异步复位信号 pl_resetn0，然后**产生一个同步到 PL 时钟源 pl_clk0 的复位信号 peripheral_aresetn** ，用于**复位 PL 端的各外设模块** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d9347dbf7aa03eedbecec9d3a0b63a8.png"></p><pre><code>    可以看到 PL端所有外设模块的时钟接口都连接到了 Zynq UltraScale+ MPSOC 输出的时钟信号 pl_clk0 上。需要注意的是，该时钟同样连接到了 PS 端 maxihpm0_pld_aclk 端口，作为M_AXI_HPM0_LPD 接口的全局时钟信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a54df03d0cedfd028171a2669e7ce9ea.png"></p><pre><code>    在 Diagram 窗口空白处右击，然后选择**“Validate Design”** 验证设计。验证完成后弹出对话框提示“Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键 “Ctrl + S”保存设计。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d026edbf7c4ce40cb984637584191f12.png"></p><pre><code>    接下来在**Source 窗口中右键点击 Design Source 设计文件“design_1.bd”** ，然后依次执行**“Generate Output Products”和“Create HDL Wrapper”** 。     在左侧 Flow Navigator 导航栏中找到 **RTL ANALYSIS** ，点击该选项中的“Open Elaborated Design”。然 后在菜单栏中点击 Layout，在下拉列表中选择 **I/O Planning** 以打开 I/O Ports 窗口。我们将在 I/O Ports 窗口 中对 AXI GPIO 引出的接口 AXI_GPIO_KEY 进行管脚分配</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/10d614749b63a945e72f6d57f7e76e21.png"></p><pre><code>    管脚分配完成后按快捷键 Ctrl+S 保存管脚约束，在弹出的窗口中输入引脚约束文件名，然后点击 “OK”</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0073c6eb2211efe47db4fdc9665158ad.png"></p><pre><code>     最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”，在弹出的窗口中点击“OK”，对设计进行综合、实现、并生成 Bitstream 文件。Bitstream 文件生成后，会弹出 Bitstream Generation Completed 对话框，这里直接点击取消。     在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”    新建 vitis 文件夹，将产生的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境...</code></pre><h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    创建vitis工程“axi_gpio”，新建main.c文件内容如下：#include &quot;stdio.h&quot;#include &quot;xparameters.h&quot;#include &quot;xgpiops.h&quot;#include &quot;xgpio.h&quot;#include &quot;xscugic.h&quot;#include &quot;xil_exception.h&quot;#include &quot;xil_printf.h&quot;#include &quot;sleep.h&quot;//宏定义#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID#define MIO_LED      38                           //PS_LED1 连接到  MIO38#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义//函数声明void instance_init();                             //初始化器件驱动void axi_gpio_handler(void *CallbackRef);         //中断服务函数//全局变量XScuGic            scugic_inst;                   //中断控制器    驱动实例XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例int led_value = 1;                                //LED显示状态int main()&#123;printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);//初始化各器件驱动instance_init();//配置PS GPIOXGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED//配置PL AXI GPIOXGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断    //设置中断优先级和触发类型(高电平触发)    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);    //关联中断ID和中断处理函数    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);    //使能AXI GPIO中断    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);    //设置并打开中断异常处理功能    Xil_ExceptionInit();    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,    (Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);    Xil_ExceptionEnable();    while(1);    return 0;&#125;//初始化各器件驱动void instance_init()&#123;//初始化中断控制器驱动scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);//初始化PS端  GPIO驱动gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);//初始化PL端  AXI GPIO驱动XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);&#125;//PL端  AXI GPIO 中断服务(处理)函数void axi_gpio_handler(void *CallbackRef)&#123;int key_value = 1;XGpio *GpioPtr = (XGpio *)CallbackRef;print(&quot;Interrupt Detected!\n&quot;);XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据    if(key_value == 0)&#123;                                     //判断按键按下    led_value = ~led_value;    XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态    &#125;    sleep(1);                                               //延时1s 按键消抖    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断&#125;    在配置 PL 端 AXI GPIO 时，我们需要使能其中断功能，包括 AXI GPIO 通道 1 的中断和全局中断。    配置 GIC时，每一个中断源都有自己唯一的标识——中断号（ID），具体的数值可以在头文件 xparameters.h 中查看。其中由 PL 产生的**共享外设中断（SPI）共 16 个** ，中断 ID 分别为 121 到 128，以及 136 到 143。我们在程序第 14 行定义了一个宏 **GPIO_INT_ID，用于标识 AXI GPIO 的中 断 ID，它的值为 121** 。    配置 GIC 首先需要**设置中断 ID 所代表的中断源的优先级和触发类型** 。中断优先级共分为 **32 个等级** ，0 代表最高优先级，0xF8（10 进制数 248）代表最低优先级，各优先级之间的**步进值为 8** 。也就是说，支持的 优先级分别为 0、8、16、32...248。中断触发类型分为高**电平敏感类型** 和**上升沿敏感类型** 。AXI GPIO 在检测到输入接口的信号发生改变时，会产生一个电平类型的中断请求，高有效，因此将中断源 AXI GPIO 的触发类型设置为高电平敏感类型。    然后还需要将中断 ID 与其中断服务函数关联起来。中断服务函数 axi_gpio_handler()是需要我们自己编写的，用于响应和处理 AXI GPIO 中断的函数。除此之外，还要调用函数 XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID)来使能中断 ID 所对应的中断源。    最后我们需要初始化并设置 ARM 处理器的异常处理功能，如程序第 57 至 61 行所示。ARM 处理器支 持 7 种异常情况：复位、未定义指令、软件中断、指令预取中止、数据中止、中断请求（IRQ）和快速中断请求（FIQ）。每种异常也都有自己的 ID 标识，其中 XIL_EXCEPTION_ID_INT 用于标识中断请求（IRQ） 异常。我们通过调用函数 Xil_ExceptionRegisterHandler( XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler) XScuGic_InterruptHandler, &amp;scugic_inst )来给 IRQ 异常注册处理程序，它会将中断控制器 GIC 的中断处理程序与 ARM 处理器中的硬件中断处理逻辑连接起来。另外还要通过 Xil_ExceptionEnable( )函数使能 IRQ 异常。</code></pre><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><pre><code>    本章节需重点理解MPSOC的内部硬件结构，重点理解GIC的工作原理以及各类器件、中断ID的含义，进而才能看懂代码部分的配置过程。查阅官方支持文档《ug1085-zynq-ultrascale-trm.pdf》，补充以下内容：</code></pre><p>除了APU GIC和RPU GIC，还有中断处理器件GIC proxy</p><ul><li><pre><code>  The **PMU** uses the **GIC proxy** interrupts when the RPU and APU cannot service an interrupt because the processor is powered down. The GIC proxy is a Xilinx architecture for the PMU external interrupt controller and is controlled by the PMU.</code></pre></li></ul><p>（PMU作用：the platform measurement unit (PMU) processor for power, error<br>management, and execution of an optional software test library (STL) for<br>functional safety applications.）</p><ul><li><pre><code>   There are **148 system interrupts **that connect to **each GIC** , the GIC proxy interrupt structure, and the PL fabric. The system interrupts are normally handled by the RPU or APU MPCores. The user firmware in the PMU can process system interrupts in the absence of an RPU or APU. The CSU does not connect to the system interrupts.</code></pre></li><li><pre><code>   GIC功能：</code></pre></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5981c4c11abe191bf657a9eaeb5c5fb6.png"></p><p>另外APU和RPU的GIC分别有各自特殊功能</p><ul><li><pre><code>   系统中断：  The table lists the IRQ numbers for the RPU and APU interrupt controllers, as well as the GIC proxy bit assignments.（部分如下，总共148个：40~187）</code></pre></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/052ea371c37f250ed9ee30b7a3920bba.png"></p><p>包含中断号、位的分配信息等</p><ul><li><pre><code>   中断控制器框图解析（图见四—1.简介）  The **shared peripheral interrupts （SPI）** are generated from various subsystems that include the _**I/O peripherals in the PS and logic in the PL.（SPI来源）**_</code></pre></li></ul><p><strong>——RPU GIC Interrupt Controller</strong></p><pre><code>    There are **two interfaces** between the **RPU MPCore** and the **RPU GIC.**    • Distributor interface is used to **assign the interrupts** to each of the Cortex-R5F MPCore processors.    • CPU interface with a separate set of **4 KB memory-mapped registers** for each CPU. This provides protection **against unwanted accesses by one CPU to interrupts that are assigned to the other.**    The **APU MPCores** processors access the RPU_GIC interrupt controller (Figure 13-2) **through their peripheral interface.**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e56a76baae5943bc6ec5fd907725da9.png"></p><pre><code>     *        三种中断：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a019922da4e97554d75c88ffb2c3443.png"></p><p>软件中断的触发为边沿且无法更改。触发方式为将SGI interrupt number写入寄存器PL390.enable_sgi_control<br>(ICDSGIR)中，通过读取interrupt acknowledge寄存器PL390.control_n_int_ack_n<br>(ICCIAR)或写入interrupt clear-pending寄存器PL390.enable_sqi_pending (ICDICPR)结束中断。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b0f0d542bdc1c62b77a0dbec31a48.png"></p><pre><code>    *        优先次序 Interrupt Prioritization    All of the **SGI and SPI interrupt** requests are assigned a unique ID number. The controller uses the ID number to arbitrate. The interrupt distributor holds the list of pending interrupts for each CPU and then selects the highest priority interrupt before issuing it to the CPU interface. Interrupts of equal priority are resolved by selecting **the lowest ID**.</code></pre><p><strong>——APU GIC Interrupt Controller</strong></p><pre><code>    The APU uses an external GICv2 controller as a central resource to support and manage interrupts. There are **peripheral interrupts, software generated interrupts, and virtual interrupts.**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db6aa664b84592fa37a46fe03ff62b69.png"></p><pre><code>    *        Virtual Interrupt    A virtual interrupt targets a **virtual machine** running on a processor and is typically signaled to the processor by the connected virtual CPU interface.（和虚拟机相关，详见文档）</code></pre><ul><li><pre><code>   Interrupt Architecture  The interrupt architecture includes eleven sets of registers with six registers per set. Each set is divided between **sending an interrupt (TRIG and OBS) and receiving an interrupt (ISR, IMR, IER, and IDR).（中断过程通过读写寄存器操作）**</code></pre></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/55ac29cbbb0817418efc8baab3e18d99.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/63fb614cb09abdfa5dffa67bee11f4b5.png"></p><ul><li><pre><code>   Determine the Source of Interrupt（确定中断源）  A processing unit reads its i**nterrupt status (ISR) and mask (IMR)** registers **to determine the source that caused the IRQ interrupt.** Once serviced, the ISR can be cleared by writing the data that was read from this register. The bits that were set are cleared while preserving any bits that got set after the read took place, which helps to eliminate missed interrupts</code></pre></li><li><pre><code>   示例代码：</code></pre></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/33f967286bcd5984c9f582d9fd3a340d.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133275810">https://blog.csdn.net/qq_32971095/article/details/133275810</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zynq简介——FPGA学习笔记＜7＞</title>
      <link href="/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/"/>
      <url>/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">一.xilinx Zynq UltraScale+ MPSoC</a></p><p><a href="about:blank#1.MPSoC%20%E7%AE%80%E4%BB%8B">1.MPSoC 简介</a></p><p><a href="about:blank#2.FPGA%E7%AE%80%E4%BB%8B">2.FPGA简介</a></p><p><a href="about:blank#3.MPSoC%20PL%20%E7%AE%80%E4%BB%8B">3.MPSoC PL 简介</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E5%8F%AF%E7%BC%96%E7%A8%8B%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83">（1）可编程输入&#x2F;输出单元</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83">（2）基本可编程逻辑单元</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9D%97%20RAM">（3）嵌入式块<br>RAM</a></p><p><a href="about:blank#%EF%BC%884%EF%BC%89%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%B8%83%E7%BA%BF%E8%B5%84%E6%BA%90">（4）丰富的布线资源</a></p><p><a href="about:blank#%EF%BC%885%EF%BC%89%E5%BA%95%E5%B1%82%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83">（5）底层嵌入功能单元</a></p><p><a href="about:blank#%EF%BC%886%EF%BC%89%E5%86%85%E5%B5%8C%E4%B8%93%E7%94%A8%E7%A1%AC%E6%A0%B8">（6）内嵌专用硬核</a></p><p><a href="about:blank#4.MPSoC%20PS%20%E7%AE%80%E4%BB%8B">4.MPSoC PS 简介</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89APU%EF%BC%88Application%20Processing%20Unit%EF%BC%89">（1）APU（Application Processing<br>Unit）</a></p><p>[（2）RPU（Real-Time Processing<br>Unit）](about:blank#%EF%BC%882%EF%BC%89RPU%EF%BC%88Real-<br>Time%20Processing%20Unit%EF%BC%89)</p><p><a href="about:blank#%EF%BC%883%EF%BC%89GPU%EF%BC%88Graphics%20Processing%20Unit%EF%BC%89">（3）GPU（Graphics Processing<br>Unit）</a></p><p><a href="about:blank#%EF%BC%884%EF%BC%89DDR%20Memory%20Controller">（4）DDR Memory<br>Controller</a></p><p><a href="about:blank#%EF%BC%885%EF%BC%89PMU%EF%BC%88Platform%20Management%20Unit%EF%BC%89">（5）PMU（Platform Management<br>Unit）</a></p><p>[（6）High-Speed Connect Zynq](about:blank#%EF%BC%886%EF%BC%89High-<br>Speed%20Connect%20Zynq)</p><p><a href="about:blank#%EF%BC%887%EF%BC%89%E6%99%AE%E9%80%9A%E5%A4%96%E8%AE%BE%E6%8E%A7%E5%88%B6%E5%99%A8">（7）普通外设控制器</a></p><p>[（8）PS-PL AXI 接口](about:blank#%EF%BC%888%EF%BC%89PS-<br>PL%20AXI%20%E6%8E%A5%E5%8F%A3)</p><p><a href="about:blank#5.DFZU2EG%20MPSoc%20%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90">5.DFZU2EG MPSoc<br>硬件连接资源</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89IO%20%E5%88%86%E9%85%8D">（1）IO 分配</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E7%94%B5%E6%BA%90%E7%B3%BB%E7%BB%9F">（2）电源系统</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">（3）启动模式</a></p><p><a href="about:blank#%EF%BC%884%EF%BC%89%E5%85%B6%E4%BB%96%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">（4）其他硬件资源</a></p><p><a href="about:blank#6.%E5%85%B6%E4%BB%96">6.其他</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">（1）注意事项</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%AD%A6%E4%B9%A0%20MPSoC%20%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%EF%BC%9A">（2）学习 MPSoC<br>基本方法：</a></p><hr><p>官网介绍：</p><p>[Zynq UltraScale+ MPSoC](<a href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p><p><a href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivityfor ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p><p><a href="http://www.pynq.io/" title="PYNQ -Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p><p>参考书目：《正点原子 DFZU2EG&#x2F;4EV MPSoc 之 FPGA 开发指南》</p><h2 id="一-xilinx-Zynq-UltraScale-MPSoC"><a href="#一-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="一.xilinx Zynq UltraScale+ MPSoC"></a>一.xilinx Zynq UltraScale+ MPSoC</h2><pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。</code></pre><h3 id="1-MPSoC-简介"><a href="#1-MPSoC-简介" class="headerlink" title="1.MPSoC 简介"></a>1.MPSoC 简介</h3><pre><code>    Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和 Virtex 系列。    每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和 UltraScale+（16nm），以提供不同的性能和功耗比。    Xilinx 的 SoC 是将可编程逻辑部分和处理器单元以及常见处理器外设封装在一起，集成到单颗芯片中， 并命名为“ZYNQ”，同样分为不同的系列，如 Zynq-7000（28nm）、Zynq UltraScale+ MPSoC（16nm）、 Zynq UltraScale+ RFSoC（16nm），如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/60b09a0ae2714b38a861d02d63e5efb1.png">​</p><pre><code>    Zynq7000 系列组合了一个双核 Arm Cortex-A9 处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件。由于该器件的可编程逻辑部分基于 Xilinx 28nm 工艺的 7 系列 FPGA，因此该系列产品的名称中添加了 “7000”，以保持与 7 系列 FPGA 的一致性，同时也方便日后本系列新产品的命名。    Zynq UltraScale+ MPSoC 的系统级性能功耗比相对 Zynq-7000 SoC 系列提升高达 5 倍。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器** 、**双核 Arm Cortex-R5F 实时处理器** 和一个传统的现场可编程门阵列（FPGA）逻辑部件，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。    Zynq UltraScale+ MPSoC 部分系列的产品，还包含了**Arm Mail-400MP2（GPU）** 和 H.264/H.265 视频编 解码器，可提供原生 UltraHD 压缩及专用引擎，满足动态电源管理与安全配置需求，可以说是对 ZYNQ 7000 的升级版本。Zynq UltraScale+ MPSoC 非常适用于 5G 无线基础设施、面向数据中心和有线通信的软件定义网络、新一代汽车驾驶员辅助系统和无人驾驶系统 (ADAS)、工业物联网系统 (IIoT)、超高清和超高画质摄像机、航空电子以及便携式软件定义无线电等各种应用。    Zynq UltraScale+ RFSoC 在 SoC 架构中集成数千兆采样 RF 数据转换器和软判决前向纠错 (SD-FEC)。 配有 ARM Cortex-A53 处理子系统和 UltraScale +可编程逻辑，该系列是业界唯一单芯片自适应射频平台。 Zynq UltraScale+ RFSoC 系列可为模拟、数字和嵌入式设计提供适当的平台，从而可简化信号链上的校准和 同步。多代产品系列包含广泛的器件类型，具有不同的直接 RF 性能，可满足各种频谱需求和使用案例。    Zynq UltraScale+ MPSoC 产品在单个设备中集成了功能丰富的**嵌入式处理系统(PS)和可编程逻辑(PL) UltraScale+架构** ，并且还包括片上存储器、多端口外部存储器接口以及丰富的外设连接接口集等等。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1885099ee6dfb7367468dd7d96d6923.png">​</p><pre><code>    Zynq UltraScale+ MPSoC除了嵌入式处理系统功能强大外，它还包含了可编程逻辑(PL) UltraScale+架构， 能够灵活的去编辑我们想要的逻辑运算，实现各种各样的复杂功能。从**本质上来讲，它还是一个片上处理系统（System on Chip，SoC）** 。</code></pre><p>注：板上系统 （System-on-a-Board）示意图如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b104c9b15be132b83147ceabf67924e.png"></p><p>​</p><p>而片上系统（System-on-<br>Chip）指的是在单个硅芯片就可以实现整个系统的功能。<strong>在一个芯片里就实现了存储、处理、逻辑和接口等各个功能模块，而不是像板上系统那样，需要用几个不同的物理芯片来实现。</strong></p><pre><code>    在过去，SoC 这个术语常用于指**专用集成电路（Application Specific Integrated Circuit，ASIC）** 。基于 ASIC 的 SoC 的代表性例子包括在 PC、平板和智能手机上使用的处理器，如华为旗舰手机中的麒麟系列芯片。这些处理器典型地是由至少两个处理器核、存储器、图形处理器、接口和其他功能模块组合起来的。 基于 ASIC 的 SoC 的主要缺点有两个：</code></pre><p>1、开发周期长且成本巨大；</p><p>2、缺乏灵活性。</p><pre><code>    开发 ASIC 时不可重 用的工程投入是巨大的，使得这种 SoC 类型只适合于**大批量而且寿命有限** 的产品中。 ASIC SoC 的局限性导致它们不适用于很多应用，特别是当快速投入市场能力、灵活性和升级能力已 经成为重要的关键因素。对于小批量或中批量的产品，ASIC SoC 也不是好的解决方案。    可编程片上系统**（SOPC，System-on-Progammable-Chip）** 为上述应用提供了一个更灵活的解决方案： 一种在可编程、可重新配置的芯片上实现的 SoC。可编程的芯片指的就是 FPGA。FPGA 天生的灵 活性使其可以被随心所欲地重新配置，以实现不同系统的功能，包括嵌入式处理器。和使用 ASIC 来实现 SoC 相比，FPGA 能构成更为基础灵活的平台，方便系统的升级。    与基于 ASSP 的固定 SoC 解决方案不同，Zynq UltraScale+ MPSoC 能通过灵活的 **32 或 64 位数据宽度** 的处理系统提供最大的可扩展性。它能将关键应用（例如图形和视频管线）分配给专用处理模块来处理，并通过有效的电源域 (power domain) 和电源孤岛 (power island) 来开启和关闭模块。Zynq UltraScale+ MPSoC 提供多种互连选项、DSP 模块以及可编程逻辑选择，因而具备整体灵活性，可满足 用户的各种 应用需求。该产品系列具备出色可扩展性，使设计人员能够利用单个平台和行业标准工具开发出低成本以 及高性能应用。</code></pre><h3 id="2-FPGA简介"><a href="#2-FPGA简介" class="headerlink" title="2.FPGA简介"></a>2.FPGA简介</h3><pre><code>    可编程逻辑器件（Programmable Logic Device，PLD），目前常见的 PLD 大体上可以分为 **SPLD（simple PLD，简单 PLD）、CPLD（complex PLD，复杂 PLD）和 FPGA（field-programmable gate array，现场可编程门阵列）** 。SPLD 中又可分为 PLA、PAL 和 GAL 几种类型。FPGA 也是一种可编程逻辑器件，但由于在电路结构上与早期已经广为应用的 PLD 不 同，所以采用 FPGA 这个名称，以示区别。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1560887deaa66558322d142f691a7c4.png"></p><pre><code>    通过扩展 SPLD 的概念就可以得到 CPLD。CPLD 是复杂可编程逻辑器件，相当于将**多个 PAL 用可编程互联阵列（Programmable Interconnect Array，PIA）连接** 起来，形成一个大的 PLD，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51b23c0e4eccaa6ca1148046910d0d8c.png"></p><pre><code>    上图中的 Logic block（逻辑块）通常被称为逻辑阵列模块，或者**LAB（Logic Array Block）** 。每个 LAB 相当于一个 PAL 电路，不同型号的 CPLD 器件可以包含十几个甚至上百个 LAB。通过 PIA 将这些 LAB 连接起来，就可以构成规模更大的逻辑电路了。另外，在 PAL 中，I/O 管脚是直接连接到逻辑的。而在 CPLD 中，I/O 管脚是通过 PIA 从器件的主要逻辑中分离出来的。I/O 管脚有它自己的控制逻辑，I/O 控 制单元可以根据需要将相应的引脚设置成输入、输出或双向工作模式。    CPLD 相对于 SPLD 最大的优势就是拥有更大的逻辑资源和布线的可能性。CPLD 中 LAB 逻辑和 PIA 是完全可编程的，使得它具有在单芯片中非凡的设计灵活性。CPLD 的 I/O 特性和功能也远比 SPLD 中简 单的 I/O 更有价值。    FPGA 由许多“可配置逻辑模块”（Configurable Logic Block，CLB）、输入/输出单元（I/O Block， IOB）和分布式的可编程互联矩阵（Programmable Interconnection Matrix，PIM）组成。在 FPGA 中，CLB 被布置成阵列的形式，如图 1.2.7 所示。可编程的布线资源分布在 CLB 与 CLB 之间，像大城市的街道一 样纵横联接。这些布线资源分为行互联和列互联，可以跨过整个器件，也可以是局部 CLB 之间的互联。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1f8eacf99307c89a4e2491e222287e7.png"></p><pre><code>    我们将图进行对比可以发现，FPGA 中的布线资源看上去似乎比 CPLD 中的互联阵列更简单，但它实际上提供了更大的功能性和连通性。FPGA 中的布线资源使得器件中所有的逻辑资源都可 以与芯片内其他资源进行通信，这种结构可以实现更大容量、低成本的逻辑器件。    在前面所讲的各种 SPLD 和 CPLD 电路中，都采用了与或逻辑阵列加上输出逻辑单元的结构形式。而 FPGA 则采用了完全不同的电路结构形式（查找表，LUT）</code></pre><h3 id="3-MPSoC-PL-简介"><a href="#3-MPSoC-PL-简介" class="headerlink" title="3.MPSoC PL 简介"></a>3.MPSoC PL 简介</h3><pre><code>    Zynq UltraScale+ MPSoC PL 部分等价于 FPGA，因此我们将首先介绍 FPGA 的架构。    简化的 FPGA 基本结构由 6 部分组成，分别为可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核等，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/278fa7234a1f4ee107063ffe158ca141.png"></p><h4 id="（1）可编程输入-输出单元"><a href="#（1）可编程输入-输出单元" class="headerlink" title="（1）可编程输入&#x2F;输出单元"></a>（1）可编程输入&#x2F;输出单元</h4><pre><code>    目前大多数 FPGA 的 I/O 单元被设 计为可编程模式，即通过软件的灵活配置，可以适配不同的电气标准与 I/O 物理特性；可以调整**匹配阻抗特性、上下拉电阻、以及调整驱动电流的大小** 等。         FPGA 支持的 I/O 电气标准有 LVTTL，LVCMOS，SSTL，HSTL，LVDS，LVPECL 和 PCI 等。一些高端 FPGA 通过 DDR 寄存器 技术，甚至可以支持高达 2Gbit/s 的数据数率。    Zynq UltraScale+ MPSoC 上的通用输入/输出功能（IOB）合起来被称作 SelectIO 资源，每个 I/O 都是可配置的，**可以遵循多种 I/O 标准** 。I/O 分为**高范围(HR，high-range)、高性能(HP)和高密度(HD)** 三种类型。其中 HR 类型提供最广泛的电压支持，**从 1.2V 到 3.3V** 。HP 类型支持 1.0V 到 1.8V 它对性能操作进行了优化。HD 类型的 IO 一般一个 BANK 上由 24 个 IO 组成，能提供从 1.2V 到 3.3V 的电压支持。    所有的 I/O 引脚都封装在 BANK 中，每个 BANK 上可以封装 52 个 HP 引脚，或者 52 个 HR 引脚，或 者 24 个 HD 引脚。每个 BANK 有一个公共的 VCCO 输出缓冲器电源，除了给输出缓冲器供电外也可以为 输入缓冲器供电。此外，HR BANK 可以一分为二，这两部分各自都有自己的 VCCO 供电。一些单端输入缓冲器需要一个内部产生的或外部应用的参考电压(VREF)。VREF 引脚可以直接连接 PCB，或者从 FPGA 内 部产生。</code></pre><p>**         所有输入和输出 IO 可以配置为组合型（wire）或注册型（reg）<strong>。所有输入和输出</strong>均支持 DDR (Double data<br>rate)** 。任何输入或输出都可以单独延迟高达 1,250ps，<strong>分辨率为 5-15ps</strong> ，这种延迟被称为<strong>IDELAY 和 ODELAY</strong><br>。我们可以通过增减 IODELAY 的延迟步进进而调整 IODELAY 的延迟时间，也可以将 IODELAY 级联在一起，使单个方向上的延迟量增加一倍。</p><pre><code>    Zynq UltraScale+ MPSoC 的 IO 资源还支持串并转换。每个 I/O 引脚拥有一个 IOSERDES(ISERDES 和 OSERDES)，能够执行 2、4 或 8 位可编程宽度的串行到并行或并行到串行转换。</code></pre><h4 id="（2）基本可编程逻辑单元"><a href="#（2）基本可编程逻辑单元" class="headerlink" title="（2）基本可编程逻辑单元"></a>（2）基本可编程逻辑单元</h4><pre><code>    基本可编程逻辑单元是可编程逻辑的主体，可以根据设计灵活地改变其内部连接与配置，完成不同的逻 辑功能。FPGA 一般是基于 SRAM 工艺的，其基本可编程逻辑单元几乎都是由**查找表（LUT，Look Up Table） 和寄存器（Register）** 组成。Xilinx UltraScale 系列 FPGA 内部查找表可以配置为带有**一个输出的 6 输入 LUT** ， 或者**两个带有独立输出但共用输入的 5 输入 LUT** ，查找表一般完成纯组合逻辑功能。FPGA 内部寄存器结构相当灵活，**可以配置为带同步/异步复位或置位的时钟使能触发器，也可以配置成锁存器** ，FPGA 依赖寄 存器完成同步时序逻辑设计。 一般来说，比较经典的基本可编程逻辑单元的配置是一个寄存器加一个查找表，但是不同厂商的寄存器 与查找表也有一定的差异，而且寄存器与查找表的组合模式也不同。当然这些可编程逻辑单元的配置结构随着器件的不断发展也在不断更新，最新的一些可编程逻辑器件常常根据需求设计新的 LUT 和寄存器的配置比率，并优化其内部的连接构造。 例如，Altera 可编程逻辑单元通常被称为 LE（Logic Element），由一个寄存器加一个 LUT 构成。Altera 大多数 FPGA 将 **10 个 LE 有机地组合在一起，构成更大的功能单元——逻辑阵列模块（LAB，Logic Array Block）** 。LAB 中除了 LE 还包含 LE 之间的进位链，LAB 控制信号，局部互联线资源，LUT 级联链，寄存器级联链等连线与控制资源。 Xilinx UltraScale 系列 FPGA 中的可编程逻辑单元叫 **CLB（Configurable Logic Block，可配置逻辑块）** 每个 CLB 包含一个逻辑运算片（**每个逻辑运算片包含 8 个 LUT 16 个寄存器** ）。逻辑运算片有两种类型， 分别是 SLICEL 和 SLICEM。SLICEM 中的 LUT 可以配置为 64 位 RAM、32 位移位寄存器(SRL32)或两个 16 位移位寄存器。与上一代 Xilinx 设备中的 CLB 相比，UltraScale 体系结构中的 CLB 增加了路由和连接 性。并且 UltraScale 的 CLB 还有额外的控制信号去使能更大的寄存器封装，可以提高设备的利用率。</code></pre><p><strong>注：xilinx新一代 UltraScale 结构可参考《xilinx FPGA 权威设计指南》</strong></p><h4 id="（3）嵌入式块-RAM"><a href="#（3）嵌入式块-RAM" class="headerlink" title="（3）嵌入式块 RAM"></a>（3）嵌入式块 RAM</h4><pre><code>    目前大多数 FPGA 都有内嵌的**块 RAM（Block RAM）** ，FPGA 内部嵌入可编程 RAM 模块，大大地拓展了 FPGA 的应用范围和使用灵活性。不同器件商或不同器件族的内嵌块 RAM 的结构不同，Lattice 常用的 块 RAM 大小是 9Kbit；Altera 的块 RAM 最灵活，一些高端器件内部同时含有 3 种块 RAM 结构，分别是 M512 RAM，M4K RAM，M9K RAM。 每个基于 UltraScale 架构的设备都包含大量的 36Kb 块 RAM（Block RAM，简称 BRAM），可以配置 为一个 36Kb RAM 或两个独立的 18Kb RAM；每个块 RAM 都有两个完全独立的端口，且每个端口都可以读写数据，读写数据由时钟进行控制。每个块 RAM 列中有一个使能信号，这个信号能够让垂直相邻的块 RAM 之间级联，这样就可以创建大型、快速的存储阵列或者创建 FIFO，而且大大降低了功耗。 对于 RAM 来说，所有输入的数据、地址、时钟使能信号和写入使能都会被寄存。比如说输入一个地址 数据，这个地址数据就会被锁定(除非地址锁关闭)寄存，在下一次操作来临之前，地址寄存器的值是不会发生改变的。在写操作期间，也可以输出数据，输出的数据可以是先前存储的数据也可以是新写入的数据，当然在写操作期间也可以不输出数据。对于在设计中未使用的块 RAM 会**自动关闭，以减少总功耗** 。在每个块 RAM 上还具有额外的引脚来控制动态功率的门控特性。 对于 Xilinx UltraScale 系列 FPGA 来说，除了具有 BRAM 资源外，还有一种 **UltraRAM** 资源。UltraRAM 是一种高密度、双端口、同步内存块，用于一些 UltraScale+系列器件。这两个端口共用同一个时钟，可以处理 **4K x 72 位** 的数据，每个端口都可以独立地对内存数组进行读写操作。UltraRAM 支持两种类型的写操作方案，第一种模式与块 RAM 写操作模式一致；第二种模式允许控制数据的奇偶字节写入。多个 UltraRAM块可以级联在一起创建更大的内存阵列。UltraRAM 可以用专用的路径使整个列的存储区域连接在一起，这 使得 UltraRAM 成为替代 SRAM 等外部存储器的理想解决方案，它可以灵活的支持级联从 288Kb 到 36Mb 的存储空间，用以满足许多不同的内存需求。</code></pre><h4 id="（4）丰富的布线资源"><a href="#（4）丰富的布线资源" class="headerlink" title="（4）丰富的布线资源"></a>（4）丰富的布线资源</h4><pre><code>    布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速 度。FPGA 芯片内部有着丰富的布线资源，这些布线资源根据工艺、长度、宽度和分布位置的不同而划分为 4 类不同的类别：    第一类是**全局布线资源** ，用于芯片内部**全局时钟和全局复位/置位** 的布线；    第二类是**长线资源** ，用以完成芯片 **Bank 间的高速信号和第二全局时钟信号的布线** ；    第三类是**短线资源** ，用于完成基本逻辑单元之间的逻辑互连和布线；    第四类是分布式的布线资源，用于专有时钟、复位等控制信号线。    在实际中设计者不需要直接选择布线资源，布局布线器可自动地根据输入逻辑网表的拓扑结构和约束条件选择布线资源来连通各个模块单元。从本质上讲，布线资源的使用方法和设计的结果有直接的关系。</code></pre><h4 id="（5）底层嵌入功能单元"><a href="#（5）底层嵌入功能单元" class="headerlink" title="（5）底层嵌入功能单元"></a>（5）底层嵌入功能单元</h4><pre><code>    底层**嵌入功能单元** 的概念比较笼统，这里我们指的是那些通用程度较高的嵌入式功能模块，比如 **PLL （Phase Locked Loop）、DLL（Delay Locked Loop）、DSP、CPU** 等。随着 FPGA 的发展，这些模块被越来 越多地**嵌入到 FPGA 的内部** ，以满足不同场合的需求。 目前大多数 FPGA 厂商都在 FPGA 内部**集成了 DLL 或者 PLL 硬件电路** ，用以完成时钟的高精度、低抖动的倍频、分频、占空比调整、相移等功能。目前，高端 FPGA 产品集成的 DLL 和 PLL 资源越来越丰富， 功能越来越复杂，精度越来越高。 另外，越来越多的高端 FPGA 产品将包含 DSP 或 CPU 等**硬核** ，从而 FPGA 将由传统的硬件设计手段逐步过渡到系统级设计平台。例如 Altera 的 Stratix IV、Stratix V 等器件内部集成了 DSP 核；Xilinx 的 Virtes II 和 Virtex II pro 系列 FPGA 内部集成了 Power PC450 的处理器。FPGA 内部嵌入 DSP 或 CPU 等处理器， 使 FPGA 在一定程度上具备了实现软硬件联合系统的能力，FPGA 正逐步成为 SOPC 的高效设计平台。</code></pre><h4 id="（6）内嵌专用硬核"><a href="#（6）内嵌专用硬核" class="headerlink" title="（6）内嵌专用硬核"></a>（6）内嵌专用硬核</h4><pre><code>    这里的**内嵌专用硬核** 与前面的底层嵌入单元是有区分的，这里讲的内嵌专用硬核主要指那些**通用性相对较弱** ，不是所有 FPGA 器件都包含硬核。 在 ZYNQ UltraScale 的 PL 端和 PS 端各有一个**系统监视模块——System Monitors** ，它就是一个硬核。 System Monitors 包含一个模数转换器（ADC），一个模拟多路复用器，片上温度和片上电压传感器等。我们可以利用这个模块监测芯片温度和供电电压，也可以用来测量外部的模拟电压信号。</code></pre><h3 id="4-MPSoC-PS-简介"><a href="#4-MPSoC-PS-简介" class="headerlink" title="4.MPSoC PS 简介"></a>4.MPSoC PS 简介</h3><pre><code>    MPSoC 实际上是 一个以处理器为核心的系统，**PL 只是它的一个外设** 。MPSoC 系列的亮点在于它**包含了完整的 ARM 处理器系统** ，且处理器系统中集成了内存控制器和大量的外设，使 **Cortex-A53 处理器可以完全独立于可编程逻辑单元** 。而且实际上在 MPSoC 中，**PL 和 PS 两部分的供电电路是独立的** ，这样 PS 或 PL 部分不被使用的话就可以被断电。    在前面我们介绍 SOPC 时提到过，FPGA 可以用来搭建嵌入式处理器，像 **Xilinx 的 MicroBlaze 处理器 或者 Altera 的 Nios II 处理器** 。像这种使用 FPGA 的可编程逻辑资源搭建的处理器我们称之为“**软核”处理器** ，它的优势在于**处理器的数量以及实现方式的灵活性** 。    而 MPSoC 中集成的是一颗**“硬核”处理器** ，它是硅芯片上专用且经过优化的硬件电路，硬核处理器的优势是它可以获得相对**较高的性能** 。另外，MPSoC 中的硬件处理器和软核处理器并不冲突，我们完全可以**使用 PL 的逻辑资源搭建一个 Microblaze 软核处理器** ，**来和 ARM 硬核处理器协同工作** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/064f01639500be171eeaf8ff627142be.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6e7b726f843d04b79e0d395bc15ad1fb.png"></p><pre><code>    从上面的结构图中可以很清楚的看到 MPSoC 的结构，它分为 PS 和 PL 两部分。在 PS 部分中它主要由 Arm Cortex-A53（APU 共 4 个核）、Arm Cortex-R5F（RPU 共两个核）以及 Arm Mali-400 MP2（GPU）三 种内核处理器构成，并且还包括 DDR 控制单元、平台管理单元、高速外设控制器以及普通外设控制器等外设组成。</code></pre><h4 id="（1）APU（Application-Processing-Unit）"><a href="#（1）APU（Application-Processing-Unit）" class="headerlink" title="（1）APU（Application Processing Unit）"></a>（1）APU（Application Processing Unit）</h4><p>APU 主要是由两个或者四个 ARM 处理器核组成的，Cortex-A53 核心是基于 Arm-v8A 架构的 32 位&#x2F;64<br>位应用程序处理器，拥有极佳的性能&#x2F;功率比，每一个 Cortex-A53 核心拥有 32KB 指令和数据 L1 缓存，具 有奇偶校验、ECC 保护、NEON<br>SIMD 引擎、单精度和双精度浮点单元。除了这些模块，APU 还有一个 snoop 控制单元以及一个带 ECC 保护的 1MB L2<br>缓存，这样的设计可以更好的提高系统级的性能。该 APU 还具有 内置的中断控制器支持虚拟中断。</p><p>它的结构框图如下所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/106eae5a24e0a7fb2a345b01badee237.png"></p><h4 id="（2）RPU（Real-Time-Processing-Unit）"><a href="#（2）RPU（Real-Time-Processing-Unit）" class="headerlink" title="（2）RPU（Real-Time Processing Unit）"></a>（2）RPU（Real-Time Processing Unit）</h4><pre><code>    PS 中的 RPU 包含一个双核 Arm Cortex-R5F 处理器，Cortex-R5F 是 32 位实时处理器，它是基于 Arm-v7R 架构的处理器内核。每个 Cortex-R5F 核都有 32KB 的指令和数据缓存（L1），除了 L1 缓存，每个 Cortex-R5F 核心还具有 128KB 的紧耦合内存(TCM)接口，用于实时单周期访问。RPU 还有一个专用的中断控制器。 两个 RPU 既可工作在独立模式，也可以工作在同步模式。在独立模式中两个处理器都是独立运行的；在同步模式下，它们彼此并行运行，逻辑资源也会综合到一起，并且 TCM 资源也整合成 256KB。RPU 还可以通过 **AXI-4 端口** 与 PS 端的 LPD 区域进行通信或者与 PL 端进行低延迟通信。支持实时 DEBUG 和信号跟踪， 每个内核还具有一个嵌入式跟踪宏单元(ETM)方便 Arm 内核调试。    Cortex-R5 处理器是用于深度嵌入式实时系统的 CPU，它采用了 **Thumb-2 技术** 以获得最佳的代码密度和处理吞吐量，它还具有一个算术逻辑单元(ALU)，为了更加有效地利用其他资源（例如寄存器资源），算术逻辑单元会执行有限的双重指令。Cortex-R5 处理器会通过重新启动和加载多个指令来保持较低的中断延迟，并且还会使用一个专用的外围端口来实现对中断控制器的低延迟访问。处理器具有紧密耦合内存(TCM) 端口，用于低延迟和确定性地访问本地 RAM。错误检查和纠正功能(ECC)是用于 Cortex-R5 处理器端口和 Level 1 (L1) 存储器的，这样可以提高系统的可靠性和准确性。Cortex-R5 处理器的结构框图如下所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/21571fa533509d390545702afb58271c.png"></p><h4 id="（3）GPU（Graphics-Processing-Unit）"><a href="#（3）GPU（Graphics-Processing-Unit）" class="headerlink" title="（3）GPU（Graphics Processing Unit）"></a>（3）GPU（Graphics Processing Unit）</h4><pre><code>    GPU 是基于 **Arm Mali - 400 MP2** 硬件加速器的 2D 和 3D 图形子系统。它由一个**几何图形处理器（GP）、 两个像素处理器（PP）、64KB L2 缓存控制器（L2）、针对 GP 和每个 PP 的独立内存管理单元(MMU)以及 128 位 AXI 总线接口构成** 。Arm Mali-400 MP2 作为 PS 专用的图形处理器它可以支持 2D 和 3D 图形加速， 最高分辨率为 1080p，对于 3D 图形它能够支持 OpenGL ES 1.1 and 2.0 规范而对于 2D 的矢量图形它只能支 持 Open VG 1.1 标准。它的几何处理器(GP)和 2 个像素处理器会并行地执行贴图渲染操作。它为 GP 和像素处理器提供了专用的内存管理单元，支持 4 KB 的页面大小。    GPU 还有 64KB 的二级(L2)只读缓存，它支持 4X 和 16X 全场景抗锯齿(FSAA)功能。它有内置的硬件纹理解压缩，允许纹理在图形硬件中保持压缩(ETC 格式)，并在运行中解压所需的样本。它还支持在不消耗额外带宽的情况下有效地混合多个硬件层，它的像素填充率为 200 万像素/秒/MHz，三角形填充率为 0.1Mvertex/秒/MHz。GPU 支持广泛的纹理格式为 RGBA 8888、565、1556 以及 YUV 格式，对于功率敏感 的应用，GPU 支持对每个 GP、像素处理器和 L2 缓存的时钟和功率进行门控。在功率门控过程中，GPU 不 消耗任何静态或动态功率；在时钟门控过程中，它只消耗静态电源。</code></pre><h4 id="（4）DDR-Memory-Controller"><a href="#（4）DDR-Memory-Controller" class="headerlink" title="（4）DDR Memory Controller"></a>（4）DDR Memory Controller</h4><pre><code>    DDR 存储控制器通过**六个 AXI 数据接口** 和一**个 AXI 控制接口** 连接到 MPSoC 的其余部分，其中一条数据路径连接到实时处理单元(RPU)，两条数据路径连接到缓存相干互连(CCI-400)，其他的在 DisplayPort 控 制器、FPD、DMA 和编程逻辑(PL) 上多路复用。在 6 个接口中，5 个是 128 位宽，而第 6 个接口(绑定到 RPU)是 64 位宽。DDR 子系统支持 DDR3、DDR3L、LPDDR3、DDR4 和 LPDDR4，它可以通过 AXI 总线 接口接收来自 6 个应用主机端口的读写请求，这些请求在内部排队访问 DRAM 设备。存储器控制器**在 DDRPHY 接口上向 PHY 模块发出命令** ，PHY 模块从 DRAM 中读取和写入数据。DDR Memory Controller 的结 构如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a8305f1515bf5ca6c2a3121525a2e38.png"></p><h4 id="（5）PMU（Platform-Management-Unit）"><a href="#（5）PMU（Platform-Management-Unit）" class="headerlink" title="（5）PMU（Platform Management Unit）"></a>（5）PMU（Platform Management Unit）</h4><pre><code>    Zynq UltraScale+ MPSoC包括一个专用的用户可编程处理器，用于电源、错误管理的**平台测量单元(PMU) 处理器** ，以及用于功能安全应用的可选软件测试库(STL)。由于 PMU 的结构和配置相当复杂这里我们只简 要列出他的功能，更加详细的介绍大家可以参考 Xilinx 官方文档 ug1085。 PMU 的功能如下：1、 使用系统监视器检查电源水平，以确保 CSU 和 LP 域的其余部分正常运行。 2、 初始化 pll 的默认配置和他们潜在的旁路。 3、 触发和排序必要的扫描和 MBIST。 4、 捕获并发出错误信号，错误 ID 可以通过 JTAG 读取。 5、 释放复位到 CSU。 6、 在应用程序和实时处理器处于睡眠状态时充当它们的委托，并在接收到它们的唤醒请求之后对他 们进行开机和重启。 7、 在任何时候维护系统电源状态。 8、 处理不同块的上电、下电、复位、内存内置自修复(MBISR)、MBIST 和扫描归零所需的低级事件序列。 9、 在休眠模式下管理系统，并基于各种触发机制唤醒系统。 10、 PS-level 错误捕获。</code></pre><h4 id="（6）High-Speed-Connect-Zynq"><a href="#（6）High-Speed-Connect-Zynq" class="headerlink" title="（6）High-Speed Connect Zynq"></a>（6）High-Speed Connect Zynq</h4><pre><code>    UltraScale+ MPSoC 的 PS 端集成了 5 个高速外设，分别是 **DP 控制器、USB3.0 控制器、SATA3.1 控制器、PCIE 1.0/2.0 控制器以及 PS-GTR 收发器** 。    1、DP接口（**DisplayPort 控制器** ）：Zynq UltraScale+ MPSoC 的 PS 端集成了 DisplayPort 控制器，它可以从内存(非实时输入)或(实时输入)可编程逻辑(PL)中获取数据，并将这些数据处理过后通过 DisplayPort 源控制器块输出到外部显示设备或 PL(实时输出)上。DisplayPort 控制器由 **DMA、缓冲区管理器、显示渲染块、音频混音块、DisplayPort 源控制器以及 PS-GTR 模块** 组成，它可以支持 超高清(UHD)视频，因此 **DP 接口常用来做视频图像传输的接口** 。    2、 USB3.0：USB 3.0 控制器由两个独立的 DRD (dual-role device)控制器组成，两者都可以单独配置为 在任何给定时间作为主机或从机设备工作。USB 3.0 DRD 控制器通过高级的可扩展 AXI 从接口， 可以为系统软件提供一个可扩展的主控制器接口(xHCI)。控制器中有一个内部的 DMA 引擎，它利 用 AXI 主接口来传输数据。三个双端口 RAM 的配置可以实现 RX 数据 FIFO、TX 数据 FIFO 和描 述符/寄存器缓存功能，AXI 主端口与协议层可以通过缓冲区管理单元访问不同的 RAM。    3、 SATA3.1：SATA 控制器是一种高性能双端口主机控制器，具有 AHCI 兼容的命令层，该命令层对 使用端口乘法器的系统来说，具有支持基于本地命令队列和帧信息结构(FIS)交换的高级功能。 SATA 使用 ATA/ATAPI 命令集，但是通过不同的导线可以实现与 SATA 第 1 代、第 2 代或第 3 代 相对应的 1.5、3.0 或 6.0 Gb/sec 的速率进行串行通信。串行数据采用 8B/10B 编码，确保数据模式 中有足够的转换以确保直流平衡（这里的转换指数据的 0/1 转换，关于直流平衡的知识大家可以自行了解或者看我们 HDMI 相关的视频，其中有涉及），并使时钟数据恢复电路能够从输入数据模式中提取时钟。    4、 PCIe 1.0/2.0 控制器：MPSoC 集成了一个 PCIe 通信控制器，用于实现 PCIe 的通信，它包含**AXI-PCIe 桥和 DMA 组件** ，AXI-PCIe 桥主要是为 PCIe 和 AXI 提供高性能桥接。模块示意图如下所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db511727b124ee7bc65a3c18c44c9ac5.png"></p><pre><code>    从上图中可以看到控制器由两个子模块组成，其中 PCIe 桥的主要功能除了**将 PCIe 协议与 AXI 协议相互转换** 外还可以转换入口/出口地址，为 DMA 和 Root Port/Endpoint (RP/EP)模式切换提供特定的服务。    5、 PS-GTR 收发器：千兆 GTR 收发器为串行输入输出单元(SIOU)的外围设备、媒体访问控制器(mac) 以及它们的高速通信链路提供专用的 I/O。Zynq UltraScale+ MPSoC 共有四个可编程高速收发器， 可以支持数据速率高达 6gb /s 的子层协议。</code></pre><h4 id="（7）普通外设控制器"><a href="#（7）普通外设控制器" class="headerlink" title="（7）普通外设控制器"></a>（7）普通外设控制器</h4><pre><code>    Zynq UltraScale+ MPSoC 的 PS 端除了集成的高速通信外设之外，还有一些普通的低速外设，其中包括 **GigE、USB2.0、CAN、UART、SPI、Quad SPI NOR、NAND 以及 SD/eMMC** 等外设控制器。</code></pre><h4 id="（8）PS-PL-AXI-接口"><a href="#（8）PS-PL-AXI-接口" class="headerlink" title="（8）PS-PL AXI 接口"></a>（8）PS-PL AXI 接口</h4><pre><code>    MPSoC 将高性能 ARM Cotex-A 系列处理器与高性能 FPGA 在单芯片内紧密结合，为设计带来了如减小体积和功耗、降低设计风险，增加设计灵活性等诸多优点。在将不同工艺特征的处理器与 FPGA 融合在 一个芯片上之后，片内处理器与 FPGA 之间的互联通路就成了 MPSoC 芯片设计的重中之重。如果 Cotex-A53 与 FPGA 之间的数据交互成为瓶颈，那么处理器与 FPGA 结合的性能优势就不能发挥出来。 Xilinx 从 Spartan-6 和 Virtex-6 系列开始**使用 AXI 协议来连接 IP 核** 。在 7 系列、Zynq-7000 和 Zynq UltraScale+ MPSoC 器件中，Xilinx 在 IP 核中继续使用 AXI 协议。AXI 的英文全称是 **Advanced eXtensible Interface，即高级可扩展接口** ，它是 ARM 公司所提出的 AMBA（Advanced Microcontroller Bus Architecture）协议的一部分。    AXI 协议是一种高性能、高带宽、低延迟的片内总线，具有如下特点：    1、总线的**地址/控制和数据通道是分离** 的；    2、支持**不对齐的数据传输** ；    3、支持突发传输，突发传输过程中只需要首地址；    4、具有分离的读/写数据通道；    5、支持显著传输访问和乱序访问；    6、更加容易进行时序收敛。    在数字电路中只能传输二进制数 0 和 1，因此可能需要一组信号才能高效地传输信息，这一组信号就组成了接口。AXI4 协议支持以下三种类型的接口：    1、 **AXI4** ：高性能存储映射接口。    2、 **AXI4-Lite** ：简化版的 AXI4 接口，用于较少数据量的存储映射通信。    3、 **AXI4-Stream** ：用于高速数据流传输，非存储映射接口。    AXI4 协议支持**突发传输** ，主要用于处理器访问存储器等需要指定地址的高速数据传输场景。AXI-Lite 为外设提供单个数据传输，主要用于访问一些低速外设中的寄存器。而 AXI-Stream 接口则像 FIFO 一样， 数据传输时**不需要地址** ，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接 口等需要高速数据传输的场合。    在 **PS 和 PL 之间的主要连接是通过一组 12 个 AXI 接口** ，每个接口有多个通道组成。这些形成了 PS 内部的互联以及与 PL 的连接，如下图所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fbe5480df361ea6c20b12f14e4d0579.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/24463930ff0801a294b79279e850f73d.png"></p><pre><code>    上图给出了每个接口的简述，标出了主机是 PL 还是 PS（按照惯例，主机是控制总线并发起会话的， 而从机是做响应的）。需要注意的是，接口命名的第一个字母表示的是 PS 的角色，也就是说，第一个字 母 “M” 表示 PS 是主机，而第一个字母“S”表示 PS 是从机。    S_AXI_HP&#123;0:3&#125;_FPD/S_AXI_HPC&#123;0,1&#125;_FPD：六个 **PL 侧高性能（High Performance）AXI 主接口连接到 PS 侧的 FPD（Full-power domain）**，主要**用于访问 DDR 内存** ，进行大量数据的传输，如摄像头图像数据等。所有的六个高性能 AXI 主接口都经过了 PS 中的 **SMMU（System Memory Management Unit）** ， SMMU 能够使用**物理和虚拟地址转换** 。其中一致性 S_AXI_HPC 接口连接到了 **CCI（Cache-coherent interconnect）** ，可以**访问 L1 和 L2 Cache** ，也正是连接到了 CCI，所以在访问 DDR 控制器时，相比于 S_AXI_HP 接口来说，延时会较大。    S_AXI_LPD：主机 PL 连接至从机 PS 侧**LPD（Low-power domain）** 的高性能 AXI 接口，它能够低延 时地访问 OCM（On-chip Memory）和 TCM（Tightly-coupled Memory）。         S_AXI_ACE_FPD：主机 PL 与从机 PS 中的 CCI 相连接，它能够支持 PS 和 PL 中的硬件块之间的**完全一致性（双向）** 。该接口使用的是 ACE（AXI coherency extension）协议，与 AXI 接口相比，ACE 协议 使用了五个额外的通道，三个通道用于监听，两个用于应答。         S_AXI_ACP_FPD：该接口实现了 PL 和 PS 之间的低延时访问，PL 端可以直接访问 APU 的 L1 和 L2 Cache 以及 DDR 内存。    M_AXI_HPM&#123;0,1&#125;_FPD：该高性能接口由主机 **PS 侧 FPD 连接至从机 PL** ，可以用于 CPU、 DMA、 PCIe 等传输大量数据到 PL。    M_AXI_HPM0_LPD：该高性能接口由主机 PS 侧 LPD 连接至从机 PL，该接口适合于为 PS 中的 LPD 主机（例如 LP-DMA）提供对 PL 中的存储器的访问，也经常用于配置 PL 端的寄存器。    上面每条总线都是由一组信号组成的，这些总线上的会话是根据 AXI4 总线协议进行通信的。</code></pre><h3 id="5-DFZU2EG-MPSoc-硬件连接资源"><a href="#5-DFZU2EG-MPSoc-硬件连接资源" class="headerlink" title="5.DFZU2EG MPSoc 硬件连接资源"></a>5.DFZU2EG MPSoc 硬件连接资源</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/285558105285fc578ebeac7655e5f78a.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/356e3108207098fd32f04578acc1619b.png"></p><pre><code>    具体说明见参考书目 P38~P42 ；注意点说明：1.纽扣电池座：DFZU2EG/4EV MPSoC 开发板板载一个纽扣电池座，在开发板断电时，电池可以持续为 MPSoC 芯片内 部的 RTC 实时时钟模块进行供电，以维持计时的功能。2. 1.8 V IO 电平扩展口和 3.3 V IO 电平扩展口。</code></pre><p>详细说明：</p><h4 id="（1）IO-分配"><a href="#（1）IO-分配" class="headerlink" title="（1）IO 分配"></a>（1）IO 分配</h4><pre><code>    Zynq UltraScale+ MPSoC 系列的 xczu2cg-sfvc784-2、 xczu2eg-sfvc784-2 和 xczu4ev-sfvc784-1，总共有 14 个用户 BANK（指连接外设的 BANK，不包 BANK224）。这 14 个 BANK 中有 6 个属于 PS 端，8 个属于 PL 端，不同的 BANK 上连接有不同的外设。    **PL 端** 的 IO 被分成 8 组也就是 8 个 BANK，同一个 BANK 中 IO 供电是相同的，不同的 BANK 之间供电电压可以不相同。在 DFZU2EG/4EV MPSoC 开发板中 PL 端 BANK24、BANK44、BANK25 以及 BANK26 都是 3.3V 电压供电，而 BANK64、BANK65 是 1.2V 供电，BANK0、BANK66 是 1.8V 供电。之所以不同 BANK 之间的供电不同主要和它们连接的外设，即承担的功能有关，遵循的原则就是**速度越快电压越低** ，例如 BANK64 连接的是 DDR4 芯片，需要处理高速的数据吞吐，因此它的供电电压较低，为 1.2V。举例 BANK 的原理图如下所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ea8e0b7083b76eb21ac3a85c38d02a8e.png"></p><pre><code>    从原理图中可以看出 DFZU2EG/4EV MPSoC 开发板的 PL 端引脚是非常多的，为了方便大家查找我们将例程用到的整理成了一张表格，可在参考书目P55~P59查看。    **PS 端** 一共包含了 6 个 IO BANK，与 PL 端 IO BANK 不同的是，**PS 端的 IO 连接是是相对固定的** ，用户不能够像 PL 引脚那样，将 PS 端的 IO 随意分配到某个外设。PS 端外设的 IO 口与 MIO（多路复用 IO）之间，具有**固定关系的映射** ，某 个外设的 IO 口可能会映射到不同的 MIO 上，某个 MIO 也有可能会具有多个外设的 IO 口映射到其上面。 可在参考书目P63~P65查看。</code></pre><h4 id="（2）电源系统"><a href="#（2）电源系统" class="headerlink" title="（2）电源系统"></a>（2）电源系统</h4><p>下图是电源的拓扑结构，标出了降压模块和降压后的电压：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d78702e8eff3db86591525204aea5c5.png"></p><pre><code>    这里要特别提醒一下大家，板子上有的已经有一种电压了例如 1.8V，为什么后 面还要再转个 1.8V 出来，而且同一种电压还会有好几个名称，这主要是因为有很多器件是有**上电顺序** 的，**不可以同时上电** ，虽然工作电压都相等，但是上电顺序有先后要求，所以我们就通过一定的电路设计让整 个板子上的器件有一个先后的上电顺序，这就是为什么同一种电压转换了多次或者好几个名字，主要是每 个名字代表的电压产生的顺序不同。</code></pre><p>电源适配器供电的电源接口原理图如下图所示：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/774c4af01a11930c7c6f55af86cbf36e.png"></p><pre><code>    上图电路的作用是将外部输入的+12V 电压经过降压芯片转换为 5V 电源 VBTN 输出。参考书目上有各个模块供电的说明P67~P76。        </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/86bcd774d1cd313007ac19e14a85151b.png"></p><p><strong>启动顺序： VCC_PSAUX &gt;DDR_1V2&gt;VCC_3V3&gt;PL_VCU_0V9（1.8V&gt;1.2V&gt;3.3V&gt;0.9V）</strong></p><pre><code>    PS 端在全功率域（FPD）可以工作之前，低功率域（LPD）必须工作。    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了低功率域（LPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。    1.VCC_PSINTLP    2.VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL 以任何顺序或同时进行。    3.VCCO_PSIO    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了全功率域（FPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。 、    1.由同一电源驱动的 VCC_PSINTFP 和 VCC_PSINTFP_DDR。             2.VPS_MGTRAVCC 和 VCC_PSDDR_PLL 以任何顺序或同时进行。    3.VPS_MGTRAVTT 和 VCCO_PSDDR 以任何顺序或同时进行。    官方推荐的 PS 端低功率域（LPD）上电顺序为：VCC_PSINTLP→VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL→VCCO_PSIO。    官方推荐的 PS 端 全 功 率 域 （ FPD ） 上 电 顺 序 为 ： VCC_PSINTFP 和 VCC_PISNTFP_DDR→ VPS_MGTRAVCC 和 VCC_PSDDR_PLL→VPS_MGTRAVTT 和 VCCO_PSDDR。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0dd10c2803ebb95a035348f35d63475.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/30ba53b3d6ab97f14bf66dc9246ad6d9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad6edabb65d61577965736979d110b08.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f70d5d4b2d9e764aae43aef8f2f91aa2.png"></p><h4 id="（3）启动模式"><a href="#（3）启动模式" class="headerlink" title="（3）启动模式"></a>（3）启动模式</h4><pre><code>    DFZU2EG/4EV MPSoC 开发板支持 8 种启动模式，我们常用的启动模式是 **JTAG 启动、FLASH 启动以 及 SD 卡启动，此外还支持 eMMC 启动以及 USB 启动** 。具体的启动方式选择可以通过拨动拨码开关去控制，拨码开关拨动的值和对应的启动模式，在原理图中以表格的形式给大家列举出来了。其原理图如下所示：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ee1a75579935f6c78af98f0332fc8eb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9fee6f910356db649db8c4e9ac714e0.png"></p><h4 id="（4）其他硬件资源"><a href="#（4）其他硬件资源" class="headerlink" title="（4）其他硬件资源"></a>（4）其他硬件资源</h4><pre><code>    此外，参考书目**P76~P101** 列出了 _PL 端千兆以太网、PS 端千兆以太网、USB3.0 接口、USB HUB 芯片、MINI DP 接口、PS 端串口、PL 端串口、XADC 接口、时钟振荡器、J19 扩展口、J1 扩展口、EEPROM、PCIe 接口、PS 端 4 片 DDR4、PL 端 1 片 DDR4、eMMC、风扇接口、PL和 PS 端按键、PL 和 PS 端 LED、MIPI CSI 接口、PL 配置完成指示灯、电源指示灯、HDMI 接口WIRELESS 接口、**ATK-MODULE** 、PL 和 PS 端复位、TF 卡接口、**QSPI FLASH** 、RGB888 TFT-LCD_ 等的**电路连接、引脚说明、时序结构** 等说明。</code></pre><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><h4 id="（1）注意事项"><a href="#（1）注意事项" class="headerlink" title="（1）注意事项"></a>（1）注意事项</h4><pre><code>    为了让大家更好的使用 DFZU2EG/4EV MPSoC 开发板，我们在这里总结该开发板使用的时候尤其要 注意的一些问题，希望大家在使用的时候多多注意，以减少不必要的问题。    1\. 当你想使用某个 IO 口用作其他用处的时候，请先看**看开发板的原理图** ，该 IO 口是否有连接在开发板的某个外设上，如果有，该外设的这个信号是否会对你的使用造成干扰， 先确定无干扰，再使用这个 IO。    2\. 开发板上的**拨码开关需要拨到对应的模式** 才能启动开发板，如果模式和启动方式不对应会造成代码下载失败或者板子启动不起来。    3\. 当液晶显示白屏的时候，请先检查液晶模块是否插好（拔下来重新插试试），如果 还不行，可以通过串口看看 LCD ID 是否正常，再做进一步的分析。</code></pre><h4 id="（2）学习-MPSoC-基本方法："><a href="#（2）学习-MPSoC-基本方法：" class="headerlink" title="（2）学习 MPSoC 基本方法："></a><strong>（2）学习 MPSoC 基本方法：</strong></h4><p>**         &lt;1&gt;了解 MPSoC 的基本结构**</p><pre><code>    学习 MPSoC 之前需要先对 **MPSoC 基本结构和其功能** 有个大概的了解，如 PS、AXI 总线、锁相环 PLL、FIFO 等。需要知道 PLL 是用来产生不同频率的时钟，如使用 HDMI 时需要生成 75MHz 的时钟； FIFO 用于数据的缓存和异步时钟域数据的传递等。</code></pre><p>**         &lt;2&gt;了解 Verilog HDL 基本语法**</p><pre><code>    Verilog HDL 做为一种硬件描述语言，是 对数字电路的一种描述，而数字电路是并行工作的，因而在编写 Verilog HDL 时要有**并行的思想** ，不同于 软件设计语言，软件设计语言是由 CPU 统一进行处理，一条指令一条指令的串行运行，所以软件设计语 言是基于串行的设计思想，因而在写 Verilog HDL 代码的时候要注意这种差别。另外对于 Verilog HDL 的 基本语法是务必要掌握的，如一般常用的 module/endmodule、input/output/inout、wire/reg、begin/end、 posedge/negedge、always/assign、if/else、case/default/endcase/parameter/localparam 等关键字要清楚它们的作用和区别。掌握了 Verilog HDL 的基本语法和 Verilog HDL 的并行设计思想后，会觉得 Verilog HDL 和 C 语言一样简单。</code></pre><p>**         &lt;3&gt;MPSoC PS 的学习**</p><pre><code>    学习 MPSoC PS 首先要了解 C 语言的基本语法。然后了解 **PS 端基本的系统框架和外设** ，例如 **PS 端架构、片内互连、AXI 总线、DDR 控制器** 等等。最关键的是 **PS 端的 C 程序** 。软件系统可以被认为是建立于基于硬件的系统上的一个栈，或者说是一系列层，**从底至上依次是基础硬件系统（来自 Vivado 的自定义硬件）、板级支持包、Operating System、软件应用** 。    初学者可以多看看官方的文档和资料，对于 PS 端的软件，**xilinx 提供了丰富的库函数** ，很多时候用户直接调用调用即可，读者要学会利用这些库函数。遇到问题时，读者可以借助 xilinx 的 SDK 开发环境中的各种调试功能来定位错误，以帮助解决问题。</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133233092">https://blog.csdn.net/qq_32971095/article/details/133233092</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞</title>
      <link href="/2023/09/22/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%94%EF%BC%88LCD%E6%B6%B2%E6%99%B6%E5%B1%8F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C6%EF%BC%9E/"/>
      <url>/2023/09/22/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%94%EF%BC%88LCD%E6%B6%B2%E6%99%B6%E5%B1%8F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C6%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.TFT_LCD%20%E6%B6%B2%E6%99%B6%E5%B1%8F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">一.TFT_LCD<br>液晶屏驱动设计</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89HV%20%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F">（1）HV<br>同步模式</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89DE%20%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F">（2）DE<br>同步模式</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（3）整体设计</a></p><p><a href="about:blank#%EF%BC%884%EF%BC%89TFT_LCD%20%E6%98%BE%E7%A4%BA%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">（4）TFT_LCD<br>显示时序控制模块</a></p><p><a href="about:blank#%3C2%3E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">&lt;2&gt;程序设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89tft_ctrl%20%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">（1）tft_ctrl<br>时序控制模块</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89tft_pic%C2%A0%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97">（2）tft_pic<br>图像数据生成模块</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">（3）顶层模块</a></p><p><a href="about:blank#%E4%BA%8C.TFT_LCD%20%E6%B6%B2%E6%99%B6%E5%B1%8F%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA">二.TFT_LCD<br>液晶屏字符显示</a></p><hr><p>前置学习：<a href="https://blog.csdn.net/qq_32971095/article/details/132993678?spm=1001.2014.3001.5501" title="基础设计四——FPGA学习笔记＜5＞">基础设计四——FPGA学习笔记＜5＞</a></p><p>参考书目：《<a href="https://so.csdn.net/so/search?q=%E9%87%8E%E7%81%AB&spm=1001.2101.3001.7020" title="野火">野火</a><a href="https://so.csdn.net/so/search?q=FPGA&spm=1001.2101.3001.7020" title="FPGA">FPGA</a> Verilog 开发实战指南》</p><h2 id="一-TFT-LCD-液晶屏驱动设计"><a href="#一-TFT-LCD-液晶屏驱动设计" class="headerlink" title="一.TFT_LCD 液晶屏驱动设计"></a>一.TFT_LCD 液晶屏驱动设计</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><p>液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态， 但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会<br>改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率<br>的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04aad9b1d62ffc8693a9159fb2d578e2.png"></p><p>​</p><pre><code>    ​常见的 LCD 按物理结构分为四种：扭曲向列型（TN－Twisted NemaTIc）、超扭曲向列型（ STN － Super TN ） 、 双层超扭曲向列型 （ DSTN － Dual Scan Tortuosity Nomograph）、薄膜晶体管型（TFT－Thin Film Transistor）。    TN－LCD、STN－LCD 和 DSYN－LCD 的基本显示原理都相同，只是液 晶分子的扭曲角度不同而已。而 TFT－LCD 则采用与 TN 系列 LCD 截然不同的显示方式。 TFT-LCD 全称 Thin Film Transistor-Liquid Crystal Display，译为薄膜晶体管液晶显示器。其中 TFT 就是 Thin Film Transistor 的简称，指的是薄膜晶体管（矩阵），可以“主动 的”对屏幕上的各个独立的像素进行控制，这也就是所谓的主动矩阵 TFT（active matrix TFT）的来历。图像产生的基本原理很简单：**显示屏由许多可以发出任意颜色的光线的像素组成** ，只要控制各个像素显示相应的颜色就能达到目的了。在 TFT LCD 中一般采用背光 技术，为了能精确地控制每一个像素的颜色和亮度就需要**在每一个像素之后安装一个类似百叶窗的半导体开关** ，以此做到完全的单独的控制一个像素点，液晶材料被夹在 TFT 玻璃层和颜色过滤层之间，通过改变刺激液晶的电压值就可以控制最后出现的光线强度与色彩。    RGB 接口 TFT-LCD 时序 对于 RGB 接口 TFT-LCD 显示屏，它的图像显示的同步模式有两种，分别为 HV 同步模式、DE 同步模式。不同的同步模式对应不同的时序。</code></pre><h4 id="（1）HV-同步模式"><a href="#（1）HV-同步模式" class="headerlink" title="（1）HV 同步模式"></a>（1）HV 同步模式</h4><pre><code>    HV 同步模式下，图像的显示只需要行同步信号(hsync)和场同步信号(vsync)来确定显示时序。此时，RGB 接口的 TFT-LCD 液晶显示屏的显示时序和 VGA 时序标准类似。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ee839d4f5ecd6d1c464881b3eab8c9c8.png">​</p><pre><code>    如图 30-3 所示，图中 RGB 代表图像信息，HSync 表示行同步信号，HSync 自上一个上升沿起到下一个上升沿止为一个完整周期，我们称之为**行扫描周期** ，一个完整的行扫描周期，包含 4 部分：**同步、后沿、有效图像、前沿** ，**基本单位为 pixel** ，即一个像素时钟周期。 在一个完整的行扫描周期中，RGB 图像信息在 HSync 行同步信号的同步下**完成一行图像的显示** ，RGB 图像信息在有效图像阶段，图像信息有效，其他阶段图像信息无效； HSync 行同步信号在同步阶段，维持高电平，其他阶段均保持低电平，在下一个行扫描周期的同步阶段，HSync 行扫描信号拉高，其他阶段拉低，周而复始。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b65511792bc354ef74f41f3eab264275.png">​</p><pre><code>    如图 30-4 所示，图中 RGB 代表图像信息，VSync 表示场同步信号，VSync 自上一个上升沿起到下一个上升沿止为一个完整周期，我们称之为**场扫描周期** ，一个完整的行扫描周期，包含 4 部分：**同步、后沿、有效图像、前沿** ，基本单位为一个完整的**行扫描周期** 。 在一个完整的行扫描周期中，RGB 图像信息在 VSync 行同步信号的同步下**完成一帧图像的显示** ，RGB 图像信息在有效图像阶段，图像信息有效，其他阶段图像信息无效； VSync 行同步信号在同步阶段，维持高电平，其他阶段均保持低电平，在下一个行扫描周 期的同步阶段，VSync 行扫描信号拉高，其他阶段拉低，周而复始。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/85f0ba7e67fa5041c85a60eb8f1c4b9b.png">​</p><pre><code>    图中的红色区域表示在一个完整的行扫描周期中，RGB 图像信息只在此区域有效；黄 色区域表示在一个完整的场扫描周期中，RGB 图像信息只在此区域有效，两者相交的橙色区域，就是 RGB 接口 TFT-LCD 显示屏的图像显示区域。</code></pre><h4 id="（2）DE-同步模式"><a href="#（2）DE-同步模式" class="headerlink" title="（2）DE 同步模式"></a>（2）DE 同步模式</h4><pre><code>    DE 同步模式下，图像的显示只需要数据使能信号确定显示时序，不需要行场同步信号。DE 同步模式下的 TFT 图像显示时序图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3bc25151b07fb4648b1983e0db34119.png"></p><pre><code>    由图可知，当数据使能信号为高电平时，表示 TFT 显示屏扫描到了有效显示区域，此时输入到 TFT 显示屏的图像信息能够显示出来；当数据使能信号为低电平时，表示 TFT 显 示屏未扫描到有效显示区域。             对于两种不同的同步模式， DE 同步模式一般使用在大尺寸屏幕，小尺寸屏幕多使用 HV 同步模式。HV 同步模式地出现早于 DE 同步模式，当今的大部分显示屏均支持 HV 和 DE 两种同步模式。    RGB 接口 TFT-LCD 分辨率 不同的分辨率的 TFT-LCD 显示屏在时序上是相似的，只是存在一些参数上的差异，**下面列举了部分分辨率的时序参数** ，刷新频率均为 60Hz</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/579146b7878cc098a77520661a25946a.png">**<br>**</p><h4 id="（3）整体设计"><a href="#（3）整体设计" class="headerlink" title="（3）整体设计"></a>（3）整体设计</h4><pre><code>    设计编写 RGB 接口 TFT-LCD 液晶显示屏驱动，在 4.3 寸(480*272) TFT-LCD 显示屏上 横向依次显示等宽多色彩条，显示颜色自左向右依次为红、橙、黄、绿、青、蓝、紫、 黑、白、灰，图像像素格式为 RGB565，帧率为 60Hz。</code></pre><p>注：本章节后文中涉及到的相关参数均与 <strong>4.3 寸(480*272)</strong> TFT-LCD 显示屏的的相关参数相对应，事先告知，后续不再声明。</p><p>升腾 mini 开发板 TFT_LCD 接口部分原理图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a9b704cd1bbef34a9ecc533fad44b6a.png"></p><p>注：在本实验工程中，输出信号中包含 <strong>HV 同步模式下需要的行、场同步信号 (hsync、vsync)和 DE 同步模式下的 tft_de 信号</strong><br>，各信号正确输出。读者<strong>若想要使用 HV 同 步模式进行图像显示，可在代码中注释掉 tft_de 信号；若想要使用 DE 同步模式进行图像<br>显示，可带代码中注释掉行、场同步信号。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5df55d88953d7318baf258bb3c1bf1e1.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1d9aa3aacb3968321f308fffdf71b364.png"></p><pre><code>    TFT 彩条显示工程的工作流程。</code></pre><p>(1) 系统上电后，板卡传入系统时钟(sys_clk)和复位信号(sys_rst_n)到顶层模块；</p><p>(2) 系统时钟直接传入时钟生成模块(clk_gen)，分频产生 TFT 显示屏工作时钟 (clk_in)，作为图像数据生成模块(tft_pic)和 TFT<br>时序控制模块(tft_ctrl)的工作时 钟；</p><p>(3) 图像数据生成模块<strong>以 TFT<br>显示时序控制模块传入的像素点坐标(pix_x,pix_y)为约束条件，生成待显示彩条图像的色彩信息(pix_data)</strong> ；</p><p>(4) 图像数据生成模块生成的彩条图像色彩信息传入 TFT 时序控制模块，在模块内部使用使能信号滤除掉非图像显示有效区域的图像数据，产生 RGB 色彩信息<br>(rgb_tft)，在行、场同步信号(hsync、vsync)或数据使能信号(tft_de)的同步作用下，将 RGB 色彩信息扫描显示到 TFT<br>显示屏，显示出彩条图像。</p><h4 id="（4）TFT-LCD-显示时序控制模块"><a href="#（4）TFT-LCD-显示时序控制模块" class="headerlink" title="（4）TFT_LCD 显示时序控制模块"></a>（4）TFT_LCD 显示时序控制模块</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/645cd28fbf833e74cfc1158207c39f1d.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd6c4b16e73cda79cdd0afbd07e55fab.png"></p><pre><code>    data_in 为彩条图像 像素点色彩信息，由图像数据生成模块产生并传入，在 TFT_LCD 显示器有效图像显示区域赋值给信号 RGB 图像色彩信息(rgb_tft_16b)。    输出信号(pix_x,pix_y)为 TFT_LCD 有效显示区域像素点坐标，由 TFT_LCD 时序控制模块生并传入图像数据生成模块；hsync、vsync 为 TFT_LCD 行、场同步信号 ，通过 TFT_LCD 接口传输给 TFT_LCD 显示屏；rgb_tft_16b 为显示器要显示的图像色彩信息，传输给 TFT_LCD 显示器；tft_bl 为 TFT 显示屏背光信号；tft_clk 为 TFT 显示屏工作时钟； tft_de 为 TFT 显示使能信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/22580f39319a512293811631cfebc085.png"></p><p>**<br>第一部分**：行同步信号(hsync)、场同步信号(vsync)。由时序图可知，<strong>行同步信号为周期性信号，信号变化周期为完整的行扫描周期</strong><br>，信号在同步阶段保持高电平，在其他阶段保持低电平，那么如何实现行同步信号的周期性变化呢？ 我们想到了前文学过的计数器，因为一个完整行扫描周期为 <strong>525<br>个像素时钟周期 (480*272@60，见前表格)</strong> ，我们可以利用计数器以像素时钟周期进行计数，每一个像素时钟周期自加 1，计数范围为<br>0-524，共计数 525 次，与完整行扫描周期数相吻合。<strong>只要在行同步阶段(计数范围 0-40)赋值 hsync<br>信号为高电平，其他阶段为低电平，就可以实现符合时序要求的行同步信号 hsync</strong> 。根据此设计思路，声明并绘制行扫描周期计数器 cnt_h、行同步信号<br>hsync 信号波形如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e499e6c45177b382ec604cfeb1deb1b7.png"></p><pre><code>    同理，参考行同步信号波形的绘制思路，我们可以进行场同步信号波形的绘制。不过要注意的是，**场扫描周期单位不是像素时钟周期，而是完整的行扫描周期** ，所以要**添加场扫描周期计数器对行扫描周期进行计数（再525分频）** ，声明并绘制场扫描周期计数器 cnt_v、场同步信号 vsync 信号波形如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e57208bdc5c5038da15c114148fd918c.png"></p><pre><code>   **  第二部分**：图像显示有效信号(data_valid)波形绘制思路由上文可知，TFT 显示屏只有在有效的显示区域内送入图像数据，图像才会被正确显示。我们可以声明一个有效信号，在图像有效显示区域赋值高电平，在非图像有效显示区域赋值低电平，以此信号为约束条件，控制图像信号的正确输入，定义此信号为图像显示有效信号(rgb_valid)。 这里我们可以利用上一部分声明的 cnt_h、cnt_v 两个计数器，以其为约束条件，**当两个计数器计数到图像有效显示区域时，data_valid 赋值高电平** ，否则赋值低电平。绘制图像显示有效信号(data_valid)波形如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f64e56c6d4b2cd677cd62e5c1be2d54c.png"></p><p>**         第三部分**：图像信息请求信号(data_req)、TFT 显示屏有效显示区域像素点坐标<br>(pix_x,pix_y)波形绘制思路为了<strong>提高模块复用性</strong> ，我们将图像数据生成功能独立出来，设计为图像数据生成模块 <strong>tft_pic</strong><br>，虽然模块复用性提高，但这样就产生一个问题，怎样保证 data_in 传输的图像数据与 TFT 显示屏时序相吻合呢？</p><pre><code>    结合之前学习的知识，我们知道只有在 TFT 显示屏有效显示区域，data_in 传输的图像数据才会传输给 TFT 显示屏，那么我们可以**只在 TFT 显示屏有效显示区域对 data_in 进行赋值** ，如何实现这一想法呢？    我们可以使用 cnt_h、cnt_v 信号来确定 TFT 显示屏有效显示区域，将有效显示区域使用坐标法表示，针对不同坐标点**对 data_in 进行赋值** ，所以我们声明 TFT 显示屏有效显示区域像素点坐标(pix_x,pix_y)。    上面两个问题解决了，新的问题又来了，TFT 显示屏有效显示区域为 480*272，如何 使像素点坐标(pix_x,pix_y)实现(0,0) – (480,272)的坐标计数？ 读者可能会想到使用已经声明的图像显示有效信号(data_valid)，但在此处不能使用该信号。    因为本次实验是 TFT 显示屏多色彩条的显示，**图像数据生成模块 tft_pic 需要以坐标 (pix_x,pix_y)为约束条件对 data_in 信号进行赋值，只能使用时序逻辑的赋值方式，那么 data_in 的赋值时刻会滞后条件满足时刻一个时钟周期，显示图像会出现问题** 。    为了解决这一问题，我们需要声明新的图像数据请求信号 **data_req** ，该信号要**超前图像显示有效信号(data_valid)一个时钟周期，以抵消 data_in 时序逻辑赋值带来的问题** 。 综上所述，我们需要声明图像信息请求信号 data_req、TFT 显示屏有效显示区域像素点坐标(pix_x,pix_y)这三路信号来解决之前提到的若干问题。对于 data_req 信号的电平控制可参考 data_valid 信号的控制方式，以 cnt_h、cnt_v 信号为约束条件；坐标(pix_x,pix_y)则 以新声明的 data_req 信号为约束条件控制生成，三路信号绘制波形图如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2630498c7621e301628c2bc304db7555.png"></p><pre><code>    **第四部分** ：RGB 色彩信息(rgb_tft_16b)波形绘制思路这一部分就比较简单了，TFT 显示屏图像显示是在行、场同步信号的作用下，将图像色彩信息以扫描显示的方式显示出来，所以 RGB 色彩信息必不可少，只要在有效显示区域写入正确图像数据即可。信号 rgb_tft_16b 绘制波形如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fa324114eb35f5f9a972e8acd3dc394d.png"></p><pre><code>    **第五部分** ： TFT 显示数据使能信号(tft_de)波形绘制思路数据使能信号为 DE 同步模式下的图像显示同步信号，只在有效图像显示区域为高电平，其他时刻为低电平。tft_de 信号的波形变化和 data_valid 信号相同，所以 tft_de 信号可 由 data_valid 信号使用组合逻辑进行赋值。数据使能信号(tft_de)波形如下图。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/609d72183797781aa1c69af398211a21.png"></p><pre><code>    **第六部分** ： TFT 显示屏工作时钟(tft_clk)、TFT 显示屏背光信号(tft_bl)波形绘制思路 TFT 显示屏与 VGA 显示器不同，TFT 显示屏的正常工作离不开时钟信号，而且输入 TFT 显示屏的时钟信号，要与行场信号或数据使能信号的同步时钟相同，否者会出现图像显示的错误。 TFT 显示屏的背光信号作用是控制显示屏背光，为高电平时打开显示器背光，低电平时关闭背光，在本实验工程使用复位信号 sys_rst_n 信号为背光信号赋值。 上述两信号波形图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e2fbf4f6bc0fd18607c3d53df7d87f.png"></p><pre><code>    本设计思路只做参考，并非唯一方法，读者可利用所学知识，按照自己思路进行设计。 </code></pre><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="&lt;2&gt;程序设计"></a>&lt;2&gt;程序设计</h3><h4 id="（1）tft-ctrl-时序控制模块"><a href="#（1）tft-ctrl-时序控制模块" class="headerlink" title="（1）tft_ctrl 时序控制模块"></a>（1）tft_ctrl 时序控制模块</h4><pre><code>module  tft_ctrl(    input   wire            clk_in      ,   //输入时钟    input   wire            sys_rst_n   ,   //系统复位,低电平有效    input   wire    [15:0]  data_in     ,   //待显示数据    output  wire            data_req    ,   //数据请求信号    output  wire    [10:0]  pix_x       ,   //输出TFT有效显示区域像素点X轴坐标    output  wire    [10:0]  pix_y       ,   //输出TFT有效显示区域像素点Y轴坐标    output  wire    [15:0]  rgb_tft_16b ,   //TFT显示数据    output  wire    [23:0]  rgb_tft_24b ,   //TFT显示数据    output  wire            hsync       ,   //TFT行同步信号    output  wire            vsync       ,   //TFT场同步信号    output  wire            tft_clk     ,   //TFT像素时钟    output  wire            tft_de      ,   //TFT数据使能    output  wire            tft_bl          //TFT背光信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter define  5寸、七寸屏// parameter   H_SYNC      =   11&#39;d34  ,   //行同步            // H_BACK      =   11&#39;d46  ,   //行时序后沿            // H_LEFT      =   11&#39;d0   ,   //行时序左边框            // H_VALID     =   11&#39;d800 ,   //行有效数据            // H_RIGHT     =   11&#39;d0   ,   //行时序右边框            // H_FRONT     =   11&#39;d210 ,   //行时序前沿            // H_TOTAL     =   11&#39;d1090;   //行扫描周期            // parameter   V_SYNC      =   11&#39;d10  ,   //场同步            // V_BACK      =   11&#39;d23  ,   //场时序后沿            // V_TOP       =   11&#39;d0   ,   //场时序左边框            // V_VALID     =   11&#39;d480 ,   //场有效数据            // V_BOTTOM    =   11&#39;d0   ,   //场时序右边框            // V_FRONT     =   11&#39;d22  ,   //场时序前沿            // V_TOTAL     =   11&#39;d535 ;   //场扫描周期//parameter define  4.3寸屏parameter H_SYNC    =   10&#39;d41  ,   //行同步          H_BACK    =   10&#39;d2   ,   //行时序后沿          H_LEFT    =   11&#39;d0   ,   //行时序左边框          H_VALID   =   10&#39;d480 ,   //行有效数据          H_FRONT   =   10&#39;d2   ,   //行时序前沿          H_RIGHT   =   11&#39;d0   ,   //行时序右边框          H_TOTAL   =   10&#39;d525 ;   //行扫描周期parameter V_SYNC    =   10&#39;d10  ,   //场同步          V_BACK    =   10&#39;d2   ,   //场时序后沿          V_TOP     =   11&#39;d0   ,   //场时序左边框          V_VALID   =   10&#39;d272 ,   //场有效数据          V_FRONT   =   10&#39;d2   ,   //场时序前沿          V_BOTTOM  =   11&#39;d0   ,   //场时序右边框          V_TOTAL   =   10&#39;d286 ;   //场扫描周期                                                                                                                                            parameter   H_PIXEL     =   11&#39;d480 ,   //水平方向有效图像像素个数            V_PIXEL     =   11&#39;d272 ;   //垂直方向有效图像像素个数parameter   H_BLACK     =   ((H_VALID - H_PIXEL) / 2),  //水平方向黑色边框宽度            V_BLACK     =   ((V_VALID - V_PIXEL) / 2);  //垂直方向黑色边框宽度//wire  definewire            data_valid  ;   //有效显示区域标志wire    [15:0]  data_out    ;   //输出有效图像数据wire    [7:0]   rgb_r;wire    [7:0]   rgb_g;wire    [7:0]   rgb_b;//reg   definereg     [10:0]   cnt_h       ;   //行扫描计数器reg     [10:0]   cnt_v       ;   //场扫描计数器//********************************************************************////***************************** Main Code ****************************////********************************************************************////tft_clk,tft_de,tft_bl:TFT像素时钟、数据使能、背光信号assign  tft_clk = clk_in    ;assign  tft_de  = data_valid;assign  tft_bl  = sys_rst_n ;//cnt_h:行扫描计数器always@(posedge clk_in or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_h   &lt;=  11&#39;d0;    else    if(cnt_h == H_TOTAL - 1&#39;b1)        cnt_h   &lt;=  11&#39;d0;    else        cnt_h   &lt;=  cnt_h + 10&#39;d1;//cnt_v:场扫描计数器always@(posedge clk_in or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_v   &lt;=  11&#39;d0;    else    if(cnt_h == H_TOTAL - 1&#39;b1)     begin        if(cnt_v == V_TOTAL - 1&#39;b1)            cnt_v   &lt;=  11&#39;d0;        else            cnt_v   &lt;=  cnt_v + 10&#39;d1;    end    else         cnt_v   &lt;=  cnt_v;//data_valid:有效显示区域标志assign  data_valid = ((cnt_h &gt;= (H_SYNC + H_BACK + H_LEFT))                    &amp;&amp; (cnt_h &lt; (H_SYNC + H_BACK + H_LEFT + H_VALID )))                    &amp;&amp;((cnt_v &gt;= (V_SYNC + V_BACK + V_TOP))                    &amp;&amp; (cnt_v &lt; (V_SYNC + V_BACK + V_TOP + V_VALID)));//data_req:图像数据请求assign  data_req = ((cnt_h &gt;= (H_SYNC + H_BACK + H_LEFT + H_BLACK - 1&#39;b1))                     &amp;&amp; (cnt_h &lt; ((H_SYNC + H_BACK + H_LEFT + H_BLACK + H_PIXEL - 1&#39;b1))))                    &amp;&amp;((cnt_v &gt;= ((V_SYNC + V_BACK + V_TOP + V_BLACK)))                    &amp;&amp; (cnt_v &lt; ((V_SYNC + V_BACK + V_TOP + V_BLACK + V_PIXEL))));assign  pix_x = (data_req == 1&#39;b1)                ? (cnt_h - (H_SYNC + H_BACK + H_LEFT - 1&#39;b1)) : 11&#39;h3ff;assign  pix_y = (data_req == 1&#39;b1)                ? (cnt_v - (V_SYNC + V_BACK + V_TOP)) : 11&#39;h3ff;//data_out:输出有效图像数据assign  data_out = (data_req == 1&#39;b1) ? data_in : 16&#39;h0000;//hsync,vsync,rgb_tft_16b:行、场同步信号、图像数据assign  rgb_tft_16b = (data_valid == 1&#39;b0) ? 16&#39;hFFFF : data_out;assign  hsync = (cnt_h  &lt;=  H_SYNC - 1&#39;d1) ? 1&#39;b1 : 1&#39;b0  ;assign  vsync = (cnt_v  &lt;=  V_SYNC - 1&#39;d1) ? 1&#39;b1 : 1&#39;b0  ;//rgb16 565转rgb24 888assign rgb_r=&#123;rgb_tft_16b[15:11],3&#39;d0&#125;;assign rgb_g=&#123;rgb_tft_16b[10:5],2&#39;d0&#125;;assign rgb_b=&#123;rgb_tft_16b[4:0],3&#39;d0&#125;; assign rgb_tft_24b=&#123;rgb_r,rgb_g,rgb_b&#125;;endmodule    可以看出 **data_req 信号超前 data_valid 信号一个时钟周期** （这里H_BLACK=V_BLACK=0且 **data_req   多减了一个 1 **）；data_req 考虑了黑边框，**因为分辨率 480*272 对应行列有效周期 480 和 272 ，故黑边多少像素减去多少周期即可** ；另外 pix_x 和 pix_y 都已在此赋值。</code></pre><h4 id="（2）tft-pic-图像数据生成模块"><a href="#（2）tft-pic-图像数据生成模块" class="headerlink" title="（2）tft_pic 图像数据生成模块"></a>（2）tft_pic 图像数据生成模块</h4><pre><code>    以 TFT 显示时序控制模块传入的图像有效显示区域像素点坐标(pix_x,pix_y)为约束条件，产生 TFT 彩条图像像素点色彩信息并回传给 TFT 显示时序控制模块。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6e497f9c789be6e30f8f2d095897aeef.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d168edbc88ab3e3d9e0d0242a1119154.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0997f4cd9124ba9a8c00f4b586e9d227.png"></p><pre><code>module  tft_pic(    input   wire            tft_clk_9m  ,   //输入工作时钟,频率9MHz    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效    input   wire    [9:0]   pix_x       ,   //输入TFT有效显示区域像素点X轴坐标    input   wire    [9:0]   pix_y       ,   //输入TFT有效显示区域像素点Y轴坐标    output  reg     [15:0]  pix_data        //输出像素点色彩信息);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************//parameter   H_VALID =   10&#39;d480 ,   //行有效数据            V_VALID =   10&#39;d272 ;   //场有效数据parameter   RED     =   16&#39;hF800,   //红色            ORANGE  =   16&#39;hFC00,   //橙色            YELLOW  =   16&#39;hFFE0,   //黄色            GREEN   =   16&#39;h07E0,   //绿色            CYAN    =   16&#39;h07FF,   //青色            BLUE    =   16&#39;h001F,   //蓝色            PURPPLE =   16&#39;hF81F,   //紫色            BLACK   =   16&#39;h0000,   //黑色            WHITE   =   16&#39;hFFFF,   //白色            GRAY    =   16&#39;hD69A;   //灰色//********************************************************************////***************************** Main Code ****************************////********************************************************************////pix_data:输出像素点色彩信息,根据当前像素点坐标指定当前像素点颜色数据always@(posedge tft_clk_9m or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pix_data    &lt;= 16&#39;d0;    else    if((pix_x &gt;= 0) &amp;&amp; (pix_x &lt; (H_VALID/10)*1))        pix_data    &lt;=  RED;    else    if((pix_x &gt;= (H_VALID/10)*1) &amp;&amp; (pix_x &lt; (H_VALID/10)*2))        pix_data    &lt;=  ORANGE;    else    if((pix_x &gt;= (H_VALID/10)*2) &amp;&amp; (pix_x &lt; (H_VALID/10)*3))        pix_data    &lt;=  YELLOW;    else    if((pix_x &gt;= (H_VALID/10)*3) &amp;&amp; (pix_x &lt; (H_VALID/10)*4))        pix_data    &lt;=  GREEN;    else    if((pix_x &gt;= (H_VALID/10)*4) &amp;&amp; (pix_x &lt; (H_VALID/10)*5))        pix_data    &lt;=  CYAN;    else    if((pix_x &gt;= (H_VALID/10)*5) &amp;&amp; (pix_x &lt; (H_VALID/10)*6))        pix_data    &lt;=  BLUE;    else    if((pix_x &gt;= (H_VALID/10)*6) &amp;&amp; (pix_x &lt; (H_VALID/10)*7))        pix_data    &lt;=  PURPPLE;    else    if((pix_x &gt;= (H_VALID/10)*7) &amp;&amp; (pix_x &lt; (H_VALID/10)*8))        pix_data    &lt;=  BLACK;    else    if((pix_x &gt;= (H_VALID/10)*8) &amp;&amp; (pix_x &lt; (H_VALID/10)*9))        pix_data    &lt;=  WHITE;    else    if((pix_x &gt;= (H_VALID/10)*9) &amp;&amp; (pix_x &lt; H_VALID))        pix_data    &lt;=  GRAY;    else        pix_data    &lt;=  BLACK;endmodule    每个时钟周期 tft_clk_9m 对 pix_data 赋值即可；由于 pix_data 由 pix_x、pix_y 的值确定，易知 **pix_data 滞后 pix_x、pix_y 信号一个时钟周期** 。</code></pre><h4 id="（3）顶层模块"><a href="#（3）顶层模块" class="headerlink" title="（3）顶层模块"></a>（3）顶层模块</h4><pre><code>module  tft_colorbar(    input   wire            sys_clk     ,   //输入工作时钟,频率50MHz    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效    output  wire    [15:0]  rgb_tft     ,   //输出像素信息    output  wire            hsync       ,   //输出行同步信号    output  wire            vsync       ,   //输出场同步信号    output  wire            tft_clk     ,   //输出TFT时钟信号    output  wire            tft_de      ,   //输出TFT使能信号    output  wire            tft_bl          //输出背光信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire            tft_clk_9m  ;   //TFT工作时钟,频率9MHzwire            locked      ;   //PLL locked信号wire            rst_n       ;   //TFT模块复位信号wire    [9:0]   pix_x       ;   //TFT有效显示区域X轴坐标wire    [9:0]   pix_y       ;   //TFT有效显示区域Y轴坐标wire    [15:0]  pix_data    ;   //TFT像素点色彩信息//rst_n:TFT模块复位信号assign  rst_n = (sys_rst_n &amp; locked);//********************************************************************////*************************** Instantiation **************************////********************************************************************//clk_wiz_0 clk_gen_inst(    .reset     (~sys_rst_n ),  //输入复位信号,高电平有效,1bit    .clk_in1   (  sys_clk  ),  //输入50MHz晶振时钟,1bit    .clk_out1  (tft_clk_9m ),  //输出TFT工作时钟,频率9Mhz,1bit    .locked    (locked     )   //输出pll locked信号,1bit);//------------- tft_ctrl_inst -------------tft_ctrl tft_ctrl_inst(    .clk_in     (tft_clk_9m ) ,   //输入时钟    .sys_rst_n  (rst_n      ) ,   //系统复位,低电平有效    .data_in    (pix_data   ) ,   //待显示数据    .data_req   (           ) ,   //数据请求信号    .pix_x      (pix_x      ) ,   //输出TFT有效显示区域像素点X轴坐标    .pix_y      (pix_y      ) ,   //输出TFT有效显示区域像素点Y轴坐标    .rgb_tft_16b(rgb_tft    ) ,   //TFT显示数据16bit    .rgb_tft_24b(           ) ,   //TFT显示数据24bit    .hsync      (hsync      ) ,   //TFT行同步信号    .vsync      (vsync      ) ,   //TFT场同步信号    .tft_clk    (tft_clk    ) ,   //TFT像素时钟    .tft_de     (tft_de     ) ,   //TFT数据使能    .tft_bl     (tft_bl     )     //TFT背光信号);//------------- tft_pic_inst -------------tft_pic tft_pic_inst(    .tft_clk_9m  (tft_clk_9m),   //输入工作时钟,频率9MHz    .sys_rst_n   (rst_n     ),   //输入复位信号,低电平有效    .pix_x       (pix_x     ),   //输入TFT有效显示区域像素点X轴坐标    .pix_y       (pix_y     ),   //输入TFT有效显示区域像素点Y轴坐标    .pix_data    (pix_data  )    //输出像素点色彩信息);endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/657603b593b0d744497cd255c77a7f32.png"></p><h2 id="二-TFT-LCD-液晶屏字符显示"><a href="#二-TFT-LCD-液晶屏字符显示" class="headerlink" title="二.TFT_LCD 液晶屏字符显示"></a>二.TFT_LCD 液晶屏字符显示</h2><pre><code>    在 TFT 显示屏中心位置显示金色“野火科技”四个汉字，字符外的背景颜色为黑色。**每个汉字大小为 56*56，字模点阵为 64*64** ，TFT 显示屏显示模式为 480*270@60。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d58f5808c61fc77af64e60a14708137c.png"></p><p>**         第一部分**：字符点阵显示区域坐标信号的设计与实现在上面小节中，我们利用<strong>取模软件</strong> 生成了要显示字符的字模，字模点阵的大小为<br><strong>256<em>64（64</em>4*64）</strong> ，那么如何利用字模点阵进行字符显示呢？ 首先确定字符<strong>有效显示区域</strong><br>，区域大小与字符点阵大小相同，显示区域的像素点与字模点阵中数据项一一对应，<strong>当字模点阵中的数据项数值为“1”时，赋值字符颜色给对应像素点；当字模点阵中的数据项数值为“0”时，赋值点阵背景颜色给对应像素点</strong><br>。 所以为了确定字符点阵显示区域，我们声明两个变量 char_x、char_y，两变量组成字 符点阵显示区域坐标，在字符点阵有效显示区域内，<strong>char_x<br>信号 0-255 循环计数，char_y 信号 0-63 循环计数</strong><br>，根据坐标(char_x,char_y)寻找字符点阵对应的数据项，根据数据项的数值，赋予对应坐标像素点颜色信息。char_x、char_y<br>信号波形具体见图。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ff106cc7206516eb925a0af0c62929b.png"></p><pre><code>module  tft_pic(    input   wire            tft_clk_9m  ,   //输入工作时钟,频率9MHz    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效    input   wire    [9:0]   pix_x       ,   //输入TFT有效显示区域像素点X轴坐标    input   wire    [9:0]   pix_y       ,   //输入TFT有效显示区域像素点Y轴坐标    output  reg     [15:0]  pix_data        //输出像素点色彩信息);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************//parameter   H_VALID =   10&#39;d480 ,   //行有效数据            V_VALID =   10&#39;d272 ;   //场有效数据parameter   CHAR_B_H=   10&#39;d112 ,   //字符开始X轴坐标            CHAR_B_V=   10&#39;d104 ;   //字符开始Y轴坐标parameter   CHAR_W  =   10&#39;d256 ,   //字符宽度            CHAR_H  =   10&#39;d64  ;   //字符高度parameter   BLACK   =   16&#39;h0000,   //黑色            GOLDEN  =   16&#39;hFEC0;   //金色//wire  definewire    [9:0]   char_x  ;   //字符显示X轴坐标wire    [9:0]   char_y  ;   //字符显示Y轴坐标//reg   definereg     [255:0] char    [63:0]  ;   //字符数据//********************************************************************////***************************** Main Code ****************************////********************************************************************////字符显示坐标assign  char_x  =   (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))                    &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))                    ? (pix_x - CHAR_B_H) : 10&#39;h3FF;assign  char_y  =   (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))                    &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))                    ? (pix_y - CHAR_B_V) : 10&#39;h3FF;//char:字符数据always@(posedge tft_clk_9m)    begin        char[0]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[1]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[2]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[3]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[4]     &lt;=  256&#39;h00000000003C0000000000000000000000000000000070000000000000000000;        char[5]     &lt;=  256&#39;h0000000E003E00000000000000000000000000000000F0000000000000000000;        char[6]     &lt;=  256&#39;h000000FF001F00000000000000000000000000000001F0000000000000400000;        char[7]     &lt;=  256&#39;h000007FF000F00000000000000000000000010000001F8000000000000E00000;        char[8]     &lt;=  256&#39;h00007FFE000F000000000000000000000003FE000001F8000000000000F00000;        char[9]     &lt;=  256&#39;h0000FE7E003F00000000000000000000000FFF800001F80000003E0000F00000;        char[10]    &lt;=  256&#39;h0000E07C01F8000000000000000000000007FF81F801FC0000003F0000F00000;        char[11]    &lt;=  256&#39;h0000E0F80380000000000000000000000003FF80FE00780000003F0001E00000;        char[12]    &lt;=  256&#39;h0000E0F80380000000000000000000000001FF80FF00780000003F0001E00000;        char[13]    &lt;=  256&#39;h0780E1F003FC000000000000000000000000FF80FF80780000003E0001E00000;        char[14]    &lt;=  256&#39;h07C0FFF003FE0000000000020000000000003F007F80780000003E0001E00000;        char[15]    &lt;=  256&#39;h07E0FFE001FE0000000000070000000000000E007F00780000003C0001FF0000;        char[16]    &lt;=  256&#39;h07F3FFE0000E00000000000700000000000000007E00F80000003C0001FF0000;        char[17]    &lt;=  256&#39;h07F9FFC0000E00000000000F0000000000003E00CC01F80000007C0003FE0000;        char[18]    &lt;=  256&#39;h03F9FFC0001C03E00000000F8000000000003F010001F80000007E0003F80000;        char[19]    &lt;=  256&#39;h03F9FF8000781FF80000001F8000000000007F038001F8000000FF0007F00000;        char[20]    &lt;=  256&#39;h03F9FF8001F07FF80000001F878000000000FE078001F8000000FF000FE00000;        char[21]    &lt;=  256&#39;h03FDFF0007C3FFF00000003FFFC000000001FC07C001F8000001FF003FE00000;        char[22]    &lt;=  256&#39;h03FDFF000F9F8FF00001C03FFFC000000007F807F001F8000007FE003FC00000;        char[23]    &lt;=  256&#39;h03FFFE001FFF8FE00001E07FFFC00000001FF807FC01F800000FFC0003C00000;        char[24]    &lt;=  256&#39;h01FFF0007FFF8FC00003E07FFC000000067FF007FE01FC00001FF80003800000;        char[25]    &lt;=  256&#39;h01FFC000FFEF9F800003E0FE000000000FFFF003FC01FE00007FF00007800000;        char[26]    &lt;=  256&#39;h01FF8001FF8F9F000007E0FE000000000FFFF041F803FC0000FFE00007800000;        char[27]    &lt;=  256&#39;h01FF8007FC1F9E00001FE0FE000000000FFFF180F00FFC000001E00007000000;        char[28]    &lt;=  256&#39;h00FF8007F01F3C00003FE1FC00000000007FF601E01FF8000001E000071C0000;        char[29]    &lt;=  256&#39;h00FF8007C01FFC00003FE1FC00000000001FFC03C0FFF8000001E0000F3E0000;        char[30]    &lt;=  256&#39;h00030002001FF800003FC3FC00000000003FF807C3FFF8000001E7800FFE0000;        char[31]    &lt;=  256&#39;h00070000001FF000007FC3F800000000003FF80F9FFFF0000001FF000FFE0000;        char[32]    &lt;=  256&#39;h0007F000001FE000007F83F800000000007FF01FFFC3F0000001FE000FFE0000;        char[33]    &lt;=  256&#39;h001FF000001FC000003F83F00000000000FFF01FFE03F0000001FC001FFE0000;        char[34]    &lt;=  256&#39;h007FE000001F8000003F07F00000000000FFE03FF003F0000003F8001F3E0000;        char[35]    &lt;=  256&#39;h007FC000001F8000001807F00000000001FFE03F8003F0000003F0001F3C0000;        char[36]    &lt;=  256&#39;h00078600001F000000000FF80000000003FFC07E0003F0000003F0001E3C0000;        char[37]    &lt;=  256&#39;h000F1E00001F000000000FFC0000000007FFC0180003F0000007E003843C0000;        char[38]    &lt;=  256&#39;h003FFC00001F800000001FDE0000000007FFC0000003F000000FF001E03C0000;        char[39]    &lt;=  256&#39;h007FF800001F800000003FDF8000000007C7C0000003F00000FFF000F83C0000;        char[40]    &lt;=  256&#39;h00FFF000001F800000007F9FF00000000787C0000003F00007FFF0007F3C0000;        char[41]    &lt;=  256&#39;h01FFE000001F80000000FF0FFE0000000707C0000003F0001FF1F8003FFC0000;        char[42]    &lt;=  256&#39;h03FF8000001F80000001FE0FFFE000000003C0000003F0003F81F8001FFC0000;        char[43]    &lt;=  256&#39;h07FF0000003F80000003FC07FFFE0000000300000003F0003E01FC000FFE0000;        char[44]    &lt;=  256&#39;h07FC0000003F80000007F803FFFFE000000000000003F0001F83FC0007FFF000;        char[45]    &lt;=  256&#39;h07F80000003F8000000FF001FFFFFF80000000000003F0000FFFFC0003FFFF80;        char[46]    &lt;=  256&#39;h03E00000007F8000001FC0007FFFFFC0000000000003F00003FFFE0007FFFFF0;        char[47]    &lt;=  256&#39;h0000000000FF8000007F80001FFFFFE0000000000003F000007FFE003FBFFFF8;        char[48]    &lt;=  256&#39;h0000000001FF800000FE000007FFFFE0000000000003E000000FFC03FE0FFFF8;        char[49]    &lt;=  256&#39;h0000000007FF800001F8000001FFFFF0000000000003E0000000F8FFC003FFF8;        char[50]    &lt;=  256&#39;h000000007FFF000003E00000001FFFC0000000000003C0000000000000007FF8;        char[51]    &lt;=  256&#39;h00000007FFFE0000070000000001FFC0000000000003C0000000000000000FF0;        char[52]    &lt;=  256&#39;h0000000200F800000000000000000F8000000000000300000000000000000060;        char[53]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[54]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[55]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[56]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[57]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[58]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[59]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[60]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[61]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[62]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;        char[63]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;    end//pix_data:输出像素点色彩信息,根据当前像素点坐标指定当前像素点颜色数据always@(posedge tft_clk_9m or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pix_data    &lt;= BLACK;    else    if(((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))                &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))        begin            if(char[char_y][10&#39;d255 - char_x] == 1&#39;b1)                pix_data    &lt;=  GOLDEN;            else                pix_data    &lt;=  BLACK;        end    else        pix_data    &lt;= BLACK;endmodule</code></pre><p>可知根据对应坐标的char二维数组值判定颜色。</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133174030">https://blog.csdn.net/qq_32971095/article/details/133174030</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式学习路线</title>
      <link href="/2023/09/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/09/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF">一.嵌入式学习路线</a></p><p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5">二.学习实践</a></p><p><a href="about:blank#1.%E8%AF%BE%E5%86%85%E8%AF%BE%E7%A8%8B">1.课内课程</a></p><p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p><p><a href="about:blank#2.51%E5%8D%95%E7%89%87%E6%9C%BA">2.51单片机</a></p><p><a href="about:blank#3.stm32">3.stm32</a></p><p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p><p><a href="about:blank#4.FPGA">4.FPGA</a></p><p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p><p><a href="about:blank#5.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">5.操作系统</a></p><p><a href="about:blank#%E4%B8%89.%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">三.其他学习资料</a></p><p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p><p><a href="about:blank#%E5%9B%9B.%E6%80%BB%E7%BB%93">四.总结</a></p><hr><h2 id="一-嵌入式学习路线"><a href="#一-嵌入式学习路线" class="headerlink" title="一.嵌入式学习路线"></a>一.嵌入式学习路线</h2><pre><code>   对于计算机科学与技术嵌入式方向的学生，要学好嵌入式括软件和硬件。 大一时搜集有关嵌入式方面的介绍，分享一篇对我颇有启发的作者——小智学长嵌入式（微信公众号）。    截取文章[【干货】关于嵌入式开发的经验之谈](https://mp.weixin.qq.com/s/HFsuS9_teHIzbdc6dQ9-IA &quot;【干货】关于嵌入式开发的经验之谈&quot;)如下：</code></pre><p>总结下来，需要掌握以下技能：</p><pre><code>    **算法层** ：需要根据处理器的特性，选择最适合在该处理上运行的算法。例如两个实现相同功能的算法，一个适合并行，一个不适合并行，则优先选取适合并行的算法。再比如有些算法的实现，存在一些过设计（如太多的迭代次数），需要能及时识别出来。算法层的优化必须先做，在这一层可能能带来事半功倍的效果。所以嵌入式工程师需要懂相关算法的原理，否则容易被算法工程师唬住（大家别笑，这种事情其实经常发生）。并行层：识别出代码中可以并行加速的部分，根据所用处理器的并行处理单元(NEON, DSP, GPU) ，使用vectorC/intrinsic C/CUDA/openCL编写并行加速代码，最大限度提高并行运算单元利用率。处理器层：如果编译器做得比较好，经过第二层，会得到优化效率很高的代码。但目前大部分编译器仍旧与人工节写的汇编有一定差距。所以针对热点代码，可以采用手写汇编的方式进行优化。但这一步，是优化到最后仍旧差一点点万不得已的办法，写汇编会耗费大量的时间精力，日后换处理器时还需要重写。处理器层除了汇编优化，还包括cache,DMA等memory相关的优化。memory的优化是经常被忽视的地方，通过提升内存的cache友好性是一件事半功倍的工作。</code></pre><p>**<br>语言基础**:C&#x2F;C++操作系统：RTOS、Linux、Android硬件：10、12C、SPI、SDIO、USB、内外部中断、定时器编程技能：数据结构、IPC、进程、线程、内存、文件、socket项目相关:wifi<br>ble 摄像头 激光雷达<br>zigbee等，这个部分根据自己学校资源与身边资源去选择。但有一个点非常重要，比如说你做wifi相关的项目，不是去实现wifi的连接功能即可，而是针对实际的产品场景，去输出有价值的实现方案。举个例子，做智能家居的产品，部分同学都是把模块买回来，源码UI改下，连接到别人服务器，然后整个链路跑通就完了。但是如果你做了一个断网以及网络延时情况下方案的解决办法或者模块远程升级的方案，这部分的实现思想比起你跑通整个链路，其实是更有谈资的。</p><pre><code>    大学可以学习学习以下方面：C和汇编语言混合编程、c++-&gt;python-&gt;JAVA、MAKEFILE、Builtroot(Linux移植)、cpu架构 ARM DSP/GPU、操作系统、通信协议(驱动)、ros系统、协议栈。    还有有关硬件基础的内容，由于大一当时看不懂，就未截取。现在看来还是非常全面的。    大学的很多竞赛都可以打打，提升自己的技术，比如：数学竞赛、算法竞赛、嵌入式相关的一些比赛和项目、数学建模...    如果想在将来创业或者职业规划最后走向管理岗，可以多多了解一些项目管理的知识。     另外看到两段比较有感触的话：    12、输出**个人价值：** 把自己对于项目、对于职场、对于专业技能的思考，转化为文字、语音或视频输出到互联网，能给你带来意想不到的收获。    13、不要给自己设限。工作十年后，你可以成为技术专家、项目经理，也可以成为售前技术、方案架构、专利顾问，可以开淘宝店卖开发板教程、出书、做培训机构老师，也可以给自己上下游厂家卖技术方案、开外包公司、建立自己品牌，甚至在自已小区楼下开小卖铺，一个月一万多生活没问题的。</code></pre><h2 id="二-学习实践"><a href="#二-学习实践" class="headerlink" title="二.学习实践"></a>二.学习实践</h2><h3 id="1-课内课程"><a href="#1-课内课程" class="headerlink" title="1.课内课程"></a>1.课内课程</h3><p>高等数学、离散数学、概率论、大学物理;</p><p>电路基础、数字电路、模拟电路、计算机通信与网络、信号与系统、数字信号处理;</p><p>计算机组织与体系结构、微机原理;</p><p>计算机导论与程序设计、程序设计、数据结构、操作系统、python、数据库系统</p><h4 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h4><p><a href="https://blog.csdn.net/qq_32971095/article/details/129629331?spm=1001.2014.3001.5502" title="python爬虫学习笔记">python爬虫学习笔记<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;129629331?spm&#x3D;1001.2014.3001.5502</a><a href="https://blog.csdn.net/qq_32971095/article/details/124532108?spm=1001.2014.3001.5502" title="位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业">位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124532108?spm&#x3D;1001.2014.3001.5502</a><a href="https://blog.csdn.net/qq_32971095/article/details/124508883?spm=1001.2014.3001.5502" title="简单文件数据库-模拟图书馆管理系统-西安电子科技大学大一程序基础设计课程设计作业">简单文件数据库-模拟图书馆管理系统-<br>西安电子科技大学大一程序基础设计课程设计作业<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124508883?spm&#x3D;1001.2014.3001.5502</a><a href="https://blog.csdn.net/qq_32971095/article/details/124302787?spm=1001.2014.3001.5502" title="UVa232解答">UVa232解答<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124302787?spm&#x3D;1001.2014.3001.5502</a><a href="https://download.csdn.net/download/qq_32971095/88221772?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机大类大一下程序设计基础课程设计大作业资源">【免费】西安电子科技大学计算机大类大一下程序设计基础课程设计大作业资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221772?spm&#x3D;1001.2014.3001.5503</a><a href="https://download.csdn.net/download/qq_32971095/88221707?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机大类大一上机代码及部分答案资源">【免费】西安电子科技大学计算机大类大一上机代码及部分答案资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221707?spm&#x3D;1001.2014.3001.5503</a><a href="https://download.csdn.net/download/qq_32971095/88221767?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机科学与技术专业大二数据结构上机代码资源">【免费】西安电子科技大学计算机科学与技术专业大二数据结构上机代码资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221767?spm&#x3D;1001.2014.3001.5503</a><a href="https://blog.csdn.net/qq_32971095/article/details/133420554" title="边缘检测——Matlab实现计算机视觉＜1＞">边缘检测——Matlab实现计算机视觉＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133420554</a></p><h3 id="2-51单片机"><a href="#2-51单片机" class="headerlink" title="2.51单片机"></a>2.51单片机</h3><p>推荐学习（结合开发板）：<a href="https://www.bilibili.com/video/BV1RB4y1i71i/?spm_id_from=333.999.0.0" title="【普中官方】51单片机手把手教学视频">【普中官方】51单片机手把手教学视频</a></p><p>学习收获：</p><p>对单片机、模块有相应概念，会通过寄存器操作的方式使用单片机；实现简单功能</p><h3 id="3-stm32"><a href="#3-stm32" class="headerlink" title="3.stm32"></a>3.stm32</h3><p>推荐学习（结合核心板和模块）：<a href="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.999.0.0" title="STM32入门教程-2023持续更新中">STM32入门教程-2023持续更新中</a></p><p>学习收获：</p><p>掌握单片机的库函数开发方式；熟悉模块互联通信；单片机系统程序设计；可制作稍复杂控制系统</p><h5 id="学习记录-1"><a href="#学习记录-1" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a href="https://blog.csdn.net/qq_32971095/article/details/132150694?spm=1001.2014.3001.5502" title="2023年电赛E题完整设计暨电赛全记录——二.学习资料分享——&lt;1&gt;学习笔记">2023年电赛E题完整设计暨电赛全记录——二.学习资料分享——&lt;1&gt;学习笔记<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132150694?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://download.csdn.net/download/qq_32971095/88226743?spm=1001.2014.3001.5503" title="电赛备战：基于stm32的多功能巡线避障小车_stm32巡线小车原理详解资源">电赛备战：基于stm32的多功能巡线避障小车_stm32巡线小车原理详解资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88226743?spm&#x3D;1001.2014.3001.5503</a><a href="https://download.csdn.net/download/qq_32971095/88221917" title="基于stm32的智能自行车尾灯_自行车尾灯资源">基于stm32的智能自行车尾灯_自行车尾灯资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221917</a><a href="https://download.csdn.net/download/qq_32971095/88221914" title="【免费】stm32测试平台，包含oled显示和蓝牙通讯功能资源">【免费】stm32测试平台，包含oled显示和蓝牙通讯功能资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221914</a></p><h3 id="4-FPGA"><a href="#4-FPGA" class="headerlink" title="4.FPGA"></a>4.FPGA</h3><p>推荐学习：</p><p><a href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA系列Xilinx Artix7教学视频">FPGA系列Xilinx<br>Artix7教学视频</a></p><p><a href="https://www.bilibili.com/video/BV1T84y1C7qy/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA-MPSoC">FPGA-<br>MPSoC</a></p><p><a href="https://www.bilibili.com/video/BV1Hq4y1u7qH/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="ZYNQ之嵌入式SDK开发">ZYNQ之嵌入式SDK开发</a></p><p><a href="https://www.bilibili.com/video/BV1qz4y1d7pF/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="ZYNQ之Linux开发">ZYNQ之Linux开发</a></p><p>学习收获：</p><p>**     **    Zynq 的 PS 部分就像 stm32<br>一样，本质都是配置外设的寄存器，利用开发商或者其他提供的友好接口的库函数对寄存器进行配置开发。 stm32 使用<br>ARM公司提供的cortex-M3内核，通过下载器将机器码下载至存储器代码段。</p><pre><code>    此时再**回头看 stm32 的 SoC 架构和总线系统** 相比 Zynq 的也容易看了许多，之后再看stm32 的数据手册也多了一些理解。还有之后的 stm32 的学习，可以使用 keil5 的调试功能，检查各个寄存器的值和执行的汇编语言，从而更深层面了解微机原理和 CPU 的运作。</code></pre><h5 id="学习记录-2"><a href="#学习记录-2" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a href="https://blog.csdn.net/qq_32971095/article/details/132220627?spm=1001.2014.3001.5502" title="FPGA基本概念及资源整理——FPGA学习笔记＜0＞——零.前言——学习实践汇总">FPGA基本概念及资源整理——FPGA学习笔记＜0＞——零.前言——学习实践汇总<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132220627?spm&#x3D;1001.2014.3001.5502</a></p><h3 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5.操作系统"></a>5.操作系统</h3><p><strong>学习记录</strong></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/130351060?spm=1001.2014.3001.5502" title="FreeRTOS学习笔记（一）">FreeRTOS学习笔记（一）<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;130351060?spm&#x3D;1001.2014.3001.5502</a><a href="https://blog.csdn.net/qq_32971095/article/details/133484963" title="Linux系统——OS学习笔记＜1＞">Linux系统——OS学习笔记＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133484963</a></p><h2 id="三-其他学习资料"><a href="#三-其他学习资料" class="headerlink" title="三.其他学习资料"></a>三.其他学习资料</h2><p>推荐学习：</p><p><a href="https://www.bilibili.com/video/BV1yx411u7iX/?spm_id_from=333.788.videocard.6&vd_source=01cde8042a76495bf513aa4407a56cd6" title="【Advanced控制理论】">【Advanced控制理论】</a></p><p><a href="https://www.bilibili.com/video/BV16E411h7Cg/?spm_id_from=333.788.videocard.10" title="现代控制理论（清华大学）">现代控制理论（清华大学）</a></p><p><a href="https://www.bilibili.com/video/BV15t411G7AG/?p=22&vd_source=01cde8042a76495bf513aa4407a56cd6" title="东北大学-计算机控制系统（国家级精品课）">东北大学-<br>计算机控制系统（国家级精品课）</a></p><p><a href="https://www.bilibili.com/video/BV1Bf4y1t7oA/?p=1&vd_source=01cde8042a76495bf513aa4407a56cd6" title="现代数字信号处理">现代数字信号处理</a></p><p><a href="https://www.bilibili.com/video/BV1es411H7eJ/?p=1&vd_source=01cde8042a76495bf513aa4407a56cd6" title="数字信号处理（西安电子科技大学&#x2F;西电）">数字信号处理（西安电子科技大学&#x2F;西电）</a></p><p><a href="https://blog.csdn.net/cqfdcw/article/details/84939698" title="常见滤波器简要对比介绍及Matlab实现">常见滤波器简要对比介绍及Matlab实现</a></p><p><a href="https://www.bilibili.com/video/BV18E411f7ZQ/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="数字信号分析理论与实践（基于matlab）">数字信号分析理论与实践（基于matlab）</a></p><p><a href="https://www.bilibili.com/video/BV1qf4y1x7kB/" title="浙江大学-机器学习">浙江大学-机器学习</a></p><h5 id="学习记录-3"><a href="#学习记录-3" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a href="https://blog.csdn.net/qq_32971095/article/details/132343604?spm=1001.2014.3001.5501" title="​​​​​项目管理概述">​​​​​项目管理概述<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132343604?spm&#x3D;1001.2014.3001.5501</a></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>总结来说就是借鉴，思考，改进，创新！</p><p>做好生涯规划，不要蹉跎岁月</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/133165306">https://blog.csdn.net/qq_32971095/article/details/133165306</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式硬件 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础设计四（信号采集、发生）——FPGA学习笔记＜5＞</title>
      <link href="/2023/09/18/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E5%9B%9B%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E3%80%81%E5%8F%91%E7%94%9F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C5%EF%BC%9E/"/>
      <url>/2023/09/18/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E5%9B%9B%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E3%80%81%E5%8F%91%E7%94%9F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C5%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E7%AE%80%E6%98%93%E9%A2%91%E7%8E%87%E8%AE%A1">一.简易频率计</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A2%91%E7%8E%87%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97">（2）频率计算模块</a></p><p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89freq_meter_calc%E6%A8%A1%E5%9D%97">（1）freq_meter_calc模块</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">（2）顶层模块</a></p><p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">&lt;3&gt;仿真设计</a></p><p><a href="about:blank#%E4%BA%8C.%E7%AE%80%E6%98%93%20DDS%20%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8">二.简易 DDS<br>信号发生器</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89DDS%E9%83%A8%E5%88%86">（2）DDS部分</a></p><p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F">&lt;3&gt;仿真</a></p><p><a href="about:blank#%E4%B8%89.%E7%AE%80%E6%98%93%E7%94%B5%E5%8E%8B%E8%A1%A8">三.简易电压表</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89ADC">（1）ADC</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A1%B6%E5%B1%82">（2）顶层</a></p><p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F">&lt;3&gt;仿真</a></p><hr><p>前置学习：</p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132818565" title="基础设计三——FPGA学习笔记＜4＞">基础设计三——FPGA学习笔记＜4＞</a></p><p>参考书目：《<a href="https://so.csdn.net/so/search?q=%E9%87%8E%E7%81%AB&spm=1001.2101.3001.7020" title="野火">野火</a>FPGA Verilog 开发实战指南》</p><h2 id="一-简易频率计"><a href="#一-简易频率计" class="headerlink" title="一.简易频率计"></a>一.简易频率计</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><p><strong>频率测量法</strong> ：在时间 t 内对被测时钟信号的时钟周期 N 进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。</p><p><strong>周期测量法</strong> ：先测量出被测时钟信号的时钟周期 T，然后根据频率 f &#x3D; 1／T 求出被测时钟信号的频率。</p><pre><code>    但是上述两种方法都会**产生±1 个被测时钟周期的误差** ，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现**频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量** ，但二者都不能兼顾高低频率同样精度的测量要求。    等精度测量法与前两种方式不同，其最大的特点是，测量的实际门控时间不是一个固定值，它与被测时钟信号相关，是被测时钟信号周期的整数倍。**在实际门控信号下，同时对标准时钟和被测时钟信号的时钟周期进行计数，再通过公式计算得到被测信号的时钟频率** 。**由于实际门控信号是被测时钟周期的整数倍，就消除了被测信号产生的±1 时钟周期的误差，但是会 产生对标准时钟信号±1 时钟周期的误差。**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/29bf724d81198014910c13dc96eaac2d.png"></p><pre><code>    结合等精度测量原理和原理示意图可得：被测时钟信号的时钟频率 fx 的相对误差与被测时钟信号无关；**增大“软件闸门”的有效范围或者提高“标准时钟信号”的时钟频率 fs，可以减小误差，提高测量精度。**    我们来说明一下被测时钟信号的计算方法。 首先我们先分别**对实际闸门下被测时钟信号和标准时钟信号的时钟周期进行计数** 。</code></pre><p>实际闸门下被测时钟信号周期数为 X，设被测信号时钟周期为 Tfx，它的时钟频率 fx &#x3D; 1&#x2F;Tfx，由此可得等式：<strong>X * Tfx &#x3D; X &#x2F; fx &#x3D;<br>Tx(实际闸门)</strong> 。</p><p>实际闸门下标准时钟信号周期数为 Y，设被测信号时钟周期为 Tfs，它的时钟频率 fs &#x3D; 1&#x2F;Tfs，由此可得等式：<strong>Y * Tfs &#x3D; Y &#x2F; fs &#x3D;<br>Tx(实际闸门)</strong> 。</p><p>其次，将两等式结合得到只包含各自时钟周期计数和时钟频率的等式：X &#x2F; fx &#x3D; Y &#x2F; fs &#x3D;<br>Tx(实际闸门)，等式变换，得到被测时钟信号时钟频率计算公式：<strong>fx &#x3D; X * fs &#x2F; Y</strong> 。 最后，将已知量标准时钟信号时钟频率 fs 和测量量<br>X、Y 带入计算公式，得到被测时 钟信号时钟频率 fx。</p><h4 id="（1）整体设计"><a href="#（1）整体设计" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><pre><code>    设计一个基于等精度测量原理的简易频率计，对输入的未知时钟信号做频率测量，并将测量结果在数码管上显示。 要求：标准时钟信号频率为 100MHz，实际闸门时间大于或等于 1s，目的是减小误差，提高测量精度。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/978217a5799aeabeded01deee9551eac.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e94173082bc78bce0b67675ae8d59ee8.png"></p><pre><code>    注：由频率计算模块输出的测量结果的单位为 Hz，为提高频率计测量范围，将结果除以 1000 后，再传入数码管显示模块，同时数码管小数点左移三位，所以**数码管显示结果的单位为 MHz** ；被测时钟生成模块(clk_test_gen)负责产生待检测时钟信号，如有条件的读者可用信号发生器代替该模块，直接输入待检测时钟信号。</code></pre><h4 id="（2）频率计算模块"><a href="#（2）频率计算模块" class="headerlink" title="（2）频率计算模块"></a>（2）频率计算模块</h4><p>波形绘制：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/02b9a4ea89adbb43d059dc540145cbb6.png"></p><p><strong>第一部分</strong> ：软件闸门 gate_s 及相关信号的设计与实现</p><pre><code>    软件闸门的生成我们需要声明计数器进行时间计数，计数时钟使用系统时钟 sys_clk。 声明软件闸门计数器 cnt_gate_s，计数时钟为 50MHz 系统时钟，时钟周期为 20ns，计数器 cnt_gate_s 初值为 0，在(0 – CNT_GATE_S_MAX)范围内循环计数。</code></pre><p><strong>第二部分</strong> ：<strong>实际闸门 gate_a 的设计与实现生成软件闸门后，使用被测时钟对软件闸门进行同步生成实际闸门 gate_a，实际闸门<br>波形图如下。（结合代码分析逻辑）</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23648a345380b8c3154eb7e6118f1e8e.png"></p><p><strong>第三部分</strong> ：实际闸门下，标准信号和被测信号时钟计数相关信号的波形设计与实现在实际闸门下，分别对标准信号和被测信号的时钟周期进行计数。声明计数器<br>cnt_clk_stand，在实际闸门下对标准时钟信号 clk_stand 进行时钟周期计数；声明计数器<br>cnt_clk_test，在实际闸门下对被测时钟信号 clk_test 进行时钟周期计数，两计数器波形如下。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5edf159cbdcee71c341f62c6e45080f0.png"></p><pre><code>    计数器 cnt_clk_stand、cnt_clk_test 在实际闸门下计数完成后，需要进行数据清零，方便下次计数。但是被测时钟频率的计算需要计数器的数据，所以在计数器数据清零之前我们需要**将计数器数据做一下寄存** ，对于数据寄存的时刻，我们选择**实际闸门的下降沿** 。 声明寄存器 cnt_clk_stand_reg；在标准时钟信号 clk_stand 同步下对实际闸门打一拍得 到 gate_a_s；使用实际闸门 gate_a 和 gate_a_s 得到标准时钟下的实际闸门下降沿标志信号 gate_a_fall_stand。当 gate_afall_stand 信号为高电平时，将计数器 cnt_clk_stand 数值赋值给寄存器 cnt_clk_stand_reg。 对 于 计 数 器 cnt_clk_test 的 数 值 寄 存 ， 我们使用相同的方法 ， 声明寄 存器 cnt_clk_test_reg；在被检测时钟信号 clk_test 同步下对实际闸门打一拍得到 gate_a_t；使用 实际闸门 gate_a 和 gate_a_t 得到被检测时钟下的实际闸门下降沿标志信号 gate_a_fall_test。 当 gate_a_fall_test 信号为高电平时，将计数器 cnt_clk_test 数值赋值给 cnt_clk_test_reg。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2bcf8e025972c05ca71aba1dc4dec4c.png"></p><p><strong>第四部分</strong> ：频率计算结果 freq 等相关信号波形的设计与实现实际闸门下的标准时钟和被测时钟的周期个数已经完成计数，且对结果进行了寄存，<br>标准时钟信号的时钟频率为已知量，得到这些参数，结合公式可以进行频率的求解。同时，新的问题出现，在哪一时刻进行数据求解。 我们可以利用最初声明的软件闸门计数器<br>cnt_gate_s，声明计算标志信号 calc_flag，在 计数器 cnt_gate_s 计数到最大值，将 calc_flag<br>拉高一个时钟周期的高电平作为计算标志， 计算被检测时钟信号时钟频率 freq_reg(注意变量位宽是否满足要求)；然后在系统时钟下将计算标志信号<br>calc_flag 打一拍，得到时钟频率输出标志信号 calc_flag_reg，当时钟频率输出标志信号 calc_flag_reg<br>为高电平时，将时钟频率计算结果 freq_reg 赋值给输出信号 freq。各信号波形图如下。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/680f95434816da76d89cec9336e84b6f.png"></p><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><p>参考书目参考代码：</p><h4 id="（1）freq-meter-calc模块"><a href="#（1）freq-meter-calc模块" class="headerlink" title="（1）freq_meter_calc模块"></a>（1）freq_meter_calc模块</h4><pre><code>module  freq_meter_calc(    input   wire            sys_clk     ,   //系统时钟,频率50MHz    input   wire            sys_rst_n   ,   //复位信号,低电平有效    input   wire            clk_test    ,   //待检测时钟    output  reg     [33:0]  freq            //待检测时钟频率);//********************************************************************////****************** Parameter And Internal Signal *******************////********************************************************************////parameter defineparameter   CNT_GATE_S_MAX  =   28&#39;d37_499_999  ,   //软件闸门计数器计数最大值            CNT_RISE_MAX    =   28&#39;d6_250_000   ;   //软件闸门拉高计数值parameter   CLK_STAND_FREQ  =   28&#39;d100_000_000 ;   //标准时钟时钟频率//wire  definewire            clk_stand           ;   //标准时钟,频率100MHzwire            gate_a_fall_s       ;   //实际闸门下降沿(标准时钟下)wire            gate_a_fall_t       ;   //实际闸门下降沿(待检测时钟下)//reg   definereg     [27:0]  cnt_gate_s          ;   //软件闸门计数器reg             gate_s              ;   //软件闸门reg             gate_a              ;   //实际闸门reg             gate_a_test         ;reg             gate_a_stand        ;   //实际闸门打一拍(标准时钟下)reg             gate_a_stand_reg    ;reg             gate_a_test_reg     ;   //实际闸门打一拍(待检测时钟下)reg     [47:0]  cnt_clk_stand       ;   //标准时钟周期计数器reg     [47:0]  cnt_clk_stand_reg   ;   //实际闸门下标志时钟周期数reg     [47:0]  cnt_clk_test        ;   //待检测时钟周期计数器reg     [47:0]  cnt_clk_test_reg    ;   //实际闸门下待检测时钟周期数reg             calc_flag           ;   //待检测时钟时钟频率计算标志信号//********************************************************************////***************************** Main Code ****************************////********************************************************************////cnt_gate_s:软件闸门计数器always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_gate_s  &lt;=  28&#39;d0;    else    if(cnt_gate_s == CNT_GATE_S_MAX)        cnt_gate_s  &lt;=  28&#39;d0;    else        cnt_gate_s  &lt;=  cnt_gate_s + 1&#39;b1;//gate_s:软件闸门always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_s  &lt;=  1&#39;b0;    else    if((cnt_gate_s&gt;= CNT_RISE_MAX)                &amp;&amp; (cnt_gate_s &lt;= (CNT_GATE_S_MAX - CNT_RISE_MAX)))        gate_s  &lt;=  1&#39;b1;    else        gate_s  &lt;=  1&#39;b0;//gate_a:实际闸门always@(posedge clk_test or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_a  &lt;=  1&#39;b0;    else        gate_a  &lt;=  gate_s;always@(posedge clk_test or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_a_test  &lt;=  1&#39;b0;    else        gate_a_test  &lt;=  gate_a;//cnt_clk_stand:标准时钟周期计数器,计数实际闸门下标准时钟周期数always@(posedge clk_stand or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_clk_stand   &lt;=  48&#39;d0;    else    if(gate_a_stand == 1&#39;b0)        cnt_clk_stand   &lt;=  48&#39;d0;    else    if(gate_a_stand == 1&#39;b1)        cnt_clk_stand   &lt;=  cnt_clk_stand + 1&#39;b1;//cnt_clk_test:待检测时钟周期计数器,计数实际闸门下待检测时钟周期数always@(posedge clk_test or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_clk_test    &lt;=  48&#39;d0;    else    if(gate_a_test == 1&#39;b0)        cnt_clk_test    &lt;=  48&#39;d0;    else    if(gate_a_test == 1&#39;b1)        cnt_clk_test    &lt;=  cnt_clk_test + 1&#39;b1;//gate_a_stand:实际闸门打一拍(标准时钟下)always@(posedge clk_stand or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_a_stand    &lt;=  1&#39;b0;    else        gate_a_stand    &lt;=  gate_a_test;always@(posedge clk_stand or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_a_stand_reg    &lt;=  1&#39;b0;    else        gate_a_stand_reg    &lt;=  gate_a_stand;//gate_a_fall_s:实际闸门下降沿(标准时钟下)assign  gate_a_fall_s = ((gate_a_stand_reg == 1&#39;b1) &amp;&amp; (gate_a_stand == 1&#39;b0))                        ? 1&#39;b1 : 1&#39;b0;//cnt_clk_stand_reg:实际闸门下标志时钟周期数always@(posedge clk_stand or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_clk_stand_reg   &lt;=  32&#39;d0;    else    if(gate_a_fall_s == 1&#39;b1)        cnt_clk_stand_reg   &lt;=  cnt_clk_stand;//gate_a_test:实际闸门打一拍(待检测时钟下)always@(posedge clk_test or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        gate_a_test_reg &lt;=  1&#39;b0;    else        gate_a_test_reg &lt;=  gate_a_test;//gate_a_fall_t:实际闸门下降沿(待检测时钟下)assign  gate_a_fall_t = ((gate_a_test_reg == 1&#39;b1) &amp;&amp; (gate_a_test == 1&#39;b0))                        ? 1&#39;b1 : 1&#39;b0;//cnt_clk_test_reg:实际闸门下待检测时钟周期数always@(posedge clk_test or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_clk_test_reg   &lt;=  32&#39;d0;    else    if(gate_a_fall_t == 1&#39;b1)        cnt_clk_test_reg   &lt;=  cnt_clk_test;//calc_flag:待检测时钟时钟频率计算标志信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        calc_flag   &lt;=  1&#39;b0;    else    if(cnt_gate_s == (CNT_GATE_S_MAX - 1&#39;b1))        calc_flag   &lt;=  1&#39;b1;    else        calc_flag   &lt;=  1&#39;b0;//freq:待检测时钟信号时钟频率always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        freq    &lt;=  34&#39;d0;    else    if(calc_flag == 1&#39;b1)        freq    &lt;=  (CLK_STAND_FREQ / cnt_clk_stand_reg * cnt_clk_test_reg);//********************************************************************////*************************** Instantiation **************************////********************************************************************////---------- clk_gen_inst ----------clk_gen clk_gen_inst(    .reset    (~sys_rst_n ),    .clk_in1  (sys_clk    ),         .clk_out1 (clk_stand  ));endmodule</code></pre><p>注：上述“打一拍”即经过一级寄存器，通过always时钟上升沿赋值即可实现</p><h4 id="（2）顶层模块"><a href="#（2）顶层模块" class="headerlink" title="（2）顶层模块"></a>（2）顶层模块</h4><pre><code>module  freq_meter(    input   wire            sys_clk     ,   //系统时钟,频率50MHz    input   wire            sys_rst_n   ,   //复位信号,低电平有效    input   wire            clk_test    ,   //待检测时钟    output  wire            clk_out     ,   //生成的待检测时钟    output  wire    [5:0]   sel         ,   //数码管位选信号    output  wire    [7:0]   seg             //数码管段选信号);//wire  definewire    [33:0]  freq    ;   //计算得到的待检测信号时钟频率//********************************************************************////*************************** Instantiation **************************////********************************************************************////---------- clk_gen_test_inst ----------clk_test_gen    clk_test_gen_inst(    .reset     (~sys_rst_n ),  //复位端口,高电平有效    .clk_in1   (sys_clk    ),  //输入系统时钟    .clk_out1  (clk_out    )   //输出生成的待检测时钟信号);//------------- freq_meter_calc_inst --------------freq_meter_calc freq_meter_calc_inst(    .sys_clk    (sys_clk    ),   //模块时钟,频率50MHz    .sys_rst_n  (sys_rst_n  ),   //复位信号,低电平有效    .clk_test   (clk_test   ),   //待检测时钟    .freq       (freq       )    //待检测时钟频率  );//------------- seg_595_dynamic_inst --------------seg_dynamic     seg_dynamic_inst(    .sys_clk     (sys_clk    ), //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n  ), //复位信号，低有效    .data        (freq/1000  ), //数码管要显示的值    .point       (6&#39;b001000  ), //小数点显示,高电平有效    .seg_en      (1&#39;b1       ), //数码管使能信号，高电平有效    .sign        (1&#39;b0       ), //符号位，高电平显示负号    .sel         (sel        ), //数码管位选信号    .seg         (seg        )  //数码管段选信号);endmodule</code></pre><p>这里还实例化了之前编写的动态数码管模块</p><h3 id="仿真设计"><a href="#仿真设计" class="headerlink" title="&lt;3&gt;仿真设计"></a>&lt;3&gt;仿真设计</h3><pre><code>module tb_freq_meter();//********************************************************************////****************** Parameter And Internal Signal *******************////********************************************************************////wire  definewire    [5:0]   sel         ;wire    [7:0]   seg         ;//reg   definereg             sys_clk     ;reg             sys_rst_n   ;reg             clk_test    ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////时钟、复位、待检测时钟的生成initial    begin        sys_clk     =   1&#39;b1;        sys_rst_n   &lt;=  1&#39;b0;        #200        sys_rst_n  &lt;=  1&#39;b1;        #500        clk_test      =   1&#39;b1;    endalways  #10     sys_clk =   ~sys_clk    ;   //50MHz系统时钟always  #100    clk_test=   ~clk_test    ;   //5MHz待检测时钟//重定义软件闸门计数时间,缩短仿真时间defparam freq_meter_inst.freq_meter_calc_inst.CNT_GATE_S_MAX    = 240   ;defparam freq_meter_inst.freq_meter_calc_inst.CNT_RISE_MAX      = 40    ;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------- freq_meter_inst -------------freq_meter  freq_meter_inst(    .sys_clk     (sys_clk   ),   //系统时钟,频率50MHz    .sys_rst_n   (sys_rst_n ),   //复位信号,低电平有效    .clk_test    (clk_test  ),   //待检测时钟    .clk_out     (clk_out   ),   //生成的待检测时钟    .sel         (sel       ),   //串行数据输入    .seg         (seg       ));endmodule</code></pre><h2 id="二-简易-DDS-信号发生器"><a href="#二-简易-DDS-信号发生器" class="headerlink" title="二.简易 DDS 信号发生器"></a>二.简易 DDS 信号发生器</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    DDS 技术是一种全新的频率合成方法，其具有低成本、低功耗、高分辨率和快速转换时间等优点，对数字信号处理及其硬件实现有着很重要的作用。 DDS 的基本结构主要由**相位累加器、相位调制器、波形数据表 ROM、D/A 转换器** 等四大结构组成，其中较多设计还会在数模转换器之后增加一个**低通滤波器** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1c2608b13ba13fac858da44b3b45277.png"></p><pre><code>    系统时钟 CLK 为整个系统的工作时钟， 频率为 fCLK；**频率字输入 F_WORD** ，一般为整数，数值大小控制输出信号的频率大小，数值越大输出信号频率越高，反之，输出信号频率越低，后文中**用 K 表示** ；**相位字输入 P_WORD** ，为整数，数值大小控制输出信号的相位偏移，主要用于相位的信号调制，后文 用 P 表示；设输出信号为 CLK_OUT，频率为 fOUT。    图中所展示的四大结构中，相位累加器是整个 DDS 的核心，在这里完成相位累加，生成相位码。相位累加器的输入为**频率字输入 K** ，表示相位增量，设其**位宽为 N** ，满足等式** K = (2^N) * fOUT / fCLK** 。其在输入相位累加器之前，在系统时钟同步下做数据寄存，数据改变时不会干扰相位累加器的正常工作。    相位调制器接收相位累加器输出的相位码， 在这里加上一个相位偏移值 P，主要用于信号的相位调制，如应用于通信方面的相移键控等，不使用此部分时可以去掉，或者将其设为一个常数输入，同样相位字输入也要做寄存。    **波形数据表 ROM 中存有一个完整周期的正弦波信号** 。假设波形数据 ROM 的**地址位宽为 12 位，存储数据位宽为 8 位** ，即 ROM 有 2^12 = 4096 个存储空间，每个存储空间可存储 1 字节数据。将一个周期的正弦波信号，**沿横轴等间隔采样 2^12 = 4096 次** ，每次采集的信号**幅度用 1 字节数据表示** ，最大值为 255，最小值为 0。将 4096 次采样结果按顺序写入 ROM 的 4096 个存储单元，一个完整周期正弦波的数字幅度信号写入了波形数据表 ROM 中。**波形数据表 ROM 以相位调制器传入的相位码为 ROM 读地址，将地址对应存储单元中的电压幅值数字量输出** 。 D/A 转换器将输入的电压幅值数字量转换为模拟量输出 ， 就得到输出信号 CLK_OUT。 输出信号 CLK_OUT 的信号频率 **fOUT = K * fCLK / 2^N。当 K = 1 时，可得 DDS 最小分辨率为：fOUT = fCLK / 2^N，此时输出信号频率最低。根据采样定理，K 的最大值应小于 (2 ^N) / 2。**</code></pre><p><strong>相位累加器得到的相位码是如何实现 ROM 寻址的</strong> ？</p><p>对于 N 位的相位累加器，它对应的相位累加值为 2^N，如果正弦 <strong>ROM 中存储单元的个数</strong> 也是 2^N 的话，这个问题就很好解决，但是这对 ROM<br>的对存储容量的要求较高。<strong>在实际操作中，我们使用相位累加值的高几位对 ROM 进行寻址</strong> ，也就是说<strong>并不是每个系统时钟都对 ROM<br>进行数据读取，而是多个时钟读取一次</strong> ，因为这样能<strong>保证相位累加器溢出时， 从正弦 ROM 表中取出正好一个正弦周期的样点</strong> 。<br>因此，<strong>相位累加器每计数 2^N 次，对应一个正弦周期</strong> 。而相位累加器 1 秒钟计数 fCLK 次，<strong>在 k&#x3D;1 时，DDS<br>输出的时钟频率就是频率分辨率。 频率控制字 K 增加时，相位累加器溢出的频率增加，对应 DDS 输出信号 CLK_OUT 频率变为 K 倍的 DDS<br>频率分辨率。</strong></p><p>举个例子： 设：ROM 存储单元个数为 4096，每个存储数据用 8 位二进制表示。即，<strong>ROM 地址线 宽度为 12，数据线宽度为 8；相位累加器位宽<br>N &#x3D; 32</strong> 。 根据上述条件可以知道，相位调制器位宽 M &#x3D; 12，那么根据 DDS<br>原理。那么在相位调制器中与相位控制字进行累加时，应用相位累加器的高 12 位累加。而相位累加器的低 20 位只与频率控制字累加。 我们以<strong>频率控制字 K<br>&#x3D; 1</strong> 为例，相位累加器的低 20 位<strong>一直会加 1</strong> ，直到低 20 位溢出向 高 12 位进位，此时 ROM 为 0，也就是说，ROM 的 0<br>地址中的数据被读了 2^20次，继续下 去，ROM 中的 4096 个点，每个点都将会被读 2^ 20次，最终输出的波形频率应该是参考时钟频率的 1 &#x2F;<br>2^20，周期被扩大了 2^20 倍。同样当<strong>频率控制字 K&#x3D;  100 时</strong>，相位累加器的低 20 位 <strong>一直会加 100</strong><br>，那么，相位累加器的低 20 位溢出的时间比上面会快 100 倍，则 ROM 中的 每个点相比于上面会少读 100 次，所以最终输出频率是上述的 10 倍。</p><pre><code>    D/A 转换器即 数/模转换器，简称 DAC（Digital to Analog Conver），是指将数字信号转换为模拟信号的电子元件或电路。    DAC 内部电路构造无太大差异，大多数 DAC 由**电阻阵列和 n 个电流开关(或电压开关)** 构成，按照输入的数字值进行**开关切换** ，输出对应电流或电压。因此，按照输出信号类型可分为电压型和电流型，也可以按照 DAC 能否做乘法运算进行分类。若将 DAC 分为电压型和电流型两大类，电压型 DAC 中又**有权电阻网络、T 形电阻网络、树形开关网络** 等分别；电流型 DAC 中又有**权电流型电阻网络和倒 T 形电阻网络** 等。    电压输出型 DAC 一般采用**内置输出放大器以低阻抗输出** ，少部分**直接通过电阻阵列进行电压输出** 。直接输出电压的 DAC 仅用于高阻抗负载，由于**无输出放大器部分的延迟** ，故常作为**高速 DAC** 使用。    电流输出型 DAC 很少直接利用电流输出，大多**外接电流 - 电压转换电路进行电压输出** 。实现电流 - 电压转换，方法有二：一是只在输出引脚上**接负载电阻而进行电流- 电压转换** ，**二是外接运算放大器** 。    DAC 的主要技术指标包括**分辨率、线性度、转换精度和转换速度** 。    分辨率指输出模拟电压的最小增量，即表明 DAC 输入一个最低有效位(LSB)而在输出端上模拟电压的变化量。    线性度在理想情况下，DAC 的数字输入量作**等量增加时，其模拟输出电压也应作等量增加** ，但是实际输出往往有偏离。    D/A 转换器的转换精度与 D/A 转换器的集成芯片的结构和接口电路配置有关。如果不考虑其他 D/A 转换误差时，D/A 的转换精度就是分辨率的大小，因此要获得高精度的 D/A 转换结果，首先要保证选择有足够分辨率的 D/A 转换器。同时 D/A 转换精度还与外接电路的配置有关，当外部电路器件或电源误差较大时，会造成较大的 D/A 转换误差，当这些误差超过一定程度时，D/A 转换就产生错误。    转换速度一般由建立时间决定。建立时间是将一个数字量转换为稳定模拟信号所需的时间，也可以认为是转换时间。**DA 中常用建立时间来描述其速度，而不是 AD 中常用的转换速率** 。一般地，电流输出 DA 建立时间较短，电压输出 DA 则较长。</code></pre><h3 id="代码设计-1"><a href="#代码设计-1" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><h4 id="（1）整体设计-1"><a href="#（1）整体设计-1" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><pre><code>    使用 FPGA 开发板和外部挂载的高速 AD/DA 板卡，设计并实现一个简易 DDS 信号发 生器，可通过按键控制实现正弦波、方波、三角波和锯齿波的波形输出，频率相位可调</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c80ea34aef420c3c4f07da0c3fcf0d2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5f9d3db772c9b21577ae3374dc4460f4.png"></p><p>详细介绍参考《野火FPGA Verilog开发实战指南》</p><pre><code>    其他 3 部分，相位累加器、相位调制器、波形数据表 ROM 由 FPGA 负责。所以我们要建立一个单独的模块对 DDS 部分进行处理；实验目标还提到要使用按键实现 4 种波形的切换，按键消抖模块必不可少；同时也要声明一个按键控制模块对 4 个输入按键进行控制，子功能模块已经足够了，最后再加一个顶层模块。    顶层模块较为简单，内部例化了各子功能模块，连接各对应信号；外部有 3 路输入信号、2 路输出信号。输入有时钟、复位信号和控制信号波形切换的 4 路按键信号；输出 2 路信号中，信号 dac_data 为 DDS 模块输出的，自波形数据表 ROM 中读取的波形数据；信号 dac_clk 为输入至外载板卡的时钟信号，**DA 模块使用此时钟进行数据处理，该信号由系统时钟 sys_clk 取反得到** 。 波形数据表 ROM 的读时钟为系统时钟 sys_clk，在系统时钟上升沿时对 ROM 进行数据读取，而 DA 模块也使用时钟上升沿进行数据处理，**将系统时钟 sys_clk 取反得到 dac_clk，dac_clk 的上升沿刚好采集到波形数据 dac_data 的稳定数据** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/da377471871ba01b431909229db0e598.png"></p><pre><code>module  top_dds(    input   wire            sys_clk     ,   //系统时钟,50MHz    input   wire            sys_rst_n   ,   //复位信号,低电平有效    input   wire    [3:0]   key         ,   //输入4位按键    output  wire            dac_clk     ,   //输入DAC模块时钟    output  wire    [7:0]   dac_data        //输入DAC模块波形数据);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire    [3:0]   wave_select ;   //波形选择//dac_clka:DAC模块时钟assign  dac_clk  = ~sys_clk;//********************************************************************////*************************** Instantiation **************************////********************************************************************////-------------------------- dds_inst -----------------------------dds     dds_inst(    .sys_clk        (sys_clk    ),   //系统时钟,50MHz    .sys_rst_n      (sys_rst_n  ),   //复位信号,低电平有效    .wave_select    (wave_select),   //输出波形选择    .data_out       (dac_data   )    //波形输出);//----------------------- key_control_inst ------------------------key_control key_control_inst(    .sys_clk        (sys_clk    ),   //系统时钟,50MHz    .sys_rst_n      (sys_rst_n  ),   //复位信号,低电平有效    .key            (key        ),   //输入4位按键    .wave_select    (wave_select)    //输出波形选择 );endmodule</code></pre><h4 id="（2）DDS部分"><a href="#（2）DDS部分" class="headerlink" title="（2）DDS部分"></a>（2）DDS部分</h4><pre><code>    dds 模块中实例化一个 ROM IP 核，按顺序存入了一个完整周期的正弦波、方波、三角波、锯齿波的信号波形， 根据输入波形选择信号对 rom 中对应信号波形进行读取，将读出波形的幅度数字值输出， 传入外部挂载的高速 AD/DA 板卡的 DA 端，板卡根据输入的数字信号生成对应波形的模拟信号。其中，输出信号的频率和相位的调节可在 dds 模块中通过修改参数实现。    需要事先在波形数据表 ROM 中存入 4 种波形信号各自的完整周期波形数据。ROM 作为只读存储器，**在进行 IP 核设置时需要指定初始化文件，我们将波形数据作为初始化文件写入其中，文件格式为 COE 文件。**    使用 MatLab 绘制 4 种信号波形，对波形进行等间隔采样，以采样次数作为 ROM 存储地址，将采集的波形幅值数据做为存储数据写入存储地址对应的存储空间。我们对 4 种信号波形进行分别采样，采样次数为 2^12 = 4096 次，采集的波形幅值数据位宽为 8bit，将采集数据保存为 MIF 文件。</code></pre><p>MATLAB文件（以正弦信号为例）：</p><pre><code>clc;                    %清除命令行命令clear all;              %清除工作区变量,释放内存空间F1=1;                   %信号频率Fs=2^12;                %采样频率P1=0;                   %信号初始相位N=2^12;                 %采样点数t=[0:1/Fs:(N-1)/Fs];    %采样时刻ADC=2^7 - 1;            %直流分量A=2^7;                  %信号幅度%生成正弦信号s=A*sin(2*pi*F1*t + pi*P1/180) + ADC;plot(s);                %绘制图形%创建coe文件fild = fopen(&#39;sin_wave_4096x8.coe&#39;,&#39;wt&#39;);%写入coe文件头fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_RADIX=10;&#39;); %10进制数fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_VECTOR=&#39;); for i = 1:N    s0(i) = round(s(i));    %对小数四舍五入以取整    if s0(i) &lt;0             %负1强制置零        s0(i) = 0    end    if i == N            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入            fprintf(fild, &#39;%s&#39;,&#39;;&#39;);        %最后一个数据使用分号    else            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入            fprintf(fild, &#39;%s\n&#39;,&#39;,&#39;);      %逗号，换行    end     endfclose(fild);</code></pre><p>整体信号写入：</p><pre><code>clc;                    %清除命令行命令clear all;              %清除工作区变量,释放内存空间F1=1;                   %信号频率Fs=2^12;                %采样频率P1=0;                   %信号初始相位N=2^12;                 %采样点数t=[0:1/Fs:(N-1)/Fs];    %采样时刻ADC=2^7 - 1;            %直流分量A=2^7;                  %信号幅度s1=A*sin(2*pi*F1*t + pi*P1/180) + ADC;          %正弦波信号s2=A*square(2*pi*F1*t + pi*P1/180) + ADC;       %方波信号s3=A*sawtooth(2*pi*F1*t + pi*P1/180,0.5) + ADC; %三角波信号s4=A*sawtooth(2*pi*F1*t + pi*P1/180) + ADC;     %锯齿波信号%创建coe文件fild = fopen(&#39;wave_16384x8.coe&#39;,&#39;wt&#39;);%写入coe文件头fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_RADIX=10;&#39;); %10进制数fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_VECTOR=&#39;);for j = 1:4    for i = 1:N        if j == 1       %打印正弦信号数据            s0(i) = round(s1(i));    %对小数四舍五入以取整        end        if j == 2       %打印方波信号数据            s0(i) = round(s2(i));    %对小数四舍五入以取整        end        if j == 3       %打印三角波信号数据            s0(i) = round(s3(i));    %对小数四舍五入以取整        end        if j == 4       %打印锯齿波信号数据            s0(i) = round(s4(i));    %对小数四舍五入以取整        end        if s0(i) &lt;0             %负1强制置零            s0(i) = 0        end                if j == 4 &amp;&amp; i == N            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入            fprintf(fild, &#39;%s&#39;,&#39;;&#39;);        %最后一个数使用分号结束        else            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入            fprintf(fild, &#39;%s\n&#39;,&#39;,&#39;);      %逗号，换行        end    endendfclose(fild);</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a87316586f399c84e19bb0b36947031f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0404863083748a6404247951d25cd7cb.png"></p><pre><code>    内部声明 3 个寄存器变量。其中 fre_add 表示相位累加器输出值，位宽为 32 位，系统上电后，**fre_add 信号一直执行自加操作，每个时钟周期自加参数 FREQ_CTRL** ，参数 FREQ_CTRL 就是在之前理论知识部分提到的频率字输入 K。    寄存器变量 rom_addr_reg 表示相位调制器输出值，将相位累加器输出值的高 12 位与相位偏移量 PHASE_CTRL 相加，参数 PHASE_CTRL 就是我们之前提到过的相位字输入P。之所以使用高 12 位，与存储波形的 ROM 深度有关。按理论讲，将得到的变量 rom_addr_reg，可直接作为 ROM 读地址输入波形数据表进行数据读取，但是我们将 4 中波形存储在了同一 ROM 中，所以还需要对读数据地址做进一步计算。    ROM 读地址 rom_addr 是输入波形数据表的 ROM 读地址，是在 rom_addr_reg 的基础上计算得到。我们之前将 4 种信号波形数据按照正弦波、方波、三角波、锯齿波的顺序写 入 ROM。若需要读取正弦波波形数据，rom_addr_reg 可直接赋值给 rom_addr；但是要进行方波波形数据的读取，rom_addr_reg 需要再加上正弦波存储单元个数才能赋值给 rom_addr；剩余两信号同理。    本实验，我们希望输出一个频率为 500Hz，初相位为π/2 的正弦波信号。 计算参数 FREQ_CTRL，即频率输入字 K。    **FREQ_CTRL = K = 2N * fOUT / fCLK** ，其中**N = 32(相位累加器输出值 fre_add 的位宽)** 、 fOUT = 500Hz，fCLK = 50MHz，带入公式，FREQ_CTRL = K = 42949.67296 ，取整数部分为 42949；             计算参数 PHASE_CTRL，即相位输入字 P。 **PHASE_CTRL = P = θ / (2π / 2M)** ，其中**M =12(输入 ROM 地址位宽)** 、θ = π / 2，带入 公式，PHASE_CTRL = P = 1024。module  dds(    input   wire            sys_clk     ,   //系统时钟,50MHz    input   wire            sys_rst_n   ,   //复位信号,低电平有效    input   wire    [3:0]   wave_select ,   //输出波形选择    output  wire    [7:0]   data_out        //波形输出);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter defineparameter   sin_wave    =   4&#39;b0001     ,   //正弦波            squ_wave    =   4&#39;b0010     ,   //方波            tri_wave    =   4&#39;b0100     ,   //三角波            saw_wave    =   4&#39;b1000     ;   //锯齿波parameter   FREQ_CTRL   =   32&#39;d42949   ,   //相位累加器单次累加值            PHASE_CTRL  =   12&#39;d1024    ;   //相位偏移量//reg   definereg     [31:0]  fre_add     ;   //相位累加器reg     [11:0]  rom_addr_reg;   //相位调制后的相位码reg     [13:0]  rom_addr    ;   //ROM读地址//********************************************************************////***************************** Main Code ****************************////********************************************************************////fre_add:相位累加器always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        fre_add &lt;=  32&#39;d0;    else        fre_add &lt;=  fre_add + FREQ_CTRL;//rom_addr:ROM读地址always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        begin            rom_addr        &lt;=  14&#39;d0;            rom_addr_reg    &lt;=  11&#39;d0;        end    else    case(wave_select)        sin_wave:            begin                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;                rom_addr        &lt;=  rom_addr_reg;            end     //正弦波        squ_wave:            begin                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;                rom_addr        &lt;=  rom_addr_reg + 14&#39;d4096;            end     //方波        tri_wave:            begin                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;                rom_addr        &lt;=  rom_addr_reg + 14&#39;d8192;            end     //三角波        saw_wave:        begin                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;                rom_addr        &lt;=  rom_addr_reg + 14&#39;d12288;            end     //锯齿波        default:            begin                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;                rom_addr        &lt;=  rom_addr_reg;            end     //正弦波    endcase//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------- rom_wave_inst ------------------------rom_wave    rom_wave_inst(  .clka(sys_clk), // input clka  .addra(rom_addr), // input [13 : 0] addra  .douta(data_out) // output [7 : 0] douta);endmodule    rom_wave 是 IP 核，可以看到改变初相位的办法就是初始值加上 PHASE_CTRL ；每个时钟周期先给 fre_add 赋值，接着是 rom_addr_reg 和 rom_addr，rom_addr 直接连接到 IP 核。</code></pre><p>（3）按键消抖部分</p><pre><code>module  key_filter#(    parameter CNT_MAX = 20&#39;d999_999 //计数器计数最大值)(    input   wire    sys_clk     ,   //系统时钟50Mhz    input   wire    sys_rst_n   ,   //全局复位    input   wire    key_in      ,   //按键输入信号    output  reg     key_flag        //key_flag为1时表示消抖后检测到按键被按下                                    //key_flag为0时表示没有检测到按键被按下);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg     [19:0]  cnt_20ms    ;   //计数器//********************************************************************////***************************** Main Code ****************************////********************************************************************////cnt_20ms:如果时钟的上升沿检测到外部按键输入的值为低电平时，计数器开始计数always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_20ms &lt;= 20&#39;b0;    else    if(key_in == 1&#39;b1)        cnt_20ms &lt;= 20&#39;b0;    else    if(cnt_20ms == CNT_MAX &amp;&amp; key_in == 1&#39;b0)        cnt_20ms &lt;= cnt_20ms;    else        cnt_20ms &lt;= cnt_20ms + 1&#39;b1;//key_flag:当计数满20ms后产生按键有效标志位//且key_flag在999_999时拉高,维持一个时钟的高电平always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        key_flag &lt;= 1&#39;b0;    else    if(cnt_20ms == CNT_MAX - 1&#39;b1)        key_flag &lt;= 1&#39;b1;    else        key_flag &lt;= 1&#39;b0;endmodulemodule  key_control(    input   wire            sys_clk     ,   //系统时钟,50MHz    input   wire            sys_rst_n   ,   //复位信号,低电平有效    input   wire    [3:0]   key         ,   //输入4位按键    output  reg     [3:0]   wave_select     //输出波形选择);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter defineparameter   sin_wave    =   4&#39;b0001,    //正弦波            squ_wave    =   4&#39;b0010,    //方波            tri_wave    =   4&#39;b0100,    //三角波            saw_wave    =   4&#39;b1000;    //锯齿波parameter   CNT_MAX =   20&#39;d999_999;    //计数器计数最大值//wire  definewire            key3    ;   //按键3wire            key2    ;   //按键2wire            key1    ;   //按键1wire            key0    ;   //按键0//********************************************************************////***************************** Main Code ****************************////********************************************************************////wave:按键状态对应波形always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wave_select   &lt;=  4&#39;b0000;    else    if(key0 == 1&#39;b1)        wave_select   &lt;=  sin_wave;    else    if(key1 == 1&#39;b1)        wave_select   &lt;=  squ_wave;    else    if(key2 == 1&#39;b1)        wave_select   &lt;=  tri_wave;    else    if(key3 == 1&#39;b1)        wave_select   &lt;=  saw_wave;    else        wave_select   &lt;=  wave_select;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------- key_fifter_inst3 --------------key_filter #(    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值)key_filter_inst3(    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz    .sys_rst_n    (sys_rst_n)   ,   //全局复位    .key_in       (key[3]   )   ,   //按键输入信号    .key_flag     (key3     )       //按键消抖后标志信号);//------------- key_fifter_inst2 --------------key_filter #(    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值)key_filter_inst2(    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz    .sys_rst_n    (sys_rst_n)   ,   //全局复位    .key_in       (key[2]   )   ,   //按键输入信号    .key_flag     (key2     )       //按键消抖后标志信号);//------------- key_fifter_inst1 --------------key_filter #(    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值)key_filter_inst1(    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz    .sys_rst_n    (sys_rst_n)   ,   //全局复位    .key_in       (key[1]   )   ,   //按键输入信号    .key_flag     (key1     )       //按键消抖后标志信号);//------------- key_fifter_inst0 --------------key_filter #(    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值)key_filter_inst0(    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz    .sys_rst_n    (sys_rst_n)   ,   //全局复位    .key_in       (key[0]   )   ,   //按键输入信号    .key_flag     (key0     )       //按键消抖后标志信号);endmodule</code></pre><p>key_control模块实例化了四个按键消抖模块</p><h3 id="仿真"><a href="#仿真" class="headerlink" title="&lt;3&gt;仿真"></a>&lt;3&gt;仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a74cf028e7f344f5bbcede195c9bddaa.png"></p><pre><code>`timescale  1ns/1ns// Author  : EmbedFire// 实验平台: 野火FPGA系列开发板// 公司    : http://www.embedfire.com// 论坛    : http://www.firebbs.cn// 淘宝    : https://fire-stm32.taobao.commodule  tb_top_dds();//**************************************************************////*************** Parameter and Internal Signal ****************////**************************************************************//parameter   CNT_1MS  = 20&#39;d19000   ,            CNT_11MS = 21&#39;d69000   ,            CNT_41MS = 22&#39;d149000  ,            CNT_51MS = 22&#39;d199000  ,            CNT_60MS = 22&#39;d249000  ;//wire  definewire            dac_clk     ;wire    [7:0]   dac_data    ;//reg   definereg             sys_clk     ;reg             sys_rst_n   ;reg     [21:0]  tb_cnt      ;reg             key_in      ;reg     [1:0]   cnt_key     ;reg     [3:0]   key         ;//defparam  definedefparam    top_dds_inst.key_control_inst.CNT_MAX = 24;//**************************************************************////************************** Main Code *************************////**************************************************************////sys_rst_n,sys_clk,keyinitial    begin        sys_clk     =   1&#39;b0;        sys_rst_n   &lt;=   1&#39;b0;        key &lt;= 4&#39;b0000;        #200;        sys_rst_n   &lt;=   1&#39;b1;    endalways #10 sys_clk = ~sys_clk;//tb_cnt:按键过程计数器，通过该计数器的计数时间来模拟按键的抖动过程always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        tb_cnt &lt;= 22&#39;b0;    else    if(tb_cnt == CNT_60MS)        tb_cnt &lt;= 22&#39;b0;    else            tb_cnt &lt;= tb_cnt + 1&#39;b1;//key_in:产生输入随机数，模拟按键的输入情况always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        key_in &lt;= 1&#39;b1;    else    if((tb_cnt &gt;= CNT_1MS &amp;&amp; tb_cnt &lt;= CNT_11MS)                || (tb_cnt &gt;= CNT_41MS &amp;&amp; tb_cnt &lt;= CNT_51MS))        key_in &lt;= &#123;$random&#125; % 2;    else    if(tb_cnt &gt;= CNT_11MS &amp;&amp; tb_cnt &lt;= CNT_41MS)        key_in &lt;= 1&#39;b0;    else        key_in &lt;= 1&#39;b1;always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_key &lt;=  2&#39;d0;    else    if(tb_cnt == CNT_60MS)        cnt_key &lt;=  cnt_key + 1&#39;b1;    else        cnt_key &lt;=  cnt_key;always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        key     &lt;=  4&#39;b1111;    else        case(cnt_key)            0:      key &lt;=  &#123;3&#39;b111,key_in&#125;;            1:      key &lt;=  &#123;2&#39;b11,key_in,1&#39;b1&#125;;            2:      key &lt;=  &#123;1&#39;b1,key_in,2&#39;b11&#125;;            3:      key &lt;=  &#123;key_in,3&#39;b111&#125;;            default:key &lt;=  4&#39;b1111;        endcase//**************************************************************////************************ Instantiation ***********************////**************************************************************////------------- top_dds_inst -------------top_dds top_dds_inst(    .sys_clk    (sys_clk    ),    .sys_rst_n  (sys_rst_n  ),    .key        (key        ),    .dac_clk    (dac_clk    ),    .dac_data   (dac_data   ));endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1889590a090cc653ecbc28aa8be916d.png"></p><h2 id="三-简易电压表"><a href="#三-简易电压表" class="headerlink" title="三.简易电压表"></a>三.简易电压表</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    模/数转换器即 A/D 转换器，或简称 ADC（Analog to Digital Conver），模拟信号与数字信号的转换过程一般分为四个步骤：**采样、保持、量化、编码** 。前两个步骤在采样-保持电路中完成，后两步则在 ADC 芯片中完成。    常用的 ADC 可分为**积分型、逐次逼近型、并行比较型/串并行型、Σ -Δ调制型、电容阵列逐次比较型以及压频变换型** 。    积分型 ADC 工作原理是**将输入电压转换成时间或频率，然后由定时器/计数器获得数字值** 。其优点是使用简单电路就能获得高分辨率；缺点是由于转换精度依赖于积分时间， 因此**转换速率极低** 。双积分是一种常用的 AD 转换技术，具有精度高，抗干扰能力强等优点。但高精度的双积分 AD 芯片，价格昂贵，设计成本较高。    逐次逼近型 ADC 由一个比较器和 DA 转换器通过逐次比较逻辑构成，从 MSB 开始， 顺序地对每一位**将输入电压与内置 DA 转换器输出进行比较，经 n 次比较而输出数字值** 。 其电路规模属于中等，优点是速度较高、功耗低，在低分辨率( &lt; 12 位)时价格便宜，但高精度( &gt; 12 位)价格昂贵。    并行比较型 ADC **采用多个比较器** ，仅作一次比较而实行转换，又称 Flash 型。由于转换速率极高，**n 位的转换需要 2n - 1 个比较器** ，因此电路规模也极大，价格也高，**只适用于视频 AD 转换器等速度特别高的领域** 。    Σ- Δ型 ADC 以**很低的采样分辨率( 1 位)和很高的采样速率** 将模拟信号数字化，通过使用**过采样、噪声整形和数字滤波等方法增加有效分辨率** ，然后对 ADC 输出进行采样抽取处理以降低有效采样速率。Σ-Δ型 ADC 的电路结构是由非常简单的模拟电路和十分复杂的数字信号处理电路构成。    电容阵列逐次比较型 ADC 在**内置 DA 转换器中采用电容矩阵方式** ，也可称为电荷再分配型。一般的电阻阵列 DA 转换器中多数电阻的值必须一致，在单芯片上生成高精度的电阻并不容易。如果用电容阵列取代电阻阵列，可以用低廉成本制成高精度单片 AD 转换器。最近的逐次比较型 AD 转换器大多为电容阵列式的。    压频变换型是通过间接转换方式实现模数转换的。其原理是首先**将输入的模拟信号转换成频率，然后用计数器将频率转换成数字量** 。从理论上讲这种 ADC 的分辨率几乎可以无限增加，**只要采样的时间能够满足输出频率分辨率要求的累积脉冲个数的宽度** 。其优点是分辨率高、功耗低、价格低，但是需要外部计数电路共同完成 AD 转换。    ADC 的主要技术指标包括：**分辨率、转换速率、量化误差、满刻度误差、线性度** 。    分辨率指输出数字量变化一个最低有效位(LSB)所需的输入模拟电压的变化量。 转换速率是指完成一次从模拟转换到数字的 AD 转换所需要的时间的倒数。**积分型 AD 的转换时间是毫秒级属低速 AD，逐次比较型 AD 是微秒级属中速 AD，全并行/串并行 型 AD 可达到纳秒级** 。采样时间则是另外一个概念，是指**两次转换的间隔** 。为了保证转换的正确完成，**采样速率（Sample Rate）必须小于或等于转换速率** 。因此有人习惯上将转换速率在数值上等同于采样速率也是可以接受的。 量化误差是由于 AD 的有限分辩率而引起的误差，即有限分辩率 AD 的阶梯状转移特性曲线与无限分辩率 AD（理想 AD）的转移特性曲线（直线）之间的最大偏差。通常是 1 个或半个最小数字量的模拟变化量，表示为 **1LSB、1/2LSB** 。 满刻度误差是满刻度输出时对应的输入信号与理想输入信号值之差。 线性度指实际转换器的转移函数与理想直线的最大偏移。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/02c1afc1e39c76f93bda212446d69078.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0285c7fd6f5b8e37bd4d93f9cdba82b.png"></p><pre><code>    实验主要把adc模块传回的数据变换为数值。本实验使用的 ADC 芯片位宽为 8 位，板卡模拟电压输入范围为-5v~+5v，即电压表测量范围，最大值和最小值压降为 10v，分辨率为 10/28。    当 ADC 芯片采集后的电压数值 ad_data 位于 0 - 127 范围内，表示测量电压位于-5V ~ 0V 范围内，换算为电压值：Vin = - (10 / 28 * (127 - ad_data))；当 ADC 芯片采集后的电压数值 ad_data 位于 128 - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，换算为电压值：Vin = (10 / 28 * (ad_data - 127))。    简易电压表实验可以参照这种思想来进行工程的设计与实现，但为了提高测量结果的精确性，我们使用**定义中值的测量方法** 。    在电压表上电后未接入测量电压时，取 ADC 芯片采集的最初的若干测量值，取平均，作为测量中值 **data_median** ，与实际测量值 0V 对应。 使用定义中值的测量方法时，当 ADC 芯片采集后的电压数值 ad_data 位于 0 ~ data_median 范围内，表示测量电压位于-5V ~ 0V 范围内，**分辨率为 10/((data_median + 1) * 2)** ，换算为电压值：Vin = - ((10 /((data_median + 1) * 2)) * (data_median - ad_data))；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，分辨率为 10/((255 - data_median + 1) * 2)，换算为电压值：Vin = ((10 /((255 - data_median + 1) * 2)) * (ad_data - data_median))。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70245ce26acea947146d29556fab06f5.png"></p><pre><code>    对于模块的输入信号不再说明，输出至外载板块的的时钟信号为 ad_clk，频率为 12.5MHz，使用系统时钟 4 分频得来，所以声明了分频计数器 cnt_sys_clk，初值为 0，在系 统时钟同步下，在 0、1 之间循环计数；声明时钟信号 clk_sample，在计数器 cnt_sys_clk 计数值为 1 时，对自身取反，就得到了时钟频率为 12.5MHz 的分频时钟信号 clk_sample，也 作为本模块工作时钟信号；因为外载板卡与本模块均使用时钟上升沿对数据采样，**为保证模块内工作时钟上升沿能够采集到板块传入的稳定数据，我们对 clk_sample 时钟信号取反 作为输入板卡的时钟信号 adc_clk，adc_clk 的上升沿刚好采集到数据的稳定状态** 。    声明中值使能信号 median_en，方便计算中值，当 median_en 信号为低电平时，进行中值的计算；当 median_en 信号为高电平时，对 ADC 测量值进行累加求平均的计算。 对中值的计算我们也使用累加求平均的方法，**在无测量电压输入电压表时，对前 1024 个数据进行累加求平均** ，所以声明计数器 cnt_median 对累加值个数进行计数，计算范围 0- 1023，只在 median_en 为低电平时进行计数，median_en 为高电平时，保持计数最大值；同时，计数最大值作为条件，拉高 median_en 使能信号。1024 个测量值总和保存在变量 data_sum_m 中，**当 cnt_median 计数到最大值，将平均值赋值给变量 data_median** 。    中值 data_median 确定后，开始测量电压的计算。 为保证运算后的电压值更准确，我们对计算出的分辨率进行放大。**当 ADC 芯片采集后的电压数值 ad_data 位于 0 - data_median 范围内，表示测量电压位于-5V ~ 0V 范围内， 声明分辨率为 data_n = (10 * 2^13 * 1000) / ((data_median + 1) * 2)；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，声明分辨率为 data_p = (10 * 2^13 * 1000) / ((255 - data_median + 1) * 2)。放大倍数为(2^13 * 1000) 倍** ，之所以使用这个放大倍数是为了方便电压值的计算与显示。（**小数除以大数精度损失，且无法恢复；左移变大，放大精度** ）    确定了分辨率之后，结合 ADC 芯片传入的测量值，我们开始计算实际电压值。声明实际电压值为 volt_reg，当 ADC 芯片采集后的电压数值 ad_data 位于 0 - data_median 范围内，表示测量电压位于-5V ~ 0V 范围内，volt_reg = (data_n *(data_median - ad_data)) &gt;&gt; 13；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压 位于 0V ~ 5V 范围内，**volt_reg = (data_p *(ad_data - data_median)) &gt;&gt; 13。使用 “&gt;&gt; 13”对 计算值进行右移 13 位，由于抵消分辨率放大的 2^13 倍，分辨率中放大的 1000 倍，可以通 过将数码管显示值小数点左移 3 位来抵消**；正负号通过 ad_data 与中值 data_median 的打消比较来确定，sign = (ad_data &lt; data_median) ? 1&#39;b1 : 1&#39;b0，sign 为高电平，代表测量结果为负向电压，反之为正向电压。</code></pre><h3 id="代码设计-2"><a href="#代码设计-2" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><h4 id="（1）ADC"><a href="#（1）ADC" class="headerlink" title="（1）ADC"></a>（1）ADC</h4><pre><code>module  adc(    input   wire            sys_clk         ,   //时钟    input   wire            sys_rst_n       ,   //复位信号，低电平有效    input   wire    [7:0]   ad_data         ,   //AD输入数据    output  wire            ad_clk          ,   //AD驱动时钟,最大支持20Mhz时钟    output  wire            sign            ,   //正负符号位    output  wire    [15:0]  volt                //数据转换后的电压值);//********************************************************************////******************Parameter And Internal Signal ********************////********************************************************************////parameter defineparameter   CNT_DATA_MAX = 11&#39;d1024;    //数据累加次数//wire  definewire    [27:0]  data_p      ;   //根据中值计算出的正向电压AD分辨率wire    [27:0]  data_n      ;   //根据中值计算出的负向电压AD分辨率//reg definereg             median_en   ;   //中值使能reg     [10:0]  cnt_median  ;   //中值数据累加计数器reg     [18:0]  data_sum_m  ;   //1024次中值数据累加总和reg     [7:0]   data_median ;   //中值数据reg     [1:0]   cnt_sys_clk ;   //时钟分频计数器reg             clk_sample  ;   //采样数据时钟reg     [27:0]  volt_reg    ;   //电压值寄存//********************************************************************////***************************** Main Code ****************************////********************************************************************////数据ad_data是在ad_sys_clk的上升沿更新//所以在ad_sys_clk的下降沿采集数据是数据稳定的时刻//FPGA内部一般使用上升沿锁存数据,所以时钟取反//这样ad_sys_clk的下降沿相当于sample_sys_clk的上升沿assign  ad_clk = ~clk_sample;//sign:正负符号位assign  sign = (ad_data &lt; data_median) ? 1&#39;b1 : 1&#39;b0;//时钟分频(4分频,时钟频率为12.5Mhz),产生采样AD数据时钟always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        begin            cnt_sys_clk &lt;=  2&#39;d0;            clk_sample  &lt;=  1&#39;b0;        end        else        begin            cnt_sys_clk &lt;=  cnt_sys_clk + 2&#39;d1;        if(cnt_sys_clk == 2&#39;d1)            begin            cnt_sys_clk &lt;=  2&#39;d0;            clk_sample  &lt;=  ~clk_sample;            end        end//中值使能信号always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        median_en   &lt;=  1&#39;b0;    else    if(cnt_median == CNT_DATA_MAX)        median_en   &lt;=  1&#39;b1;    else        median_en   &lt;=  median_en;//cnt_median:中值数据累加计数器always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_median    &lt;=  11&#39;d0;    else    if(median_en == 1&#39;b0)        cnt_median    &lt;=  cnt_median + 1&#39;b1;//data_sum_m:1024次中值数据累加总和always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_sum_m  &lt;=  19&#39;d0;    else    if(cnt_median == CNT_DATA_MAX)        data_sum_m    &lt;=  19&#39;d0;    else        data_sum_m    &lt;=  data_sum_m + ad_data;//data_median:中值数据always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_median    &lt;=  8&#39;d0;    else    if(cnt_median == CNT_DATA_MAX)        data_median    &lt;=  data_sum_m / CNT_DATA_MAX;    else        data_median    &lt;=  data_median;//data_p:根据中值计算出的正向电压AD分辨率(放大2^13*1000倍)//data_n:根据中值计算出的负向电压AD分辨率(放大2^13*1000倍)assign  data_p = (median_en == 1&#39;b1) ? 8192_0000 / ((255 - data_median) * 2) : 0;assign  data_n = (median_en == 1&#39;b1) ? 8192_0000 / ((data_median + 1) * 2) : 0;//volt_reg:处理后的稳定数据always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        volt_reg    &lt;= &#39;d0;    else    if(median_en == 1&#39;b1)        if((ad_data &gt; (data_median - 3))&amp;&amp;(ad_data &lt; (data_median + 3)))            volt_reg    &lt;= &#39;d0;        else    if(ad_data &lt; data_median)            volt_reg &lt;= (data_n *(data_median - ad_data)) &gt;&gt; 13;        else    if(ad_data &gt; data_median)            volt_reg &lt;= (data_p *(ad_data - data_median)) &gt;&gt; 13;    else        volt_reg    &lt;= &#39;d0;//volt:数据转换后的电压值assign  volt    =   volt_reg;endmodule</code></pre><p>可以看到 volt_reg 数值在 da_data 接近 0 （ data_median ）时直接赋值 0<br>；同时注意到系统只能通过复位进行重新测量，median_en并没有自动拉低</p><h4 id="（2）顶层"><a href="#（2）顶层" class="headerlink" title="（2）顶层"></a>（2）顶层</h4><pre><code>module  dig_volt(    input   wire            sys_clk     ,   //系统时钟,50MHz    input   wire            sys_rst_n   ,   //复位信号，低有效    input   wire    [7:0]   ad_data     ,   //AD输入数据    output  wire            ad_clk      ,   //AD驱动时钟,最大支持20Mhz时钟    output  wire    [5:0]   sel         ,   //串行数据输入    output  wire    [7:0]   seg             //使能信号);//********************************************************************////*********************** Internal Signal ****************************////********************************************************************////wire  definewire    [15:0]  volt    ;   //数据转换后的电压值wire            sign    ;   //正负符号位//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------- adc_inst -------------adc     adc_inst(    .sys_clk    (sys_clk    ),  //时钟    .sys_rst_n  (sys_rst_n  ),  //复位信号，低电平有效    .ad_data    (ad_data    ),  //AD输入数据    .ad_clk     (ad_clk     ),  //AD驱动时钟,最大支持20Mhz时钟    .sign       (sign       ),  //正负符号位    .volt       (volt       )   //数据转换后的电压值);//------------- seg_dynamic_inst --------------seg_dynamic     seg_dynamic_inst(    .sys_clk    (sys_clk    ),  //系统时钟，频率50MHz    .sys_rst_n  (sys_rst_n  ),  //复位信号，低有效    .data       (&#123;4&#39;b0,volt&#125;),  //数码管要显示的值    .point      (6&#39;b001000  ),  //小数点显示,高电平有效    .seg_en     (1&#39;b1       ),  //数码管使能信号，高电平有效    .sign       (sign       ),  //符号位，高电平显示负号    .sel        (sel        ),  //串行数据输入    .seg        (seg        )   //输出使能信号);endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/21ad66777b680d8d5fb99e1369c3fbe1.png"></p><h3 id="仿真-1"><a href="#仿真-1" class="headerlink" title="&lt;3&gt;仿真"></a>&lt;3&gt;仿真</h3><pre><code>module  tb_dig_volt();//wire  definewire            ad_clk  ;wire      [5:0]      sel    ;wire      [7:0]      seg    ;//reg   definereg             sys_clk     ;reg             clk_sample  ;reg             sys_rst_n   ;reg             data_en     ;reg     [7:0]   ad_data_reg ;reg     [7:0]   ad_data     ;//sys_rst_n,sys_clk,ad_datainitial    begin        sys_clk     =   1&#39;b1;        clk_sample  =   1&#39;b1;        sys_rst_n   =   1&#39;b0;        #200;        sys_rst_n   =   1&#39;b1;        data_en     =   1&#39;b0;        #499990;        data_en     =   1&#39;b1;     endalways #10 sys_clk = ~sys_clk;always #40 clk_sample = ~clk_sample;always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        ad_data_reg &lt;=  8&#39;d0;    else    if(data_en == 1&#39;b1)        ad_data_reg &lt;=  ad_data_reg + 1&#39;b1;    else        ad_data_reg &lt;=  8&#39;d0;always@(posedge clk_sample or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        ad_data &lt;=  8&#39;d0;    else    if(data_en == 1&#39;b0)        ad_data &lt;=  8&#39;d125;    else    if(data_en == 1&#39;b1)        ad_data &lt;=  ad_data_reg;    else        ad_data &lt;=  ad_data;//------------- dig_volt_inst -------------dig_volt    dig_volt_inst(    .sys_clk     (sys_clk   ),    .sys_rst_n   (sys_rst_n ),    .ad_data     (ad_data   ),    .ad_clk      (ad_clk    ),    .sel        (sel      ),    .seg        (seg      ));endmodule</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132993678">https://blog.csdn.net/qq_32971095/article/details/132993678</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础设计三（RS232、I2C）——FPGA学习笔记＜4＞</title>
      <link href="/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%89%EF%BC%88RS232%E3%80%81I2C%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C4%EF%BC%9E/"/>
      <url>/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%89%EF%BC%88RS232%E3%80%81I2C%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C4%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E4%B8%B2%E5%8F%A3%20RS232">一.串口 RS232</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%3C2%3E%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B">&lt;2&gt;物理模型</a></p><p><a href="about:blank#%3C3%3ERS232%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">&lt;3&gt;RS232通信协议</a></p><p><a href="about:blank#%3C4%3E%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">&lt;4&gt;设计实践</a></p><p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">1.硬件资源</a></p><p><a href="about:blank#2.%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">2.程序设计</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89uart_rx%E8%AE%BE%E8%AE%A1">（1）uart_rx设计</a></p><p><a href="about:blank#%E2%91%A0%E6%B3%A2%E5%BD%A2%E5%9B%BE%E5%88%86%E6%9E%90">①波形图分析</a></p><p><a href="about:blank#%E2%91%A1%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">②代码设计</a></p><p><a href="about:blank#%E2%91%A2%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">③仿真设计</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89uart_tx%E8%AE%BE%E8%AE%A1">（2）uart_tx设计</a></p><p><a href="about:blank#%E2%91%A0%E6%B3%A2%E5%BD%A2%E5%9B%BE%E5%88%86%E6%9E%90">①波形图分析</a></p><p><a href="about:blank#%E2%91%A1%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">②代码设计</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1">（3）顶层设计</a></p><p><a href="about:blank#%E2%91%A0%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">①代码设计</a></p><p><a href="about:blank#%E2%91%A1%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">②仿真设计</a></p><p><a href="about:blank#3.%E6%80%BB%E7%BB%93">3.总结</a></p><p><a href="about:blank#%E4%BA%8C.%E5%9F%BA%E4%BA%8E%20I2C%20%E5%8D%8F%E8%AE%AE%E7%9A%84%20EEPROM%20%E9%A9%B1%E5%8A%A8%E6%8E%A7%E5%88%B6">二.基于 I2C 协议的 EEPROM<br>驱动控制</a></p><p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p><p><a href="about:blank#%3C2%3E%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C">&lt;2&gt;读写操作</a></p><p><a href="about:blank#%3C3%3E%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">&lt;3&gt;设计实践</a></p><p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p><p><a href="about:blank#%EF%BC%882%EF%BC%89I2C%20%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97">（2）I2C<br>驱动模块</a></p><p><a href="about:blank#%E3%80%901%E3%80%91%E5%8D%95%E5%AD%97%E8%8A%82%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">【1】单字节写操作时序分析</a></p><p><a href="about:blank#%E3%80%902%E3%80%91%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">【2】随机读操作时序分析</a></p><p><a href="about:blank#%E3%80%903%E3%80%91%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">【3】代码设计</a></p><p><a href="about:blank#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%A8%A1%E5%9D%97">（3）数据收发模块</a></p><p><a href="about:blank#%E3%80%901%E3%80%91%E5%86%99%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86">【1】写数据操作部分</a></p><p><a href="about:blank#%E3%80%902%E3%80%91%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86">【2】读数据操作部分</a></p><p><a href="about:blank#%E3%80%903%E3%80%91%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">【3】代码设计</a></p><p><a href="about:blank#%EF%BC%884%EF%BC%89%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">（4）仿真设计</a></p><hr><p>前置学习：</p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132779996" title="基础设计二——FPGA学习笔记＜3＞">基础设计二——FPGA学习笔记＜3＞</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p><p>参考书目：《野火FPGA Verilog 开发实战指南》</p><h2 id="一-串口-RS232"><a href="#一-串口-RS232" class="headerlink" title="一.串口 RS232"></a>一.串口 RS232</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    **通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），通常称作 UART** 。UART 是一种**通用的数据通信协议** ，也是**异步串行通信口（串口）的总称** ，它在**发送数据时将并行数据转换成串行数据来传输** ，在**接收数据时将接收到的串行数据转换成并行数据** 。它包括了 RS232、RS499、RS423、RS422 和 RS485 等接口标准规范和总线标准规范。三大低速总线（UART、SPI、IIC）    UART 和 SPI、IIC 不同的是，它是**异步通信接口** ，异步通信中的接收方并不知道数据什么时候会到达，所以双方收发端都要有各自的时钟，在数据传输过程中是不需要时钟的，发送方发送的时间间隔可以不均匀，接受方是在数据的**起始位和停止位** 的帮助下实现信息同步的。而**SPI、IIC 是同步通信接口** （后面的章节会做详细介绍），同步通信中双方使用频率一致的时钟，在数据传输过程中时钟伴随着数据一起传输，发送方和接收方使用的时钟都是由主机提供的。     UART 通信只有两根信号线，一根是发送数据端口线叫 tx（Transmitter），一根是接收数据端口线叫 rx（Receiver），如图 26-1 所示，对于 PC 来说它的 tx 要和对于 FPGA 来 说的 rx 连接，同样 PC 的 rx 要和 FPGA 的 tx 连接，如果是两个 tx 或者两个 rx 连接那数据 就不能正常被发送出去和接收到，所以不要弄混，记住 rx 和 tx 都是相对自身主体来讲的。 UART 可以实现全双工，即可以同时进行发送数据和接收数据。        </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41ba38e183929d6376ec40adbf1f8724.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad1a4ba482564893ff8359fd376ba7fc.png"></p><pre><code>    设计 FPGA 部分接收串口数据和发送串口数据的模块，最后把两个模块拼接起来，最后通过 loopback 测试（回环测试）来验证设计模块的正确性。所谓**loopback 测试** 就是发送端发送什么数据，接收端就接收什么数据。</code></pre><p>串口 RS232 缺点：距离不远，传输速率相对较慢</p><p>串口 RS232优点：</p><p>1、很多传感器芯片或 CPU 都带有串口功能，目的是在使用一些传感器或 CPU 时可以通过串口进行调试，十分方便；</p><p>2、在较为复杂的<strong>高速数据接口和数据链路集合的系统</strong> 中往往<strong>联合调试比较困难</strong><br>，可以<strong>先使用串口将数据链路部分验证后，再把串口换成高速数据接口</strong><br>。如在做以太网相关的项目时，可以在调试时先使用串口把整个数据链路调通，然后再把串口换成以太网的接口；</p><p>3、串口的数据线一共就两根，也没有时钟线，节省了大量的管脚资源。</p><h3 id="物理模型"><a href="#物理模型" class="headerlink" title="&lt;2&gt;物理模型"></a>&lt;2&gt;物理模型</h3><p>设备被分为<strong>数据终端设备 DTE</strong>(计算机、路由)和 <strong>数据通讯设备 DCE</strong>(调制调解器)。我们以这种通讯模型讲解它们的信号线连接方式及各个<br>信号线的作用。</p><p>旧式台式计算机 RS-232 标准 COM 口(也称 DB9 接口)：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efd543a7b07dc4ab460314ea28977952.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0b0c8afd598edcb653a10bd0c1f5ab4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/88c30e0af5325c41a66213c7d463ec71.png"></p><p>串口线中的 RTS、CTS、DSR、DTR 及 DCD 信号，使用逻辑 1 表示信号有效，逻辑 0 表示信号无效。例如，当计算机端控制 DTR<br>信号线表示为逻辑 1 时，它是为了告知远端的调制调解器，本机已准备好接收数据， 0 则表示还没准备就绪。</p><h3 id="RS232通信协议"><a href="#RS232通信协议" class="headerlink" title="&lt;3&gt;RS232通信协议"></a>&lt;3&gt;RS232通信协议</h3><p>1、RS232 是 UART 的一种，没有时钟线，只有两根数据线，分别是 rx 和 tx，这两根线都是<strong>1bit 位宽</strong> 的。其中 rx<br>是接收数据的线，tx 是发送数据的线。</p><p>2、rx 位宽为 1bit，PC 机通过串口调试助手往 FPGA 发 8bit 数据时，FPGA 通过串口线 rx<br>一位一位地接收，<strong>从最低位到最高位依次接收</strong> ，最后在 FPGA 里面位拼接成 8 比特数据。</p><p>3、tx 位宽为 1bit，FPGA 通过串口往 PC 机发 8bit 数据时，FPGA 把 8bit 数据通过 tx 线一位一位的传给 PC<br>机，从最低位到最高位依次发送，最后上位机通过串口助手按照 RS232 协议把这一位一位的数据位拼接成 8bit 数据。</p><p>4、串口数据的发送与接收是基于帧结构的，即一帧一帧的发送与接收数据。<strong>每一帧除 了中间包含 8bit<br>有效数据外，还在每一帧的开头都必须有一个起始位，且固定为 0</strong> ；<strong>在每 一帧的结束时也必须有一个停止位，且固定为 1</strong><br>，<strong>即最基本的帧结构（不包括校验等）有 10bit</strong> 。在不发送或者不接收数据的情况下，r<strong>x 和 tx 处于空闲状态，此时 rx 和 tx 线都保持<br>高电平</strong> ，如果有数据帧传输时，首先会有一个起始位，然后是 8bit 的数据位，接着有 1bit 的停止位，然后 rx 和 tx<br>继续进入空闲状态，然后等待下一次的数据传输。如图为一个最基本的 RS232 帧结构。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b8c4ca545f52dddf282fb029181733a.png"></p><p>5、波特率：在信息传输通道中，携带数据信息的信号单元叫码元（因为串口是 1bit 进<br>行传输的，所以其码元就是代表一个二进制数），每秒钟通过信号传输的码元数称为码元的传输速率，简称波特率，常用符号“Baud”表示，其单位为“波特每秒（Bps）”。串口常见的波特率有<br>4800、9600、115200 等，我们选用 9600 的波特率进行串口章节的讲解。</p><p>6、比特率：每秒钟通信信道传输的信息量称为位传输速率，简称比特率，其单位为 “每秒比特数（bps）”。比特率可由波特率计算得出，公式为：比特率&#x3D;波特率 *<br><strong>单个调制状态对应的二进制位数</strong> 。如果使用的是 9600 的波特率，其串口的比特率为：9600Bps * <strong>1bit</strong> &#x3D; 9600bps。</p><p>7、由计算得串口发送或者接收 1bit 数据的时间为一个波特，即 1&#x2F;9600 秒，如果用 50MHz（周期为<br>20ns）的系统时钟来计数，需要计数的个数为<strong>cnt &#x3D; (1s * 10^9)ns &#x2F; 9600bit)ns &#x2F; 20ns ≈ 5208<br>个系统时钟周期</strong> ，即每个 bit 数据之间的间隔要在 50MHz 的时钟频率下计数 <strong>5208 次</strong> 。</p><p>8、上位机通过串口发 8bit 数据时，会自动在发 8 位有效数据前发一个波特时间的起始位，也会自动在发完 8<br>位有效数据后发一个停止位。同理，串口助手接收上位机发送的数据前，必须检测到一个波特时间的起始位才能开始接收数据，接收完 8bit<br>的数据后，再接收一个波特时间的停止位。</p><h3 id="设计实践"><a href="#设计实践" class="headerlink" title="&lt;4&gt;设计实践"></a>&lt;4&gt;设计实践</h3><h4 id="1-硬件资源"><a href="#1-硬件资源" class="headerlink" title="1.硬件资源"></a>1.硬件资源</h4><p>Artix-7开发板上使用CH340芯片将Rx、Tx信号线转成USB，硬件电路图见参考图书。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/01160649df593bdc68380afe16a251a7.png"></p><p>在使用时需将 J9 口的 1、2 脚以及 3、4 脚用跳帽连接起来才能正常使 用。</p><h4 id="2-程序设计"><a href="#2-程序设计" class="headerlink" title="2.程序设计"></a>2.程序设计</h4><p>整体框图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ee97485a24245074b314660c134dafd.png"></p><h5 id="（1）uart-rx设计"><a href="#（1）uart-rx设计" class="headerlink" title="（1）uart_rx设计"></a>（1）uart_rx设计</h5><pre><code>    uart_rx按照规定波特率将接受到的1bit串行数据转成8bit并行数据po_data，并有效并行数据有效的标志信号 po_data_flag</code></pre><h6 id="①波形图分析"><a href="#①波形图分析" class="headerlink" title="①波形图分析"></a>①波形图分析</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe6084b0edb9a5f4cd334a61d80e651c.png"></p><p><strong>波形设计思路详细解析：</strong></p><p><strong>第一部分</strong> ：</p><p>首先画出三个输入信号，时钟和复位，另一个是串行输入数据 rx， rx 串行数据一开始经过了 <strong>两级寄存器</strong> 。</p><p>理论上我们应该按照串口接收数据的时序要求找到 rx 的下降沿，然后开始接收起始位的数据，但为什么先将数据打了两拍呢？那就要先从跨时钟域会导致“<strong>亚稳态</strong><br>” 的问题上说起。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/facb669a93fa73b488a4709d2cadce6f.png"></p><pre><code>    把一个矩形脉冲的上升沿或下降沿放大后会发现其上升沿和下降沿并不是瞬间被拉高或拉低的，而是有一个**倾斜变化的过程** ，这在 运放中被称为“**压摆率** ”。    如果 FPGA 的系统时钟刚好采集到 rx 信号上升沿或下降沿的中间位置附近（按照概率来讲，如果数据传输量足够大或传输速度足够快时一定会产生这种情况），即 FPGA 在接收 rx 数据时不满足**内部寄存器的建立时间 Tsu（指触发器的时钟信号上升沿到来以前，数据稳定不变的最小时间）和保持时间 Th（指触发器的时钟信号上升沿到来以后，数据稳定不变的最小时间）** ，此时 FPGA 的**第一级寄存器的输出端在时钟沿到来之后比较长的一段时间内都处于不确定的状态** ，在 0 和 1 之间处于**振荡状态** ，而不是 等于串口输入的确定的 rx 值。    如图为产生亚稳态的波形示意图，rx 信号经过 FPGA 中的第一级寄存器后输出的 rx_reg1 信号在时钟上升沿 Tco 时间后会有**Tmet（决断时间）的振荡时段** ，当第一 个寄存器发生亚稳态后，经过 Tmet 的振荡稳定后，第二级寄存器就能采集到一个相对稳定的值。但由于** _振荡时间 Tmet 是受到很多因素影响的，所以 Tmet 时间有长有短_** 。如图所示，当 **Tmet1 时间长到大于一个采样周期后，那第二级寄存器就会采集到亚稳态** ，但是从第二级寄存器输出的信号就是相对稳定的了。当然会人会问到第二级寄存器的 Tmet2 的持续时间会不会继续延长到大于一个采样周期？这种情况虽然会存在，但是其概率是极小的，寄存器本身就有减小 Tmet 时间让数据快速稳定的作用。 由于在 PC 机中**波特率和 rx 信号是同步的，而 rx 信号和 FPGA 的系统时钟 sys_clk 是异步** 的关系，我们此时要做的是**将慢速时钟域（PC 机中的波特率）系统中的 rx 信号同步到快速时钟域（FPGA 中的 sys_clk）系统** 中，所使用的方法叫电平同步，俗称**“打两拍法”** 。所以 rx 信号进入 FPGA 后会首先经过一级寄存器，出现如图 26-13 所示的亚稳态现 象，导致 rx_reg1 信号的状态不确定是 0 还是 1，就会受其影响使其他相关信号做出不同的判断，有的判断到“0”有的判断到“1”，有的也进入了亚稳态并产生连锁反应，导致后 级相关逻辑电路混乱。为了避免这种情况，rx 信号进来后首先进行打一拍的处理，打一拍后产生 rx_reg1 信号。但 rx_reg1 可能还存在低概率的亚稳态现象，为了进一步降低出现亚稳态的概率，我们将从 rx_reg1 信号再打一拍后产生 rx_reg2 信号，使之能够较大概率保证 rx_reg2 信号是 0 或者 1 中的一种确定情况，这样 rx_reg2 所影响的后级电路就都是相对稳定的了。但一定要注意：**打两拍后虽然能让信号稳定到 0 或者 1 中确定的值，但究竟是 0 还是 1 却是随机的，与打拍之前输入信号的值没有必然的关系** 。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d8f07d8ac3ff30bf88e42bedf2ad6151.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/89cd57b8bd71f41c5fe4616c0cb4bc03.png"></p><p>注：单比特信号从慢速时钟域同步到快速时钟域需要使用打两拍的方式消除亚稳态。<strong>第一级寄存器产生亚稳态并经过自身后可以稳定输出的概率为<br>70%~80%左右，第二级寄存器可以稳定输出的概率为 99%左右</strong> ，<strong>后面再多加寄存器的级数改善效果就不明显了</strong> ，所以<br>数据进来后一般选择打两拍即可。 另外<strong>单比特信号从<br>快速时钟域同步到慢速时钟域还仅仅使用打两拍的方式会漏采数据，所以往往使用脉冲同步法或的握手信号法</strong>；而<strong>多比特信号跨时钟域需要进行格雷码编码</strong><br>（<strong>多比特顺序数</strong> 才可以）后才能进行打两拍的处理，或者通过使用 FIFO、RAM 来处理数据与时钟同步的问题。 亚稳态振荡时间 Tmet<br>关系到后级寄存器的采集稳定问题，Tmet<br>影响因素包括：器件的生产工艺、温度、环境以及寄存器采集到亚稳态里稳定态的时刻等。甚至某些特定条件，如干扰、辐射等都会造成 Tmet 增长。</p><p><strong>第二部分：</strong></p><pre><code>  打两拍后的 rx_reg2 信号就是我们可以在后级逻辑电路中使用的相对稳定的信号，只 比 rx 信号延后两。下一步我们就可以根据串口接收数据的时序要求找到串口帧起始开始的标志——下降沿，然后按顺序接收数据。由第一部分的分析得 rx_reg1 信号可能是不稳定的， 而 rx_reg2 信号是相对稳定的，所以不能直接用 rx_reg1 信号和 rx_reg2 信号来产生下降沿标志信号，因为 **rx_reg1 信号的不稳定性可能会导致由它产生的下降沿标志信号也不稳定** 。所以如图所示，我们将 rx_reg2 信号再打一拍，得到 rx_reg3 信号，用 rx_reg2 信 号和 rx_reg3 信号产生 staet_nedge 作为下降沿标志信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e38f5d9d318853e610d55253e535ed8d.png"></p><p><strong>第三部分：</strong></p><pre><code>    我们检测到了第一个下降沿，后面的信号将以下降沿标志信号 start_nedge 为条件开始接收一帧 10bit 的数据。但新的问题又出现了，我们的 rx 信号本身就是 1bit 的，如 果在判断第一个下降沿后，后面帧中的数据还可能会有下降沿出现，那我们会又产生一个start_nedge 标志信号。我们知道在 Verilog 代码中**标志信号（flag）和使能信号（en）** 都是非常有用的，标志信号只有一拍，非常适合我们产生像下降沿标志这种信号，而使能信号就特别适合在此处使用，即**对一段时间区域进行控制锁定** 。如图所示，当下降沿标志信号 start_nedge 为高电平时拉高工作使能信号 work_en（什么时候拉低在后面讲解），在 work_en 信号为高的时间区域内虽然也会有下降沿 start_nedge 标志信号产生，但是我们可 以根据 work_en 信号就可以判断出此时出现的 start_nedge 标志信号并不是我们想要的串口帧起始下降沿，从而将其过滤除掉。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1bb92fefa5e8f242a1c746b4cd59c1d.png"></p><pre><code>    开始接收一帧数据。我们使用的是 9600bps 的波特率 和 PC 机进行串口通信，PC 机的串口调试助手要将发送数据波特率调整为 9600bps。而 FPGA 内部使用的系统时钟是 50MHz，前面也进行过计算，得出 1bit 需要的时间约为 5208 个（因为一帧只有 10bit，**细微的近似计数差别不会产生数据错误** ，但是如果计数值差的过大，则会产生接收数据的错误）系统时钟周期，那么我们就需要产生一个能计 5208 个数的计数器来依次接收 10 个比特的数据，计数器每计 5208 个数就接收一个新比特的数据。如 图 26-17 所示，计数器名为 baud_cnt，当 **work_en 信号为高电平的时候就让计数器计数** ， **当计数器计 5208 个数（从 0 到 5207）或 work_en 信号为低电平时计数器清零。**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae18e4581af78dc5e42749840658916c.png"></p><p><strong>第四部分：</strong></p><pre><code>    现在我们可以根据波特率计数器一个一个接收数据了，我们发现 baud_cnt 计数 器在计数值为 0 到 5207 期间都是数据有效的时刻，那我们该什么时候取数据呢？理论上讲，在数据变化的地方取数是不稳定的，所以我们**选择当 baud_cnt 计数器计数到 2603，即中间位置时取数最稳定** （其实只要 baud_cnt 计数器在计数值不是在 0 和 5207 这两个最不稳定的时刻取数都可以，**更为准确的是多次取值取概率最大的情况** ）。所以如图所示，在 baud_cnt 计数器**计数到中点时产生一个时钟周期的 bit_flag 的取数标志信号** ，用于 指示该时刻的数据可以被取走。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6933ce910fc5d709216700158924677.png"></p><pre><code>    也就是说我们需要准确的知道此时此刻接收的是第几比特，当接收够 10bit 数据后，我们就停止继续接收数据，等 rx 信号被拉高待恢复到空闲状态后再等待接收下一帧的数据。所以我们还需要 产生一个用于计数该时刻接收的数据是第几个比特的 **bit_cnt 计数器** 。如图所示，刚好可以利用我们已经产生的 bit_flag 取数标志信号，对该信号进行计数既可以知道此时我们接收的数据是第几个比特了。这里我们只让 bit_cnt 计数器的计数值为 8 时再清零，虽然 bit_cnt 计数器的计数值从 0 计数到 8 只有 9 个 bit，但这 9 个 bit 中已经包含的我们所需要 的 8bit 有用的数据，最后的 1bit 停止位没有用，可以不用再进行计数了，但如果非要将 bit_cnt 计数器的计数值计数到 9 后再清零也是可以的。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/01fac4f9c508d4dd87006a8b89346c90.png"></p><p><strong>第五部分：</strong></p><pre><code>    我们接收到的 rx 信号是串行的，后面的系统要使用的是完整的 8bit 并行数据。 也就是说我们还需要将 1bit 串行数据转换为 8bit 并行数据的串并转换的工作，这也是我们在接口设计中常遇到的一种操作。**串并转换就需要做移位** ，我们要考虑清楚什么时候开始移位，不能提前也不能推后，否则会将无用的数据也移位进来，所以我们需要卡准时间。 如图所示 PC 机的串口调试助手发送的数据是先发送的低位后发送的高位，所以我们接收的 rx 信号也是先接收的低位后接收的高位，我们采用边接收边移位的操作。移位操作的方法我们已经在前面的流水灯章节中讲过，这里不再重复。接下来我们需要确定移位开始和结束的时间。如图所示，当 bit_cnt 计数器的计数值为 1 时说明第一个有用数据已经接收到了，刚好剔除了起始位，就可以进行移位了。注意移位的条件， _**要在 bit_cnt 计 数器的计数值为 1 到 8 区间内且 bit_flag 取数标志信号同时为高时才能移位**_ ，也就是移动 7 次即可，接收最后 1bit 有用数据时就不需要再进行移位了。当移位 7 次后 1bit 的串行数据 已经变为 8bit 的并行数据了，此时产生一个移位完成标志信号 rx_flag。</code></pre><p><strong>第六部分：</strong></p><pre><code>    最后一 点，rx_data 信号是参与移位的数据，在移位的过程中数据是变动的，不可以被后级模块所使用，而可以肯定的是**在移位完成标志信号 rx_flag 为高时，rx_data 信号一定是移位完成的 稳定的 8bit 有用数据** 。如图所示，此时我们当移位完成标志信号 **rx_flag 为高时让 rx_data 信号赋值给专门用于输出 稳定 8bit 有用数据的 po_data 信号**就可以了，但 **rx_flag 信号又不能作为 po_data 信号有效的标志信号，所以需要将 rx_flag 信号 再打一拍**。最后输出的有用 8bit 数据为 po_data 信号和伴随 po_data 信号有效的标志信号 po_flag 信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6128969d4060f737d0dd13fb53fcc866.png"></p><pre><code>    到此为止我们 uart_rx 模块的波形就全部设计好了，此时再看时序图就能理解各个设计。为了获得数据到来标志start_nedge设置了三级寄存器；work_en确定了接收状态，对start_nedge进行管控，不再变化，并开启计数器baud_cnt ；在计数中央采集数据并记录数据个数bit_cnt ；结束置标志位rx_flag，但为稳定，滞后一拍得最终结果和标志位</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe6084b0edb9a5f4cd334a61d80e651c.png"></p><h6 id="②代码设计"><a href="#②代码设计" class="headerlink" title="②代码设计"></a>②代码设计</h6><pre><code>module  uart_rx#(    parameter   UART_BPS    =   &#39;d9600,         //串口波特率    parameter   CLK_FREQ    =   &#39;d50_000_000    //时钟频率)(    input   wire            sys_clk     ,   //系统时钟50MHz    input   wire            sys_rst_n   ,   //全局复位    input   wire            rx          ,   //串口接收数据    output  reg     [7:0]   po_data     ,   //串转并后的8bit数据    output  reg             po_flag         //串转并后的数据有效标志信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////localparam    definelocalparam  BAUD_CNT_MAX    =   CLK_FREQ/UART_BPS   ;//reg   definereg         rx_reg1     ;reg         rx_reg2     ;reg         rx_reg3     ;reg         start_nedge ;reg         work_en     ;reg [12:0]  baud_cnt    ;reg         bit_flag    ;reg [3:0]   bit_cnt     ;reg [7:0]   rx_data     ;reg         rx_flag     ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////插入两级寄存器进行数据同步，用来消除亚稳态//rx_reg1:第一级寄存器，寄存器空闲状态复位为1always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rx_reg1 &lt;= 1&#39;b1;    else        rx_reg1 &lt;= rx;//rx_reg2:第二级寄存器，寄存器空闲状态复位为1always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rx_reg2 &lt;= 1&#39;b1;    else        rx_reg2 &lt;= rx_reg1;//rx_reg3:第三级寄存器和第二级寄存器共同构成下降沿检测always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rx_reg3 &lt;= 1&#39;b1;    else        rx_reg3 &lt;= rx_reg2;//start_nedge:检测到下降沿时start_nedge产生一个时钟的高电平always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        start_nedge &lt;= 1&#39;b0;    else    if((~rx_reg2) &amp;&amp; (rx_reg3))        start_nedge &lt;= 1&#39;b1;    else        start_nedge &lt;= 1&#39;b0;//work_en:接收数据工作使能信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        work_en &lt;= 1&#39;b0;    else    if(start_nedge == 1&#39;b1)        work_en &lt;= 1&#39;b1;    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))        work_en &lt;= 1&#39;b0;//baud_cnt:波特率计数器计数，从0计数到BAUD_CNT_MAX - 1always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        baud_cnt &lt;= 13&#39;b0;    else    if((baud_cnt == BAUD_CNT_MAX - 1) || (work_en == 1&#39;b0))        baud_cnt &lt;= 13&#39;b0;    else    if(work_en == 1&#39;b1)        baud_cnt &lt;= baud_cnt + 1&#39;b1;//bit_flag:当baud_cnt计数器计数到中间数时采样的数据最稳定，//此时拉高一个标志信号表示数据可以被取走always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        bit_flag &lt;= 1&#39;b0;    else    if(baud_cnt == BAUD_CNT_MAX/2 - 1)        bit_flag &lt;= 1&#39;b1;    else        bit_flag &lt;= 1&#39;b0;//bit_cnt:有效数据个数计数器，当8个有效数据（不含起始位和停止位）//都接收完成后计数器清零always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        bit_cnt &lt;= 4&#39;b0;    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))        bit_cnt &lt;= 4&#39;b0;     else    if(bit_flag ==1&#39;b1)         bit_cnt &lt;= bit_cnt + 1&#39;b1;//rx_data:输入数据进行移位always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rx_data &lt;= 8&#39;b0;    else    if((bit_cnt &gt;= 4&#39;d1)&amp;&amp;(bit_cnt &lt;= 4&#39;d8)&amp;&amp;(bit_flag == 1&#39;b1))        rx_data &lt;= &#123;rx_reg3, rx_data[7:1]&#125;;//rx_flag:输入数据移位完成时rx_flag拉高一个时钟的高电平always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rx_flag &lt;= 1&#39;b0;    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))        rx_flag &lt;= 1&#39;b1;    else        rx_flag &lt;= 1&#39;b0;//po_data:输出完整的8位有效数据always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        po_data &lt;= 8&#39;b0;    else    if(rx_flag == 1&#39;b1)        po_data &lt;= rx_data;//po_flag:输出数据有效标志（比rx_flag延后一个时钟周期，为了和po_data同步）always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        po_flag &lt;= 1&#39;b0;    else        po_flag &lt;= rx_flag;endmodule    可以看到，在2-5行声明参数方便修改；7-13行声明输入输出接口；20行定义局部变量；23-32行声明内部寄存器；40-58行rx数据经过三级寄存器赋值；start_nedge是判断(~rx_reg2) &amp;&amp; (rx_reg3)进行赋值，对应波形图上的关系；在112行进行了移位赋值，rx_data &lt;= &#123;rx_reg3, rx_data[7:1]&#125;，使得低位在右；后面要注意start_nedge和work_en的关系，后面一大部分实际上是以baud_cnt为基石，所以在baud_cnt的赋值中引入work_en的限制即可（另一种不同思路是start_nedge的赋值引入work_en作为判断【&amp;&amp;~work_en】，然后baud_cnt引入start_nedge）。</code></pre><h6 id="③仿真设计"><a href="#③仿真设计" class="headerlink" title="③仿真设计"></a>③仿真设计</h6><pre><code>module  tb_uart_rx();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg             sys_clk;reg             sys_rst_n;reg             rx;//wire  definewire    [7:0]   po_data;wire            po_flag;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位和输入信号initial begin        sys_clk    = 1&#39;b1;        sys_rst_n &lt;= 1&#39;b0;        rx        &lt;= 1&#39;b1;        #20;        sys_rst_n &lt;= 1&#39;b1;end//模拟发送8次数据，分别为0~7initial begin        #200        rx_bit(8&#39;d0);  //任务的调用，任务名+括号中要传递进任务的参数        rx_bit(8&#39;d1);        rx_bit(8&#39;d2);        rx_bit(8&#39;d3);        rx_bit(8&#39;d4);        rx_bit(8&#39;d5);        rx_bit(8&#39;d6);        rx_bit(8&#39;d7);end//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号always #10 sys_clk = ~sys_clk;//定义一个名为rx_bit的任务，每次发送的数据有10位//data的值分别为0~7由j的值传递进来//任务以task开头，后面紧跟着的是任务名，调用时使用task rx_bit(    //传递到任务中的参数，调用任务的时候从外部传进来一个8位的值        input   [7:0]   data);        integer i;      //定义一个常量//用for循环产生一帧数据，for括号中最后执行的内容只能写i=i+1//不可以写成C语言i=i++的形式        for(i=0; i&lt;10; i=i+1) begin            case(i)                0: rx &lt;= 1&#39;b0;                1: rx &lt;= data[0];                2: rx &lt;= data[1];                3: rx &lt;= data[2];                4: rx &lt;= data[3];                5: rx &lt;= data[4];                6: rx &lt;= data[5];                7: rx &lt;= data[6];                8: rx &lt;= data[7];                9: rx &lt;= 1&#39;b1;            endcase            #(5208*20); //每发送1位数据延时5208个时钟周期        endendtask         //任务以endtask结束//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------uart_rx_inst------------------------uart_rx uart_rx_inst(        .sys_clk    (sys_clk    ),  //input           sys_clk        .sys_rst_n  (sys_rst_n  ),  //input           sys_rst_n        .rx         (rx         ),  //input           rx                        .po_data    (po_data    ),  //output  [7:0]   po_data        .po_flag    (po_flag    )   //output          po_flag);endmodule    8-9行因要对输入信号赋值使用reg变量；21-27初始化系统时钟、全局复位和输入信号；29-40模拟拟发送 8 次数据；43行对时钟进行规定；77-86行进行实例化，实例名为代码设计中的模块名，实例化名可以是实例名加_inst；最关键的是48-70行对发送任务的定义，类似c语言中的函数，单独分析：//定义一个名为rx_bit的任务，每次发送的数据有10位//data的值分别为0~7由j的值传递进来//任务以task开头，后面紧跟着的是任务名，调用时使用task rx_bit(    //传递到任务中的参数，调用任务的时候从外部传进来一个8位的值        input   [7:0]   data);        integer i;      //定义一个常量//用for循环产生一帧数据，for括号中最后执行的内容只能写i=i+1//不可以写成C语言i=i++的形式        for(i=0; i&lt;10; i=i+1) begin            case(i)                0: rx &lt;= 1&#39;b0;                1: rx &lt;= data[0];                2: rx &lt;= data[1];                3: rx &lt;= data[2];                4: rx &lt;= data[3];                5: rx &lt;= data[4];                6: rx &lt;= data[5];                7: rx &lt;= data[6];                8: rx &lt;= data[7];                9: rx &lt;= 1&#39;b1;            endcase            #(5208*20); //每发送1位数据延时5208个时钟周期        endendtask         //任务以endtask结束    注意这是第一次for循环的使用，for 括号中最后执行的内容只能写 i=i+1；任务以 task 开头，后面紧跟着的是任务名，调用时使用，以 endtask 结束；任务名紧接着是传入参数的定义，i是内部参数定义在括号外（类比c语言函数定义）</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c596d3b31134c232a5b00ae3aa4e8e48.png"></p><pre><code>    第一、第二、第三部分仿真波形如图所示，我们可以清晰的看到将 rx 信号打三拍的操作，并产生了串口帧起始的下降沿标志信号，以及 work_en 信号在串口帧起始的下降沿标志信号为高时拉高，baud_cnt 计数器在 work_en 信号为高时开始计数。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a4836417c6b50f8cf813a88f9361063.png"></p><p>……</p><h5 id="（2）uart-tx设计"><a href="#（2）uart-tx设计" class="headerlink" title="（2）uart_tx设计"></a>（2）uart_tx设计</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed4132b9525222bdeaa4e73667653c35.png"></p><h6 id="①波形图分析-1"><a href="#①波形图分析-1" class="headerlink" title="①波形图分析"></a>①波形图分析</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df689b6329ed5b9a83b12ebab4268f37.png"></p><pre><code>    前6个信号通过uart_rx的设计可以知道其用途    下面我们就可以按照 5208 个系统时钟周期的波特率间隔来发送 1bit 数据了。理论上我们在第一个 5208 系统时钟周期内 的任意一个位置发送数据都可以，这和接收数据时要在中间位置不同，所以我们直接让当 **baud_cnt** 计数器的计数值为 1（选择其他的值也可以，但是尽量不要选择 baud_cnt 计数器的计数值为 0 或 5207 这种端点，因为容易出问题）的时候作为发送数据的点，产生 **bit_flag** 信号，并使 **bit_cnt** 计数值加一，而下一个 baud_cnt 计数器的计数值为 1 的时候和上一个正好相差 5208 个系统时钟周期，是完全可以满足要求的。发送完一帧数据后要将 work_en 信号拉低。    bit_cnt清零和work_en拉低的条件：**让 bit_cnt 计数器计数到 9** ，停止位和空闲情况下都为高电平，所以最有一个停止位就没有必要再单独计数了，所以 bit_cnt 计数器计数到 9 清零是完全可以 的，当然让 bit_cnt 计数器计数到 10 更是可以的。 最后再来说说 work_en 信号拉低的条件，work_en 存在的原因就是为了方便 baud_cnt 计数器计数的，当我们不需要 baud_cnt 计数器计数的时候也就可以让 work_en 信号拉低 了。当 bit_cnt 计数器计数到 9 且 bit_flag 信号有效时停止位就可以被发送出去了，此时就不再需要 baud_cnt 计数器计数了，就可以把 work_en 信号拉低了，但同时还要将 baud_cnt 计数器清零，等待下一次发送数据时再从 0 开始计数。</code></pre><h6 id="②代码设计-1"><a href="#②代码设计-1" class="headerlink" title="②代码设计"></a>②代码设计</h6><pre><code>module  uart_tx#(    parameter   UART_BPS    =   &#39;d9600,         //串口波特率    parameter   CLK_FREQ    =   &#39;d50_000_000    //时钟频率)(     input   wire            sys_clk     ,   //系统时钟50MHz     input   wire            sys_rst_n   ,   //全局复位     input   wire    [7:0]   pi_data     ,   //模块输入的8bit数据     input   wire            pi_flag     ,   //并行数据有效标志信号      output  reg             tx              //串转并后的1bit数据);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////localparam    definelocalparam  BAUD_CNT_MAX    =   CLK_FREQ/UART_BPS   ;//reg   definereg [12:0]  baud_cnt;reg         bit_flag;reg [3:0]   bit_cnt ;reg         work_en ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////work_en:接收数据工作使能信号always@(posedge sys_clk or negedge sys_rst_n)        if(sys_rst_n == 1&#39;b0)            work_en &lt;= 1&#39;b0;        else    if(pi_flag == 1&#39;b1)            work_en &lt;= 1&#39;b1;        else    if((bit_flag == 1&#39;b1) &amp;&amp; (bit_cnt == 4&#39;d9))            work_en &lt;= 1&#39;b0;//baud_cnt:波特率计数器计数，从0计数到BAUD_CNT_MAX - 1always@(posedge sys_clk or negedge sys_rst_n)        if(sys_rst_n == 1&#39;b0)            baud_cnt &lt;= 13&#39;b0;        else    if((baud_cnt == BAUD_CNT_MAX - 1) || (work_en == 1&#39;b0))            baud_cnt &lt;= 13&#39;b0;        else    if(work_en == 1&#39;b1)            baud_cnt &lt;= baud_cnt + 1&#39;b1;//bit_flag:当baud_cnt计数器计数到1时让bit_flag拉高一个时钟的高电平always@(posedge sys_clk or negedge sys_rst_n)        if(sys_rst_n == 1&#39;b0)            bit_flag &lt;= 1&#39;b0;        else    if(baud_cnt == 13&#39;d1)            bit_flag &lt;= 1&#39;b1;        else            bit_flag &lt;= 1&#39;b0;//bit_cnt:数据位数个数计数，10个有效数据（含起始位和停止位）到来后计数器清零always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        bit_cnt &lt;= 4&#39;b0;    else    if((bit_flag == 1&#39;b1) &amp;&amp; (bit_cnt == 4&#39;d9))        bit_cnt &lt;= 4&#39;b0;    else    if((bit_flag == 1&#39;b1) &amp;&amp; (work_en == 1&#39;b1))        bit_cnt &lt;= bit_cnt + 1&#39;b1;//tx:输出数据在满足rs232协议（起始位为0，停止位为1）的情况下一位一位输出always@(posedge sys_clk or negedge sys_rst_n)        if(sys_rst_n == 1&#39;b0)            tx &lt;= 1&#39;b1; //空闲状态时为高电平        else    if(bit_flag == 1&#39;b1)            case(bit_cnt)                0       : tx &lt;= 1&#39;b0;                1       : tx &lt;= pi_data[0];                2       : tx &lt;= pi_data[1];                3       : tx &lt;= pi_data[2];                4       : tx &lt;= pi_data[3];                5       : tx &lt;= pi_data[4];                6       : tx &lt;= pi_data[5];                7       : tx &lt;= pi_data[6];                8       : tx &lt;= pi_data[7];                9       : tx &lt;= 1&#39;b1;                default : tx &lt;= 1&#39;b1;            endcaseendmodule</code></pre><p>③仿真设计</p><pre><code>module  tb_uart_tx();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg         sys_clk;reg         sys_rst_n;reg [7:0]   pi_data;reg         pi_flag;//wire  definewire        tx;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位initial begin        sys_clk    = 1&#39;b1;        sys_rst_n &lt;= 1&#39;b0;        #20;        sys_rst_n &lt;= 1&#39;b1;end//模拟发送7次数据，分别为0~7initial begin        pi_data &lt;= 8&#39;b0;        pi_flag &lt;= 1&#39;b0;        #200        //发送数据0        pi_data &lt;= 8&#39;d0;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;//每发送1bit数据需要5208个时钟周期，一帧数据为10bit//所以需要数据延时(5208*20*10)后再产生下一个数据        #(5208*20*10);        //发送数据1        pi_data &lt;= 8&#39;d1;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据2        pi_data &lt;= 8&#39;d2;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据3        pi_data &lt;= 8&#39;d3;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据4        pi_data &lt;= 8&#39;d4;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据5        pi_data &lt;= 8&#39;d5;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据6        pi_data &lt;= 8&#39;d6;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;        #(5208*20*10);        //发送数据7        pi_data &lt;= 8&#39;d7;        pi_flag &lt;= 1&#39;b1;        #20        pi_flag &lt;= 1&#39;b0;end//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号always #10 sys_clk = ~sys_clk;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------uart_rx_inst------------------------uart_tx uart_tx_inst(        .sys_clk    (sys_clk    ),  //input           sys_clk        .sys_rst_n  (sys_rst_n  ),  //input           sys_rst_n        .pi_data    (pi_data    ),  //output  [7:0]   pi_data        .pi_flag    (pi_flag    ),  //output          pi_flag        .tx         (tx         )   //input           tx);endmodule</code></pre><p>仿真这里测试了发送数据0~7</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/27adf568c1d8464861d39e0417d4b893.png"></p><pre><code>    第三部分仿真波形如图所示，**我们可以清晰地看到最后一个 bit_flag 信号为高的时刻，且 bit_cnt 计数器也计数到 9，将停止位发送出去，同时 work_en 信号拉低， baud_cnt 计数器检测到 work_en 信号为低电平后立刻清零并停止计数，等待下一次发送数据时再工作。**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bff01cc72bba6840bbb1317293b334c8.png"></p><h5 id="（3）顶层设计"><a href="#（3）顶层设计" class="headerlink" title="（3）顶层设计"></a>（3）顶层设计</h5><h6 id="①代码设计"><a href="#①代码设计" class="headerlink" title="①代码设计"></a>①代码设计</h6><pre><code>`timescale  1ns/1nsmodule  rs232(    input   wire    sys_clk     ,   //系统时钟50MHz    input   wire    sys_rst_n   ,   //全局复位    input   wire    rx          ,   //串口接收数据    output  wire    tx              //串口发送数据);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter defineparameter   UART_BPS    =   20&#39;d9600        ,   //比特率            CLK_FREQ    =   26&#39;d50_000_000  ;   //时钟频率//wire  definewire    [7:0]   po_data;wire            po_flag;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------ uart_rx_inst ------------------------uart_rx#(    .UART_BPS    (UART_BPS  ),  //串口波特率    .CLK_FREQ    (CLK_FREQ  )   //时钟频率)uart_rx_inst(    .sys_clk    (sys_clk    ),  //input             sys_clk    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n    .rx         (rx         ),  //input             rx                .po_data    (po_data    ),  //output    [7:0]   po_data    .po_flag    (po_flag    )   //output            po_flag);//------------------------ uart_tx_inst ------------------------uart_tx#(    .UART_BPS    (UART_BPS  ),  //串口波特率    .CLK_FREQ    (CLK_FREQ  )   //时钟频率)uart_tx_inst(    .sys_clk    (sys_clk    ),  //input             sys_clk    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n    .pi_data    (po_data    ),  //input     [7:0]   pi_data    .pi_flag    (po_flag    ),  //input             pi_flag                    .tx         (tx         )   //output            tx);endmodule    可以看到，顶层模块先定义好顶层输入输出线in/output wire，需要用到的参数parameter和内部模块的连线wire型变量；然后实例化设计好的模块，按照模块代码实例化参数，格式与模块定义时一致，**·+参数名**** _引出模块内部参数_** ，**括号内是顶层模块的变量** ，起连接作用。</code></pre><h6 id="②仿真设计"><a href="#②仿真设计" class="headerlink" title="②仿真设计"></a>②仿真设计</h6><pre><code>module  tb_rs232();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire    tx          ;//reg   definereg     sys_clk     ;reg     sys_rst_n   ;reg     rx          ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位和输入信号initial begin    sys_clk    = 1&#39;b1;    sys_rst_n &lt;= 1&#39;b0;    rx        &lt;= 1&#39;b1;    #20;    sys_rst_n &lt;= 1&#39;b1;end//调用任务rx_byteinitial begin    #200    rx_byte();end//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号always #10 sys_clk = ~sys_clk;//创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7task    rx_byte();  //因为不需要外部传递参数，所以括号中没有输入    integerj;    for(j=0; j&lt;8; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化7        rx_bit(j);endtask//创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来task    rx_bit(    input   [7:0]   data);    integer i;    for(i=0; i&lt;10; i=i+1)   begin        case(i)            0: rx &lt;= 1&#39;b0;            1: rx &lt;= data[0];            2: rx &lt;= data[1];            3: rx &lt;= data[2];            4: rx &lt;= data[3];            5: rx &lt;= data[4];            6: rx &lt;= data[5];            7: rx &lt;= data[6];            8: rx &lt;= data[7];            9: rx &lt;= 1&#39;b1;        endcase        #(5208*20); //每发送1位数据延时5208个时钟周期    endendtask//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------ rs232_inst ------------------------rs232   rs232_inst(    .sys_clk    (sys_clk    ),  //input         sys_clk    .sys_rst_n  (sys_rst_n  ),  //input         sys_rst_n    .rx         (rx         ),  //input         rx    .tx         (tx         )   //output        tx);endmodule    这里的仿真使用了**task的嵌套** ，再实例化了顶层设计模块；**从此对模块设计 .V 文件中的参数及实例化理解加深，类似于顶层模块的综合，仿真模块开始时定义的变量时为了后面的实例化所服务的，要么起连线作用（wire），要么起赋值仿真作用（reg），在实例化的括号里连接。**</code></pre><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><pre><code>    “在本章的 Testbench 的设计中我们第一次使用到了 task 任务以及 for 循环语句，这两个语法都在仿真中使用的较多，虽然都是可以综合的但还是推荐初学者尽量**不要在 RTL 代码中使用** ，尤其是对它们理解不深刻的情况下。而我们**在 Testbench 中使用就不用担心这么多** ，且可以大大简化我们的代码，提高效率，是十分好用的，也推荐大家以后再 Testbench 中多尝试使用。”    以及更深入了解Verilog HDL代码的编写，深刻理解了参数、变量、实例化。</code></pre><p>知识点总结：</p><p>1. 理解亚稳态产生的原理，掌握单比特数据从<strong>慢速时钟域到快速时钟域</strong> 处理亚稳态的方法。</p><p>2. 学会使用边沿检测，并记住代码的格式，理解原理。（<strong>第三级寄存器和第二级寄存器共同构成下降沿检测(~rx_reg2) &amp;&amp; (rx_reg3)）</strong></p><p>3. 串并转换是接口中很常用的一种方法，用到了移位，要熟练掌握。</p><p>4. 掌握 loopback 测试的方法，以后用于我们模块中代码的调试。</p><h2 id="二-基于-I2C-协议的-EEPROM-驱动控制"><a href="#二-基于-I2C-协议的-EEPROM-驱动控制" class="headerlink" title="二.基于 I2C 协议的 EEPROM 驱动控制"></a>二.基于 I2C 协议的 EEPROM 驱动控制</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    I2C 通讯协议(Inter－Integrated Circuit)是由 Philips 公司开发的一种简单、**双向二线制同步串行总线** ，只需要两根线即可在连接于总线上的器件之间传送信息。 I2C 通讯协议和通信接口在很多工程中有广泛的应用，如数据采集领域的串行 AD，图像处理领域的摄像头配置，工业控制领域的 X 射线管配置等等。除此之外，由于 I2C 协议占用引脚特别少，硬件实现简单，可扩展型强，现在被广泛地使用在系统内多个**集成电路 (IC)间的通讯** 。    下面我们分别对 I2C 协议的**物理层** 及**协议层** 进行讲解。    它的**物理层** 有如下特点：            (1) 它是一个支持多设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯 总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。    (2) 一个 I2C 总线只使用两条总线线路，**一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)** 。数据线即用来表示数据，时钟线用于数据收发同步。    (3) 每个连接到总线的设备都有**一个独立的地址** ，主机可以利用这个地址进行不同设备之间的访问。    (4) 总线通过上拉电阻接到电源。**当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平** 。    (5) 多个主机同时使用总线时，为了防止数据冲突，会利用**仲裁** 方式决定由哪个设备占用总线。    (6) 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。    (7) 连接到相同总线的 IC 数量受到**总线的最大电容 400pF 限制** 。    它的**协议层** 有如下特点：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/752abc66eb1c6660c1e6af853f3feb85.png"></p><pre><code>    由图可知，I2C 协议整体时序图分为 4 个部分，图中标注的①②③④表示 I2C 协议的 4 个状态，分别为“总线空闲状态”、“起始信号”、“数据读/写状态”和“停止信号”， 针对这 4 个状态，我们来做一下详细介绍。    (1) 图中标注①表示“总线空闲状态”，在此状态下串口时钟信号 SCL 和串行数据信 号 SDA 均保持高电平，此时无 I2C 设备工作。    (2) 图中标注②表示“起始信号”，在 I2C 总线处于“空闲状态”时，SCL 依旧保持高电平时， SDA 出现由高电平转为低电平的**下降沿，产生一个起始信号** ，此时与总线相连的所有 I2C 设备在检测到起始信号后，均跳出空闲状态，**等待控制字节的输入** 。    (3) 图中标注③表示“数据读/写状态”，“数据读/写状态”时序图具体见图：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c934c50ba6ee94b62f9e40b9f133fcf7.png"></p><pre><code>    I2C 通讯设备的通讯模式是**主从通讯模式** ，通讯双方有主从之分。 当主机向从机进行指令或数据的写入时，串行数据线 SDA 上的数据**在串行时钟 SCL 为高电平时写入从机设备** ，每次只写入一位数据；串行数据线 SDA 中的数据**在串行时钟 SCL 为低电平时进行数据更新** ，以保证在 SCL 为高电平时采集到 SDA 数据的稳定状态。 当一个完整字节的指令或数据传输完成，从机设备正确接收到指令或数据后，会通过**拉低 SDA 为低电平，向主机设备发送单比特的应答信号** ，表示数据或指令写入成功。若从机正确应答，可以结束或开始下一字节数据或指令的传输，否则表明数据或指令写入失败，主机就可以决定是否放弃写入或者重新发起写入。    (4) 图中标注④表示“停止信号”，完成数据读写后，串口时钟 SCL 保持高电平，当 串口数据信号 SDA 产生一个由低电平转为高电平的上升沿时，产生一个停止信号，I2C 总线跳转回“总线空闲状态”。    **I2C 设备器件地址与存储地址** 有如下特点：    每个 I2C 设备在出厂前都被设置了器件地址，用户不可自主更改；器件地址一般位宽为 7 位，有的 I2C 设备的器件地址**设置了全部位宽** ，例如后面章节要讲解的 OV7725、 OV5640 摄像头；有的 I2C 设备的器件地址**设置了部分位宽** ，例如本章节要使用的 EEPROM 存储芯片，它的器件地址只设置了高 4 位，**剩下的低 3 位由用户在设计硬件时自主设置** 。 FPGA 开发板使用的是 ATMEL 公司生产的 AT24C 系列中的型号为 AT24C64 的 EEPROM 存储芯片。AT24C64 存储容量为**64Kbit，内部分成 256 页，每页 32 字节** ， 共有 8192 个字节，且其读写操作都是以字节为基本单位。 AT24C64 EEPROM 存储芯片的器件地址包括厂商设置的高 4 位 1010 和用户需自主设置的低 3 位 A0、A1、A2 。**在硬件设计时，通过将芯片的 A0、A1、A2 这 3 个引脚分别连接到 VCC 或 GND 来实现器件地址低 3 位的设置** ，若 3 个引脚均连接到 VCC，则设置后的器件地址为 1010_111；若 3 个引脚均连接到 GND，则设置后的器件地址为 1010_000。由于 A0、A1、A2 这 3 位只能组合出 8 种 情况，所以一个主机最多只能连接 8 个 AT24C64 存储芯片。 在 I2C 主从设备通讯时，主机在发送了起始信号后，接着会向从机发送控制命令。控制命令长度为 1 个字节，它的**高 7 位为上文讲解的 I2C 设备的器件地址，最低位为读写控制位** 。读写控制位为 0 时，表示主机要对从机进行数据写入操作；读写控制位为 1 时，表 示主机要对从机进行数据读出操作。         EEPROM 储存芯片控制命令格式示意图，具体见图：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6b29ef23df2793e6dee03a09ab8981.png"></p><pre><code>    **I2C 设备存储地址相关** ：     每一个支持 I2C 通讯协议的设备器件，内部都会**包含一些可进行读/写操作的寄存器或存储器** 。例如后面章节将会讲到的 OV7725、OV5640 摄像头(它们使用的是与 I2C 协议极 为相似的 SCCB 协议，后面章节会进行讲解)，他们内部包含一些需要进行读/写配置的寄存器，只有**向对应寄存器写入正确参数** ，摄像头才能被正确使用；同样，本章节要使用的 EEPROM 存储芯片内部则包含许多存储单元，需要**存储的数据按照地址被写入对应存储单元** 。 由于 I2C 设备要配置寄存器的多少或**存储容量的大小的不同，存储地址根据 位宽分为单字节和 2 字节**两种。例如后文要提到的 OV7725、OV5640 摄像头，两者的寄存器数量不 同，OV7725 摄像头需要配置寄存器较少，单个字节能够实现所有寄存器的寻址，所以他的存储地址位宽为 8 位；而 OV5640 摄像头需要配置寄存器较多，单个字节不能够实现所有寄存器的寻址，所以他的存储地址位宽为 16 位，2 个字节。 以 EEPROM 存储芯片为例，在 ATMEL 公司生产的 AT24C 系列 EEPROM 存储芯片中选取两款存储芯片 AT24C04 和 AT24C64。AT24C04 的存储容量为 1Kbit(128byte)，7 位存储地址即可满足所有存储单元的寻址，存储地址为单字节即可；而 AT24C64 的存储空间为 64 Kbit(8Kbyte)，需要 13 位存储地址才可满足所有存储单元的寻址，存储地址为 2 字节。</code></pre><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="&lt;2&gt;读写操作"></a>&lt;2&gt;读写操作</h3><pre><code>    I2C 读/写操作对传入从机的控制命令最低位读写控制位写入不同数据值，主机可实现对从机的读/写 操作，读写控制位为 0 时，表示主机要对从机进行数据写入操作；读写控制位为 1 时，表 示主机要对从机进行数据读出操作。</code></pre><p><strong>I2C 单字节写操作：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4b199374ee410594861d4b291846da6.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/416c880b3f8aca3ecaa6fcfbeba575bf.png"></p><p><strong>注：MSB（最高有效位，Most Significant Bit）；LSB（最低有效位，Last Significant Bit）</strong></p><p>参照时序图，列出单字节写操作流程如下：</p><pre><code>    (1) **主机** 产生并**发送起始信号** 到从机，将控制命令写入从机设备，读写控制位设置为低电平，表示对从机进行数据写操作，控制命令的写入高位在前低位在后；    (2) **从机** 接收到控制指令后，**回传应答信号** ，主机接收到应答信号后开始存储地址的写入。若为 2 字节地址，顺序执行操作；若为单字节地址跳转到步骤(5)；    (3) **先** 向从机写入**高 8 位地址** ，且**高位在前低位在后** ；    (4) 待接收到从机回传的应答信号，**再写入低 8 位地址** ，且高位在前低位在后，若为 2 字节地址，跳转到步骤(6)；    (5) 按高位在前低位在后的顺序写入单字节存储地址；    (6) 地址写入完成，主机接收到从机**回传的应答信号** 后，开始单字节**数据的写入** ；    (7) 单字节数据写入完成，主机接收到应答信号后，向从机**发送停止信号** ，数据写入完成。</code></pre><p><strong>I2C 页写操作：</strong></p><pre><code>    单字节写操作中，主机一次向从机中写入单字节数据；页写操作中，主机一次可向从机写入**多字节数据** 。连续写时序图，具体见图：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f2fe112d1778081fc5d2cce74354fc.png"></p><pre><code>    所有 I2C 设备均支持单字节数据写入操作，但只有**部分 I2C 设备支持页写操作** ； 且支持页写操作的设备，一次页写操作写入的字节数**不能超过设备 单页包含的存储单元数**。本章节使用的 AT24CXX 系列的 EEPROM 存储芯片，单页存储单元个数为 32 个，**一 次页写操作只能写入 32 字节数据。**</code></pre><p><strong>I2C 随机读操作：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/435e1a69a14a95b0356304920bc062df.png"></p><p>参照时序图，列出页写时序操作流程如下：</p><pre><code>    (1) 主机产生并发送起始信号到从机，将控制命令写入从机设备，读写控制位设置为**低电平** ，表示对从机进行**数据写操作** ，控制命令的写入高位在前低位在后；    (2) 从机接收到控制指令后，回传应答信号，主机接收到应答信号后**开始存储地址的写入** 。若为 2 字节地址，顺序执行操作；若为单字节地址跳转到步骤(5)；             (3) 先向从机写入高 8 位地址，且高位在前低位在后；             (4) 待接收到从机回传的应答信号，再写入低 8 位地址，且高位在前低位在后，若为 2 字节地址，跳转到步骤(6)；    (5) 按高位在前低位在后的顺序写入单字节存储地址；    (6) **地址写入完成** ，主机接收到从机回传的应答信号后，主机**再次向从机发送一个起始信号** ；    (7) 主机向从机发送控制命令，读写控制位设置为**高电平** ，表示对从机进行**数据读操作** ；    (8) 主机接收到从机回传的应答信号后，开始**接收从机传回的第一个单字节数据** ；    (9) 数据接收完成后，**主机产生应答信号回传给从机** ，**从机接收到应答信号开始下一字节数据的传输** ，若数据接收完成，执行下一操作步骤；若数据接收未完成，在此执行步骤(9)；    (10) 主机产生**一个时钟的高电平 无应答信号**；    (11) 主机向从机发送**停止信号** ，顺序读操作完成。</code></pre><p>注：可以看到，主机进行了<strong>两次控制命令发送（读写操作，地址+w&#x2F;r）</strong> ；在写操作中写入地址，然后在读操作读取数据。</p><h3 id="设计实践-1"><a href="#设计实践-1" class="headerlink" title="&lt;3&gt;设计实践"></a>&lt;3&gt;设计实践</h3><pre><code>    运用所学理论知识设计一个使用 I2C 通讯协议的 EEPROM 读写控制器，使用按键控制数据写入或读出 EEPROM。使用写控制按键向 EEPROM 中写入数据 1-10 共 10 字节数据， 使用读控制按键读出之前写入到 EEPROM 的数据，并将读出的数据在数码管上显示出来。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/12435cc99834822d4e7d56554f5cd25b.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/25c752bd6943503f200153f7dce4a032.png"></p><pre><code>    由原理图可知，升腾 Mini 板载 EEPROM 地址位 A0、A1 接高电平，A2 接地； EEPROM 地址为 7’b1010_011。</code></pre><h4 id="（1）整体设计"><a href="#（1）整体设计" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad709b86b2f585ed9b7e32572f475fa0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5046f4605c4667e12c78374ab7af14f9.png"></p><pre><code>    按下数据写操作按键，写触发信号传入按键消抖模块(key_filter)，经消抖处理后的写触发信号传入数据收发模块(i2c_rw_data)，模块接收到有效的**写触发信号** 后，生成写**使能信号、待写入数据、数据地址** 传入 I2C 驱动模块(i2c_ctrl)，I2C 驱动模块按照 I2C 协议将数据写入 EEPROM 存储芯片； 数据写入完成后，按下数据读操作按键，读触发信号传入按键消抖模块(key_filter)， 经消抖处理后的读触发信号传入数据收发模块(i2c_rw_data)，模块接收到有效的**读触发信号** 后，生成**读使能信号、数据地址** 传入 I2C 驱动模块(i2c_ctrl)，I2C 驱动模块自 EEPROM 存储芯片读取数据，将读取到的数据回传给数据收发模块(i2c_rw_data)，**数据收发模块将数据暂存** ，待所有数据均读取完成后，将数据传至数码管动态显示模块(seg_dynamic)，自 EEPROM 中读取的数据在数码管显示出来。module  eeprom_byte_rd_wr(    input   wire            sys_clk     ,   //输入工作时钟,频率50MHz    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效    input   wire            key_wr      ,   //按键写    input   wire            key_rd      ,   //按键读    inout   wire            sda         ,   //串行数据    output  wire            scl         ,   //串行时钟    output  wire    [5:0]   sel         ,   //数码管位选信号    output  wire    [7:0]   seg             //数码管段选信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire            read        ;wire            write       ;wire    [7:0]   po_data     ;wire    [7:0]   rd_data     ;wire            wr_en       ;wire            rd_en       ;wire            i2c_end     ;wire            i2c_start   ;wire    [7:0]   wr_data     ;wire    [15:0]  byte_addr   ;wire            i2c_clk     ;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------- key_wr_inst -------------key_filter  key_wr_inst(    .sys_clk    (sys_clk    ),  //系统时钟50Mhz    .sys_rst_n  (sys_rst_n  ),  //全局复位    .key_in     (key_wr     ),  //按键输入信号    .key_flag   (write      )   //key_flag为1时表示按键有效，0表示按键无效);//------------- key_rd_inst -------------key_filter  key_rd_inst(    .sys_clk    (sys_clk    ),  //系统时钟50Mhz    .sys_rst_n  (sys_rst_n  ),  //全局复位    .key_in     (key_rd     ),  //按键输入信号    .key_flag   (read       )   //key_flag为1时表示按键有效，0表示按键无效);//------------- i2c_rw_data_inst -------------i2c_rw_data i2c_rw_data_inst(    .sys_clk     (sys_clk   ),  //输入系统时钟,频率50MHz    .i2c_clk     (i2c_clk   ),  //输入i2c驱动时钟,频率1MHz    .sys_rst_n   (sys_rst_n ),  //输入复位信号,低有效    .write       (write     ),  //输入写触发信号    .read        (read      ),  //输入读触发信号    .i2c_end     (i2c_end   ),  //一次i2c读/写结束信号    .rd_data     (rd_data   ),  //输入自i2c设备读出的数据    .wr_en       (wr_en     ),  //输出写使能信号    .rd_en       (rd_en     ),  //输出读使能信号    .i2c_start   (i2c_start ),  //输出i2c读/写触发信号    .byte_addr   (byte_addr ),  //输出i2c设备读/写地址    .wr_data     (wr_data   ),  //输出写入i2c设备的数据    .fifo_rd_data(po_data   )   //输出自fifo中读出的数据);//------------- i2c_ctrl_inst -------------i2c_ctrl#(    .DEVICE_ADDR    (7&#39;b1010_011     ), //i2c设备器件地址    .SYS_CLK_FREQ   (26&#39;d50_000_000  ), //i2c_ctrl模块系统时钟频率    .SCL_FREQ       (18&#39;d250_000     )  //i2c的SCL时钟频率)i2c_ctrl_inst(    .sys_clk     (sys_clk   ),   //输入系统时钟,50MHz    .sys_rst_n   (sys_rst_n ),   //输入复位信号,低电平有效    .wr_en       (wr_en     ),   //输入写使能信号    .rd_en       (rd_en     ),   //输入读使能信号    .i2c_start   (i2c_start ),   //输入i2c触发信号    .addr_num    (1&#39;b1      ),   //输入i2c字节地址字节数    .byte_addr   (byte_addr ),   //输入i2c字节地址    .wr_data     (wr_data   ),   //输入i2c设备数据    .rd_data     (rd_data   ),   //输出i2c设备读取数据    .i2c_end     (i2c_end   ),   //i2c一次读/写操作完成    .i2c_clk     (i2c_clk   ),   //i2c驱动时钟    .i2c_scl     (scl       ),   //输出至i2c设备的串行时钟信号scl    .i2c_sda     (sda       )    //输出至i2c设备的串行数据信号sda);//------------- seg_dynamic_inst -------------seg_dynamic seg_dynamic_inst(    .sys_clk     (sys_clk   ), //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n ), //复位信号，低有效    .data        (po_data   ), //数码管要显示的值    .point       (          ), //小数点显示,高电平有效    .seg_en      (1&#39;b1      ), //数码管使能信号，高电平有效    .sign        (          ), //符号位，高电平显示负号    .sel         (sel       ), //数码管位选信号    .seg         (seg       )  //数码管段选信号);endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d5635fe91ddb5bd3e38a3c10b537fc9f.png"></p><h4 id="（2）I2C-驱动模块"><a href="#（2）I2C-驱动模块" class="headerlink" title="（2）I2C 驱动模块"></a>（2）I2C 驱动模块</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb7cecb706c44404eb242fcfc064d9aa.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c4f74a5010a210f39adf6fbdc8ec967.png"></p><pre><code>    由图表可知，I2C 驱动模块包括 13 路输入输出信号，其中输入信号 8 路、输出信号 5 路。输入信号中，sys_clk、sys_rst_n 是必不可少的系统时钟和复位信号；wr_en、rd_en 为写使能信号，由数据收发模块生成并传入，高电平有效；**i2c_start 信号为单字节数据读/写 开始信号；与 i2c_start 信号同时传入的还有数据存储地址 byte_addr 和待写入字节数据 wr_data** ；当写使能 wr_en 和 i2c_start 信号同时有效，模块执行单字节数据写操作，按照数据存储地址 byte_addr，向 EEPROM 对应地址写入数据 wr_data；当读使能信号 rd_en 和 i2c_start 信号同时有效，模块执行单字节数据读操作，按照数据存储地址 byte_addr 读取 EEPROM 对应地址中的数据；前文中我们提到， I2C 设备存储地址有单字节和 2 字节两种，为了应对这一情况，我们向模块输入**addr_num** 信号**，当信号为低电平时，** 表示 I2C 设备存储地址为单字节，在进行数据读写操作时只写入数据存储地址**byte_addr 的低 8 位** ；**当信号为高电平时，** 表示 I2C 设备存储地址为 2 字节，在进行数据读写操作时要写入数据存储地址 **byte_addr 的全部 16 位。**    输出信号中，**i2c_clk** 是本模块的工作时钟，由系统时钟 sys_clk 分频而来，它的时钟频率为串行时钟 **i2c_scl 频率的 4 倍** ，时钟信号 i2c_clk 要传入数据收发模块(i2c_rw_data)作为模块的工作时钟；输出给数据收发模块(i2c_rw_data)的单字节数据读/写结束信号 i2c_end，高电平有效，表示一次单字节数据读/写操作完成；rd_data 信号表示自 EEPROM 读出的单字节单字节数据，输出至数据收发模块(i2c_rw_data)；i2c_scl、i2c_sda 分别是串行时钟信号和串行数据信号，由模块产生传入 EEPROM 存储芯片。    注：对 EERPROM 的数据读写操作均使用单字节读/写操作，即**每次操作只读/写单字节数据** ；若想要实现数据的连续读/写，可**持续拉高读/写使能 rd_en/wr_en** ，并输入有效的单字节数据读/写开始信号 i2c_start 即可。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/981cf57f7293a8b151ecefba24bcc8ab.png"></p><pre><code>    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)；FPGA 向 EEPROM 存储芯片发送起始信号；随后状态机跳转到 SEND_D_ADDR(发送器件地址状态)，在此状态下向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表 示执行写操作；控制指令写入完毕后，状态机跳转到 ACK_1(应答状态)。 在 ACK_1(应答状态)状态下，要根据存储地址字节数进行不同状态的跳转。当 FPGA 接收到 EEPROM 回传的应答信号且存储地址字节为 2 字节 ， 状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，将存储地址的高 8 位写入 EEPROM，写入完成后，状态机跳转到 ACK_2(应答状态)；FPGA 接收到应答信号后，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态)；当 FPGA 接收到 EEPROM 回传的应答信号且存储地址字节为单字节，状态机状态机直接跳转到 SEND_B_ADDR_L(发送低字节地址状 态)；在此状态低 8 位存储地址或单字节存储地址写入完成后，状态机跳转到 ACK_3(应答状态)。 在 ACK_3(应答状态)状态下，要根据读/写使能信号做不同的状态跳转。当 FPGA 接收到应答信号且写使能信号有效，状态机跳转到 WR_DATA(写数据状态)；在写数据状态， 向 EEPROM 写入单字节数据后，状态机跳转到 ACK_4(应答状态)；待 FPGA 接收到有效应答信号后，状态机跳转到**STOP(停止状态)** ；当 FPGA 接收到应答信号且读使能信号有效， 状态机跳转到 START_2(起始状态)；再次向 EEPROM 写入起始信号，状态跳转到 SEND_RD_ADDR(发送读控制状态)；再次向 EEPROM 写入控制字节，高 7 位器件地址不变，读写控制位写入“1”，表示进行读操作，控制字节写入完毕后，状态机跳转到 ACK_5(应答状态)；待 FPGA 接收到有效应答信号后，状态机跳转到 RD_DATA(读数据状态)；在 RD_DATA(读数据状态)状态，EEPROM 向 FPGA 发送存储地址对应存储单元下的单字节数据，待数据读取完成户，状态机跳转到 **N_ACK(无应答状态)** ，在此状态下向 EEPROM 写入一个时钟的高电平，表示数据读取完成，随后状态机跳转到 STOP(停止状态)。 在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次单字节数据读/写操作完成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a22e72a1f9818b6e8dd52d4e6e556113.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2c607f0961eaa4707998a179c81932b4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dbbae5dafe0c9d75fea0a0c8f4c0b8b0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f163cf331443f13ea529491e0964a4d1.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6ddc3bdf972cfc6b409df0357a7b299.png"></p><p>注：参考复习状态机设计<a href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5501" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞</a></p><h5 id="【1】单字节写操作时序分析"><a href="#【1】单字节写操作时序分析" class="headerlink" title="【1】单字节写操作时序分析"></a><strong>【1】单字节写操作时序分析</strong></h5><pre><code>    **第一部分** ：输入信号说明    本模块的输入信号有 8 路，其中 7 路信号与单字节写操作有关。系统时钟信号 sys_clk 和复位信号 sys_rst_n 不必多说，这是模块正常工作必不可少的；写使能信号 wr_en、 单 字节数据读/写开始信号 i2c_start，只有在两信号同时有效时，模块才会执行单字节数据写操作，若 wr_en 有效时，i2c_start 信号 n 次有效输入，可以实现 **n 个字节的连续写操作** ； addr_num 信号为存储地址字节数标志信号，赋值为 0 时，表示 I2C 设备存储地址为单字节，赋值为 1 时，表示 I2C 设备存储地址为 2 字节，本实验使用的 EEPROM 存储芯片的存 储地址位 2 字节，此信号**恒为高电平** ；信号 byte_addr 为存储地址；wr_data 表示要写入该地址的单字节数据。    **第二部分** ：时钟信号计数器 cnt_clk 和输出信号 i2c_clk 的设计与实现    本实验对 EEPROM 读写操作的串行时钟**scl 的频率为 250KHz** ，且只在数据读写操作时时钟信号才有效，其他时刻 scl 始终保持高电平。若直接使用系统时钟生成串行时钟 scl，计数器要设置**较大的位宽** ，较为麻烦，我们这里先**将系统时钟分频为频率较小的时钟，在使用新分频的时钟来生成串行时钟 scl** 。    所以，在这里声明一个新的计数器 **cnt_clk** 对系统时钟 sys_clk 进行计数，利用计数器 cnt_clk 生成新的时钟 **i2c_clk** 。    串行时钟 scl 的时钟频率为 250KHz，我们要生成的新时钟 i2c_clk 的频率要是 scl 的 4 倍，之所以这样是为了后面更好的生成 scl 和 sda，所以 i2c_clk 的时钟频率为 1MHz。经计 算，cnt_clk 要在 0-24 （25次）内循环计数，每个系统时钟周期自加 1；cnt_clk **每计完一个周期， i2c_clk 进行一次取反（50分频）** ，最后得到 i2c_clk 为频率 1MHz 的时钟，本模块中其他信号的生成都以此信号为同步时钟。两信号波形图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/21691eb71a39d5bf950a025e94f0dda7.png"></p><pre><code>    注：由于系统时钟 sys_clk 与时钟 i2c_clk 时钟频率相差较大，sys_clk 信号用虚线表示。    **第三部分** ：输出至 EEPROM 的串行时钟 scl 与串行数据 sda 只有在进行数据读写操作时有效，其他时刻始终保持高电平。由前文状态机相关讲解可知，除 IDLE(初始 状态)状态之外的其他状态均属于数据读写操作的有效部分，所以声明一个使能信号 **cnt_i2c_clk_en** ，在除 IDLE(初始状态)状态之外的其他状态保持有效高电平，作为 I2C 数据读写操作使能信号。    我们使用 50MHz 系统时钟生成了 1MHz 时钟 i2c_clk，但输出至 EEPROM 的串行时钟 scl 的时钟频率为 250KHz，我们声明时钟信号计数器 **cnt_i2c_clk** ，作为分频计数器，对时钟 i2c_clk 时钟信号进行计数，初值为 0，计数范围为 0-3，计数时钟为 i2c_clk 时钟，每个 时钟周期自加 1，实现时钟 i2c_clk 信号的 4 分频，生成串行时钟 **scl** 。同时计数器 cnt_i2c_clk 也可作为生成串行数据 sda 的约束条件，以及状态机跳转条件。    计数器 cnt_i2c_clk 循环计数一个周期，对应串行时钟 scl 的 1 个时钟周期以及串行数据 **sda 的 1 位数据保持时间** ，进行数据读写操作时，传输的指令、地址以及数据，位宽为固定的 8 位数据，我们声明一个比特计数器 cnt_bit，对计数器 cnt_i2c_clk 的计数周期进行计数，可以辅助串行数据 sda 的生成，同时作为状态机状态跳转的约束条件。    输出的串行数据 sda 作为一个双向端口，主机通过它向从机发送控制指令、地址以及数据，接收从机回传的应答信号和读取数据。回传给主机的**应答信号是实现状态机跳转的条件之一** 。**声明信号 sda_in 作为串行数据 sda 缓存** ，声明 ack 信号作为应答信号，ack 信号只在状态机处于各应答状态时由 sda_in 信号赋值，此时为从机回传的应答信号，其他状态时钟保持高电平。    状态机状态跳转的各约束条件均已介绍完毕，声明**状态变量 state** ， 单字节写操作状态机跳转流程如下：    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)，同时使能信号 **cnt_i2c_clk_en 拉高** 、计数器 **cnt_i2c_clk、cnt_bit 开始计数** ，开始数据读写操作；    在 START_1(起始状态)状态保持一个串行时钟周期，期间 FPGA 向 EEPROM 存储芯 片发送起始信号，一个时钟周期过后，计数器 cnt_i2c_clk 完成一个周期计数，计数到最大值 3，状态机跳转到 SEND_D_ADDR(发送器件地址状态)；    计数器 cnt_i2c_clk、cnt_bit 同时归 0，重新计数，计数器 cnt_i2c_clk 每计完一个周期，cnt_bit 自加 1，当计数器 cnt_i2c_clk 完成 8 个计数周期后，cnt_bit 计数到 7，实现 8 个比特计数，器件 FPGA 按照时序向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表示执行写操作。当计数器 cnt_ i2c_clk 计数到最大值 3、cnt_bit 计数到 7，两计数器同时归 0，**状态机跳转到转到 ACK_1(应答状态)** ；    在 ACK_1(应答状态)状态下，计数器 cnt_i2c_clk、cnt_bit 重新计数，当计数器 cnt_ i2c_clk 计数到最大值 3 ， 且应答信号 ack 为有效的低电平 ， 状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，两计数器清 0；    此状态下，FPGA 将存储地址的高 8 位按时序写入 EEPROM，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，状态机跳转到 ACK_2(应答状态)， 两计数器清 0；    ACK_2 状态下，当计数器 cnt_ i2c_clk 计数到 3，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态) ，两计数器清 0；    在此状态下，低 8 位存储地址按时序写入 EEPROM，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_3(应答状态)；    在 ACK_3(应答状态)状态下，当 **cnt_ i2c_clk 计数 3、应答信号 ack 有效，且写使能信号 wr_en 有效，状态机跳转到 WR_DATA(写数据状态)** ；    在写数据状态，按时序向 EEPROM 写入单字节数据，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_4(应答状态)；    在 ACK_4(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，状态机跳转到 STOP(停止状态)状态；    在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次单字节数据读/写操作完成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。    可以看到主要决定状态机状态**跳转的判断条件** 是**cnt_ i2c_clk 计数到 3、应答信号 ack 有效、cnt_bit 计数到 7**</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a970f3612ef8aafc029a265ccdf27ec.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ec68fc6685298d54ce1f1f76d69b368c.png"></p><pre><code>    **第四部分** ：输出串行时钟 i2c_scl、串行数据信号 i2c_sda 及相关信号的波形设计与实现    串口数据 sda 端口作为一个双向端口，在单字节读取操作中，**主机只在除应答状态之外的其他状态拥有它的控制权，在应答状态下主机只能接收由从机通过 sda 传入的应答信号** 。声明使能信号 sda_en，只在除应答状态之外的其他状态赋值为有效的高电平，**sda_en 有效时，主机拥有对 sda 的控制权。**    声明 **i2c_sda_reg** 作为输出 i2c_sda 信号的**数据缓存** ，**在 sda_en 有效时，将 i2c_sda_reg 的值赋值给输出串口数据 i2c_sda，sda_en 无效时，输出串口数据 i2c_sda 为高阻态，主机放弃其控制权，接收其传入的应答信号。**    i2c_sda_reg 在使能信号 sda_en 无效时始终保持高电平，在使能 sda_en 有效时，在状态机对应状态下，以计数器 cnt_ i2c_clk、cnt_bit 为约束条件，对应写入起始信号、控制指令、存储地址、写入数据、停止信号。    对于输出的串行时钟 i2c_clk，由 I2C 通讯协议可知，I2C 设备只在串行时钟为高电平时进行数据采集，在串行时钟低电平时实现串行数据更新。我们使用计数器 cnt_ i2c_clk、 cnt_bit 以及状态变量 state 为约束条件，结合 I2C 通讯协议，生成满足时序要求的输出串行 时钟 i2c_clk。    输出串行时钟 i2c_scl、串行数据信号 i2c_sda 及相关信号的波形图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b50b1bf58d51104cf8dcdb6ec165a14.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f84ba56575b04cae5fd6ae73bea6d80.png"></p><h5 id="【2】随机读操作时序分析"><a href="#【2】随机读操作时序分析" class="headerlink" title="【2】随机读操作时序分析"></a>【2】随机读操作时序分析</h5><pre><code>    单字节写操作和随机读操作所涉及的各信号大体相同，在随机读操作，我们只讲解差别较大之处，两操作相同或相似之处不再说明，读者可回顾单字节写操作部分的介 绍。     **第一部分** ：输入信号说明 本模块的输入信号有 8 路，其中 6 路信号与随机读操作有关。系统时钟信号 sys_clk 和 复位信号 sys_rst_n 不必多说，这是模块正常工作必不可少的；读使能信号 rd_en、 单字节数据读/写开始信号 i2c_start，只有在两信号同时有效时，模块才会执行随机读操作，若 rd_en 有效时，i2c_start 信号 n 次有效输入，可以实现 n 个字节的连续读操作；addr_num 信 号为存储地址字节数标志信号，赋值为 0 时，表示 I2C 设备存储地址为单字节，赋值为 1 时，表示 2C 设备存储地址为 2 字节，本实验使用的 EEPROM 存储芯片的存储地址位 2 字节，此信号恒为高电平；信号 byte_addr 为存储地址。    **第二部分** ：状态机相关信号波形的设计与实现    状态机状态跳转的各约束条件，读者可回顾单字节写操作部分介绍。声明状态变量 state，结合各约束信号，单字节写操作状态机跳转流程如下：    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)，同时使能信号 cnt_i2c_clk_en 拉高、计数器 cnt_i2c_clk、cnt_bit 开始计数，开始数据读写操作；    在 START_1(起始状态)状态保持一个串行时钟周期，期间 FPGA 向 EEPROM 存储芯 片发送起始信号，一个时钟周期过后，计数器 cnt_ i2c_clk 完成一个周期计数，计数器 cnt_ i2c_clk 计数到最大值 3，状态机跳转到 SEND_D_ADDR(发送器件地址状态)；    计数器 cnt_i2c_clk、cnt_bit 同时归 0，重新计数，计数器 cnt_i2c_clk 每计完一个周期，cnt_bit 自加 1，当计数器 cnt_i2c_clk 完成 8 个计数周期后，cnt_bit 计数到 7，实现 8 个比特计数，器件 FPGA 按照时序向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表示执行写操作。当计数器 cnt_ i2c_clk 计数到最大值 3、cnt_bit 计数到 7，两计数器同时归 0，状态机跳转到转到 ACK_1(应答状态)；    在 ACK_1(应答状态)状态下，计数器 cnt_i2c_clk、cnt_bit 重新计数，当计数器 cnt_ i2c_clk 计数到最大值 3 ，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，两计数器清 0；    此状态下，FPGA 将存储地址的高 8 位按时序写入 EEPROM，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，状态机跳转到 ACK_2(应答状态)， 两计数器清 0；    ACK_2 状态下，当计数器 cnt_ i2c_clk 计数到 3，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态) ，两计数器清 0； 在此状态下，低 8 位存储地址按时序写入 EEPROM，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_3(应答状态)；    在 ACK_3(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，且读使能信号 rd_en 有效，状态机跳转到 START_2(起始状态)；    在 START_2(起始状态)状态保持一个串行时钟周期，期间 FPGA 再次向 EEPROM 存 储芯片发送起始信号，一个时钟周期过后，计数器 cnt_ i2c_clk 完成一个周期计数，计数器 cnt_ i2c_clk 计数到 3，状态机跳转到 SEND_RD_ADDR(发送读控制状态)；    在此状态下，按时序向 EEPROM 写入控制指令，控制指令高 7 位为器件地址，最低位 为读写控制字，写入“1”，表示执行读操作。当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计 数到 7，两计数器同时归 0，状态机跳转到 ACK_5(应答状态)；    在 ACK_5(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，状态机跳转 到 RD_DATA(读数据状态)；读数据状态下，主机读取从机发送的单字节数据，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，数据读取完成，计数器清 0，状态机跳转到 N_ACK(非应答状态)；在非应答状态下，向 EEPROM 写入一个时钟的高电平，当 cnt_ i2c_clk 计数 3，状态机跳转到 STOP(停止状态)。    在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次随机数据读操作完 成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c844ac970c4e331bb4259a5372a63cb7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3502bc1d7fd38855b0b7f7a688156c7a.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a9f2151c7bafded4a203e9e302ce02b.png"></p><p>可以看到主要决定状态机状态<strong>跳转的判断条件</strong> 是<strong>cnt_ i2c_clk 计数到 3、应答信号 ack 有效、cnt_bit 计数到 7</strong></p><pre><code>    **第三部分** ：输出串行时钟 i2c_scl、串行数据信号 i2c_sda、读出数据 rd_data 及相关信号的波形设计与实现串口数据 sda 端口作为一个双向端口，在随机读操作中，主机只在除应答状态、读数据状态之外的其他状态拥有它的控制权，在应答状态下主机接收由从机通过 sda 传入的应答信号，在读数据状态下主机接收由从机传入的单字节数据。声明使能信号 sda_en，只在除应答状态、读数据状态之外的其他状态赋值为有效的高电平，sda_en 有效时，主机拥有 对 sda 的控制权。    声明 i2c_sda_reg 作为输出 i2c_sda 信号的数据缓存；声明 rd_data_reg 作为 EEPROM 读 出数据缓存。    i2c_sda_reg 在使能信号 sda_en 无效时始终保持高电平，在使能 sda_en 有效时，在状态机对应状态下，以计数器 cnt_ i2c_clk、cnt_bit 为约束条件，对应写入起始信号、控制指令、存储地址、写入数据、停止信号；在状态机处于读数据状态时，变量 rd_data_reg 由输入信号 sda_in 赋值，暂存 EEPROM 读取数据。    当 sda_en 有效时，将 i2c_sda_reg 赋值给 i2c_sda；当 sda_en 无效时，**i2c_sda 保持高阻 态。主机放弃对 sda 端口的控制；在状态机处于读数据状态时，变量 rd_data_reg 暂存 EEPROM 读取数据，读数据状态结束后，将暂存数据赋值给输出信号 rd_data** 。    对于输出的串行时钟 i2c_clk，由 I2C 通讯协议可知，I2C 设备只在串行时钟为高电平时进行数据采集，在串行时钟低电平时实现串行数据更新。我们使用计数器 cnt_ i2c_clk、 cnt_bit 以及状态变量 state 为约束条件，结合 I2C 通讯协议，生成满足时序要求的输出串行 时钟 i2c_clk。    输出串行时钟 i2c_scl、串行数据信号 i2c_sda、读出数据 rd_data 及相关信号波形图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5807cf4689a02cb0d3cc686a4d8d115e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/724069bcb981b658644f954820b36b02.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/31e7abe3c09fafe03c928c4066ed76e5.png"></p><h5 id="【3】代码设计"><a href="#【3】代码设计" class="headerlink" title="【3】代码设计"></a>【3】代码设计</h5><pre><code>module  i2c_ctrl#(    parameter   DEVICE_ADDR     =   7&#39;b1010_000     ,   //i2c设备地址    parameter   SYS_CLK_FREQ    =   26&#39;d50_000_000  ,   //输入系统时钟频率    parameter   SCL_FREQ        =   18&#39;d250_000         //i2c设备scl时钟频率)(    input   wire            sys_clk     ,   //输入系统时钟,50MHz    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效    input   wire            wr_en       ,   //输入写使能信号    input   wire            rd_en       ,   //输入读使能信号    input   wire            i2c_start   ,   //输入i2c触发信号    input   wire            addr_num    ,   //输入i2c字节地址字节数    input   wire    [15:0]  byte_addr   ,   //输入i2c字节地址    input   wire    [7:0]   wr_data     ,   //输入i2c设备数据    output  reg             i2c_clk     ,   //i2c驱动时钟    output  reg             i2c_end     ,   //i2c一次读/写操作完成    output  reg     [7:0]   rd_data     ,   //输出i2c设备读取数据    output  reg             i2c_scl     ,   //输出至i2c设备的串行时钟信号scl    inout   wire            i2c_sda         //输出至i2c设备的串行数据信号sda);//************************************************************************////******************** Parameter and Internal Signal *********************////************************************************************************//// parameter defineparameter   CNT_CLK_MAX     =   (SYS_CLK_FREQ/SCL_FREQ) &gt;&gt; 2&#39;d3   ;   //cnt_clk计数器计数最大值parameter   CNT_START_MAX   =   8&#39;d100; //cnt_start计数器计数最大值parameter   IDLE            =   4&#39;d00,  //初始状态            START_1         =   4&#39;d01,  //开始状态1            SEND_D_ADDR     =   4&#39;d02,  //设备地址写入状态 + 控制写            ACK_1           =   4&#39;d03,  //应答状态1            SEND_B_ADDR_H   =   4&#39;d04,  //字节地址高八位写入状态            ACK_2           =   4&#39;d05,  //应答状态2            SEND_B_ADDR_L   =   4&#39;d06,  //字节地址低八位写入状态            ACK_3           =   4&#39;d07,  //应答状态3            WR_DATA         =   4&#39;d08,  //写数据状态            ACK_4           =   4&#39;d09,  //应答状态4            START_2         =   4&#39;d10,  //开始状态2            SEND_RD_ADDR    =   4&#39;d11,  //设备地址写入状态 + 控制读            ACK_5           =   4&#39;d12,  //应答状态5            RD_DATA         =   4&#39;d13,  //读数据状态            N_ACK           =   4&#39;d14,  //非应答状态            STOP            =   4&#39;d15;  //结束状态// wire  definewire            sda_in          ;   //sda输入数据寄存wire            sda_en          ;   //sda数据写入使能信号// reg   definereg     [7:0]   cnt_clk         ;   //系统时钟计数器,控制生成clk_i2c时钟信号reg     [3:0]   state           ;   //状态机状态reg             cnt_i2c_clk_en  ;   //cnt_i2c_clk计数器使能信号reg     [1:0]   cnt_i2c_clk     ;   //clk_i2c时钟计数器,控制生成cnt_bit信号reg     [2:0]   cnt_bit         ;   //sda比特计数器reg             ack             ;   //应答信号reg             i2c_sda_reg     ;   //sda数据缓存reg     [7:0]   rd_data_reg     ;   //自i2c设备读出数据//************************************************************************////******************************* Main Code ******************************////************************************************************************//// cnt_clk:系统时钟计数器,控制生成clk_i2c时钟信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_clk &lt;=  8&#39;d0;    else    if(cnt_clk == CNT_CLK_MAX - 1&#39;b1)        cnt_clk &lt;=  8&#39;d0;    else        cnt_clk &lt;=  cnt_clk + 1&#39;b1;// i2c_clk:i2c驱动时钟always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        i2c_clk &lt;=  1&#39;b1;    else    if(cnt_clk == CNT_CLK_MAX - 1&#39;b1)        i2c_clk &lt;=  ~i2c_clk;// cnt_i2c_clk_en:cnt_i2c_clk计数器使能信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_i2c_clk_en  &lt;=  1&#39;b0;    else    if((state == STOP) &amp;&amp; (cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))        cnt_i2c_clk_en  &lt;=  1&#39;b0;    else    if(i2c_start == 1&#39;b1)        cnt_i2c_clk_en  &lt;=  1&#39;b1;// cnt_i2c_clk:i2c_clk时钟计数器,控制生成cnt_bit信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_i2c_clk &lt;=  2&#39;d0;    else    if(cnt_i2c_clk_en == 1&#39;b1)        cnt_i2c_clk &lt;=  cnt_i2c_clk + 1&#39;b1;// cnt_bit:sda比特计数器always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_bit &lt;=  3&#39;d0;    else    if((state == IDLE) || (state == START_1) || (state == START_2)                || (state == ACK_1) || (state == ACK_2) || (state == ACK_3)                || (state == ACK_4) || (state == ACK_5) || (state == N_ACK))        cnt_bit &lt;=  3&#39;d0;    else    if((cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 2&#39;d3))        cnt_bit &lt;=  3&#39;d0;    else    if((cnt_i2c_clk == 2&#39;d3) &amp;&amp; (state != IDLE))        cnt_bit &lt;=  cnt_bit + 1&#39;b1;// state:状态机状态跳转always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        state   &lt;=  IDLE;    else    case(state)        IDLE:            if(i2c_start == 1&#39;b1)                state   &lt;=  START_1;            else                state   &lt;=  state;        START_1:            if(cnt_i2c_clk == 3)                state   &lt;=  SEND_D_ADDR;            else                state   &lt;=  state;        SEND_D_ADDR:            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  ACK_1;            else                state   &lt;=  state;        ACK_1:            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))                begin                    if(addr_num == 1&#39;b1)                        state   &lt;=  SEND_B_ADDR_H;                    else                        state   &lt;=  SEND_B_ADDR_L;                end             else                state   &lt;=  state;        SEND_B_ADDR_H:            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  ACK_2;            else                state   &lt;=  state;        ACK_2:            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))                state   &lt;=  SEND_B_ADDR_L;            else                state   &lt;=  state;        SEND_B_ADDR_L:            if((cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 3))                state   &lt;=  ACK_3;            else                state   &lt;=  state;        ACK_3:            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))                begin                    if(wr_en == 1&#39;b1)                        state   &lt;=  WR_DATA;                    else    if(rd_en == 1&#39;b1)                        state   &lt;=  START_2;                    else                        state   &lt;=  state;                end             else                state   &lt;=  state;        WR_DATA:            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  ACK_4;            else                state   &lt;=  state;        ACK_4:            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))                state   &lt;=  STOP;            else                state   &lt;=  state;        START_2:            if(cnt_i2c_clk == 3)                state   &lt;=  SEND_RD_ADDR;            else                state   &lt;=  state;        SEND_RD_ADDR:            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  ACK_5;            else                state   &lt;=  state;        ACK_5:            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))                state   &lt;=  RD_DATA;            else                state   &lt;=  state;        RD_DATA:            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  N_ACK;            else                state   &lt;=  state;        N_ACK:            if(cnt_i2c_clk == 3)                state   &lt;=  STOP;            else                state   &lt;=  state;        STOP:            if((cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))                state   &lt;=  IDLE;            else                state   &lt;=  state;        default:    state   &lt;=  IDLE;    endcase// ack:应答信号always@(*)    case    (state)        IDLE,START_1,SEND_D_ADDR,SEND_B_ADDR_H,SEND_B_ADDR_L,        WR_DATA,START_2,SEND_RD_ADDR,RD_DATA,N_ACK:            ack &lt;=  1&#39;b1;        ACK_1,ACK_2,ACK_3,ACK_4,ACK_5:            if(cnt_i2c_clk == 2&#39;d0)                ack &lt;=   sda_in /* 1&#39;b0 */;            else                ack &lt;=  ack;        default:    ack &lt;=  1&#39;b1;    endcase// i2c_scl:输出至i2c设备的串行时钟信号sclalways@(*)    case    (state)        IDLE:            i2c_scl &lt;=  1&#39;b1;        START_1:            if(cnt_i2c_clk == 2&#39;d3)                i2c_scl &lt;=  1&#39;b0;            else                i2c_scl &lt;=  1&#39;b1;        SEND_D_ADDR,ACK_1,SEND_B_ADDR_H,ACK_2,SEND_B_ADDR_L,        ACK_3,WR_DATA,ACK_4,START_2,SEND_RD_ADDR,ACK_5,RD_DATA,N_ACK:            if((cnt_i2c_clk == 2&#39;d1) || (cnt_i2c_clk == 2&#39;d2))                i2c_scl &lt;=  1&#39;b1;            else                i2c_scl &lt;=  1&#39;b0;        STOP:            if((cnt_bit == 3&#39;d0) &amp;&amp;(cnt_i2c_clk == 2&#39;d0))                i2c_scl &lt;=  1&#39;b0;            else                i2c_scl &lt;=  1&#39;b1;        default:    i2c_scl &lt;=  1&#39;b1;    endcase// i2c_sda_reg:sda数据缓存always@(*)    case    (state)        IDLE:            begin                i2c_sda_reg &lt;=  1&#39;b1;                rd_data_reg &lt;=  8&#39;d0;            end        START_1:            if(cnt_i2c_clk &lt;= 2&#39;d0)                i2c_sda_reg &lt;=  1&#39;b1;            else                i2c_sda_reg &lt;=  1&#39;b0;        SEND_D_ADDR:            if(cnt_bit &lt;= 3&#39;d6)                i2c_sda_reg &lt;=  DEVICE_ADDR[6 - cnt_bit];            else                i2c_sda_reg &lt;=  1&#39;b0;        ACK_1:            i2c_sda_reg &lt;=  1&#39;b1;        SEND_B_ADDR_H:            i2c_sda_reg &lt;=  byte_addr[15 - cnt_bit];        ACK_2:            i2c_sda_reg &lt;=  1&#39;b1;        SEND_B_ADDR_L:            i2c_sda_reg &lt;=  byte_addr[7 - cnt_bit];        ACK_3:            i2c_sda_reg &lt;=  1&#39;b1;        WR_DATA:            i2c_sda_reg &lt;=  wr_data[7 - cnt_bit];        ACK_4:            i2c_sda_reg &lt;=  1&#39;b1;        START_2:            if(cnt_i2c_clk &lt;= 2&#39;d1)                i2c_sda_reg &lt;=  1&#39;b1;            else                i2c_sda_reg &lt;=  1&#39;b0;        SEND_RD_ADDR:            if(cnt_bit &lt;= 3&#39;d6)                i2c_sda_reg &lt;=  DEVICE_ADDR[6 - cnt_bit];            else                i2c_sda_reg &lt;=  1&#39;b1;        ACK_5:            i2c_sda_reg &lt;=  1&#39;b1;        RD_DATA:            if(cnt_i2c_clk  == 2&#39;d2)                rd_data_reg[7 - cnt_bit]    &lt;=  sda_in;            else                rd_data_reg &lt;=  rd_data_reg;        N_ACK:            i2c_sda_reg &lt;=  1&#39;b1;        STOP:            if((cnt_bit == 3&#39;d0) &amp;&amp; (cnt_i2c_clk &lt; 2&#39;d3))                i2c_sda_reg &lt;=  1&#39;b0;            else                i2c_sda_reg &lt;=  1&#39;b1;        default:            begin                i2c_sda_reg &lt;=  1&#39;b1;                rd_data_reg &lt;=  rd_data_reg;            end    endcase// rd_data:自i2c设备读出数据always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_data &lt;=  8&#39;d0;    else    if((state == RD_DATA) &amp;&amp; (cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 2&#39;d3))        rd_data &lt;=  rd_data_reg;// i2c_end:一次读/写结束信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        i2c_end &lt;=  1&#39;b0;    else    if((state == STOP) &amp;&amp; (cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))        i2c_end &lt;=  1&#39;b1;    else        i2c_end &lt;=  1&#39;b0;// sda_in:sda输入数据寄存assign  sda_in = i2c_sda;// sda_en:sda数据写入使能信号assign  sda_en = ((state == RD_DATA) || (state == ACK_1) || (state == ACK_2)                    || (state == ACK_3) || (state == ACK_4) || (state == ACK_5))                    ? 1&#39;b0 : 1&#39;b1;// i2c_sda:输出至i2c设备的串行数据信号sdaassign  i2c_sda = (sda_en == 1&#39;b1) ? i2c_sda_reg : 1&#39;bz;endmodule    代码中有一处，读者要注意，经计算，生成 i2c_clk 时钟信号的计数器 cnt_clk 一个循环周期计数 25 次满足要求，但此处计数器 cnt_clk 计数最大值 CNT_CLK_MAX 并未直接赋值，而是使用公式赋值。parameter CNT_CLK_MAX = (SYS_CLK_FREQ/SCL_FREQ) &gt;&gt; 2&#39;d3 ;     这是为了提高 I2C 驱动模块的复用性，参数 **SYS_CLK_FREQ** 表示系统时钟 sys_clk 时钟频率，参数 **SCL_FREQ** 表示输出串行时钟 i2c_scl 时钟频率；两参数做除法运算，结果右移一位结表示除 2，得到的结果用于**分频计数器计数最大值** ，可直接由系统时钟分频产生串行时钟 i2c_scl 时钟信号；结果继续右移两位表示除 4，作为分频计数器计数最大值， 可产生时钟信号 **i2c_clk** ，时钟频率为串行时钟 **i2c_scl 时钟频率的 4 倍** 。 这样一来，只要设置好系统时钟与串行时钟的时钟频率，本模块即可在多种时钟频率下使用，复用性大大提高。 </code></pre><h4 id="（3）数据收发模块"><a href="#（3）数据收发模块" class="headerlink" title="（3）数据收发模块"></a>（3）数据收发模块</h4><pre><code>    数据收发模块的主要功能是：为 I2C 驱动模块**提供读/写数据存储地址** 、**待写入数据** 以及作为 **EEPROM 读出数据缓存** ，待数据读取完成后将读出数据**发送给数码管** 显示模块进行数据示。        </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1eabdb473fb9d49eb26921b67ba45288.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e9d9b2f0b9d41c7067ec9a6cd74b3c2b.png"></p><pre><code>    由图表可知，I2C 驱动模块包括 13 路输入输出信号，其中输入信号 7 路、输出信号 6 路。    输入信号中，有 2 路时钟信号和 1 路复位信号，sys_clk 为系统时钟信号，在数据收发模块中用于采集读/写触发信号 read 和 write，2 路触发信号均由外部按键输出，经消抖处理后传入本模块，消抖模块使用的时钟信号为与 sys_clk 相同的系统时钟，所以读/写触发信号的采集要使用系统时钟；i2c_clk 为模块工作时钟，由 I2C 驱动模块生成并传入，是存储地址、读/写数据以及使能信号的同步时钟，因为 I2C 模块的工作时钟为 i2c_clk 时钟信号，两模块工作时钟相同，不会出现时钟不同引起时序问题；复位信号 sys_rst_n，低电平有效，不必多说；i2c_end 为单字节数据读/写接数信号，由 I2C 驱动模块产生并传入，告 知数据生成模块单字节数据读/写操作完成。若连续读/写多字节数据，此信号可作为存储地址、写数据的更新标志；rd_data 为 I2C 驱动模块传入的数据信号，表示由 EEPROM 读出的字节数据。    输出信号中，**rd_en、wr_en 分别为读写使能信号** ，生成后传入 I2C 驱动模块，作为 I2C 驱动模块读/写操作的判断标志；i2c_start 是单字节数据读/写开始信号，作为 I2C 驱动模块单字节读/写操作开始的标志信号；byte_addr 为读写数据存储地址；wr_data 为待写入 EEPROM 的字节数据；**fifo_rd_data 为自 EEPROM 读出的字节数据，要发送到数码换显示模块在数码管显示出来** 。    注：数据收发模块内部**实例化一个 FIFO** ，将读出 EEPROM 的字节数据做**暂存** ，待**所有数据读取完成后，开始向数码管发送数据** 。例如本实验向 EEPROM 连续写入 10 个字节数据，随后将写入数据读出并在数码管显示，数据收发模块只有接收到读出的 10 个字节数据后，才会开始向数码管显示模块发送数据。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50887563f603498a62193a654156c9c0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0209b025d932bf0f3184f96236101d7e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c37479538b21c177100541d00510745f.png"></p><h5 id="【1】写数据操作部分"><a href="#【1】写数据操作部分" class="headerlink" title="【1】写数据操作部分"></a>【1】写数据操作部分</h5><pre><code>    **第一部分** ：输出写使能信号 wr_en 及其相关信号波形的设计与实现    外部按键传入的写触发信号经消抖处理后传入本模块，该信号只保持一个有效时钟， 且同步时钟为系统时钟 sys_clk，模块工作时钟 i2c_clk 很难采集到该触发信号。我们需要**延长该写使能触发信号的有效时间** ，使模块工作时钟 i2c_clk 可以采集到该触发信号。    声明计数器 cnt_wr 和写有效信号 wr_valid 两信号的同步时钟均为系统时钟 sys_clk，当外部传入有效的写触发信号 write，写有效信号 wr_valid 拉高，计数器 cnt_wr 来时计数，计数器计数到设定值(200)后归 0，写有效信号拉低。计数器 cnt_wr 计数设定值可自主设定，只要能使 **wr_valid 信号保持一个工作时钟周期高电平即可** 。计数器 cnt_wr 和写有效信号 wr_valid 波形图如下：</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/231d2a6b838d3c39c536be23ca2454f6.png"></p><pre><code>    写有效信号 wr_valid 拉高后，工作时钟 i2c_clk 上升沿采集到 wr_valid 高电平，拉高写使能信号 wr_en，告知 I2C 驱动模块接下来要进行数据写操作。在此次实验我们要连续写入 10 字节数据，所以写使能信号 wr_en 要保持 10 次数据写操作的有效时间，在这一时间段我们要**输出 10 次有效的 i2c_start 信号** ，在接收到第 10 次 i2c_end 信号后，表示 10 字节 数据均已写入完成，将**写使能信号 rw_en 拉低** ，完成 10 字节数据的连续写入。 要实现这一操作我们需要声明 2 个变量，声明**字节计数器 wr_i2c_data_num** 对已写入 字节进行计数；由数据手册可知，两次相邻的读/写操作之间需要一定的**时间间隔，以保证 上一次读/写操作完成** ，所以声明计数器 **cnt_start** ，对相邻读/写操作**时间间隔进行计数** 。 采集到写有效信号 wr_valid 为高电平，拉高写使能信号 wr_en，计数器 **cnt_wait** 、 wr_i2c_data_num 均由 0 开始计数，每一个工作时钟周期 cnt_wait 自加 1，计数到最大值 1499，i2c_start 保持一个工作时钟的高电平，同时 cnt_wait 归 0，重新开始计数；I2C 驱动模块接收到有效的 i2c_start 信号后，向 EEPROM 写入单字节数据，传回 i2c_end 信号，表示一次单字节写操作完毕，计数器 wr_i2c_data_num 加 1；计数器 cnt_start 完成 10 次循环 计数，i2c_start 拉高 10 次，在接收到第 10 次有效的 i2c_end 信号后，表示连续 10 字节数 据写入完毕，将写使能信号 wr_en 拉低，写操作完毕。相关信号波形如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b26cbb5556b0e75db6eae9f5e4854b8d.png"></p><pre><code>    **第二部分** ：输出存储地址 byte_addr、写数据 wr_data 信号波形的设计与实现    既然是对 EEPROM 中写数据操作，存储地址和写数据必不可少，在本从实验中，向 EEPROM 中 10 个连续存储存储单元写入 10 字节数据。对输出存储地址 byte_addr，赋值**初始存储地址** ，当 i2c_end 信号有效时，地址加 1，待 10 字节数据均写入完毕，再次赋值初始从从地址；对于写数据 wr_data 处理方式相同，先赋值写数据初值，当 i2c_end 信号有效时，写数据加1，待 10 字节数据均写入完毕，在此赋值写数据初值。两输出信号波形如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7aefb6d791d0e5b2ee40791a003868d2.png"></p><h5 id="【2】读数据操作部分"><a href="#【2】读数据操作部分" class="headerlink" title="【2】读数据操作部分"></a>【2】读数据操作部分</h5><pre><code>   延长该读使能触发信号的有效时间，使模块工作时钟 i2c_clk 可以采集到该触发信号。声明计数器 cnt_rd 和读有效信号 rd_valid 两信号，延长读触发信号 read 有效时间，使 i2c_clk 时钟能采集到该读触发信号。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/807dba7ae4cedc9edcfd57af4d0a16da.png"></p><pre><code>    对于读使能信号的处理方式也与写操作方式相同，工作时钟 i2c_clk 上升沿采集到有效 rd_valid 信号，拉高读使能信号 **rd_en** ，告知 I2C 驱动模块接下来要进行数据读操作。    声明字节计数器 rd_i2c_data_num 对已读出字节进行计数；使用之前声明的计数器 **cnt_start** ，对相邻读/写操作**时间间隔进行计数** 。    采集到读有效信号 rd_valid 为高电平，拉高 rd_en，计数器 cnt_wait、 rd_i2c_data_num 均由 0 开始计数，每一个工作时钟周期 cnt_wait 自加 1，计数到最大值 1499，i2c_start 保持一个工作时钟的高电平，同时 cnt_wait 归 0，重新开始计数；I2C 驱动模块接收到有效的 i2c_start 信号后，自 EEPROM 读出单字节数据，传回 i2c_end 信号，表 示一次单字节写操作完毕，计数器 rd_i2c_data_num 加 1；计数器 cnt_start 完成 10 次循环计 数，i2c_start 拉高 10 次，在接收到第 10 次有效的 i2c_end 信号后，表示连续 10 字节数据 写入完毕，将读使能信号 rd_en 拉低，读操作完毕。相关信号波形如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e2a77dfc171149e04c16efba72151793.png"></p><pre><code>    既然是数据读操作，自然有读出数据传入本模块，一次读操作连续读出 10 字节数据， 先将读取的 10 字节数据暂存到内部例化的 FIFO 中，以传回的 i2c_end 结束信号为写使能，在 i2c_clk 时钟同步下将读出数据写入 FIFO 中。同时我们将 FIFO 的数据计数器引出，方便后续数据发送阶段的操作。相关信号波形图如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/48ccb6e9de9b9a2775173b221db5bbf9.png"></p><pre><code>    对于存储地址信号 byte_addr 的讲解，读者参阅写操作部分相关介绍，此处不再赘述， 接下来开始数据发送部分各信号波形的讲解。    等到读取的 10 字节均写入 FIFO 中，FIFO 数据计数器 data_num 显示为 10，表示 FIFO 中存有 10 字节读出数据。此时拉高 FIFO 读有效信号 fifo_rd_valid，只有信号 fifo_rd_valid 为有效高电平，对 FIFO 的读操作才有效；fifo_rd_valid 有效时，计数器 cnt_wait 开始循环计数，声明此计数器的目的是计数字节数据读出时间间隔，间隔越长，每字节数据在数码 管显示时间越长，方面现象观察；当计数器 cnt_wait 计数到最大值时，归 0 重新计数， FIFO 读使能信号信号 fifo_rd_en 拉高一个时钟周期，自 FIFO 读出一个字节数据，由 fifo_rd_data 将数据传出给数码管显示模块，读出字节计数器 rd_data_num 加 1；等到 10 字 节数据均读取并传出后，fifo_rd_valid 信号拉低，数据发送操作完成。相关信号波形如下。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a252e7dbc6797d1f315a8c7a7f10f427.png"></p><h5 id="【3】代码设计-1"><a href="#【3】代码设计-1" class="headerlink" title="【3】代码设计"></a>【3】代码设计</h5><pre><code>module  i2c_rw_data(    input   wire            sys_clk     ,   //输入系统时钟,频率50MHz    input   wire            i2c_clk     ,   //输入i2c驱动时钟,频率1MHz    input   wire            sys_rst_n   ,   //输入复位信号,低有效    input   wire            write       ,   //输入写触发信号    input   wire            read        ,   //输入读触发信号    input   wire            i2c_end     ,   //一次i2c读/写结束信号    input   wire    [7:0]   rd_data     ,   //输入自i2c设备读出的数据    output  reg             wr_en       ,   //输出写使能信号    output  reg             rd_en       ,   //输出读使能信号    output  reg             i2c_start   ,   //输出i2c读/写触发信号    output  reg     [15:0]  byte_addr   ,   //输出i2c设备读/写地址    output  reg     [7:0]   wr_data     ,   //输出写入i2c设备的数据    output  wire    [7:0]   fifo_rd_data    //输出自fifo中读出的数据);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************//// parameter  defineparameter   DATA_NUM        =   8&#39;d10       ,   //读/写操作读出或写入的数据个数            CNT_START_MAX   =   16&#39;d4000    ,   //cnt_start计数器计数最大值            CNT_WR_RD_MAX   =   8&#39;d200      ,   //cnt_wr/cnt_rd计数器计数最大值            CNT_WAIT_MAX    =   28&#39;d500_000 ;   //cnt_wait计数器计数最大值// wire  definewire    [7:0]   data_num    ;   //fifo中数据个数// reg   definereg     [7:0]   cnt_wr          ;   //写触发有效信号保持时间计数器reg             write_valid     ;   //写触发有效信号reg     [7:0]   cnt_rd          ;   //读触发有效信号保持时间计数器reg             read_valid      ;   //读触发有效信号reg     [15:0]  cnt_start       ;   //单字节数据读/写时间间隔计数reg     [7:0]   wr_i2c_data_num ;   //写入i2c设备的数据个数reg     [7:0]   rd_i2c_data_num ;   //读出i2c设备的数据个数reg             fifo_rd_valid   ;   //fifo读有效信号reg     [27:0]  cnt_wait        ;   //fifo读使能信号间时间间隔计数reg             fifo_rd_en      ;   //fifo读使能信号reg     [7:0]   rd_data_num     ;   //读出fifo数据个数//********************************************************************////***************************** Main Code ****************************////********************************************************************////cnt_wr:写触发有效信号保持时间计数器,计数写触发有效信号保持时钟周期数always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_wr    &lt;=  8&#39;d0;    else    if(write_valid == 1&#39;b0)        cnt_wr    &lt;=  8&#39;d0;    else    if(write_valid == 1&#39;b1)        cnt_wr    &lt;=  cnt_wr + 1&#39;b1;//write_valid:写触发有效信号//由于写触发信号保持时间为一个系统时钟周期(20ns),//不能被i2c驱动时钟i2c_scl正确采集,延长写触发信号生成写触发有效信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        write_valid    &lt;=  1&#39;b0;    else    if(cnt_wr == (CNT_WR_RD_MAX - 1&#39;b1))        write_valid    &lt;=  1&#39;b0;    else    if(write == 1&#39;b1)        write_valid    &lt;=  1&#39;b1;//cnt_rd:读触发有效信号保持时间计数器,计数读触发有效信号保持时钟周期数always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_rd    &lt;=  8&#39;d0;    else    if(read_valid == 1&#39;b0)        cnt_rd    &lt;=  8&#39;d0;    else    if(read_valid == 1&#39;b1)        cnt_rd    &lt;=  cnt_rd + 1&#39;b1;//read_valid:读触发有效信号//由于读触发信号保持时间为一个系统时钟周期(20ns),//不能被i2c驱动时钟i2c_scl正确采集,延长读触发信号生成读触发有效信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        read_valid    &lt;=  1&#39;b0;    else    if(cnt_rd == (CNT_WR_RD_MAX - 1&#39;b1))        read_valid    &lt;=  1&#39;b0;    else    if(read == 1&#39;b1)        read_valid    &lt;=  1&#39;b1;//cnt_start:单字节数据读/写操作时间间隔计数always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_start   &lt;=  16&#39;d0;    else    if((wr_en == 1&#39;b0) &amp;&amp; (rd_en == 1&#39;b0))        cnt_start   &lt;=  16&#39;d0;    else    if(cnt_start == (CNT_START_MAX - 1&#39;b1))        cnt_start   &lt;=  16&#39;d0;    else    if((wr_en == 1&#39;b1) || (rd_en == 1&#39;b1))        cnt_start   &lt;=  cnt_start + 1&#39;b1;//i2c_start:i2c读/写触发信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        i2c_start   &lt;=  1&#39;b0;    else    if((cnt_start == (CNT_START_MAX - 1&#39;b1)))        i2c_start   &lt;=  1&#39;b1;    else        i2c_start   &lt;=  1&#39;b0;//wr_en:输出写使能信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wr_en   &lt;=  1&#39;b0;    else    if((wr_i2c_data_num == DATA_NUM - 1)                 &amp;&amp; (i2c_end == 1&#39;b1) &amp;&amp; (wr_en == 1&#39;b1))        wr_en   &lt;=  1&#39;b0;    else    if(write_valid == 1&#39;b1)        wr_en   &lt;=  1&#39;b1;//wr_i2c_data_num:写入i2c设备的数据个数always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wr_i2c_data_num &lt;=  8&#39;d0;    else    if(wr_en == 1&#39;b0)        wr_i2c_data_num &lt;=  8&#39;d0;    else    if((wr_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))        wr_i2c_data_num &lt;=  wr_i2c_data_num + 1&#39;b1;//rd_en:输出读使能信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_en   &lt;=  1&#39;b0;    else    if((rd_i2c_data_num == DATA_NUM - 1)                 &amp;&amp; (i2c_end == 1&#39;b1) &amp;&amp; (rd_en == 1&#39;b1))        rd_en   &lt;=  1&#39;b0;    else    if(read_valid == 1&#39;b1)        rd_en   &lt;=  1&#39;b1;//rd_i2c_data_num:写入i2c设备的数据个数always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_i2c_data_num &lt;=  8&#39;d0;    else    if(rd_en == 1&#39;b0)        rd_i2c_data_num &lt;=  8&#39;d0;    else    if((rd_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))        rd_i2c_data_num &lt;=  rd_i2c_data_num + 1&#39;b1;//byte_addr:输出读/写地址always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        byte_addr   &lt;=  16&#39;h00_5A;    else    if((wr_en == 1&#39;b0) &amp;&amp; (rd_en == 1&#39;b0))        byte_addr   &lt;=  16&#39;h00_5A;    else    if(((wr_en == 1&#39;b1) || (rd_en == 1&#39;b1)) &amp;&amp; (i2c_end == 1&#39;b1))        byte_addr   &lt;=  byte_addr + 1&#39;b1;//wr_data:输出待写入i2c设备数据always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wr_data &lt;=  8&#39;h01;    else    if(wr_en == 1&#39;b0)        wr_data &lt;=  8&#39;h01;    else    if((wr_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))        wr_data &lt;=  wr_data + 1&#39;b1;//fifo_rd_valid:fifo读有效信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        fifo_rd_valid  &lt;=  1&#39;b0;    else    if((rd_data_num == DATA_NUM)                &amp;&amp; (cnt_wait == (CNT_WAIT_MAX - 1&#39;b1)))        fifo_rd_valid  &lt;=  1&#39;b0;    else    if(data_num == DATA_NUM)        fifo_rd_valid  &lt;=  1&#39;b1;//cnt_wait:fifo读使能信号间时间间隔计数,计数两fifo读使能间的时间间隔always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_wait    &lt;=  28&#39;d0;    else    if(fifo_rd_valid == 1&#39;b0)        cnt_wait    &lt;=  28&#39;d0;    else    if(cnt_wait == (CNT_WAIT_MAX - 1&#39;b1))        cnt_wait    &lt;=  28&#39;d0;    else    if(fifo_rd_valid == 1&#39;b1)        cnt_wait    &lt;=  cnt_wait + 1&#39;b1;//fifo_rd_en:fifo读使能信号always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        fifo_rd_en &lt;=  1&#39;b0;    else    if((cnt_wait == (CNT_WAIT_MAX - 1&#39;b1))                &amp;&amp; (rd_data_num &lt; DATA_NUM))        fifo_rd_en &lt;=  1&#39;b1;    else        fifo_rd_en &lt;=  1&#39;b0;//rd_data_num:自fifo中读出数据个数计数always@(posedge i2c_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_data_num &lt;=  8&#39;d0;    else    if(fifo_rd_valid == 1&#39;b0)        rd_data_num &lt;=  8&#39;d0;    else    if(fifo_rd_en == 1&#39;b1)        rd_data_num &lt;=  rd_data_num + 1&#39;b1;//****************************************************************////************************* Instantiation ************************////****************************************************************////------------- fifo_read_inst -------------fifo_read   fifo_read_inst(    .clk        (i2c_clk            ),  //输入时钟信号,频率1MHz,1bit    .din        (rd_data            ),  //输入写入数据,1bit    .rd_en      (fifo_rd_en         ),  //输入数据读请求,1bit    .wr_en      (i2c_end &amp;&amp; rd_en   ),  //输入数据写请求,1bit    .dout       (fifo_rd_data       ),  //输出读出数据,1bit    .data_count (data_num           )   //输出fifo内数据个数,1bit);endmodule</code></pre><h4 id="（4）仿真设计"><a href="#（4）仿真设计" class="headerlink" title="（4）仿真设计"></a>（4）仿真设计</h4><pre><code>module  tb_eeprom_byte_rd_wr();//wire definewire            scl ;wire            sda ;wire    [5:0]   sel ;wire    [7:0]   seg ;//reg definereg           clk   ;reg           rst_n ;reg           key_wr;reg           key_rd;//时钟、复位信号initial  begin    clk     =   1&#39;b1  ;    rst_n   &lt;=  1&#39;b0  ;    key_wr  &lt;=  1&#39;b1  ;    key_rd  &lt;=  1&#39;b1  ;    #200    rst_n   &lt;=  1&#39;b1  ;    #1000    key_wr  &lt;=  1&#39;b0  ;    key_rd  &lt;=  1&#39;b1  ;    #400    key_wr  &lt;=  1&#39;b1  ;    key_rd  &lt;=  1&#39;b1  ;    #20000000    key_wr  &lt;=  1&#39;b1  ;    key_rd  &lt;=  1&#39;b0  ;    #400    key_wr  &lt;=  1&#39;b1  ;    key_rd  &lt;=  1&#39;b1  ;    #40000000    $stop;  endalways  #10 clk = ~clk;defparam eeprom_byte_rd_wr_inst.key_wr_inst.CNT_MAX = 5;defparam eeprom_byte_rd_wr_inst.key_rd_inst.CNT_MAX = 5;defparam eeprom_byte_rd_wr_inst.i2c_rw_data_inst.CNT_WAIT_MAX = 1000;//-------------eeprom_byte_rd_wr_inst-------------eeprom_byte_rd_wr   eeprom_byte_rd_wr_inst(    .sys_clk        (clk    ),    //输入工作时钟,频率50MHz    .sys_rst_n      (rst_n  ),    //输入复位信号,低电平有效    .key_wr         (key_wr ),    //按键写    .key_rd         (key_rd ),    //按键读    .sda            (sda    ),    //串行数据    .scl            (scl    ),    //串行时钟    .seg            (seg    ),    //数码管段选信号    .sel            (sel    )     //数码管位选信号);//-------------eeprom_inst-------------M24LC64  M24lc64_inst(    .A0     (1&#39;b0       ),  //器件地址    .A1     (1&#39;b0       ),  //器件地址    .A2     (1&#39;b0       ),  //器件地址    .WP     (1&#39;b0       ),  //写保护信号,高电平有效    .RESET  (~rst_n     ),  //复位信号,高电平有效    .SDA    (sda        ),  //串行数据    .SCL    (scl        )   //串行时钟);endmodule    拓展训练：将串口 RS232 与 EEPROM 读写工程结合起来，使用 PC 机通过串口发送指令和和数据实现 EEPROM 数据读写操作。</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132818565">https://blog.csdn.net/qq_32971095/article/details/132818565</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础设计二（IP核）——FPGA学习笔记＜3＞</title>
      <link href="/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%8C%EF%BC%88IP%E6%A0%B8%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C3%EF%BC%9E/"/>
      <url>/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%8C%EF%BC%88IP%E6%A0%B8%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C3%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8">一.IP核的使用</a></p><p><a href="about:blank#1.PLL%20IP%E6%A0%B8">1.PLL IP核</a></p><p><a href="about:blank#%3C1%3EPLL%E7%AE%80%E4%BB%8B">&lt;1&gt;PLL简介</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;2&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p><p><a href="about:blank#2.ROM%20IP%E6%A0%B8">2.ROM IP核</a></p><p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#%E2%91%B4%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6.coe%E6%96%87%E4%BB%B6">⑴创建初始化文件.coe文件</a></p><p><a href="about:blank#%E2%91%B5%E5%8D%95%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑵单端口 ROM<br>的配置</a></p><p><a href="about:blank#%E2%91%B6%E5%8F%8C%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑶双端口 ROM<br>的配置</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p><p><a href="about:blank#3.RAM%20IP%E6%A0%B8">3.RAM IP核</a></p><p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#%E2%91%B4%E5%8D%95%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑴单端口 ROM<br>的配置</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;2&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#4.FIFO%20IP%E6%A0%B8">4.FIFO IP核</a></p><p><a href="about:blank#%E2%91%B4SCFIFO%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑴SCFIFO 的配置</a></p><p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p><p><a href="about:blank#%E2%91%B5DCFIFO%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑵DCFIFO 的配置</a></p><p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p><p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p><p><a href="about:blank#%E2%91%B6%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98">⑶注意问题</a></p><hr><p>前置学习：</p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="设计流程——FPGA学习笔记＜2＞">设计流程——FPGA学习笔记＜2＞</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p><p>参考书目：《野火FPGA Verilog 开发实战指南》</p><h2 id="一-IP核的使用"><a href="#一-IP核的使用" class="headerlink" title="一.IP核的使用"></a>一.IP核的使用</h2><pre><code>    IP 核有三种不同的存在形式：HDL 语言形式，网表形式、版图形式。分别对应我们常说的三类 IP 内核：软核、固核和硬核。    软核是用硬件描述语言的形式功能块的行为，并不涉及用什么电路和电路元件实现这 些行为，软 IP 通常是**以硬件描述语言 HDL 源文件** 的形式出现，应用开发过程与普通的 HDL 设计也十分相似，大多数应用于 FPGA 的 IP 内核均为软核，软核有助于用户调节参 数并增强可复用性。软核**通常以加密形式提供** ，这样实际的 RTL 对用户是不可见的，但布局和布线灵活。在这些加密的软核中，**如果对内核进行了参数化，那么用户就可通过头文件或图形用户接口（GUI）方便地对参数进行操作** 。软 IP 的设计周期短，设计投入少。由 于不涉及物理实现，为后续设计留有很大的发挥空间，增大了 IP 的灵活性和适应性。其主 要缺点是在一定程度上使后续工序无法适应整体设计，从而需要一定程度的软 IP 修正，在性能上也不可能获得全面的优化。由于软核是以源代码的形式提供，尽管源代码可以采用加密方法，但其知识产权保护问题不容忽视。    固核则是软核和硬核的折衷。固核是完成了综合的功能块，有较大的设计深度，以网表的形式交给客户使用。对于那些对时序要求严格的内核（如 PCIE 接口内核），可预布线特定信号或分配特定的布线资源，以满足时序要求。这些内核可归类为固核，由于内核 是预先设计的代码模块，因此这有可能影响包含该内核的整体设计。由于内核的建立时 间、保持时间和握手信号都可能是固定的，因此其它电路的设计时都必须考虑与该内核进 行正确地接口。如果内核具有固定布局或部分固定的布局，那么这还将影响其它电路的布局。    硬核是完成提供设计的最终阶段产品——掩膜（Mask），以经过完全的布局布线的网 表形式提供，这种硬核既具有可预见性，同时还可以针对特定工艺或购买商进行功耗和尺寸上的优化。尽管硬核由于缺乏灵活性而可移植性差，但由于无须提供寄存器转移级 （RTL）文件，因而更易于实现 IP 保护。比如一些 FPGA 芯片内置的 ARM 核就是硬核。</code></pre><p>IP 核在拥有以上众多好处的同时也有他的巨大缺点：  </p><p> 1、在<strong>跨平台时，IP 核往往不通用</strong> ，需要重新设计。IP 核都是不全透明的，是每个 FPGA 开发厂商根据自己芯片适配的定制<br>IP，所以如果你之前用的 Altera 的芯片，用了一 个 PLL，但是因为某些原因需要将代码移植到 Xilinx 平台上，那就必须要将 PLL 给重新替<br>换掉，着增加了代码移植的复杂性。</p><p>2、IP 核就是个黑匣子，是<strong>不透明</strong> 的，我们往往看不到其核心代码。IP 核都是各大 FPGA 厂商专门设计的，都会进行<strong>加密</strong><br>，内核代码都看不到，如果你使用的这个 IP<br>核万一出现了问题或者需要知道其内部结构针对具体的应用进行定制优化时，你是无法进行修改的。以上两个问题就很棘手，所以<strong>有些公司坚持所有的可综合设计都不使用<br>IP 核，就是为了是所有的模块都能够掌控在在自己手里。</strong></p><p>3、有些定制的 IP 核由于是不通用的，往往会有较高的收费，这也是一笔巨大的开 销。所以 IP<br>核在能够加快我们开发周期的情况下也存在以上三种常见的问题，这就是需要 我们权衡利弊，针对具体的需求来做具体的选择。</p><p>IP 核生成工具提供的 IP 核主要有以下几类：</p><p>1、数学运算模块，包括累加器、乘加器、乘累加器、计数器、加&#x2F;减法器、实&#x2F;复数乘 法器、除法器、CORDIC 算法器、DSP48 宏和浮点数操作器。</p><p>2、存储器构造模块，包括块存储器和分布式存储器、先入先出存储器（FIFO）和移位寄存器。 3、DSP<br>功能，包括直接数字频率合成（DDS）编译器、数字上变频&#x2F;下变频 （DUC&#x2F;DDC）编译器、有限冲激响应（FIR）滤波器、级联积分梳状（CIC）滤波器、离<br>散傅里叶变换（DFT）和快速傅里叶变换（FFT）。</p><p>4、信道纠错码，包括 RS 码编码器和译码器、卷积码编码器、Viterbi 译码器、Turbo 码编&#x2F;译码器和低密度奇偶校验码（LDPC）编码器等。</p><p>5、网络应用，包括媒体访问控制器（MAC）、以太网物理编码子层&#x2F;物理介质连接<br>（PCS&#x2F;PMA）、网络负载统计、以太网拓展连接单元接口（XAUI）、减少引脚使用的 XAUI（RXAUI）、MAC 封装包和音&#x2F;视频桥接（AVB）端点。</p><p>6、FPGA 结构属性，包括时钟向导、高速串行收发器（GTX&#x2F;GTP）和系统监视向导。</p><p>7、连接器，包括标准总线接口（如 PCI&#x2F;PCI-X、PCI Express、CAN）和数据接口（如 以太网、RapidIO 等）。</p><p>8、调试和验证，包括逻辑调试内核（集成控制器核（ICON）、集成逻辑分析核 （ILA）、虚拟输入&#x2F;输出核（VIO）、Agilent<br>跟踪核（ATC2）、误比特率测试核 （IBERT）和集成总线分析核（IBA）。</p><p>9、针对不同设计方法的特殊IP核，包括用工程导航工具进行逻辑设计的IP核、用<br>Xilinx系统生成工具进行DSP算法设计的IP核，以及用Xilinx平台开发环境（XPS）或 PlanAhead进行嵌入式设计的IP核。</p><h3 id="1-PLL-IP核"><a href="#1-PLL-IP核" class="headerlink" title="1.PLL IP核"></a>1.PLL IP核</h3><h4 id="PLL简介"><a href="#PLL简介" class="headerlink" title="&lt;1&gt;PLL简介"></a>&lt;1&gt;PLL简介</h4><pre><code>    PLL（Phase Locked Loop，即锁相环）是最常用的 IP 核之一，其性能强大，可以对输入到 FPGA 的时钟信号进行任意**分频、倍频、相位调整、占空比调整** ，从而输出一个期望时钟，实际上，即使不想改变输入到 FPGA 时钟的任何参数，也常常会使用 PLL，因为经 过 PLL 后的时钟在抖动（Jitter）方面的性能更好一些。Xilinx 中的 PLL 是模拟锁相环，和数字锁相环不同的是**模拟锁相环** 的优点是**输出的稳定度高、相位连续可调、延时连续可调** ；缺点是当**温度过高或者电磁辐射过强时会失锁** （普通环境下不考虑该问题）。</code></pre><p><strong>工作原理</strong> ：</p><pre><code>    1、首先需要参考时钟（ref_clk）通过**鉴频（FD）鉴相器（PD）** 和需要比较的时钟频率进行比较，我们以频率调整为例，如果参考时钟频率等于需要比较的时钟频率则鉴频鉴相器输出为 0，如果参考时钟频率大于需要比较的时钟频率则鉴频鉴相器输出一个变大的成正比的值，如果参考时钟频率小于需要比较的时钟频率则鉴频鉴相器输出一个变小的正比的值。    2、鉴频鉴相器的输出连接到** _环路_ 滤波器（LF）**上，用于控制噪声的带宽，**滤掉高频噪声** ，使之稳定在一个值，起到将带有噪声的波形变平滑的作用。如果鉴频鉴相器之前的波形抖动比较大，经过环路滤波器后抖动就会变小，**趋近于信号的平均值** 。    3、经过环路滤波器的输出连接到** _压控_ 振荡器（VCO）**上，环路滤波器输出的电压可以控制 VCO 输出频率的大小，环路滤波器输出的电压越大 VCO 输出的频率越高，然后将这个频率信号连接到鉴频鉴相器作为需要比较的频率。 如果 ref_clk 参考时钟输入的频率和需要比较的时钟频率不相等，该系统最终实现的就是让它们**逐渐相等并稳定下来** 。如果 ref_clk 参考时钟的频率是 50MHz，经过整个闭环反馈系统后，锁相环对外输出的时钟频率 pll_out 也是 50MHz。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/274a1b99ce88f7fabcba88e6ee3f1a26.png"></p><pre><code>    **倍频实现** ：倍频是在 **VCO 后直接加一级分频器** ，我们知道 ref_clk 参考时钟输入的频率和需要比较的时钟频率经过闭环反馈系统后最终会保持频率相等，而在需要比较的时钟之前加入分频器，就会使进入分频器之前的信号频率为需要比较的时钟频率的倍数，VCO 后输出的 pll_out 信号频率就是 ref_clk 参考时钟倍频后的结果。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a0b93e3ee21781dd2ef71e93e013b7f.png"></p><pre><code>    **分频实现** ：分频是在 **ref_clk 参考时钟后加一级分频器** ，这样需要比较的时钟频率就始终和 ref_clk 参考时钟分频后的频率相等，在 VCO 后输 出的 pll_out 信号就是 ref_clk 参考时钟分频后的结果。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f036569d6714c19ca076417fac7171cc.png"></p><h4 id="xilinx-vivado-IP核配置"><a href="#xilinx-vivado-IP核配置" class="headerlink" title="&lt;2&gt;xilinx vivado IP核配置"></a>&lt;2&gt;xilinx vivado IP核配置</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a60f7c9a83f3e41601ca6bafa50a4d7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d786b3bd2e5b1c4223912ded98e6dd3f.png"></p><p>②框选项区别在于左上Resoursce栏使用资源的不同</p><p>Clocking Features选择功能，左上Switch To Defaults恢复默认</p><p>Documentation可打开官方手册</p><p>IP Location选择核存放位置</p><p>接下来配置输出：这里输出四路信号，注意各个参数（<strong>期望和实际输出、相位&#x2F;占空比调整</strong> ）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cc03fe6e0a562e0631c4fdd0bb30ec9a.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9bca276789b7c6f78709a555880eb0dd.png"></p><p>生成之后可以在工程中看到我们生成的 IP 核，双击 IP 核可进入配置界面，对 IP 核的相关参数进行更改。</p><h4 id="xilinx-vivado-IP核调用"><a href="#xilinx-vivado-IP核调用" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h4><p> （拷贝调用： 要求同版本开发IDE。直接复制IP核文件夹，位置在source里的ip文件夹）新工程添加设计文件，点击后缀为xci的文件。</p><p>通过实例化对IP核进行调用，可从多个文件中选择复制。如下是一种办法：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/074776a8f290ace02f39615b2d040dc6.png"></p><p>或者找到IP核下的.veo文件，其中也包含实例化模版</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9136cc140a3a9a316d989e8dfca6e10b.png"></p><p>再编写一个顶层设计文件来例化这个 PLL IP 核：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1824668d82cca9e65be6ebe3bf79987d.png"></p><p>仿真：</p><pre><code>`timescale  1ns/1nsmodule tb_pll();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg     sys_clk     ;//wire  definewire    clk_mul_2   ;wire    clk_div_2   ;wire    clk_phase_90;wire    clk_ducle_20;wire    locked      ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟initial sys_clk = 1&#39;b1;//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhzalways #10 sys_clk = ~sys_clk;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------pll_inst------------------------pll pll_inst(    .sys_clk        (sys_clk        ),  //input     sys_clk    .clk_mul_2      (clk_mul_2      ),  //output    clk_mul_2    .clk_div_2      (clk_div_2      ),  //output    clk_div_2    .clk_phase_90   (clk_phase_90   ),  //output    clk_phase_90    .clk_ducle_20   (clk_ducle_20   ),  //output    clk_ducle_20    .locked         (locked         )   //output    locked);endmodule</code></pre><h3 id="2-ROM-IP核"><a href="#2-ROM-IP核" class="headerlink" title="2.ROM IP核"></a>2.ROM IP核</h3><pre><code>    ROM 是**只读存储器（Read-Only Memory）** 的简称，是一种只能读出事先所存数据的固态半导体存储器。 其特性是一旦储存资料就无法再将之改变或删除，**且资料不会因为电源关闭而消失** 。而事实上在 FPGA 中通过 IP 核生成的 ROM 或 RAM（RAM 将在下一节为大家讲解）调用的**都是 FPGA 内部的 RAM 资源** ，**掉电内容都会丢失** （这也很容易解释，FPGA 芯片内部本来 就没有掉电非易失存储器单元）。用 IP 核生成的 ROM 模块只是**提前添加了数据文件 （.coe 格式）** （Quartus II中是mif/nex文件），**在 FPGA 运行时通过数据文件给 ROM 模块初始化** ，才使得 ROM 模块像个 “真正”的掉电非易失存储器；也正是这个原因，ROM 模块的内容必须提前在数据文件中 写死，无法在电路中修改。         Xilinx 推出的 ROM IP 核分为两种类型：**单端口 ROM（Single-Port Rom）和双端口 ROM（Dual-Port ROM）** 。对于单端口 ROM 提供一个读地址端口和一个读数据端口，只能进行读操作；双端口 ROM 与单端口 ROM 类似，区别是其提供两个读地址端口和两个读数 据端口，基本上**可以看做两个单口 ROM 拼接而成** 。下面是 ROM 不同配置模式存储器的接口信号图</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ec5a640e49917f4840c4ca3c15742b60.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39d6daa7b05762402544c85107019209.png"></p><h4 id="xilinx-vivado-IP核配置-1"><a href="#xilinx-vivado-IP核配置-1" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h4><h5 id="⑴创建初始化文件-coe文件"><a href="#⑴创建初始化文件-coe文件" class="headerlink" title="⑴创建初始化文件.coe文件"></a>⑴创建初始化文件.coe文件</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ccd8980974bd3fa8b4fdce24cd3f8fe8.png"><br>        该文件的格式较为简单，第一行是定义数据的格式，其中 16 表示 数据格式为 16 进制，也可将数据格式定义为二进制和八进制，只需将 16 改为 2 或 8 即 可。其中第 3 到第 18 行是 16*8bit 大小 ROM 的初始化数据。</p><h5 id="⑵单端口-ROM-的配置"><a href="#⑵单端口-ROM-的配置" class="headerlink" title="⑵单端口 ROM 的配置"></a>⑵单端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8085df36a1e00f03bf8ec852afc0f5e2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2e78260a857973e7e77d95b658b3b5d8.png"></p><pre><code>    给该 IP 核取名为rom_256x8（rom 是我们调用的 IP 核，**256 是调用的 IP 核容量，8 是调用的 IP 核数据位宽** 。这里这样命名是为了方便识别我们创建的 IP 核类型及资源量）。    3 框中选择存储器类型，可供选择的类型有：Single Port RAM（单端口 RAM）、 Simple Dual Port RAM（简单双口 RAM）、True Dual Port RAM（真双口 RAM）、Singl Port ROM（单端口 ROM）、Doul Port ROM（双端口 ROM）。这里我们选择“Single Port Rom”单端口 ROM。    4 框在 Algorithm 一栏中可选择用于实现内存的算法，其中 Minimum Area 为最小面积 算法；Low Power 为低功耗算法；Fixed Primitives 为固定单元算法。这里我们按默认选择 Minimum Area 即可。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/790b6532330c243f14b65c359514812d.png"></p><pre><code>    1 框中是设置存储数据的位宽，这里我们设置为 8 位；    2 框中是设置数据深度，所谓深度其实就是个数的选择，即设置的 ROM 可以存储多 少个 8 位宽的数据，这里我们设置为 256；这样我们设置的 ROM 和最大能存储的数据即为 256 x 8bit。（注意：设置的容量需大于我们需要写入的数据文件的数据量）    3 框中选择是否创建端口使能信号，这里我们不创建，选择“Always Enabled”始终 使能。    4 框是选择是否创建输出端口寄存器，** _若创建了择输出数据则会延后一个时钟输出_** ， 这里我们不创建。    5 框是选择是否生产复位信号，这里我们不创建。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/14d99e61cee29c3ecc71c15ca55c8275.png"></p><p>添加初始化coe文件</p><h5 id="⑶双端口-ROM-的配置"><a href="#⑶双端口-ROM-的配置" class="headerlink" title="⑶双端口 ROM 的配置"></a>⑶双端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7538ac4b37f9a0e1ab940d76c1c9a54.png"></p><pre><code>    对端口 A 的设置跟单端口 ROM 的设置一样即可。对端口 B 的设置，这里我们只需对 B 端口的数据位宽设置即可，数据深度会根据端口 A 的位宽自动设置。例如我们端口 A 设置的数据位宽为 8bit，深度为 256；而我们 B 端 口设置的数据位宽为 16bit，则其深度即为 128，其数据总量是一样的。其余设置与端口 A 设置一样即可。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59a531959f333f68e956985587bcc348.png"></p><p>剩余操作与单端口 ROM 相同</p><h5 id="xilinx-vivado-IP核调用-1"><a href="#xilinx-vivado-IP核调用-1" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>`timescale  1ns/1nsmodule  rom(    input   wire            sys_clk ,   //系统时钟，频率50MHz    input   wire    [7:0]   addra   ,   //输入rom地址    output  wire    [7:0]   douta       //输出rom数据);//********************************************************************////*************************** Instantiation **************************////********************************************************************////----------------rom_256x8_inst---------------rom_256x8 rom_256x8_inst(    .clka   (sys_clk    ), // input clka    .addra  (addra      ), // input  [7 : 0] addra    .douta  (douta      )  // output [7 : 0] douta);endmodule</code></pre><p>仿真：</p><pre><code>`timescale  1ns/1nsmodule  tb_rom();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg         sys_clk     ;reg         sys_rst_n   ;reg [7:0]   addra       ;//wire  definewire    [7:0]   douta   ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////对sys_clk,sys_rst赋初值，并模拟按键抖动initial    begin            sys_clk     =   1&#39;b1 ;            sys_rst_n   &lt;=  1&#39;b0 ;    #200    sys_rst_n   &lt;=  1&#39;b1 ;    end    //sys_clk:模拟系统时钟，每10ns电平取反一次，周期为20ns，频率为50Mhzalways  #10 sys_clk =   ~sys_clk;//让地址从0~255循环always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        addra   &lt;=  8&#39;d0;    else    if(addra == 8&#39;d255)        addra   &lt;=  8&#39;d0;    else        addra   &lt;=  addra   +   1&#39;b1;//********************************************************************////*************************** Instantiation **************************////********************************************************************////---------------rom_inst--------------rom rom_inst(    .sys_clk     (sys_clk   ),   //系统时钟，频率50MHz    .addra       (addra     ),   //输入rom地址    .douta       (douta     )    //输出rom数据);endmodule</code></pre><p>通过reg变量进行手动赋值仿真，wire变量引出输出结果</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc49853964c20fc15b53b0176631ac29.png"></p><h3 id="3-RAM-IP核"><a href="#3-RAM-IP核" class="headerlink" title="3.RAM IP核"></a>3.RAM IP核</h3><pre><code>    RAM 是**随机 存取存储器（Random Access Memory）**的简称，是一个易失性存储器。 RAM 工作时可以**随时从任何一个指定的地址写入或读出数据** ，同时我们还能修改其存储的数据，即写入新的数据，这是 ROM 所并不具备的功能。在 FPGA 中这也是其与 ROM 的最大区别。**ROM 是只读存储器，而 RAM 是可写可读存储器** ，在我们 FPGA 中使用这两个存储器主要也是要区分这一点，因为这**两个存储器使用的都是我们 FPGA 内部的 RAM 资源，不同的是 ROM 是只用到了 RAM 资源的读数据端口** 。 Xilinx 推出的 RAM IP 核分为两种类型：单端口 RAM 和双端口 RAM。其中双端口 RAM 又分为简单双端口 RAM 和真正双端口 RAM。对于单端口 RAM， _**读写操作共用一组地址线，读写操作不能同时进行；对于简单双端口 RAM，读操作和写操作有专用地址端口 （一个读端口和一个写端口），即写端口只能写不能读，而读端口只能读不能写；对于真正双端口 RAM，有两个地址端口用于读写操作（两个读/写端口），即两个端口都可以进行读写。**_</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c138921d867b29ade86307accec8a2bd.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7676d6bbc9ea22f2b9315547c234d66.png"></p><h5 id="xilinx-vivado-IP核配置-2"><a href="#xilinx-vivado-IP核配置-2" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h5><h5 id="⑴单端口-ROM-的配置"><a href="#⑴单端口-ROM-的配置" class="headerlink" title="⑴单端口 ROM 的配置"></a>⑴单端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b07438a39423a20b261db7f1f923058.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9aede4ded03495c40d4069e1d2d36603.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/28198190f61b0884d06f953d2688a724.png"></p><pre><code>    2 框中是操作模式的选择。RAM 读写操作模式共分为三种，非别是 Write First（写优 先模式）、Read First（读优先模式）和 No Change（不变模式）。    Write First（写优先模式）：若我们在在同一个时钟沿下对同一个地址进行读写，则**读出的数据为写入的数据** 。    Read First（读优先模式）：若我们在在同一个时钟沿下对同一个地址进行读写，则**读出的数据为该地址写入数据前存储的数据** 。    No Change（不变模式）：在该模式下**不能同时进行读写操作** ，输出数据为同时读写操作前输出的数据。     加载数据文件时，同 ROM 一样，RAM 也可以加载初始 化文件，但是 RAM 是可以写入数据的，所以这里可以选择不加，该页面按默认设置即可。</code></pre><p>注：（真）双端口 ROM 的配置类似</p><h4 id="xilinx-vivado-IP核配置-3"><a href="#xilinx-vivado-IP核配置-3" class="headerlink" title="&lt;2&gt;xilinx vivado IP核配置"></a>&lt;2&gt;xilinx vivado IP核配置</h4><pre><code>    RTL 顶层的输入信号有：50MHz 的系统时钟 sys_clk、输入 256 个 8bit 地址 addra（值 为十进制 0~256）、输入 256 个 8bit 的数据 dina（值为十进制 0~255）和伴随该输入数据的 写使能信号 wea。这些输入信号需要在 Testbench 中产生激励。    RTL 顶层的输出信号有：从 RAM 中读取的数据 douta。</code></pre><p>RTL 顶层代码如下所示：</p><pre><code>`timescale  1ns/1nsmodule  ram(    input   wire            sys_clk     ,   //系统时钟，频率50MHz    input   wire    [7:0]   addra       ,   //输入ram读写地址    input   wire    [7:0]   dina        ,   //输入ram写入数据    input   wire            wea         ,   //输入ram写使能        output  wire    [7:0]   douta           //输出读ram数据);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////---------------ram_256x8_inst--------------ram_256x8   ram_256x8_inst (    .clka       (sys_clk    ),  //使用系统时钟作为读写时钟    .addra      (addra      ),  //读写地址线    .dina       (dina       ),  //输入写入RAM的数据    .wea        (wea        ),  //写RAM使能    .douta      (douta      )   //输出读RAM数据);endmodule</code></pre><p>仿真代码：</p><pre><code>`timescale  1ns/1nsmodule  tb_ram();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg         sys_clk     ;reg         sys_rst_n   ;reg [7:0]   addra       ;reg         wea         ;reg         wr_flag     ;//wire  definewire    [7:0]   dina    ;wire    [7:0]   douta   ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////对sys_clk,sys_rst赋初值，并模拟按键抖动initial    begin            sys_clk     =   1&#39;b1 ;            sys_rst_n   &lt;=  1&#39;b0 ;    #200    sys_rst_n   &lt;=  1&#39;b1 ;    end    //sys_clk:模拟系统时钟，每10ns电平取反一次，周期为20ns，频率为50Mhzalways  #10 sys_clk =   ~sys_clk;//写完成标志信号always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wr_flag &lt;=  1&#39;b0;    else    if(addra == 8&#39;d255)        wr_flag &lt;=  1&#39;b1;    else        wr_flag &lt;=  wr_flag;//wea:产生写RAM使能信号always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        wea   &lt;=  1&#39;b0;    else    if(wr_flag == 1&#39;b1)        wea  &lt;=  1&#39;b0;    else        wea  &lt;=  1&#39;b1;//addra：读写地址（0~255循环）always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        addra    &lt;=  8&#39;d0;    else    if(addra == 8&#39;d255)        addra    &lt;=  8&#39;d0;    else        addra    &lt;=  addra + 1&#39;b1;//写使能为高时产生写数据0~255assign  dina =   (wea == 1&#39;b1) ? addra : 8&#39;d0;//********************************************************************////*************************** Instantiation **************************////********************************************************************////---------------ram_inst--------------ram ram_inst(    .sys_clk    (sys_clk    ),   //系统时钟，频率50MHz    .addra      (addra      ),   //输入ram读写地址    .dina       (dina       ),   //输入ram写入数据    .wea        (wea        ),   //输入ram写使能        .douta      (douta      )    //输出读ram数据);endmodule     这里我们截取了前面我们讲到的 Write First 模式以及 No Change 模式下的仿真波形图；**从 Write First 模式仿真图看一看到，当我们往 RAM 里写数据时，就有数据读出了；而从 No Change 模式下的波形图可以看到，当我们往 RAM 里写数据时，是不同同时进行数据读取的，读数据端口会输出读写操作前的输出数据，这里为 0。**</code></pre><h3 id="4-FIFO-IP核"><a href="#4-FIFO-IP核" class="headerlink" title="4.FIFO IP核"></a>4.FIFO IP核</h3><pre><code>    FIFO（First In First Out，即先入先出），是一种**数据缓冲器** ，用来实现数据先入先出的读写方式。与 ROM 或 RAM 的按地址读写方式不同，FIFO 的读写遵循“先进先出”的原则，即数据按顺序写入 FIFO，先被写入的数据同样在读取的时候先被读出，所以 **FIFO 存储器没有地址线** 。FIFO 有**一个写端口和一个读端口** 外部无需使用者控制地址，使用方便。 FIFO 存储器主要是作为缓存，应用在同步时钟系统和异步时钟系统中，在很多的设计中都会使用，后面实例中如： _多比特数据做跨时钟域的转换、前后带宽不同步等都用到了 FIFO_ 。FIFO 根据读写时钟是否相同，分为**SCFIFO（同步 FIFO）和 DCFIFO（异步 FIFO）** ，SCFIFO 的读写为同一时钟，应用在同步时钟系统中；DCFIFO 的读写时钟不同，应用在异步时钟系统中。</code></pre><p>可参考：<a href="https://reborn.blog.csdn.net/article/details/108553930" title="FPGA设计心得（11）关于FIFO IP核使用的一点注意事项">FPGA设计心得（11）关于FIFO<br>IP核使用的一点注意事项</a></p><h4 id="⑴SCFIFO-的配置"><a href="#⑴SCFIFO-的配置" class="headerlink" title="⑴SCFIFO 的配置"></a><strong>⑴SCFIFO 的配置</strong></h4><h5 id="xilinx-vivado-IP核配置-4"><a href="#xilinx-vivado-IP核配置-4" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c106fa7567b9a84b4d3cb8480483a57a.png">​</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a853439259bb2a5f665df76c626314e1.png">​</p><pre><code>    3 框是选中 FIFO 的类型，以及使用什么资源来实现。这里我们选择“Common Clock Block RAM”使用块 RAM 来实现同步 FIFO；其中 Common Clock 表示是同步 FIFO， Block RAM 表示的是块 RAM 资源。可以从界面中的表格查看各类型区别</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1bcb36c171301bf55732cb8a0fd259a7.png">​</p><pre><code>    1 框中是对模式的选择，这里我们选择标准 FIFO（Standard FIF0）即可。    若3框下选项选择异步复位（Asynchronous Reset），还会多出安全电路使能选项    若3框上选项选中输出端口寄存器，可选择相应寄存器</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2678aece1ef8c870530c111406c36f6d.png">​</p><pre><code>    1 框中可勾选生成 FIFO 几乎满（Almost Full Flag），几乎空（Almost Empty Flag）输 出信号；也就是说若勾选了这两个信号，当 FIFO 存储数据快满或者快空的时候，该信号 就有效。这里大家可根据自己的实际需求进行勾选，这里我们选择都不勾选。    2 框中可勾选生成写确认标志信号，用于报告写操作成功。若勾选后可以配置为高电 平有效或低电平有效，这里我们选择不勾选。    3 框中可勾选生成溢出标志信号；该标志信号可以指示 FIFO 内存储数据是否溢出， 可以指示上一次写操作何时失败。若勾选后可以配置为高电平有效或低电平有效，这里我 们选择不勾选。    4 框中可勾选生成指示输出总线上数据何时有效的有效标志信号。若勾选后可以配置 为高电平有效或低电平有，这里我们选择不勾选。    5 框中可勾选生成下溢标志信号；该标志信号可以指示 FIFO 内存储数据空了，可以 指示上一次的读请求何时失败。若勾选后可以配置为高电平有效或低电平有效，这里我们 选择不勾选。 这些选项可以根据自己的设计需求进行勾选，这里我们按默认都不勾选，直接切换到 “Data Counts”页面。</code></pre><h5 id="xilinx-vivado-IP核调用-2"><a href="#xilinx-vivado-IP核调用-2" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>    RTL 代码顶层的输入信号有：50MHz 的系统时钟 sys_clk、输入 256 个 8bit 的数据 pi_data（值为十进制 0~255）和伴随该输入数据有效的标志信号 pi_flag、FIFO 的写请求信 号 rd_en。这些输入信号需要在 Testbench 中产生激励。    RTL 代码顶层的输出信号有：从 FIFO 中读取的数据 po_data、FIFO 空标志信号 empty、FIFO 满标志信号 full、指示 FIFO 中存在数据个数的信号 data_count。这些信号也是我们需要通过仿真 SCFIFO IP 核主要观察的信号，这些信号通过 Testbench 中给输入信号激励后产生输出。`timescale  1ns/1nsmodule fifo(    input   wire            sys_clk     ,   //系统时钟50Mhz    input   wire            sys_rst_n   ,   //复位信号    input   wire    [7:0]   pi_data     ,   //输入顶层模块的数据                                            //要写入到FIFO中的数据    input   wire            pi_flag     ,   //输入数据有效标志信号                                            //也作为FIFO的写请求信号    input   wire            rd_en       ,   //FIFO读请求信号    output  wire    [7:0]   po_data     ,   //FIFO读出的数据    output  wire            empty       ,   //FIFO空标志信号，高有效    output  wire            full        ,   //FIFO满标志信号，高有效    output  wire    [7:0]   data_count      //FIFO中存在的数据个数);//********************************************************************////*************************** Instantiation **************************////********************************************************************//scfifo_256x8 scfifo_256x8_inst(    .clk       (sys_clk   ),    // input clk    .srst      (~sys_rst_n),    // input srst    .din       (pi_data   ),    // input [7 : 0] din    .wr_en     (pi_flag   ),    // input wr_en    .rd_en     (rd_en     ),    // input rd_en    .dout      (po_data   ),    // output [7 : 0] dout    .full      (full      ),    // output full    .empty     (empty     ),    // output empty    .data_count(data_count)     // output [7 : 0] data_count    );endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/803786cc93ca0a0583f559f08f092a06.png"></p><p>仿真：</p><pre><code>    下面是 Testbench 仿真测试文件，和 SCFIFO 的仿真一样，我们也需要给输入信号测试激励，pi_flag 每 4 个时钟周期且没有读请求时产生一个数据有效标志信号也作为 FIFO 的写请求信号，因为需要 pi_data 伴随着 pi_flag 一起产生，所以每当 pi_data 检测到 pi_flag 标 志信号有效时就自加 1，其值从 0~255 循环变化，这样我们就可以在 pi_flag 标志信号有效时将 pi_data 写入到 FIFO 中。而 FIFO 的读请求信号 rd_en 当 FIFO 的满标志信号 full 有效时拉高，当 FIFO 的空标志信号 empty 有效时拉低。`timescale  1ns/1nsmodule tb_fifo();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg         sys_clk     ;reg [7:0]   pi_data     ;reg         pi_flag     ;reg         rd_en       ;reg         sys_rst_n   ;reg [1:0]   cnt_baud    ;//wire  definewire    [7:0]   po_data     ;wire            empty       ;wire            full        ;wire    [7:0]   data_count  ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、复位initial begin    sys_clk    = 1&#39;b1;    sys_rst_n &lt;= 1&#39;b0;    #200;    sys_rst_n &lt;= 1&#39;b1;end//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhzalways #10 sys_clk = ~sys_clk;//cnt_baud:计数从0到3的计数器，用于产生输入数据间的间隔always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_baud &lt;= 2&#39;b0;    else    if(&amp;cnt_baud == 1&#39;b1)        cnt_baud &lt;= 2&#39;b0;    else        cnt_baud &lt;= cnt_baud + 1&#39;b1;//pi_flag:输入数据有效标志信号，也作为FIFO的写请求信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_flag &lt;= 1&#39;b0;    //每4个时钟周期且没有读请求时产生一个数据有效标志信号    else    if((cnt_baud == 2&#39;d0) &amp;&amp; (rd_en == 1&#39;b0))        pi_flag &lt;= 1&#39;b1;    else        pi_flag &lt;= 1&#39;b0;//pi_data:输入顶层模块的数据，要写入到FIFO中的数据always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_data &lt;= 8&#39;b0;    //pi_data的值为0~255依次循环    else    if((pi_data == 8&#39;d255) &amp;&amp; (pi_flag == 1&#39;b1))        pi_data &lt;= 8&#39;b0;    else    if(pi_flag  == 1&#39;b1)    //每当pi_flag有效时产生一个数据        pi_data &lt;= pi_data + 1&#39;b1;//rd_en:FIFO读请求信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_en &lt;= 1&#39;b0;    else    if(full == 1&#39;b1)  //当FIFO中的数据存满时，开始读取FIFO中的数据        rd_en &lt;= 1&#39;b1;    else    if(empty == 1&#39;b1) //当FIFO中的数据被读空时停止读取FIFO中的数据        rd_en &lt;= 1&#39;b0;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------fifo_inst------------------------fifo fifo_inst(    .sys_clk    (sys_clk    ),  //input             sys_clk    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n    .pi_data    (pi_data    ),  //input     [7:0]   pi_data    .pi_flag    (pi_flag    ),  //input             pi_flag    .rd_en      (rd_en      ),  //input             rd_en    .po_data    (po_data    ),  //output    [7:0]   po_data    .full       (full       ),  //output            full    .empty      (empty      ),  //output            empty    .data_count (data_count )   //output    [7:0]   data_count);endmodule    可以看到 pi_data 和 po_data 交替出现并一直循环下去，pi_flag 数据有效标志信号伴随着 pi_data 一一对应，po_data 在读请求信号 rd_en 为高时输出。其中 我们也可以看到 empty 和 full 在不同的位置均有拉高的脉冲，接下来我们将图中位置 1 和 位置 2 分别放大观察。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00d7409a0130be8cc12feeb8788375d2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eca70840bd1db754c3bc3d701b1818ad.png"></p><p>如图所示为位置 1 放大后的波形，有几个点需要我们重点观察：</p><pre><code>    1、full、data_count 信号的状态：我们可以看到当 pi_flag 为高且 pi_data 为 255 的同时 full 满标志信号拉高了，说明 FIFO 的存储空间已经满了，而 data_count 信号也从 255 变成 了 0，因为产生的 SCFIFO IP 核中 data_count 的位宽是 8bit 的，**而十进制 256 需要 9bit 才能 完全显示，这样最高位就无法显示出来，所以 data_count 的值显示为** 0。    2、FIFO 读出的数据与 FIFO 读请求的关系：因为我们这里是对普通同步 FIFO 模式进行的仿真，所以可以看到当检测到 full 满标志信号有效，rd_en 读请求信号开始拉高，FIFO 开始读数据，FIFO 读出的第一个数据为 0，可以看到数据为 0 的时间有两个时钟周期，**所以第一个 0 为潜伏期导致的，第二个 0 才是我们真正读出来的数据** ，FIFO 中随着数据的读 出，FIFO 中的数据减少，full 满标志信号也拉低了，data_count 信号的值也随着减小。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f14c8432a6eb9fd004287a706d316a2.png"><br>如图所示为位置 2 放大后的波形，这里我们重点观察一下 empty 空标志信号。 因为我们使用的是标准<br>fifo，所以读出的数据要比读使能延后一拍，所以当读出十进制数 据 254 后 empty 空标志信号拉高，表示 FIFO 中的数据已经被读空。</p><h4 id="⑵DCFIFO-的配置"><a href="#⑵DCFIFO-的配置" class="headerlink" title="⑵DCFIFO 的配置"></a><strong>⑵DCFIFO 的配置</strong></h4><h5 id="1-xilinx-vivado-IP核配置"><a href="#1-xilinx-vivado-IP核配置" class="headerlink" title="**&lt; 1&gt;**xilinx vivado IP核配置"></a>**&lt; 1&gt;**xilinx vivado IP核配置</h5><p>与SCFIFO配置不同：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0fea968cb4005828177c4488c948c9c.png"></p><pre><code>    2 框中是选中 FIFO 的类型，以及使用什么资源来实现。这里我们选择“Independent Clock Block RAM”使用块 RAM 来实现异步 FIFO；其中 Independent Clock 表示是异步 FIFO，Block RAM 表示的是块 RAM 资源。 </code></pre><p>如图所示，可勾选“Write Data Count”和“Read Data Count”生成 FIFO<br>内剩余个数输出信号，一个是基于读时钟，一个是基于写时钟。该输出信号可根据自己设计是否需要进行生成，默认是不生成，这里我们都勾选进行生成。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0314ab41426a1bfe5a18823d095c43d4.png"></p><h5 id="xilinx-vivado-IP核调用-3"><a href="#xilinx-vivado-IP核调用-3" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>    RTL 代码顶层的输入信号有：50MHz 的写时钟 wr_clk、输入 256 个 8bit 的数据 pi_data （值为十进制 0~255）和伴随该输入数据有效的标志信号 pi_flag、25MHz 的读时钟 rd_clk、FIFO 的写请求信号 rd_en。这些输入信号需要在 Testbench 中产生激励。    RTL 代码顶层的输出信号有：FIFO 空标志信号 empty、FIFO 满标志信号 full、同步于 wr_clk 指示 FIFO 中存在数据个数的信号 wr_data_count、从 FIFO 中读取的数据 po_data、 同步于 rd_clk 指示 FIFO 中存在数据个数的信号 rd_data_count。这些信号也是我们需要通过仿真 DCFIFO IP 核主要观察的信号，这些信号通过 Testbench 中给输入信号激励后产生输出。`timescale  1ns/1nsmodule fifo(    input   wire         wr_clk    ,   //同步于FIFO写数据的时钟50MHz    input   wire  [7:0]  pi_data   ,   //输入顶层模块的数据，要写入到FIFO中                                       //的数据同步于wrclk时钟    input   wire         pi_flag   ,   //输入数据有效标志信号，也作为FIFO的                                       //写请求信号，同步于wrclk时钟    input   wire         rd_clk    ,   //同步于FIFO读数据的时钟25MHz    input   wire         rd_en     ,   //FIFO读请求信号，同步于rdclk时钟    output  wire  [15:0] po_data   ,   //FIFO读出的数据，同步于rdclk时钟    output  wire         empty     ,   //空标志信号，高有效，    output  wire         full      ,   //满标志信号，高有效，    output  wire  [6:0]  rd_data_count,//FIFO读端口中存在的数据个数，                                       //同步于rdclk时钟    output  wire  [7:0]  wr_data_count //FIFO写端口中存在的数据个数，                                       //同步于wrclk时钟);//----------------------dcfifo_256x8to128x16_inst-----------------------dcfifo_256x8to128x16    dcfifo_256x8to128x16_inst(    .din            (pi_data),  //input   [7:0]   din    .rd_clk         (rd_clk ),  //input           rd_clk    .rd_en          (rd_en  ),  //input           rd_en    .wr_clk         (wr_clk ),  //input           wr_clk    .wr_en          (pi_flag),  //input           wr_en    .dout           (po_data),  //output   [15:0] dout    .empty          (empty  ),  //output          empty    .full           (full   ),  //output          full    .rd_data_count  (rd_data_count),//output   [6:0]  rd_data_count    .wr_data_count  (wr_data_count) //output   [7:0]  wr_data_count);endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/58847d86d5164408b79f24c556aaf70e.png"></p><p>仿真：</p><pre><code>`timescale  1ns/1nsmodule tb_fifo();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg          wr_clk         ;reg  [7:0]   pi_data        ;reg          pi_flag        ;reg          rd_clk         ;reg          rd_en          ;reg          sys_rst_n      ;reg  [1:0]   cnt_baud       ;reg          full_reg0      ;reg          full_reg1      ;//wire  definewire            empty           ;wire            full            ;wire    [7:0]   wr_data_count   ;wire    [15:0]  po_data         ;wire    [6:0]   rd_data_count   ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化时钟、复位initial begin    wr_clk     = 1&#39;b1;    rd_clk     = 1&#39;b1;    sys_rst_n &lt;= 1&#39;b0;    #100;    sys_rst_n &lt;= 1&#39;b1;    #100000    sys_rst_n &lt;= 1&#39;b0;end//wr_clk:模拟FIFO的写时钟，每10ns电平翻转一次，周期为20ns，频率为50MHzalways #10 wr_clk = ~wr_clk;//rd_clk:模拟FIFO的读时钟，每20ns电平翻转一次，周期为40ns，频率为25MHzalways #20 rd_clk = ~rd_clk;//cnt_baud:计数从0到3的计数器，用于产生输入数据间的间隔always@(posedge wr_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_baud &lt;= 2&#39;b0;    else    if(&amp;cnt_baud == 1&#39;b1)        cnt_baud &lt;= 2&#39;b0;    else        cnt_baud &lt;= cnt_baud + 1&#39;b1;//pi_flag:输入数据有效标志信号，也作为FIFO的写请求信号always@(posedge wr_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_flag &lt;= 1&#39;b0;    //每4个时钟周期且没有读请求时产生一个数据有效标志信号    else    if((cnt_baud == 2&#39;d0) &amp;&amp; (rd_en == 1&#39;b0))        pi_flag &lt;= 1&#39;b1;    else        pi_flag &lt;= 1&#39;b0;//pi_data:输入顶层模块的数据，要写入到FIFO中的数据always@(posedge wr_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_data &lt;= 8&#39;b0;    pi_data的值为0~255依次循环    else    if((pi_data == 8&#39;d255) &amp;&amp; (pi_flag == 1&#39;b1))        pi_data &lt;= 8&#39;b0;    else    if(pi_flag  == 1&#39;b1)    //每当pi_flag有效时产生一个数据        pi_data &lt;= pi_data + 1&#39;b1;//将同步于rd_clk时钟的写满标志信号full在rd_clk时钟下打两拍always@(posedge rd_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)           begin            full_reg0 &lt;= 1&#39;b0;            full_reg1 &lt;= 1&#39;b0;        end    else        begin            full_reg0 &lt;= full;            full_reg1 &lt;= full_reg0;        end//rd_en:FIFO读请求信号同步于rd_clk时钟always@(posedge rd_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        rd_en &lt;= 1&#39;b0;//如果full信号有效就立刻读，则不会看到full信号拉高，//所以此处使用full在rd_clk时钟下打两拍后的信号    else    if(full_reg1 == 1&#39;b1)        rd_en &lt;= 1&#39;b1;    else    if(empty == 1&#39;b1)//当FIFO中的数据被读空时停止读取FIFO中的数据        rd_en &lt;= 1&#39;b0;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------fifo_inst------------------------fifo    fifo_inst(    .wr_clk  (wr_clk    ),  //input             wr_clk    .pi_data (pi_data   ),  //input     [7:0]   pi_data    .pi_flag (pi_flag   ),  //input             pi_flag    .rd_clk  (rd_clk    ),  //input             rd_clk    .rd_en   (rd_en     ),  //input             rd_en    .po_data (po_data   ),  //output    [15:0]  po_data    .empty   (empty     ),  //output            empty    .full    (full      ),  //output            full    .rd_data_count(rd_data_count),//output  [6:0]  rd_data_count    .wr_data_count(wr_data_count) //output  [7:0]   wr_data_count);endmodule</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cd8a48624086dad5e90938923f91948.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/023c8533627e2e6d569a0488456e668a.png"></p><pre><code>    如图所示为位置 1 放大后的波形，因为我们设置的是普通模式 FIFO，所以和 SCFIFO 的普通模式一样读出的数据存在**一个时钟周期的潜伏期** ，另外还有几个点需要我们重点观察：    1、full 满标志信号的状态：我们可以看到当 pi_flag 为高且 pi_data 为 254 的 full 满标 志信号先拉高了，虽然我们是往里面写入数据 0~255，但是我们在配置 fifo 核时知道**fifo 的实际深度只有 255，所以这里到数据写到 254 个时，full 满信号就被拉高了** 。    2、wr_data_count、rd_data_count 信号的状态：我们可以看到 wr_data_count 信号计数到 255，而 rd_data_count 信号则计数到 127，这是因为**输入时 8btit 的，输出是 16bit 的** ，刚好总数据量相等。同样 wr_data_count 信号也从 255 变成了 0、rd_data_count 信号从 127 变 成 0 的原因和 SCFIFO 中的情况一样，都是因为数据存储满了，FIFO 内部的计数器溢出所导致的。我们还可以发现读出的 16bit 数据，是输入的 8bit 数据低位在后高位在前的顺序， 如果记错了顺序在使用数据的时候会产生错误。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cea9670fb75213b148fa33d32c8fc165.png"></p><pre><code>    如图所示为位置 2 放大后的波形，我们发现，最后一个读取的数据为 16’hfcfd （实际深度为 127），同时 empty 空信号标志信号也拉高，表示 16bit 的读 FIFO 数据已空。</code></pre><h4 id="⑶注意问题"><a href="#⑶注意问题" class="headerlink" title="⑶注意问题"></a>⑶注意问题</h4><p>1、在单位时间内，写数据的总带宽一定要等于读数据的总带宽，否则会存在写满或读空的现象；</p><p>2、控制好、利用好 FIFO 的关键信号，如读写时钟、读写使能、空满标志信号；</p><p>3、根据实际的项目需求还要考虑需要多大的 FIFO，大了会浪费资源，小了则达不到需求。</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132779996">https://blog.csdn.net/qq_32971095/article/details/132779996</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fpga开发 </tag>
            
            <tag> 嵌入式硬件 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理概述</title>
      <link href="/2023/08/17/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/08/17/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6">一.项目管理框架</a></p><p><a href="about:blank#1.%E4%B8%80%E4%BA%9B%E6%B5%81%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF">1.一些流行的时间管理工具和技术</a></p><p><a href="about:blank#2.%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B">2.项目章程</a></p><p><a href="about:blank#3.%E8%8C%83%E5%9B%B4%E8%AF%B4%E6%98%8E%E4%B9%A6">3.范围说明书</a></p><p><a href="about:blank#4.%E5%B7%A5%E4%BD%9C%E5%88%86%E8%A7%A3%E7%BB%93%E6%9E%84">4.工作分解结构</a></p><p><a href="about:blank#5.%E4%B8%80%E4%BA%9B%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%A2%AB%E5%8F%91%E7%8E%B0%E5%8F%AF%E4%BB%A5%E4%BF%83%E8%BF%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%B1%95%E7%9A%84%E9%87%8D%E8%A6%81%E5%B7%A5%E5%85%B7">5.一些广泛使用，被发现可以促进项目开展的重要工具</a></p><p><a href="about:blank#6.%E9%A1%B9%E7%9B%AE%E4%BA%A4%E4%BB%98%E8%83%BD%E5%8A%9B%E5%87%BA%E8%89%B2%E7%9A%84%E5%85%AC%E5%8F%B8%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%A6%81%E7%B4%A0">6.项目交付能力出色的公司的四个重要的实践要素</a></p><p><a href="about:blank#7.%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86">7.项目经理所需知识</a></p><p><a href="about:blank#8.%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F%E7%BB%8F%E7%90%86%E9%98%B6%E6%AE%B5">8.项目团队经理阶段</a></p><p><a href="about:blank#%E4%BA%8C.%E9%A1%B9%E7%9B%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E7%BB%84">二.项目生命周期和管理过程组</a></p><p><a href="about:blank#1.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%A7%82%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%90%83%E6%A8%A1%E5%9E%8B">1.项目管理的系统观以及系统管理的三球模型</a></p><p><a href="about:blank#2.%E9%A2%84%E6%B5%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B">2.预测生命周期和自适应软件开发生命周期模型</a></p><p><a href="about:blank#3.IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%80%E6%96%B0%E8%B6%8B%E5%8A%BF%EF%BC%9A">3.IT项目管理最新趋势：</a></p><p><a href="about:blank#4.%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">4.敏捷项目管理</a></p><p><a href="about:blank#5.%E9%A1%B9%E7%9B%AE%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E5%92%8C%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B">5.项目业务过程和管理过程</a></p><p><a href="about:blank#%3C1%3E%E8%B5%B7%E8%8D%89%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0">&lt;1&gt;起草项目章程​编辑</a></p><p><a href="about:blank#%3C2%3E%E5%BC%80%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E4%BC%9A%E8%AE%AE%C2%A0">&lt;2&gt;开项目启动会议</a></p><p><a href="about:blank#%3C3%3E%E5%85%B6%E4%BB%96">&lt;3&gt;其他</a></p><p><a href="about:blank#%E4%B8%89.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5">三.项目实践</a></p><p><a href="about:blank#%C2%A0%E4%B8%89.%E5%85%B6%E4%BB%96">四.其他</a></p><hr><h2 id="一-项目管理框架"><a href="#一-项目管理框架" class="headerlink" title="一.项目管理框架"></a>一.项目管理框架</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6561e507e27384e79a36ac6d5a8acb.png"></p><h3 id="1-一些流行的时间管理工具和技术"><a href="#1-一些流行的时间管理工具和技术" class="headerlink" title="1.一些流行的时间管理工具和技术"></a><strong>1.一些流行的时间管理工具和技术</strong></h3><p>◦ 项目章程, 范围说明书, 以及工作分解结构 (范围)</p><p>◦ 甘特图, 项目网络图, 关键路径分析, 关键链排程 (时间)</p><p>◦ 成本估算和挣值管理 (成本)</p><h3 id="2-项目章程"><a href="#2-项目章程" class="headerlink" title="2.项目章程"></a><strong>2.项目章程</strong></h3><p>◦ 编写一份<strong><strong>正式批准项目</strong></strong> 并授权项目经理在项目活动中使用组织资源的文件的过程。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b6e40deeb4c39947d46f1e5e21e22db7.png"></p><h3 id="3-范围说明书"><a href="#3-范围说明书" class="headerlink" title="3.范围说明书"></a><strong>3.范围说明书</strong></h3><h3 id="4-工作分解结构"><a href="#4-工作分解结构" class="headerlink" title="4.工作分解结构"></a><strong>4.工作分解结构</strong></h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb3053d170916cfedd694bb9272efd5d.png"></p><h3 id="5-一些广泛使用，被发现可以促进项目开展的重要工具"><a href="#5-一些广泛使用，被发现可以促进项目开展的重要工具" class="headerlink" title="5.一些广泛使用，被发现可以促进项目开展的重要工具"></a>5.<strong>一些广泛使用，被发现可以促进项目开展的重要工具</strong></h3><p>◦ 进程报告</p><p>◦ 开工会议</p><p>◦ 甘特图</p><p>◦ 变更请求</p><h3 id="6-项目交付能力出色的公司的四个重要的实践要素"><a href="#6-项目交付能力出色的公司的四个重要的实践要素" class="headerlink" title="6.项目交付能力出色的公司的四个重要的实践要素"></a>6.<strong>项目交付能力出色的公司的四个重要的实践要素</strong></h3><p>◦ 使用集成工具箱 (使用标准&#x2F;高级项目管理工具， 大量的模板)</p><p>◦ 培养项目领导人, 尤其是商业技巧和软件技术</p><p>◦ 开发一个流线型的项目交付过程</p><p>◦ 对项目的健康度进行量化（例如，客户满意度和投 资回报等）</p><h3 id="7-项目经理所需知识"><a href="#7-项目经理所需知识" class="headerlink" title="7.项目经理所需知识"></a>7.项目经理所需知识</h3><p>} 项目管理知识体系</p><p>} 应用领域的知识、标准和规则</p><p>} 项目环境知识</p><p>} 通用管理知识和技能</p><p>} 软技能或人际关系能力</p><pre><code>    1\. 人际关系技能    2\. 领导能力    3\. 倾听能力    4\. 正直、行为道德、坚定    5\. 善于建立信任关系    6\. 口头沟通    7\. 善于创建团队    8\. 解决冲突、冲突管理    9\. 批判式思考、解决问题    10\. 理解、权衡优先</code></pre><p>不同种类项目所需能力：</p><p>} 大型项目：领导力、相关经历、计划、人际关系技能、 口头沟通和团队建设技能是最重要的。</p><p>} 高不确定性项目: 风险管理、期望管理、领导力、人 际关系技能和计划能力是最重要的。</p><p>} 非常新颖项目：领导力、人际关系技能、有远见和目 标、自信、期望管理和倾听技能是最重要的</p><h3 id="8-项目团队经理阶段"><a href="#8-项目团队经理阶段" class="headerlink" title="8.项目团队经理阶段"></a><strong>8.项目团队经理阶段</strong></h3><p>组建期、激荡期、规范期、执行期和休整期</p><p>PMI 提供项目管理师 (PMP)认证</p><h2 id="二-项目生命周期和管理过程组"><a href="#二-项目生命周期和管理过程组" class="headerlink" title="二.项目生命周期和管理过程组"></a><strong><strong>二.项目生命周期和管理过程组</strong></strong></h2><h3 id="1-项目管理的系统观以及系统管理的三球模型"><a href="#1-项目管理的系统观以及系统管理的三球模型" class="headerlink" title="1.项目管理的系统观以及系统管理的三球模型"></a>1.项目管理的系统观以及系统管理的三球模型</h3><p>} 不能孤立地执行项目</p><p>} 必须在广阔的组织环境中运作</p><p>} 项目经理也不能孤立地领导项目，需要使用系统 思维、整体的观点，理解项目的组织环境</p><p>◦ 在组织情境内采用整体观点来实施项目</p><p>◦ 高级管理人员必须确保项目持续支持当前的业务需求</p><h3 id="2-预测生命周期和自适应软件开发生命周期模型"><a href="#2-预测生命周期和自适应软件开发生命周期模型" class="headerlink" title="2.预测生命周期和自适应软件开发生命周期模型"></a>2.预测生命周期和自适应软件开发生命周期模型</h3><p>◦ 项目阶段 ：传统项目管理存在一些基本阶段：概念、开发、实施和收 尾阶段。</p><p>◦ 这些阶段不能与今后提到的项目管理过程组的启动、计划、 执行、监控、收尾相混淆。</p><p>} 项目生命周期 是一系列项目阶段的集合</p><p>◦ 在每个阶段中要进行的工作</p><p>◦ 什么时候给出什么样的可交付成果</p><p>◦ 每个阶段涉及的人员和时间</p><p>◦ 管理层将如何控制和验证每个阶段产生的工作</p><p>} 一个 可交付成果 是作为项目的一部分生产或提供 的产品或服务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e6a54b386d3f4b133d946789a016a0d.png"></p><p> } 瀑布式生命周期模型: 定义了良好的线性系统分析、 设计、编码、测试和维护的阶段。</p><p>} 原型生命周期模型: 用于开发软件原型来阐明用户 操作软件的需求。</p><p>} 渐增式构建生命周期模型: 提供了对操作软件累进 的开发。</p><p>} 螺旋式生命周期模型: 显示了多数软件是使用迭代 或者螺旋方法而不是线性方法开发出来的。 } 快速应用开发(RAD)生命周期模型: 用于在不牺牲<br>质量的前提下快速开发项目。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8df9890e84386a023ed31d1c7949d1f4.png"></p><h3 id="3-IT项目管理最新趋势："><a href="#3-IT项目管理最新趋势：" class="headerlink" title="3.IT项目管理最新趋势："></a>3.IT项目管理最新趋势：</h3><p><strong>全球化</strong></p><p>◦ 问题——沟通、信任、工作方式、工具</p><p>◦ 建议——项目规范、全球化与本地化、合作、新技术等</p><p><strong>外包</strong> ：从外部寻找来源以获得需要的产品和服务。</p><p>虚拟团队: 运用通信技术实现跨时间和跨地域工 作的个人组成的团队。</p><h3 id="4-敏捷项目管理"><a href="#4-敏捷项目管理" class="headerlink" title="4.敏捷项目管理"></a>4.敏捷项目管理</h3><p>敏捷宣言：</p><p>◦ 个体和交互 重于 过程和工具</p><p>◦ 可运行的软件 重于 面面俱到的文档</p><p>◦ 客户合作 重于 合同谈判</p><p>◦ 响应变化 重于 遵循计划</p><h3 id="5-项目业务过程和管理过程"><a href="#5-项目业务过程和管理过程" class="headerlink" title="5.项目业务过程和管理过程"></a>5.项目业务过程和管理过程</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a293d6846a5fc6174773cfe4d2d21824.png"></p><h4 id><a href="#" class="headerlink" title></a></h4><p>&lt;1&gt;起草项目章程<img src="https://i-blog.csdnimg.cn/blog_migrate/23428b81336d7764ceef3d263a46b820.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9a191e6eb24a199568ffd4c1c83bf5c.png"></p><h4 id="开项目启动会议"><a href="#开项目启动会议" class="headerlink" title="&lt;2&gt;开项目启动会议"></a>&lt;2&gt;开项目启动会议</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/44f91820f373f7b555aa503d8bfd6232.png"></p><h4 id="其他"><a href="#其他" class="headerlink" title="&lt;3&gt;其他"></a>&lt;3&gt;其他</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5081537ca94bfe3852addd9a2661845.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/156f32c4a921fc7addcce0b3e179376e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c1d2a14497ac2dddb0faa40d2bf4c4d.png"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/090816d0caa2f7c0ea69492a9e497bc7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/66c4ba44817c651e2cb865aabd3dcfd3.png"></p><h2 id="三-项目实践"><a href="#三-项目实践" class="headerlink" title="三.项目实践"></a>三.项目实践</h2><p>见资源绑定部分，作者描述了曾经的一个项目进行规范化后的流程。</p><h2 id="四-其他"><a href="#四-其他" class="headerlink" title="四.其他"></a>四.其他</h2><p>项目总监—项目经理—— 项目主管—项目助理<br>产品总监—产品经理—产品助理—产品实习生<br>技术总监—技术经理—研发经理—技术主管—架构师</p><p>PDCA（plan ，do，check，action）<br>愿景-&gt;甲方（利益相关方、领导、客户）-&gt;产品经理-——（理解需求，记录）——&gt;开发团队<br>沟通：快速、高效、记录</p><p>产品负责人-&gt;做什么<br>开发团队-&gt;怎么做<br>项目经理（敏捷教练）-&gt;怎么快速交付</p><p>敏捷监控-&gt;判断敏捷项目状态（VT图【功能-时间图，最乐观、悲观两条直线，项目在这两条直线之间】）-&gt;提供方案</p><p><strong>相关资料及了解：</strong></p><p><a href="https://download.csdn.net/download/qq_32971095/88226711" title="西安电子科技大学工程概论相关资料资源">西安电子科技大学工程概论相关资料资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88226711</a></p><p><a href="https://blog.csdn.net/wypblog/article/details/108701343?spm=1001.2014.3001.5506&ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTcxMDk1P3R5cGU9Y29sbGVjdA==" title="互联网大厂的薪资和职级一览">互联网大厂的薪资和职级一览<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/wypblog/article/details/108701343?spm=1001.2014.3001.5506&amp;ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTcxMDk1P3R5cGU9Y29sbGVjdA%3D%3D</a><a href="https://blog.csdn.net/Albert_weiku/article/details/123089529?spm=1001.2014.3001.5506" title="一个大厂的项目组织架构学习">一个大厂的项目组织架构学习<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/Albert_weiku&#x2F;article&#x2F;details&#x2F;123089529?spm&#x3D;1001.2014.3001.5506</a><a href="https://blog.csdn.net/xhtchina/article/details/112859450?spm=1001.2014.3001.5506" title="大厂人才结构">大厂人才结构<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/xhtchina/article/details/112859450?spm=1001.2014.3001.5506</a></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132343604">https://blog.csdn.net/qq_32971095/article/details/132343604</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础设计一——FPGA学习笔记＜2＞</title>
      <link href="/2023/08/16/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C2%EF%BC%9E/"/>
      <url>/2023/08/16/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C2%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E9%9B%B6.%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B">零.设计流程</a></p><p><a href="about:blank#%E4%B8%80.%E6%8C%89%E9%94%AE%E7%82%B9%E4%BA%AELED%E7%81%AF">一.按键点亮LED灯</a></p><p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">1.硬件资源</a></p><p><a href="about:blank#%C2%A02.%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1"> 2.项目设计</a></p><p><a href="about:blank#%C2%A03.%E6%B3%A2%E5%BD%A2%E8%AE%BE%E8%AE%A1"> 3.波形设计</a></p><p><a href="about:blank#%C2%A04.%E5%88%9B%E5%BB%BAVivado%E5%B7%A5%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91"><br>4.创建Vivado工程​编辑</a></p><p><a href="about:blank#%3C1%3E%E6%B7%BB%E5%8A%A0%E8%AE%BE%E8%AE%A1%E6%96%87%E4%BB%B6">&lt;1&gt;添加设计文件</a></p><p><a href="about:blank#%3C2%3E%E6%B7%BB%E5%8A%A0%E4%BB%BF%E7%9C%9F%E6%96%87%E4%BB%B6">&lt;2&gt;添加仿真文件</a></p><p><a href="about:blank#5.%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F">5.引脚约束</a></p><p><a href="about:blank#6.%E7%94%9F%E6%88%90%E6%AF%94%E7%89%B9%E6%B5%81%E6%96%87%E4%BB%B6">6.生成比特流文件</a></p><p><a href="about:blank#7.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">7.下载验证</a></p><p><a href="about:blank#8.%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96">8.程序固化</a></p><p><a href="about:blank#%E4%BA%8C.%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8">二.多路选择器</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p><p>[&lt;1&gt;always 中 if-else 实现方法](about:blank#%3C1%3Ealways%20%E4%B8%AD%20if-<br>else%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95)</p><p><a href="about:blank#%C2%A0%3C2%3Ealways%20%E4%B8%AD%20case%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E2%80%8B%E7%BC%96%E8%BE%91"> &lt;2&gt;always 中 case<br>实现方法​编辑</a></p><p><a href="about:blank#%C2%A0%3C3%3Eassign%20%E4%B8%AD%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"> &lt;3&gt;assign<br>中条件运算符（三元运算符）实现方法</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E4%B8%89.%E8%AF%91%E7%A0%81%E5%99%A8">三.译码器</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E5%9B%9B.%E5%8D%8A%E5%8A%A0%E5%99%A8">四.半加器</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E4%BA%94.%E5%B1%82%E6%AC%A1%E5%8C%96%E8%AE%BE%E8%AE%A1">五.层次化设计</a></p><p><a href="about:blank#1.%E5%85%A8%E5%8A%A0%E5%99%A8">1.全加器</a></p><p><a href="about:blank#%E5%85%AD.%E9%81%BF%E5%85%8DLatch%E7%9A%84%E4%BA%A7%E7%94%9F">六.避免Latch的产生</a></p><p><a href="about:blank#%E4%B8%83.%E5%AF%84%E5%AD%98%E5%99%A8">七.寄存器</a></p><p><a href="about:blank#1.%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%C2%A0D%20%E8%A7%A6%E5%8F%91%E5%99%A8">1.同步复位 D 触发器和异步复位 D<br>触发器</a></p><p><a href="about:blank#%3C1%3E%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8">&lt;1&gt;同步复位 D<br>触发器</a></p><p><a href="about:blank#%3C2%3E%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8">&lt;2&gt;异步复位 D<br>触发器</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E5%85%AB.%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC">八.阻塞赋值与非阻塞赋值</a></p><p><a href="about:blank#%E4%B9%9D.%E8%AE%A1%E6%95%B0%E5%99%A8">九.计数器</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E5%8D%81.%E5%88%86%E9%A2%91%E5%99%A8">十.分频器</a></p><p><a href="about:blank#1.%E5%81%B6%E5%88%86%E9%A2%91">1.偶分频</a></p><p><a href="about:blank#2.%E5%A5%87%E5%88%86%E9%A2%91">2.奇分频</a></p><p><a href="about:blank#%E5%8D%81%E4%B8%80.%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96">十一.按键消抖</a></p><p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E6%B6%88%E6%8A%96">1.硬件消抖</a></p><p><a href="about:blank#2.%E8%BD%AF%E4%BB%B6%E6%B6%88%E6%8A%96">2.软件消抖</a></p><p><a href="about:blank#%E5%8D%81%E4%BA%8C.%E6%B5%81%E6%B0%B4%E7%81%AF">十二.流水灯</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><p><a href="about:blank#%E5%8D%81%E4%B8%89.%E7%8A%B6%E6%80%81%E6%9C%BA">十三.状态机</a></p><p><a href="about:blank#1.%E7%AE%80%E6%98%93%E5%8F%AF%E4%B9%90%E6%9C%BA">1.简易可乐机</a></p><p><a href="about:blank#2.%E5%A4%8D%E6%9D%82%E5%8F%AF%E4%B9%90%E6%9C%BA">2.复杂可乐机</a></p><p><a href="about:blank#%E5%8D%81%E5%9B%9B.%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8">十四.无源蜂鸣器</a></p><p><a href="about:blank#%E5%8D%81%E4%BA%94.%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA">十五.动态数码管显示</a></p><p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p><p><a href="about:blank#%3C1%3Edata_gen">&lt;1&gt;data_gen</a></p><p><a href="about:blank#%C2%A0%3C2%3Ebcd_8421"> &lt;2&gt;bcd_8421</a></p><p><a href="about:blank#%3C3%3E%C2%A0seg_dynamic">&lt;3&gt; seg_dynamic</a></p><p><a href="about:blank#%C2%A0%3C4%3Etop_seg_dynamic"> &lt;4&gt;top_seg_dynamic</a></p><p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p><hr><p>前置学习：</p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5501" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132220627?spm=1001.2014.3001.5501" title="FPGA基本概念及资源整理——FPGA学习笔记＜0＞">FPGA基本概念及资源整理——FPGA学习笔记＜0＞</a></p><p> 参考书目：《野火FPGA Verilog 开发实战指南》</p><h2 id="零-设计流程"><a href="#零-设计流程" class="headerlink" title="零.设计流程"></a>零.设计流程</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2efe3610ba66737b9104ad2f0d80a3c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f92d1d6e686a5d2205375e96b85fff6b.png"></p><p><strong>熟悉Vivado界面参考：</strong><a href="https://blog.csdn.net/L20902/article/details/86542768" title="4.1 Vivado使用技巧（1）：了解主界面"> 4.1 Vivado使用技巧（1）：了解主界面<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/L20902/article/details/86542768</a></p><p><a href="https://zhuanlan.zhihu.com/p/152589392" title="[走近FPGA]之工具篇（上）-Vivado">[走近FPGA]之工具篇（上）-Vivado<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://zhuanlan.zhihu.com/p/152589392</a></p><h2 id="一-按键点亮LED灯"><a href="#一-按键点亮LED灯" class="headerlink" title="一.按键点亮LED灯"></a>一.按键点亮LED灯</h2><h3 id="1-硬件资源"><a href="#1-硬件资源" class="headerlink" title="1.硬件资源"></a>1.硬件资源</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2667696a820c85797d4d6df1cd43b3c2.png"></p><h3 id="2-项目设计"><a href="#2-项目设计" class="headerlink" title="2.项目设计"></a>2.项目设计</h3><p>①项目分解成模块；②模块设计：模块、输入信号、输出信号</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a547736864f1e460e82164c0dbd31028.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b7294591ac560a6ea16c433bad7f58b.png"></p><h3 id="3-波形设计"><a href="#3-波形设计" class="headerlink" title="3.波形设计"></a>3.波形设计</h3><p>信号之间的逻辑或时序上关系，众多信号使用波形图表达（注意信号间规范区分，比如绿色输入信号，黄色之间变量，红色输出变量等等）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9529f923229460a5c7d62e2813b2a149.png"></p><h3 id><a href="#" class="headerlink" title></a></h3><p>4.创建Vivado工程<img src="https://i-blog.csdnimg.cn/blog_migrate/5c2a7cc9868e417cc2454b198ef7c77c.png"></p><h4 id="添加设计文件"><a href="#添加设计文件" class="headerlink" title="&lt;1&gt;添加设计文件"></a>&lt;1&gt;添加设计文件</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/af3dc861458df3b6b3b0b48ef0d48397.png"></p><p> 文件会复制到xxx.srcs文件夹内；创建文件路径也在此文件夹中；复制选项上面的选项指复制搜寻并复制子模块RTL文件</p><p>示例RTL代码：</p><pre><code>`timescale  1ns/1ns//// Company: // Engineer: // // Create Date: 2023/08/16 22:03:43// Design Name: // Module Name: led_creat// Project Name: // Target Devices: // Tool Versions: // Description: // // Dependencies: // // Revision:// Revision 0.01 - File Created// Additional Comments:// //module  led(    input   wire    key_in  ,   //输入按键    output  wire    led_out     //输出控制led);//********************************************************************////***************************** Main Code ****************************////********************************************************************////led_out:led灯输出的结果为key_in按键取反的输入assign  led_out  =  ~key_in;endmodule</code></pre><h4 id="添加仿真文件"><a href="#添加仿真文件" class="headerlink" title="&lt;2&gt;添加仿真文件"></a>&lt;2&gt;添加仿真文件</h4><p>逻辑仿真时使用的Testbench脚本也是用HDL语言写的，其原理如下：</p><p>第一步创建Testbench脚本，名字通常为被测试模块前加tb_</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1dd6f2041ad2af10e07bce42ef0ed57.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8a5b95f6c18a4f91ac7113d884df5d06.png"></p><p>代码示例：</p><pre><code>`timescale  1ns/1nsmodule  tb_led();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire    led_out ;//reg   definereg     key_in  ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化输入信号initial key_in &lt;= 1&#39;b0;//key_in:产生输入随机数，模拟按键的输入情况always #10 key_in &lt;= &#123;$random&#125; % 2; /*取模求余数，产生非负随机数0、1                                      每隔10ns产生一次随机数*///********************************************************************////**************************** Instantiate ***************************////********************************************************************////------------- led_inst -------------led led_inst(    .key_in (key_in ),  //input     key_in    .led_out(led_out)   //output    led_out);endmodule    _**这里定义的变量类型如果要手动赋值仿真，使用reg变量；如果是输出则用使用wire变量引出**_ ，理解变量的含义即可。</code></pre><p>然后运行仿真即可，可选择Vivado仿真或Modelsim联合仿真。仿真过程类似Quartus II</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/195ecfe4afdbb59d8a2c2871b179f4b4.png"></p><p>此处可设定仿真参数</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b47bce4a0d597ad6c2f825c93fddea3c.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/5f7462237ec90db44d753643fd1175f8.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b47c2afa869d2985439cd6a764acec2.png"></p><h3 id="5-引脚约束"><a href="#5-引脚约束" class="headerlink" title="5.引脚约束"></a>5.引脚约束</h3><p><strong>&lt; 1&gt;方式一——RTL ANALYSIS</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/08347777a3520b80c7389d37b9a8f174.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7022f97c6a64984110ce0190374f40ee.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07d2cc78f9f45c76abd50199a1765abb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db93f9f8c2c93c51f9cebe41a5343324.png"></p><p><strong>注：相关文件信息及更改在中间框中如下</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c87e94d3d00825f28e055fc0409abf65.png"></p><p>**  &lt;2&gt;方式二——直接编写并添加.xdc连接文件**</p><p><strong>注：.xdc文件使用#注释</strong></p><h3 id="6-生成比特流文件"><a href="#6-生成比特流文件" class="headerlink" title="6.生成比特流文件"></a>6.生成比特流文件</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/357b240f0acec1fdd18ae18c48ac40e6.png"></p><h3 id="7-下载验证"><a href="#7-下载验证" class="headerlink" title="7.下载验证"></a>7.下载验证</h3><p>**  注意事项**</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/45e3ec6b37e6730e9b3cb619c63e3506.png"></p><p><strong>即先将JTAG连接至FPGA，然后打开FPGA电源，然后JTAG链接电脑</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0cb4b6be1ea1d93446498b0a58ccf824.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/702c1dbfa022a48d2038ebc95a365143.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3f5cb3dcb64fe6c9a9fb78114e65ab90.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0552faa2eab0dffee4a70c5accc31b5b.png"></p><p>可以看到生成的bit文件保存在.runs文件夹中</p><h3 id="8-程序固化"><a href="#8-程序固化" class="headerlink" title="8.程序固化"></a>8.程序固化</h3><p><strong>首先在.xdc连接文件添加以下代码，目的是使用spi4加速（如果不添加后续只能使用spi1）</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/140e2313fb9fd6db965f491478b676bd.png"></p><pre><code>set_property CFGBVS VCCO [current_design]set_property CONFIG_VOLTAGE 3.3 [current_design]set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]set_property CONFIG_MODE SPIx4 [current_design]set_property BITSTREAM.CONFIG.CONFIGRATE 50 [current_design]</code></pre><p>参考：<a href="https://blog.csdn.net/weixin_42741023/article/details/110523933" title="XILINX 7系列配置4线SPI_spi_setconfig">XILINX<br>7系列配置4线SPI_spi_setconfig</a></p><p>MSC文件是xilinx的二进制文件</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0dc2ae66a16b4d70850a1f4ae1018297.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9cce811c897aaa8d84456affe85324ee.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a4bbc39dcadb1a386cb97f00b0ed60ca.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/87d997a95dc950fcd7f972d92fa4b0a5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad5f6ceceaaa31907048acf97b94a072.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6d545db03b98d36c3b125aa76fba5f7.png"></p><p> 进程两步操作：擦除FLASH芯片、写入FLASH芯片；</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a08207a83f751091bd3135d3a6b23cf.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9cfdde4d3a4b725549baa2d34cf355c.png"></p><p>生成bin文件之后，右键之前生成的存储器配置文件，更改“programme file”为生成的bin文件如下</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b7b0ba72cbd40812bb052723628d968f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e538294c904a9336b2a9984f3527a2bf.png"></p><p> 之后便可以在这里进行程序烧录</p><p><strong>最终简化流程为“Generate BItstrean”- &gt;“Program Configuration Memory Device”</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9be6c6007e107c284be2d883a67a383.png"></p><h2 id="二-多路选择器"><a href="#二-多路选择器" class="headerlink" title="二.多路选择器"></a>二.多路选择器</h2><h3 id="1-实现方法"><a href="#1-实现方法" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><h4 id="always-中-if-else-实现方法"><a href="#always-中-if-else-实现方法" class="headerlink" title="&lt;1&gt;always 中 if-else 实现方法"></a>&lt;1&gt;always 中 if-else 实现方法</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/93bb9d23989a1f4147bf1e7de4c66084.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/937dd3128d1f5cdf77c8fccd00816ed4.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/4cbcc3ca593a40beb56c37d744b6a0b5.png"></p><h4 id="always-中-case"><a href="#always-中-case" class="headerlink" title="&lt;2&gt;always 中 case"></a>&lt;2&gt;always 中 case</h4><p>实现方法<img src="https://i-blog.csdnimg.cn/blog_migrate/d8e7264f035f94a2d4c35f795bc2e70e.png"></p><h4 id="assign-中条件运算符（三元运算符）实现方法"><a href="#assign-中条件运算符（三元运算符）实现方法" class="headerlink" title="&lt;3&gt;assign 中条件运算符（三元运算符）实现方法"></a>&lt;3&gt;assign 中条件运算符（三元运算符）实现方法</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/56dcc057c914e8a882f7fcaae1c8522c.png"></p><p>注：<a href="https://blog.csdn.net/wordwarwordwar/article/details/101114439" title="assign和always@(*)区别">assign和always@(*)区别</a></p><h3 id="2-仿真"><a href="#2-仿真" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d640913a44f0ee53ed095a299dea32bf.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f03c006da178aee72d96d6e2a4269007.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/64bba58e601e6b56807646b7f5dedf3e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c59d2b0cbc40709126a80bb867ab976a.png"></p><h2 id="三-译码器"><a href="#三-译码器" class="headerlink" title="三.译码器"></a>三.译码器</h2><h3 id="1-实现方法-1"><a href="#1-实现方法-1" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d07f66848d920d0322d81f64d5e9bfa5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/94b02aeeb99d1401d4105fccbf6f30cb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1268b6615fce43b3f1c4286c6f1b6908.png"></p><h3 id="2-仿真-1"><a href="#2-仿真-1" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c327b5d96c1e35949a45b32ae231a9e5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/72d0265f36c516cd1237289542749cae.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9907890950a3eb61c446e3525534c57.png"></p><h2 id="四-半加器"><a href="#四-半加器" class="headerlink" title="四.半加器"></a>四.半加器</h2><h3 id="1-实现"><a href="#1-实现" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ec6283f38702f38a3f6b123c9d7d8cb.png"></p><h3 id="2-仿真-2"><a href="#2-仿真-2" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/005205dcc527510028d73ea92813072b.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04a58b1443519b04e6ba1b564905ca29.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/53534ff8355e13c45c4c60f415bed274.png"></p><h2 id="五-层次化设计"><a href="#五-层次化设计" class="headerlink" title="五.层次化设计"></a>五.层次化设计</h2><p>**         <em>自上而下设计</em>** ：自上而下的设计是<strong>从系统级开始</strong> ，<strong>把系统分为基本单元</strong> ，然后再把每个单元划分为<strong>下<br>一层次的基本单元</strong> ，一直这样做下去，<strong>直到直接可以用 EDA 元件库中的原件来实现为止。</strong> 在自顶向下设计方法中，我们首<br>先定义顶层功能块，进而分析需要哪些构成顶层模块的必 要子模块；然后进一步对各个子模块进行分解，直到到达无法进一步分解的底层功能块。</p><p>**         <em>自下而上设计</em>** ：自底向上的设计是一种传统的设计方法，对设计进行逐次划分的过程是<strong>从存在的基本单元出发的</strong><br>，设计树最末枝上的单元要么是<strong>已经构造出的单元</strong> ，要么是<strong>其他 项目开发好的单元</strong><br>或者是可外购得到的单元。在自底向上建模方法中，我们首先对现有的功能块进行分 析，然后使用这些模块来搭建规模大一些的功能块，如此继续<strong>直至顶层模块</strong> 。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7538cc8f96cd3ed8557ff715e102cc35.png"></p><h3 id="1-全加器"><a href="#1-全加器" class="headerlink" title="1.全加器"></a>1.全加器</h3><p>&lt;1&gt;实现</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/098c9d43dc2c588dda513c7f86aef146.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0550049229a1c71c2bf226988dc5403d.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b63e0103ecc4b574df8128798cca2804.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5d7fc4a027154627993d5a2ea410858.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c81af6a8d1452ff19cb2584c664cb05e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9212a0f54789e4279e0deb46892893a0.png"></p><h2 id="六-避免Latch的产生"><a href="#六-避免Latch的产生" class="headerlink" title="六.避免Latch的产生"></a>六.避免Latch的产生</h2><pre><code>    Latch 其实就是**锁存器** ，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。    在同步电路中 Latch 会产生不好的效果，**如对毛刺敏感** ；不能异步复位，**上电后处于不定态** ；还会让静态时序分析变得十分复杂；在 FPGA 的资源中，大部分器件没有锁存器 这个东西，所以需要用使用寄存器来组成锁存器所以会**占用更多逻辑资源** ；在 ASIC 设计 中，锁存器也会带来**额外的延时和 DFT** ，并不利于提高系统的工作频率，所以要避免产 生。在这里我们把会产生组合逻辑的几种情况列举出来，希望大家以后能够避免出现类似 的问题。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0c366aa57dc96fc107f7a98134ea541e.png"></p><h2 id="七-寄存器"><a href="#七-寄存器" class="headerlink" title="七.寄存器"></a>七.寄存器</h2><pre><code>    时序逻辑最基本的单元就是寄存器， 寄存器具有存储功能，一般是由 **D 触发器构成** ，由时钟脉冲控制，每个 D 触发器（**D Flip Flop ，DFF** ）能够存储一位二进制码。    我们先给模块取一个名字叫 **flip_flop** ，接下来是分析端口信号：D 触发器能够正常工 作一定有时钟，每当**时钟** 的“沿（上升沿或下降沿）”来到时我们采集到稳定有效的数 据；其次还需要的就是**复位信号** ，用于让触发器的回到初始状态把数据清零；因为是用按 键控制 led 灯的亮灭，所以输入端我们还需要一个按键控制信号；输出就只有一个控制 led 灯的信号，这里我们的输入输出信号都是 1bit 的。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7cfd9794934a24ebb4c1604bc93ddff.png"></p><h3 id="1-同步复位-D-触发器和异步复位-D-触发器"><a href="#1-同步复位-D-触发器和异步复位-D-触发器" class="headerlink" title="1.同步复位 D 触发器和异步复位 D 触发器"></a>1.同步复位 D 触发器和异步复位 D 触发器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb4bca81cfe11f1a319e9269c00fc728.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a587c62737e05e53796c075785335997.png"></p><pre><code>    因为时 序电路只有在沿到来时才检测信号是否有效，所以在两个上升沿之间的毛刺都会被自然的 过滤掉，可以大大减少毛刺现象产生的干扰，提高了电路中数据的可靠性。    时序电路还有一个特点，就是“**延一拍** ”的效果。上面两个图最左边的一组红色竖线所表达的就是这个现象。key_in 在复位后的第一个时钟的上升沿来到时拉高，我们可以发 现此时 led_out 并**没有在同一时刻也跟着拉高** ，而在之前的组合逻辑中输出是在输入变化的 同一时刻立刻变化的    因为我们所画的波形图都是基于前仿真的，没有加入**门延时** 的信息，所以很多时候数 据的变化都是和时钟直接对齐的。当表达**时序逻辑时如果时钟和数据是对齐的，则默认当 前时钟沿采集到的数据为在该时钟上升沿前一时刻的值** ；当表达组合逻辑时如果时钟和数据是对齐的，则默认当前时钟沿采集到的数据为在该时钟上升沿同一时刻的值。而仿真工 具在进行 RTL 代码的仿真时也遵循这个规则，我们也可以理解为仿真寄存器是按照**建立时间 Tsu（指触发器的时钟信号上升沿到来以前，数据稳定不变的最小时间）最大（一个时 钟周期），保持时间 Th（指触发器的时钟信号上升沿到来以后，数据稳定不变的最小时 间）最小（为 0）的理想环境下进行的** ；而在仿真组合逻辑时因为没有时钟也就**没有建立时间和保持时间的概念** ，所以数据只要有变化就立刻有效。这里我们在 _**画波形图的时候一 定要记住这个“延一拍”的效果**_ ，否则我们绘制的波形图就会和最后的仿真结果不符，也 可能会导致最后的逻辑混乱。</code></pre><h4 id="同步复位-D-触发器"><a href="#同步复位-D-触发器" class="headerlink" title="&lt;1&gt;同步复位 D 触发器"></a>&lt;1&gt;同步复位 D 触发器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f0dd282c6d098d42d7ccbd5dcc6a8060.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9a0ef5616d5f85f5cd9134eba3f8b4af.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19ead2babd57ed1bfbd253080790a2e8.png"></p><h4 id="异步复位-D-触发器"><a href="#异步复位-D-触发器" class="headerlink" title="&lt;2&gt;异步复位 D 触发器"></a>&lt;2&gt;异步复位 D 触发器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8046c5befbf38e5f3597ba0ee3ed4d54.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9b531d4379ea89303cbfd9c4322c8649.png"></p><h3 id="2-仿真-3"><a href="#2-仿真-3" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce8ccc7525ce5b5d56a6159fc5739653.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bde02cf87bc7d8048af7109c8740f6fb.png"></p><pre><code>    begin...end 是一个串行块在 Testbench 中被使用时其内部的语句是**顺序执行** 的，在本例中，我们多次进行延时，其时间是在之前基础上**叠加** 的，而不是从 0 时 刻开始计算时间。</code></pre><h2 id="八-阻塞赋值与非阻塞赋值"><a href="#八-阻塞赋值与非阻塞赋值" class="headerlink" title="八.阻塞赋值与非阻塞赋值"></a>八.阻塞赋值与非阻塞赋值</h2><pre><code>    阻塞赋值的赋值号用“=”表示。对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关系。阻塞赋值的操作可以认为 是只有一个步骤的操作，即计算赋值号右边的语句并更新赋值号左边的语句，此时不允许 有来自任何其他 Verilog 语句的干扰，直到现行的赋值完成时刻，即把当前赋值号右边的值 赋值给左边的时刻完成后，它才允许下一条的赋值语句的执行。串行块（begin-end）中的各条阻塞型过程赋值语句将以它们在**顺序块后的排列次序依次执行** 。阻塞型过程赋值语句的执行过程是：首先计算赋值号右边的值，然后立即将计算结果赋值给左边，赋值语句结束，变量值立即发生改变。阻塞的概念是指在同一个 always 块中，其后面的赋值语句从概念上是在前一句赋值语句结束后再开始下面的赋值。   非阻塞赋值的赋值号用“&lt;=”表示。对应的电路结构往往与触发沿有关系，只有在触发沿的时刻才能进行非阻塞赋值。非阻塞操作开始时计算非阻塞赋值符的赋值号右边的语句，赋值操作结束时刻才更新赋值号左 边的语句，可以认为是两个步骤（赋值开始时刻和结束时刻）来完成非阻塞赋值。在计算 非阻塞语句赋值号右边的语句和更新赋值号左边的语句期间，其他的 Verilog 语句包括其他 的 Verilog 非阻塞赋值语句都能同时计算赋值号右边的语句和更新赋值号左边的语句，**允许 其他的 Verilog 语句同时进行操作** 。非阻塞赋值的操作可以看作为两个步骤的过程：在赋值开始时刻，计算赋值号右边的语句。在赋值结束时刻，更新赋值号左边的语句。注意：非阻塞操作只能用于对寄存器类型变量进行赋值，**因此只能用于“initial”和“always”块 中，不允许用于连续赋值“assign”** 。    **在描述逻辑电路时使用阻塞赋值，在描述时序逻辑电路时要用非阻塞赋值** ，这也 是官方的推荐写法。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/709bad310d63a8fb4530b7384ede5919.png"></p><h2 id="九-计数器"><a href="#九-计数器" class="headerlink" title="九.计数器"></a>九.计数器</h2><h3 id="1-实现方法-2"><a href="#1-实现方法-2" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1b3d9a5fc4da47dfa2eeb409d54cb4a.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a48c6951f6329e22e97c67b20b033e15.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc1c3738464e52a3b09c540e65703e3e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/13d4617698f497ba37ed751532fd025b.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/193aa0a1d5a6cc8beda043590a0a82e7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b48d646be58e4074fd5758995c1b194.png"></p><pre><code>    原理图可以看出由触发器组成的状态机，累加器，选择器等    通过对比我们可以发现第一种实现方式用了 2 个 always 块，其 RTL 视图分别对应两组 触发器，而第二种实现方式用了 3 个 always 块，其 RTL 视图分别对应了 3 组触发器</code></pre><h3 id="2-仿真-4"><a href="#2-仿真-4" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b64737d4cf0b4fb0e5a5ef634392b4e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cccccf928ca614d15bdc36b46caf2b3.png"></p><h2 id="十-分频器"><a href="#十-分频器" class="headerlink" title="十.分频器"></a>十.分频器</h2><pre><code>    无论分频和倍频，我们都有两种方式可以选择，一种是器件厂商提供的锁相环（PLL，后面章节会讲解），另一种是自己动手来用 Verilog 代码描述。用 Verilog 代码描述的往往是分频电路，即分频器。</code></pre><h3 id="1-偶分频"><a href="#1-偶分频" class="headerlink" title="1.偶分频"></a>1.偶分频</h3><p><strong>方法 1 实现：仅实现分频功能</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f441c1d4aef20817a3875e82ada804c9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b6e5825667316f9e53a7c78b93238025.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb3cb18907d7b8039a8cab21a18b9a46.png"></p><p><strong>方法 2 实现： 实用的降频方法</strong></p><p>方法一中的 clk_out 输出信号是我们想要的分频后的信号，然后很多同学就直接把这个<br>信号当作新的低频时钟来使用，并实现了自己想要的功能。大家肯定会觉得能够实现功能 就一切 OK 了，而往往忽略了一些隐患的存在，如果你对 FPGA<br>的了解多一些就会理解其 实这是不严谨的做法，这种做法所衍生的潜在问题在低速系统中不易察觉，而在高速系统<br>中就很容易出现问题。因为我们通过这种方式分频得到的时钟虽然表面上是对系统时钟进<br>行了分频产生了一个新的低频时钟，但实际上和真正的时钟信号还是有很大区别的。因为在 FPGA<br>中凡是时钟信号都要连接到全局时钟网络上，<strong>全局时钟网络也称为全局时钟树， 是 FPGA<br>厂商专为时钟路径而特殊设计的，它能够使时钟信号到达每个寄存器的时间都尽 可能相同，以保证更低的时钟偏斜（Skew）和抖动（Jitter）</strong><br>。而我们用这种分频的方式产 生的 clk_out 信号并没有<strong>连接到全局时钟网络</strong> 上，但 sys_clk 则是由外部晶振直接通过管脚 连接到了<br>FPGA 的专用时钟管脚上，自然就会连接到全局时钟网络上，所以在 <strong>sys_clk 时钟 工作下的信号要比在 clk_out<br>时钟工作下的信号更容易在高速系统中保持稳定</strong> ，既然发现了 问题那我们该怎么办呢？这时可不要忘记了上一章中刚学到的 flag 标志信号，这里我们就<br>可以用上了，我们可以产生一个用于标记 6 分频的 clk_flag 标志信号，这样每两 clk_flag 脉 冲之间的频率就是对 sys_clk 时钟信号的<br>6 分频，但是计数器计数的个数我们需增加一些， 如图 17-4 所示需要从 0~5 共 6 个数，否则不能实现 6 分频的功能。和方法 1 对比可以发<br>现，相当于<strong>把 clk_out 的上升沿信号变成了 clk_flag 的脉冲电平信号</strong> （和上一章方法 2 中的 cnt_flag<br>是一样的道理），为后级模块实现相同的降频效果。虽然这样会多使用一些寄存器资源，不过不用担心我们的系统是完全可以承担的起的，而得到的好处却远远大于这点资源的使用，能让系统更加稳定。<img src="https://i-blog.csdnimg.cn/blog_migrate/a4604d25ce110aa5d7fcf14ae08cc6b7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/de1332e424bc46b895e1e0d63443eacf.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad6b10f466b0b610deb1f226a1481d6d.png"></p><h3 id="2-奇分频"><a href="#2-奇分频" class="headerlink" title="2.奇分频"></a>2.奇分频</h3><p>&lt;1&gt;方法一：分频（两结果或运算）</p><p>这里 clk1 和 clk2 都是低电平 2 个时钟周期，高电平 3 个时钟周期，clk1 和 clk2 相与的结果就是 clk_out 的波形。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6b290cd161a83a533df103f57c759bc.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c4c0e4274d427c529f6abec8fe8c648b.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/499a0fa7af357d8d9cca522a16524e9c.png"></p><p>&lt;2&gt;方法二：降频（同前）</p><p>&lt;3&gt;后面的 IP 核章节还会讲解到通过 PLL（Phase Locked Loop，即锁相环）的方法来实现对时钟的任意分频、倍频、相位 移动。</p><h2 id="十一-按键消抖"><a href="#十一-按键消抖" class="headerlink" title="十一.按键消抖"></a>十一.按键消抖</h2><h3 id="1-硬件消抖"><a href="#1-硬件消抖" class="headerlink" title="1.硬件消抖"></a>1.硬件消抖</h3><pre><code>    图中两个与非门构成一个 RS 触发器。当按键未按下时，输出为 0；当键按下时， 输出为 1。此时即使用按键的机械性能，使按键因弹性抖动而产生瞬时断开(抖动跳开 B)， 只要按键不返回原始状态 A，双稳态电路的状态不改变，输出保持为 0，不会产生抖动的波形。也就是说，即使 B 点的电压波形是抖动的，但经双稳态电路之后，其输出为正规的矩形波。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6893b44caf7ec63ddc68714a118b9b4.png"></p><h3 id="2-软件消抖"><a href="#2-软件消抖" class="headerlink" title="2.软件消抖"></a>2.软件消抖</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16ddf72ebb4d584e925a8b26d958cfaa.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8b274eaefe8b17e020a89b2ddfd461a9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5599919d9d77d3ca30d278b89288156.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a266ef72d4b7f265101a20d9fed74c1.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/056d9b2536446b3eb89583eccfe55204.png"></p><h2 id="十二-流水灯"><a href="#十二-流水灯" class="headerlink" title="十二.流水灯"></a>十二.流水灯</h2><h3 id="1-实现-1"><a href="#1-实现-1" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be646017aad2b634afd574b313146586.png"></p><p>三个计数器、cnt_en使led由暗到亮再由亮到暗</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b1bd720cad58a07bb520c880f0b80ac.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae562916815db1311874ac2adf109bfb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dab5caf57215a249ba38d858e47fb211.png"></p><p>可用异或简化判断语句</p><h3 id="2-仿真-5"><a href="#2-仿真-5" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/68e8473cbba3135dd5d8fc77423e4351.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/093258a351514dd05e83d3cf3d4e8bde.png"></p><p>减小三个MAX的值方便仿真观察</p><h2 id="十三-状态机"><a href="#十三-状态机" class="headerlink" title="十三.状态机"></a>十三.状态机</h2><pre><code>    **状态机（FSM，Finite State Machine）** ，若最后的输出只和当前状态有关而与输入无关则称为 Moore 型状态机； 若最后的输出不仅和当前状态有关还和输入有关则称为 Mealy 型状态机。    最原始的状态我们称之为**IDLE** 状态</code></pre><h3 id="1-简易可乐机"><a href="#1-简易可乐机" class="headerlink" title="1.简易可乐机"></a>1.简易可乐机</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff4a4f1a879daad7f8bfe49f24fe63b2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f705ff295f1ea2ea1e088ef15013368c.png"></p><pre><code>    上面是一个用 Verilog 描述的简单状态机，我们可以发现它是按照我们总结好的一套格 式来编写的，我们按照这种格式再结合状态转移图可以编写出更复杂的状态机代码，所以 我们总结一下我们套用的格式有哪些主要部分构成：</code></pre><p>其中 01-09 行是端口列表部分；</p><p>17-19 行是状态编码部；</p><p>22 行是定义的状态变量；</p><p>29-49 行是第一段状态机部分；</p><p>52-58 是第二段 状态机部分。</p><pre><code>    一共有五部分，我们写状态机代码的时候根据这 5 部分对照着状态机依次编写，非常容易的就可以实现。 第一部分：第一部分是端口列表，和之前的设计一样没有什么特殊之处。 第二部分、第三部分：第二部分是状态编码，第三部分是状态变量，这两个是有联系 的，所以放到一起讲解。17-19 行是状态编码，状态转移图中有多少个状态数就需要有多少 个状态编码，这里一共有 3 个状态数，所以就需要 3 个状态编码。22 行是状态变量，这里 为什么状态变量的位宽是 3 呢？因为我们采用了独热码的编码方式，每个状态数只有 1 比 特为 1，其余比特都为 0，所以 3 个状态就要用 3 位宽的变量，如果是 4 个状态那就要用 4 位宽的变量，也就是一共有几个状态数就需要几位宽的状态变量。那么除了用独热码的方 式对状态进行编码，还有其他的方法吗？当然有，我们还可以采用二进制码或格雷码的方式对状态进行编码，上面的例子中如果我们用二进制码编码 3 个状态则为：2’b00， 2’b01，2’b10；而用格雷码编码 3 个状态则为：2’b00，2’b01，2’b11，都只需要 2 位宽的状态变量即可，即便是有 4 个状态数，我们使用 2 位宽的状态变量依然可以解决问题，要比独热码更节省状态变量的位宽个数。    为什么例子中我们使用的是独热码而非二进制码或格雷码呢？那就要从每种编码的特性上说起了，首先独热码因为每个状态只有 1bit 是不同的，所以在执行到 55 行时的（state == TWO）这条语句时，综合器会识别出这是一个比较器，而因为只有 1 比特为 1，所以综**合器会进行智能优化为（state[2] == 1’b1）** ，这就相当于把之前 3 比特的比较器变为了 **1 比特的比较器** ，大大**节省了组合逻辑资源** ，但是付出的代价就是状态变量的位宽需要的比较多，而我们 FPGA 中组合逻辑资源相对较少，所以比较宝贵，而**寄存器资源较多** ，所以很完美。而二进制编码的情况和独热码刚好相反，他因为使用了较少的状态变量，使之在减 少了寄存器状态的同时无法进行比较器部分的优化，所以使用的寄存器资源较少，而使用 的组合逻辑资源较多，我们还知道 **CPLD 就是一个组合逻辑资源多而寄存器逻辑资源少的器件** ，因为这里我们使用的是 FPGA 器件，所以使用独热码进行编码。就因为这个比较部分的优化，还使得使用**独热码编码的状态机可以在高速系统上运行，其原因是多比特的比 较器每个比特到达比较器的时间可能会因为布局布线的走线长短而导致路径延时的不同， 这样在高速系统下，就会导致采集到不稳定的状态，导致比较后的结果产生一个时钟的毛刺，使输出不稳定，而单比特的比较器就不用考虑这种问题。** 下面是示意图解析。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b075f02dfe393c49623598e5ca2c5a23.png"></p><pre><code>    用独热码编码虽然好处多多，但是如果状态数非常多的话即使是 FPGA 也吃不消独热码对寄存器的消耗，所以当**状态数特别多的时候可以使用格雷码对状态进行编码** 。格雷码虽然也是和二进制编码一样使用的寄存器资源少，组合逻辑资源多，但是其相邻状态转换 时**只有一个状态发生翻转，这样不仅能消除状态转换时由多条信号线的传输延迟所造成的毛刺，又可以降低功耗** ，所以要优于二进制码的方式，相当于是独热码和二进制编码的折中。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/992fdf3e38def6dea07b66383225d3c4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/21e5c11ef610a33d93b404ef205251e3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/277af51439649f5fd8edd3bea324ba42.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/669f0463e404b28fe73cf0b254d242bd.png"></p><pre><code>    第 40 行重新定义了一个 2bit 名为 state 的变量，然后通过在 Testbench 模块中实例化 RTL 模块的名字与“.”定位到 RTL 模块中的信号，如果要引入到 Testbench 模块中的信号是 RTL 模块多层实例化中最底层的信号则需要从顶层的实例化 RTL 模块的名字与“.”依次传递，直到最后定位到内部的信号。这样我们就把**RTL 模块中的内部信号引入到 Testbench 模块中** 了。之所以这样做是因为我们要在 ModelSim 的 “Transcript”界面中打印 RTL 模块中内部信号的信息以方便观察验证，直接实例化 RTL 模块的方式只能够将 **RTL 模块中的端口信号** 引入到 Testbench 模块中，而不能将 RTL 模块 的内部信号引入到 Testbench 模块中，所以无法在 ModelSim 的“Transcript”界面中观察打印的信息。</code></pre><h3 id="2-复杂可乐机"><a href="#2-复杂可乐机" class="headerlink" title="2.复杂可乐机"></a>2.复杂可乐机</h3><pre><code>    输入信号除了可以投 1 元外，还可以投 0.5 元，一次只投一个币；可乐机的输出除了可乐还可能会有找零（找零的结果只有一种即找回 0.5 元），我们将可乐机输出购买可乐的信号取名为 po_cola，找零的信号取名为 po_money。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5300ccd1c590907cd2eef1605876a964.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8759c5a5b929f36c23f74d72c739fdb.png"></p><pre><code>    大家在画状态转移图时容易出现状态跳转情况遗漏的问题，这里我们给大家总结一个 小技巧：我们可以观察到，输入有多少种情况（上一节是两种输入情况，本节是三种输入 情况），每个状态的跳转就有多少种情况（上一节每个状态都有两种跳转情况。这样根据输入来确定状态的跳转就能够保证我们不漏掉任何一 种状态跳转。`timescale  1ns/1nsmodule  complex_fsm(    input   wire    sys_clk         ,   //系统时钟50MHz    input   wire    sys_rst_n       ,   //全局复位    input   wire    pi_money_one    ,   //投币1元    input   wire    pi_money_half   ,   //投币0.5元                        output  reg     po_money        ,   //po_money为1时表示找零                                        //po_money为0时表示不找零    output  reg     po_cola             //po_cola为1时出可乐                                        //po_cola为0时不出可乐);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter define//只有五种状态，使用独热码parameter   IDLE     = 5&#39;b00001;parameter   HALF     = 5&#39;b00010;parameter   ONE      = 5&#39;b00100;parameter   ONE_HALF = 5&#39;b01000;parameter   TWO      = 5&#39;b10000;//reg   definereg     [4:0]   state;//wire  definewire    [1:0]   pi_money;//********************************************************************////***************************** Main Code ****************************////********************************************************************////pi_money:为了减少变量的个数，我们用位拼接把输入的两个1bit信号拼接成1个2bit信号//投币方式可以为：不投币（00）、投0.5元（01）、投1元（10），每次只投一个币assign pi_money = &#123;pi_money_one, pi_money_half&#125;;//第一段状态机，描述当前状态state如何根据输入跳转到下一状态always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        state &lt;= IDLE;  //任何情况下只要按复位就回到初始状态    elsecase(state)                IDLE    : if(pi_money == 2&#39;b01)   //判断一种输入情况                              state &lt;= HALF;                          else    if(pi_money == 2&#39;b10)//判断另一种输入情况                              state &lt;= ONE;                          else                              state &lt;= IDLE;                    HALF    : if(pi_money == 2&#39;b01)                              state &lt;= ONE;                          else    if(pi_money == 2&#39;b10)                              state &lt;= ONE_HALF;                          else                              state &lt;= HALF;                    ONE     : if(pi_money == 2&#39;b01)                              state &lt;= ONE_HALF;                          else    if(pi_money == 2&#39;b10)                              state &lt;= TWO;                          else                              state &lt;= ONE;                    ONE_HALF: if(pi_money == 2&#39;b01)                              state &lt;= TWO;                          else    if(pi_money == 2&#39;b10)                              state &lt;= IDLE;                          else                              state &lt;= ONE_HALF;                    TWO     : if((pi_money == 2&#39;b01) || (pi_money == 2&#39;b10))                              state &lt;= IDLE;                          else                              state &lt;= TWO;        //如果状态机跳转到编码的状态之外也回到初始状态                default :       state &lt;= IDLE;            endcase//第二段状态机，描述当前状态state和输入pi_money如何影响po_cola输出always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        po_cola &lt;= 1&#39;b0;    else    if((state == TWO &amp;&amp; pi_money == 2&#39;b01) || (state == TWO &amp;&amp;           pi_money == 2&#39;b10) || (state == ONE_HALF &amp;&amp; pi_money == 2&#39;b10))        po_cola &lt;= 1&#39;b1;    else        po_cola &lt;= 1&#39;b0;//第二段状态机，描述当前状态state和输入pi_money如何影响po_money输出always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n ==1&#39;b0)        po_money &lt;= 1&#39;b0;    else if((state == TWO) &amp;&amp; (pi_money == 2&#39;b10))        po_money &lt;= 1&#39;b1;    else        po_money &lt;= 1&#39;b0;endmodule`timescale  1ns/1nsmodule  tb_complex_fsm();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg         sys_clk;reg         sys_rst_n;reg         pi_money_one;reg         pi_money_half;reg         random_data_gen;//wire  definewire        po_cola;wire        po_money;//********************************************************************////***************************** Main Code ****************************////********************************************************************////初始化系统时钟、全局复位initial begin    sys_clk    = 1&#39;b1;    sys_rst_n &lt;= 1&#39;b0;    #20    sys_rst_n &lt;= 1&#39;b1;end//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50MHzalways  #10 sys_clk = ~sys_clk;//random_data_gen:产生非负随机数0、1always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        random_data_gen &lt;= 1&#39;b0;    else        random_data_gen &lt;= &#123;$random&#125; % 2;//pi_money_one:模拟投入1元的情况always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_money_one &lt;= 1&#39;b0;    else        pi_money_one &lt;= random_data_gen;//pi_money_half:模拟投入0.5元的情况always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        pi_money_half &lt;= 1&#39;b0;    else    //取反是因为一次只能投一个币，即pi_money_one和pi_money_half不能同时为1        pi_money_half &lt;= ~random_data_gen;//------------------------------------------------------------//将RTL模块中的内部信号引入到Testbench模块中进行观察wire    [4:0]   state    = complex_fsm_inst.state;wire    [1:0]   pi_money = complex_fsm_inst.pi_money;initial begin    $timeformat(-9, 0, &quot;ns&quot;, 6);    $monitor(&quot;@time %t: pi_money_one=%b pi_money_half=%b pi_money=%b state=%b po_cola=%b po_money=%b&quot;, $time, pi_money_one, pi_money_half, pi_money, state, po_cola, po_money);end//------------------------------------------------------------//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------------------complex_fsm_inst------------------------complex_fsm complex_fsm_inst(    .sys_clk        (sys_clk        ),  //input     sys_clk    .sys_rst_n      (sys_rst_n      ),  //input     sys_rst_n    .pi_money_one   (pi_money_one   ),  //input     pi_money_one    .pi_money_half  (pi_money_half  ),  //input     pi_money_half                        .po_cola        (po_cola        ),  //output    po_money    .po_money       (po_money       )   //output    po_cola);  endmodule</code></pre><h2 id="十四-无源蜂鸣器"><a href="#十四-无源蜂鸣器" class="headerlink" title="十四.无源蜂鸣器"></a>十四.无源蜂鸣器</h2><pre><code>    蜂鸣器按其是否带有震荡源又分为有源蜂鸣器和无源蜂鸣器。有源蜂鸣器的内部装有 集成电路，不需要音频驱动电路，只需要接通直流电源就能直接发出声响。而无源蜂鸣器 只有外加音频驱动信号才能发出声响。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9739916bd01d5da854f10529de7bf04c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff8f350fea1cf05ea913f0a2cc20aed0.png"></p><pre><code>    这里占空比我们保持为 50%。cnt_500ms：该信号我们定义为蜂鸣器的鸣叫状态计数。由于我们需鸣叫七个音调，所 以我们需要计 7 个数（0~6），而每个音调的鸣叫时间即计数值的持续时间。所以这里我们 需要用一个鸣叫持续时间计数器去控制蜂鸣器各音调的鸣叫持续时间。 cnt：蜂鸣器各音调鸣叫持续时间计数器。在“计数器”章节我们详细的介绍了该如何 用计数器进行时间计数，这里就不详细的介绍了。本次实验我们设计让每个音调持续鸣叫 0.5s，故这里我们计数到 24999999（0.5s）时让鸣叫状态计数器加 1。当最后一个音调 （cnt_500ms = 3’d6）鸣叫了 0.5s 时，我们让状态计数器跳转回第一个音调鸣叫状态 （cnt_500ms = 3’d0），以此循环，我们就能实现蜂鸣器七个基本音调的循环鸣叫了。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5620fa45183aaca2fc841d87809c8010.png"></p><pre><code>    首先是音调的频率我们该如何产生？我们先计算该频率单个方波的时间：1 / 262 ≈ 0.003816794s=3816794ns；而我们单个系统时钟（50MHz）的时间为：1 / 50000000 =0.00000002s = 20ns；所以我们需用：3816794 / 20 ≈ 190840 个系统时钟去产生一个 PWM 波，该 PWM 波形的频率即为 262。故我们需先对 190840 个系统时钟进行计数，这里我们 声明 freq_cnt 信号进行计数。</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efc4721fe989ceadb077cfa024b628d1.png"></p><pre><code>`timescale  1ns/1nsmodule  beep#(    parameter   TIME_500MS =   25&#39;d24999999,   //0.5s计数值    parameter   DO  =   18&#39;d190839 ,   //&quot;哆&quot;音调分频计数值（频率262）    parameter   RE  =   18&#39;d170067 ,   //&quot;来&quot;音调分频计数值（频率294）    parameter   MI  =   18&#39;d151514 ,   //&quot;咪&quot;音调分频计数值（频率330）    parameter   FA  =   18&#39;d143265 ,   //&quot;发&quot;音调分频计数值（频率349）    parameter   SO  =   18&#39;d127550 ,   //&quot;梭&quot;音调分频计数值（频率392）    parameter   LA  =   18&#39;d113635 ,   //&quot;拉&quot;音调分频计数值（频率440）    parameter   XI  =   18&#39;d101214     //&quot;西&quot;音调分频计数值（频率494）)(    input   wire        sys_clk     ,   //系统时钟,频率50MHz    input   wire        sys_rst_n   ,   //系统复位，低有效    output  reg         beep            //输出蜂鸣器控制信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg     [24:0]  cnt         ;   //0.5s计数器reg     [17:0]  freq_cnt    ;   //音调计数器reg     [2:0]   cnt_500ms   ;   //0.5s个数计数reg     [17:0]  freq_data   ;   //音调分频计数值//wire  definewire    [16:0]  duty_data   ;   //占空比计数值//********************************************************************////***************************** Main Code ****************************////********************************************************************////设置50％占空比：音阶分频计数值的一半即为占空比的高电平数assign  duty_data   =   freq_data   &gt;&gt;    1&#39;b1;//cnt:0.5s循环计数器always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt &lt;=  25&#39;d0;    else    if(cnt == TIME_500MS )        cnt &lt;=   25&#39;d0;    else        cnt &lt;=  cnt +   1&#39;b1;//cnt_500ms：对500ms个数进行计数，每个音阶鸣叫时间0.5s，7个音节一循环always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_500ms   &lt;=  3&#39;d0;    else    if(cnt == TIME_500MS &amp;&amp; cnt_500ms ==  6)        cnt_500ms   &lt;=  3&#39;d0;    else    if(cnt == TIME_500MS)        cnt_500ms   &lt;=  cnt_500ms + 1&#39;b1;//不同时间鸣叫不同的音阶always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        freq_data   &lt;=  DO;    else    case(cnt_500ms)        0:  freq_data   &lt;=   DO;        1:  freq_data   &lt;=   RE;        2:  freq_data   &lt;=   MI;        3:  freq_data   &lt;=   FA;        4:  freq_data   &lt;=   SO;        5:  freq_data   &lt;=   LA;        6:  freq_data   &lt;=   XI;        default:  freq_data   &lt;=   DO;    endcase//freq_cnt：当计数到音阶计数值或跳转到下一音阶时，开始重新计数always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        freq_cnt    &lt;=  18&#39;d0;    else    if(freq_cnt == freq_data || cnt == TIME_500MS)        freq_cnt    &lt;=  18&#39;d0;    else        freq_cnt    &lt;=  freq_cnt +  1&#39;b1;//beep：输出蜂鸣器波形always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        beep    &lt;=  1&#39;b0;    else    if(freq_cnt &gt;= duty_data)        beep    &lt;=  1&#39;b1;    else        beep    &lt;=  1&#39;b0;endmodule`timescale  1ns/1nsmodule  tb_beep();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg     sys_clk     ;   //时钟reg     sys_rst_n   ;   //复位//********************************************************************////***************************** Main Code ****************************////********************************************************************////对时钟，复位信号赋初值initial    begin        sys_clk     =   1&#39;b1;        sys_rst_n   &lt;=  1&#39;b0;        #100        sys_rst_n   &lt;=  1&#39;b1;    end//产生时钟信号always #10 sys_clk =   ~sys_clk;//********************************************************************////*************************** Instantiation **************************////********************************************************************//beep#(    .TIME_500MS(25&#39;d2499 ),   //0.5s计数值    .DO        (18&#39;d190  ),   //&quot;哆&quot;音调分频计数值（频率262）    .RE        (18&#39;d170  ),   //&quot;来&quot;音调分频计数值（频率294）    .MI        (18&#39;d151  ),   //&quot;咪&quot;音调分频计数值（频率330）    .FA        (18&#39;d143  ),   //&quot;发&quot;音调分频计数值（频率349）    .SO        (18&#39;d127  ),   //&quot;梭&quot;音调分频计数值（频率392）    .LA        (18&#39;d113  ),   //&quot;拉&quot;音调分频计数值（频率440）    .XI        (18&#39;d101  )    //&quot;西&quot;音调分频计数值（频率494）)beep_inst(    .sys_clk     (sys_clk   ),   //系统时钟,频率50MHz    .sys_rst_n   (sys_rst_n ),   //系统复位，低有效    .beep        (beep      )    //输出蜂鸣器控制信号);endmodule</code></pre><h2 id="十五-动态数码管显示"><a href="#十五-动态数码管显示" class="headerlink" title="十五.动态数码管显示"></a>十五.动态数码管显示</h2><p>让六位数码管显示从十进制数 0 开始计数，每 0.1s 加 1，一直到加到十进制数 999999。到达 999999 之后回到 0 开始重新计数。</p><h3 id="1-实现-2"><a href="#1-实现-2" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cbae469f08cf53fc9d5f56e3059bb4f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/696166e97ce5d3b1a2be055ac6dc925c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b28c0e71220e72cd013719c820965bed.png"></p><h4 id="data-gen"><a href="#data-gen" class="headerlink" title="&lt;1&gt;data_gen"></a>&lt;1&gt;data_gen</h4><pre><code>    生成0-999999的计数值，用20位二进制表示。bcd_8421生成6位十进制8421码。再转化成相应段码。`timescale  1ns/1nsmodule  data_gen#(    parameter   CNT_MAX = 23&#39;d4999_999, //100ms计数值    parameter   DATA_MAX= 20&#39;d999_999   //显示的最大值)(    input   wire            sys_clk     ,   //系统时钟，频率50MHz    input   wire            sys_rst_n   ,   //复位信号，低电平有效    output  reg     [19:0]  data        ,   //数码管要显示的值    output  wire    [5:0]   point       ,   //小数点显示,高电平有效    output  reg             seg_en      ,   //数码管使能信号，高电平有效    output  wire            sign            //符号位，高电平显示负号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////reg   definereg     [22:0]  cnt_100ms   ;   //100ms计数器reg             cnt_flag    ;   //100ms标志信号//********************************************************************////***************************** Main Code ****************************////********************************************************************////不显示小数点以及负数assign  point   =   6&#39;b000_000;assign  sign    =   1&#39;b0;//cnt_100ms:用50MHz时钟从0到4999_999计数即为100msalways@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_100ms   &lt;=  23&#39;d0;    else    if(cnt_100ms == CNT_MAX)        cnt_100ms   &lt;=  23&#39;d0;    else        cnt_100ms   &lt;=  cnt_100ms + 1&#39;b1;//cnt_flag:每100ms产生一个标志信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_flag    &lt;=  1&#39;b0;    else    if(cnt_100ms == CNT_MAX - 1&#39;b1)        cnt_flag    &lt;=  1&#39;b1;    else        cnt_flag    &lt;=  1&#39;b0;//数码管显示的数据:0-999_999always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data    &lt;=  20&#39;d0;    else    if((data == DATA_MAX) &amp;&amp; (cnt_flag == 1&#39;b1))        data    &lt;=  20&#39;d0;    else    if(cnt_flag == 1&#39;b1)        data    &lt;=  data + 1&#39;b1;    else        data    &lt;=  data;//数码管使能信号给高即可always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        seg_en  &lt;=  1&#39;b0;    else        seg_en  &lt;=  1&#39;b1;endmodule</code></pre><h4 id="bcd-8421"><a href="#bcd-8421" class="headerlink" title="&lt;2&gt;bcd_8421"></a>&lt;2&gt;bcd_8421</h4><pre><code>`timescale  1ns/1nsmodule  bcd_8421(    input   wire            sys_clk     ,   //系统时钟，频率50MHz    input   wire            sys_rst_n   ,   //复位信号，低电平有效    input   wire    [19:0]  data        ,   //输入需要转换的数据    output  reg     [3:0]   unit        ,   //个位BCD码    output  reg     [3:0]   ten         ,   //十位BCD码    output  reg     [3:0]   hun         ,   //百位BCD码    output  reg     [3:0]   tho         ,   //千位BCD码    output  reg     [3:0]   t_tho       ,   //万位BCD码    output  reg     [3:0]   h_hun           //十万位BCD码);//********************************************************************////******************** Parameter And Internal Signal *****************////********************************************************************////reg   definereg     [4:0]   cnt_shift   ;   //移位判断计数器reg     [43:0]  data_shift  ;   //移位判断数据寄存器reg             shift_flag  ;   //移位判断标志信号//********************************************************************////***************************** Main Code ****************************////********************************************************************////cnt_shift:从0到21循环计数always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_shift   &lt;=  5&#39;d0;    else    if((cnt_shift == 5&#39;d21) &amp;&amp; (shift_flag == 1&#39;b1))        cnt_shift   &lt;=  5&#39;d0;    else    if(shift_flag == 1&#39;b1)        cnt_shift   &lt;=  cnt_shift + 1&#39;b1;    else        cnt_shift   &lt;=  cnt_shift;       //data_shift：计数器为0时赋初值，计数器为1~20时进行移位判断操作always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_shift  &lt;=  44&#39;b0;    else    if(cnt_shift == 5&#39;d0)        data_shift  &lt;=  &#123;24&#39;b0,data&#125;;    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1&#39;b0))        begin            data_shift[23:20]   &lt;=  (data_shift[23:20] &gt; 4) ? (data_shift[23:20] + 2&#39;d3) : (data_shift[23:20]);            data_shift[27:24]   &lt;=  (data_shift[27:24] &gt; 4) ? (data_shift[27:24] + 2&#39;d3) : (data_shift[27:24]);            data_shift[31:28]   &lt;=  (data_shift[31:28] &gt; 4) ? (data_shift[31:28] + 2&#39;d3) : (data_shift[31:28]);            data_shift[35:32]   &lt;=  (data_shift[35:32] &gt; 4) ? (data_shift[35:32] + 2&#39;d3) : (data_shift[35:32]);            data_shift[39:36]   &lt;=  (data_shift[39:36] &gt; 4) ? (data_shift[39:36] + 2&#39;d3) : (data_shift[39:36]);            data_shift[43:40]   &lt;=  (data_shift[43:40] &gt; 4) ? (data_shift[43:40] + 2&#39;d3) : (data_shift[43:40]);        end    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1&#39;b1))        data_shift  &lt;=  data_shift &lt;&lt; 1;    else        data_shift  &lt;=  data_shift;//shift_flag：移位判断标志信号，用于控制移位判断的先后顺序always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        shift_flag  &lt;=  1&#39;b0;    else        shift_flag  &lt;=  ~shift_flag;//当计数器等于20时，移位判断操作完成，对各个位数的BCD码进行赋值always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        begin            unit    &lt;=  4&#39;b0;            ten     &lt;=  4&#39;b0;            hun     &lt;=  4&#39;b0;            tho     &lt;=  4&#39;b0;            t_tho   &lt;=  4&#39;b0;            h_hun   &lt;=  4&#39;b0;        end    else    if(cnt_shift == 5&#39;d21)        begin            unit    &lt;=  data_shift[23:20];            ten     &lt;=  data_shift[27:24];            hun     &lt;=  data_shift[31:28];            tho     &lt;=  data_shift[35:32];            t_tho   &lt;=  data_shift[39:36];            h_hun   &lt;=  data_shift[43:40];        endendmodule</code></pre><p> BCD码分类：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bbbe960d9a46469be4d41b77fe63590.png"></p><p> BCD码转换原理：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce08eac2cbdaba2d66e7242c75655e6e.png"></p><pre><code>    如上图所示，十进制数 234 其对应的二进制数为 1110_1010，首先第一步我们在其前面补上若干个 0，这里我们就需要 12 位 BCD 码，故我们就在前面补 12 个 0。 **第二步我们需要进行判断运算移位操作，首先判断每一个 BCD 码其对应的十进制数是否大于 4，如果大于 4 就对 BCD 码做加 3 操作，若小于等于 4 就让其值保持不变** 。当对每 一个 BCD 码进行判断运算后，都需要将运算后的数据像左移 1 位。移完位后我们仍按前面所述进行判断运算，判断运算后需再次移位，以此循环，当我们进行 8 次判断移位后的BCD 码部分数据就是我们转换的数据。这里需要注意的是我们**输入转换的二进制码有多少位我们就需要进行多少次判断移位操作** ，这里输入的是 8 位二进制，我们就进行 8 次判断移位操作。 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2782237565cfc547af71d1efbb7664d.png"></p><pre><code>    cnt_shift：移位判断计数器，前面我们说到我们输入转换的二进制码有多少位我们就需要进行多少次判断移位操作，这里我们 data 数据的位宽为 20 位，所以这里我们声明移位判断计数器对移位 20 次进行判断控制。    data_shift：移位判断数据寄存器，该寄存器用于存储移位判断操作过程中的数据，这里我们输入的二进制位宽为 20 位，待转换成的 BCD 码位宽为 24 位，所以这里我们声明该 寄存器的位宽为输入的二进制位宽和待转换完成的 BCD 码位宽之和，即 44 位。根据波形 图可知，这里我们设计当移位计数器等于 0 时寄存器的低 20 位即为待转换数据，而由于还 没开始进行转换，高 24 位的 BCD 码我们补 0 即可。    shift_flag：移位判断操作标志信号。前面说到我们需要对数据进行移位和判断，判断在前移位在后，所以这里我们声明一个标志信号，用于控制判断和移位的先后顺序，**当 shift_flag 为低时对数据进行判断，当 shift_flag 为高时对数据进行移位** 。需要注意的是无论 是移位操作和判断操作都是在单个系统时钟下完成的，故我们判断 20 次移位 20 次在 40 个 系统时钟内就能完成。 </code></pre><h4 id="seg-dynamic"><a href="#seg-dynamic" class="headerlink" title="&lt;3&gt; seg_dynamic"></a>&lt;3&gt; seg_dynamic</h4><pre><code>`timescale  1ns/1nsmodule  seg_dynamic(    input   wire            sys_clk     , //系统时钟，频率50MHz    input   wire            sys_rst_n   , //复位信号，低有效    input   wire    [19:0]  data        , //数码管要显示的值    input   wire    [5:0]   point       , //小数点显示,高电平有效    input   wire            seg_en      , //数码管使能信号，高电平有效    input   wire            sign        , //符号位，高电平显示负号    output  reg     [5:0]   sel         , //数码管位选信号    output  reg     [7:0]   seg           //数码管段选信号);//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////parameter defineparameter   CNT_MAX =   16&#39;d49_999;  //数码管刷新时间计数最大值 1ms//wire  definewire    [3:0]   unit        ;   //个位数wire    [3:0]   ten         ;   //十位数wire    [3:0]   hun         ;   //百位数wire    [3:0]   tho         ;   //千位数wire    [3:0]   t_tho       ;   //万位数wire    [3:0]   h_hun       ;   //十万位数//reg   definereg     [23:0]  data_reg    ;   //待显示数据寄存器reg     [15:0]  cnt_1ms     ;   //1ms计数器reg             flag_1ms    ;   //1ms标志信号reg     [2:0]   cnt_sel     ;   //数码管位选计数器reg     [5:0]   sel_reg     ;   //位选信号reg     [3:0]   data_disp   ;   //当前数码管显示的数据reg             dot_disp    ;   //当前数码管显示的小数点//********************************************************************////***************************** Main Code ****************************////********************************************************************////data_reg：控制数码管显示数据 always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_reg    &lt;=  24&#39;b0;//若显示的十进制数的十万位为非零数据或需显示小数点，则六个数码管全显示    else    if((h_hun) || (point[5]))        data_reg    &lt;=  &#123;h_hun,t_tho,tho,hun,ten,unit&#125;;//若显示的十进制数的万位为非零数据或需显示小数点，则值显示在5个数码管上//打比方我们输入的十进制数据为20’d12345，我们就让数码管显示12345而不是012345    else    if(((t_tho) || (point[4])) &amp;&amp; (sign == 1&#39;b1))//显示负号        data_reg &lt;= &#123;4&#39;d10,t_tho,tho,hun,ten,unit&#125;;//4&#39;d10我们定义为显示负号    else    if(((t_tho) || (point[4])) &amp;&amp; (sign == 1&#39;b0))        data_reg &lt;= &#123;4&#39;d11,t_tho,tho,hun,ten,unit&#125;;//4&#39;d11我们定义为不显示//若显示的十进制数的千位为非零数据或需显示小数点，则值显示4个数码管    else    if(((tho) || (point[3])) &amp;&amp; (sign == 1&#39;b1))        data_reg &lt;= &#123;4&#39;d11,4&#39;d10,tho,hun,ten,unit&#125;;    else    if(((tho) || (point[3])) &amp;&amp; (sign == 1&#39;b0))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,tho,hun,ten,unit&#125;;//若显示的十进制数的百位为非零数据或需显示小数点，则值显示3个数码管    else    if(((hun) || (point[2])) &amp;&amp; (sign == 1&#39;b1))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d10,hun,ten,unit&#125;;    else    if(((hun) || (point[2])) &amp;&amp; (sign == 1&#39;b0))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,hun,ten,unit&#125;;//若显示的十进制数的十位为非零数据或需显示小数点，则值显示2个数码管    else    if(((ten) || (point[1])) &amp;&amp; (sign == 1&#39;b1))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d10,ten,unit&#125;;    else    if(((ten) || (point[1])) &amp;&amp; (sign == 1&#39;b0))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,ten,unit&#125;;//若显示的十进制数的个位且需显示负号    else    if(((unit) || (point[0])) &amp;&amp; (sign == 1&#39;b1))        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d10,unit&#125;;//若上面都不满足都只显示一位数码管    else        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,unit&#125;;//cnt_1ms:1ms循环计数always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_1ms &lt;=  16&#39;d0;    else    if(cnt_1ms == CNT_MAX)        cnt_1ms &lt;=  16&#39;d0;    else        cnt_1ms &lt;=  cnt_1ms + 1&#39;b1;//flag_1ms:1ms标志信号always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        flag_1ms    &lt;=  1&#39;b0;    else    if(cnt_1ms == CNT_MAX - 1&#39;b1)        flag_1ms    &lt;=  1&#39;b1;    else        flag_1ms    &lt;=  1&#39;b0;//cnt_sel：从0到5循环数，用于选择当前显示的数码管always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        cnt_sel &lt;=  3&#39;d0;    else    if((cnt_sel == 3&#39;d5) &amp;&amp; (flag_1ms == 1&#39;b1))        cnt_sel &lt;=  3&#39;d0;    else    if(flag_1ms == 1&#39;b1)        cnt_sel &lt;=  cnt_sel + 1&#39;b1;    else        cnt_sel &lt;=  cnt_sel;//数码管位选信号寄存器always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        sel_reg &lt;=  6&#39;b000_000;    else    if((cnt_sel == 3&#39;d0) &amp;&amp; (flag_1ms == 1&#39;b1))        sel_reg &lt;=  6&#39;b000_001;    else    if(flag_1ms == 1&#39;b1)        sel_reg &lt;=  sel_reg &lt;&lt; 1;    else        sel_reg &lt;=  sel_reg;//控制数码管的位选信号，使六个数码管轮流显示always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        data_disp    &lt;=  4&#39;b0;    else    if((seg_en == 1&#39;b1) &amp;&amp; (flag_1ms == 1&#39;b1))        case(cnt_sel)        3&#39;d0:   data_disp    &lt;=  data_reg[3:0]  ;  //给第1个数码管赋个位值        3&#39;d1:   data_disp    &lt;=  data_reg[7:4]  ;  //给第2个数码管赋十位值        3&#39;d2:   data_disp    &lt;=  data_reg[11:8] ;  //给第3个数码管赋百位值        3&#39;d3:   data_disp    &lt;=  data_reg[15:12];  //给第4个数码管赋千位值        3&#39;d4:   data_disp    &lt;=  data_reg[19:16];  //给第5个数码管赋万位值        3&#39;d5:   data_disp    &lt;=  data_reg[23:20];  //给第6个数码管赋十万位值        default:data_disp    &lt;=  4&#39;b0        ;        endcase    else        data_disp   &lt;=  data_disp;//dot_disp：小数点低电平点亮，需对小数点有效信号取反always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        dot_disp    &lt;=  1&#39;b1;    else    if(flag_1ms == 1&#39;b1)        dot_disp    &lt;=  ~point[cnt_sel];    else        dot_disp    &lt;=  dot_disp;//控制数码管段选信号，显示数字always@(posedge sys_clk or  negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        seg &lt;=  8&#39;b1111_1111;    else            case(data_disp)            4&#39;d0  : seg  &lt;=  &#123;dot_disp,7&#39;b100_0000&#125;;    //显示数字0            4&#39;d1  : seg  &lt;=  &#123;dot_disp,7&#39;b111_1001&#125;;    //显示数字1            4&#39;d2  : seg  &lt;=  &#123;dot_disp,7&#39;b010_0100&#125;;    //显示数字2            4&#39;d3  : seg  &lt;=  &#123;dot_disp,7&#39;b011_0000&#125;;    //显示数字3            4&#39;d4  : seg  &lt;=  &#123;dot_disp,7&#39;b001_1001&#125;;    //显示数字4            4&#39;d5  : seg  &lt;=  &#123;dot_disp,7&#39;b001_0010&#125;;    //显示数字5            4&#39;d6  : seg  &lt;=  &#123;dot_disp,7&#39;b000_0010&#125;;    //显示数字6            4&#39;d7  : seg  &lt;=  &#123;dot_disp,7&#39;b111_1000&#125;;    //显示数字7            4&#39;d8  : seg  &lt;=  &#123;dot_disp,7&#39;b000_0000&#125;;    //显示数字8            4&#39;d9  : seg  &lt;=  &#123;dot_disp,7&#39;b001_0000&#125;;    //显示数字9            4&#39;d10 : seg  &lt;=  8&#39;b1011_1111          ;    //显示负号            4&#39;d11 : seg  &lt;=  8&#39;b1111_1111          ;    //不显示任何字符            default:seg  &lt;=  8&#39;b1100_0000;        endcase//sel:数码管位选信号赋值always@(posedge sys_clk or negedge sys_rst_n)    if(sys_rst_n == 1&#39;b0)        sel &lt;=  6&#39;b000_000;    else        sel &lt;=  sel_reg;//********************************************************************////*************************** Instantiation **************************////********************************************************************////---------- bsd_8421_inst ----------bcd_8421    bcd_8421_inst(    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n),   //复位信号，低电平有效    .data        (data     ),   //输入需要转换的数据    .unit        (unit     ),   //个位BCD码    .ten         (ten      ),   //十位BCD码    .hun         (hun      ),   //百位BCD码    .tho         (tho      ),   //千位BCD码    .t_tho       (t_tho    ),   //万位BCD码    .h_hun       (h_hun    )    //十万位BCD码);endmodule</code></pre><h4 id="top-seg-dynamic"><a href="#top-seg-dynamic" class="headerlink" title="&lt;4&gt;top_seg_dynamic"></a>&lt;4&gt;top_seg_dynamic</h4><pre><code>`timescale  1ns/1nsmodule  top_seg_dynamic(    input   wire            sys_clk     ,   //系统时钟，频率50MHz    input   wire            sys_rst_n   ,   //复位信号，低电平有效    output  wire    [5:0]   sel         ,   //数码管位选信号    output  wire    [7:0]   seg             //数码管段选信号);//********************************************************************////******************** Parameter And Internal Signal *****************////********************************************************************////wire  definewire    [19:0]  data    ;   //数码管要显示的值wire    [5:0]   point   ;   //小数点显示,高电平有效top_seg_595wire            seg_en  ;   //数码管使能信号，高电平有效wire            sign    ;   //符号位，高电平显示负号//********************************************************************////**************************** Main Code *****************************////********************************************************************////-------------data_gen_inst--------------data_gen    data_gen_inst(    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n),   //复位信号，低电平有效        .data        (data     ),   //数码管要显示的值    .point       (point    ),   //小数点显示,高电平有效    .seg_en      (seg_en   ),   //数码管使能信号，高电平有效    .sign        (sign     )    //符号位，高电平显示负号);//-------------seg7_dynamic_inst--------------seg_dynamic seg_dynamic_inst(    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n),   //复位信号，低有效    .data        (data     ),   //数码管要显示的值    .point       (point    ),   //小数点显示,高电平有效    .seg_en      (seg_en   ),   //数码管使能信号，高电平有效    .sign        (sign     ),   //符号位，高电平显示负号    .sel         (sel      ),   //数码管位选信号    .seg         (seg      )    //数码管段选信号);endmodule</code></pre><h3 id="2-仿真-6"><a href="#2-仿真-6" class="headerlink" title="2.仿真"></a>2.仿真</h3><pre><code>`timescale  1ns/1ns// Author  : EmbedFire// 实验平台: 野火FPGA系列开发板// 公司    : http://www.embedfire.com// 论坛    : http://www.firebbs.cn// 淘宝    : https://fire-stm32.taobao.commodule  tb_top_seg_dynamic();//********************************************************************////****************** Parameter and Internal Signal *******************////********************************************************************////wire  definewire    sel    ;   //数码管位选信号wire    seg    ;   //数码管段选信号//reg   definereg     sys_clk     ;reg     sys_rst_n   ;//********************************************************************////***************************** Main Code ****************************////********************************************************************////对sys_clk,sys_rst_n赋初始值initial    begin        sys_clk     =   1&#39;b1;        sys_rst_n   &lt;=  1&#39;b0;        #100        sys_rst_n   &lt;=  1&#39;b1;    end//clk:产生时钟always  #10 sys_clk &lt;=  ~sys_clk;//重新定义参数值，缩短仿真时间defparam  top_seg_dynamic_inst.seg_dynamic_inst.CNT_MAX =    9;defparam  top_seg_dynamic_inst.data_gen_inst.CNT_MAX    =  239;//********************************************************************////*************************** Instantiation **************************////********************************************************************////------------- seg_595_static_inst -------------top_seg_dynamic  top_seg_dynamic_inst(    .sys_clk     (sys_clk   ),  //系统时钟，频率50MHz    .sys_rst_n   (sys_rst_n ),  //复位信号，低电平有效    .sel         (sel       ),  //串行数据输入    .seg         (seg       )   //输出使能信号);endmodule</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132314807">https://blog.csdn.net/qq_32971095/article/details/132314807</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDL语法——FPGA学习笔记＜1＞</title>
      <link href="/2023/08/15/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/"/>
      <url>/2023/08/15/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E6%A6%82%E8%BF%B0">一.Verilog概述</a></p><p><a href="about:blank#%E4%BA%8C.%E5%85%B7%E4%BD%93%E8%AF%AD%E6%B3%95">二.Verilog具体语法</a></p><p><a href="about:blank#1.%E6%A0%87%E8%AF%86">1.标识</a></p><p><a href="about:blank#2.%E9%80%BB%E8%BE%91%E5%80%BC">2.逻辑值</a></p><p><a href="about:blank#3.%E5%B8%B8%E9%87%8F">3.常量</a></p><p><a href="about:blank#4.%E5%8F%98%E9%87%8F">4.变量</a></p><p><a href="about:blank#5.%E5%8F%82%E6%95%B0">5.参数</a></p><p><a href="about:blank#6.%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">6.赋值语句</a></p><p><a href="about:blank#7.%E8%BF%90%E7%AE%97%E7%AC%A6">7.运算符</a></p><p><a href="about:blank#8.%E8%AF%AD%E5%8F%A5">8.语句</a></p><p><a href="about:blank#9.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">9.系统函数</a></p><hr><p>参考书目：《野火FPGA Verilog 开发实战指南》</p><h2 id="一-Verilog概述"><a href="#一-Verilog概述" class="headerlink" title="一.Verilog概述"></a>一.Verilog概述</h2><p>1.IEEE定义标准Verilog语法参考文档</p><p><a href="https://ieeexplore.ieee.org/document/1620780" title="IEEE Standard for Verilog Hardware DescriptionLanguage">IEEE Standard for Verilog Hardware Description Language<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://ieeexplore.ieee.org/document/1620780</a><img src="https://i-blog.csdnimg.cn/blog_migrate/f28180bb6ad7d5e7cf2d0be08bed5b87.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42b3b557654abe4183f82a59a0ba6d84.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/83f261e770d0298d5b3c99ef2a82a1af.png"></p><h2 id="二-Verilog具体语法"><a href="#二-Verilog具体语法" class="headerlink" title="二.Verilog具体语法"></a>二.Verilog具体语法</h2><p>**  KEY WORD：标识符、逻辑值、常量、变量、参数、赋值语句、注释、运算符、语句、系统函数**</p><h3 id="1-标识"><a href="#1-标识" class="headerlink" title="1.标识"></a>1.标识</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5faa8d75ee441d53d178a116fc8754d8.png"></p><h3 id="2-逻辑值"><a href="#2-逻辑值" class="headerlink" title="2.逻辑值"></a>2.逻辑值</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90dc5515dae6c757c524019fa8383c66.png"></p><h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcf1e8adfc490d537036a7ab48c212e7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/019cf81e0945052440e899cf52edd6cb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d078c9fd4a40ce4295d4b0744c878321.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/18d269aa4707511f0473895823444f06.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb92bfc53bec3fd438009b3ae9a773f.png"></p><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d098bdb00c939fa2dcf3efe1100fb3b.png"></p><h3 id="5-参数"><a href="#5-参数" class="headerlink" title="5.参数"></a>5.参数</h3><p>有parameter和localparam两种，前者可以通过实例化在model外部改变</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bf3c357e7436845ff568400d9196dc4e.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3be814a053d3080ca8ca49ad54ab5a65.png"></p><h3 id="6-赋值语句"><a href="#6-赋值语句" class="headerlink" title="6.赋值语句"></a>6.赋值语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39d62da1b54d44b352732de96396a766.png"></p><h3 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edd387a12d3e04f5571e0679c848aebb.png"></p><p> 注:^异或运算</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3c0a5e86253afeb65e89f7f4e001e28c.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/908f2d529d157eac38981769103cf85a.png"></p><h3 id="8-语句"><a href="#8-语句" class="headerlink" title="8.语句"></a>8.语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efec5da318903ecd4b9ebe1870d3c8db.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2fbf03e1dc5171c9a448486ed7563340.png"></p><h3 id="9-系统函数"><a href="#9-系统函数" class="headerlink" title="9.系统函数"></a>9.系统函数</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1b041ff1b50feb52ba7288198de8082.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca2d1eaf85929c7ff512190c9a77271.png"></p><p> wirte与display区别：不自动换行</p><p>strobe：最后执行<img src="https://i-blog.csdnimg.cn/blog_migrate/fac806b50bdd1a8089f129b7e824e507.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4be67eab72d8fffa966896974f67a64.png"></p><p>monitor：当变量变化时打印</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb492cf19fd7d3df4ad2a237caf4ee09.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/87b31817095385274983dbecfcaab5d1.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/71bdc0b1d1cd629da73bac8834b0c764.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4b45c51ab3699a795f370bf588fd3e7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/367dd47eb20337132f7bf1dd5641e3f1.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6e281793195ce7abdddbcbc97812adb.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/21be8673f8f0217c17967439be42ccdd.png"></p><p>注：a是位宽为8bit，深度为20的存储器；reg [7:0]是一个变量类型</p><p>三.VHDL概述</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132308209">https://blog.csdn.net/qq_32971095/article/details/132308209</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA基本概念及资源整理——FPGA学习笔记＜0＞</title>
      <link href="/2023/08/10/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/"/>
      <url>/2023/08/10/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p><p><a href="about:blank#%E4%B8%80.FPGA%C2%A0">一.FPGA </a></p><p><a href="about:blank#%E4%BA%8C.FPGA%2BAI">二.FPGA+AI</a></p><p><a href="about:blank#%E4%B8%89.HDL">三.HDL</a></p><p><a href="about:blank#%E5%9B%9B.XILINX">四.XILINX</a></p><p><a href="about:blank#%E4%BA%94.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">五.学习资源</a></p><p><a href="about:blank#%E5%85%AD.%E5%85%B6%E4%BB%96">六.硬件命名规则</a></p><p><a href="about:blank#%E4%B8%83.vivado%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">七.vivado使用介绍</a></p><p>[八.FPGA Arm-Cortex-M1软核配置](about:blank#%E5%85%AB.FPGA%20Arm-<br>Cortex-M1%E8%BD%AF%E6%A0%B8%E9%85%8D%E7%BD%AE)</p><p><a href="about:blank#%E4%B9%9D.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">九.xilinx Zynq UltraScale+ MPSoC</a></p><p><a href="about:blank#%E5%8D%81.%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E6%B1%87%E6%80%BB">十.学习实践汇总</a></p><hr><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><p>作者的“FPGA学习笔记”系列将采用野火 XILINX-Artix7-FPGA 升腾开发板作为学习平台进行学习，总结学习过程中的收获。</p><p><strong>学习实践汇总</strong></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="​​​​​​verilog语法——FPGA学习笔记＜1＞">​​​​​​verilog语法——FPGA学习笔记＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132308209?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞xilinx FPGA<br>verilog工程设计流程<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132314807?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132779996?spm=1001.2014.3001.5502" title="基础设计二（IP核）——FPGA学习笔记＜3＞">基础设计二（IP核）——FPGA学习笔记＜3＞xilinx fpga<br>基础设计学习笔记，学习资料来自野火<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132779996?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132818565?spm=1001.2014.3001.5502" title="基础设计三（RS232、I2C）——FPGA学习笔记＜4＞">基础设计三（RS232、I2C）——FPGA学习笔记＜4＞参考书目：《野火FPGA Verilog<br>开发实战指南》<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132818565?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/132993678?spm=1001.2014.3001.5502" title="基础设计四（信号采集、发生）——FPGA学习笔记＜5＞">基础设计四（信号采集、发生）——FPGA学习笔记＜5＞频率测量法：在时间 t 内对被测时钟信号的时钟周期 N<br>进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。周期测量法：先测量出被测时钟信号的时钟周期 T，然后根据频率 f &#x3D; 1／T<br>求出被测时钟信号的频率。但是上述两种方法都会产生±1<br>个被测时钟周期的误差，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量，但二者都不能兼顾高低频率同样精度的测量要求。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132993678?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/133174030?spm=1001.2014.3001.5502" title="基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞">基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态，<br>但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会<br>改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率<br>的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少。​。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133174030?spm&#x3D;1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/133233092?spm=1001.2014.3001.5502" title="Zynq简介——FPGA学习笔记＜7＞">Zynq简介——FPGA学习笔记＜7＞Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on<br>Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和<br>Virtex 系列。每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和<br>UltraScale+（16nm），以提供不同的性能和功耗比。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133233092?spm&#x3D;1001.2014.3001.5502</a></p><h2 id="一-FPGA"><a href="#一-FPGA" class="headerlink" title="一.FPGA"></a>一.FPGA</h2><p>1.FPGA——可编程逻辑器件，大家都知道。大家可能之前还做过电子线路实验，用过Quartus II，但是当看到各种各样的型号比如Xilinx<br>Artix-7 XC7A35T、Altera Cyclone IV<br>EP4CE10时完全不知道这是什么，推荐看一下：<a href="https://zhuanlan.zhihu.com/p/117974989" title="FPGA最全科普总结">FPGA最全科普总结</a></p><p>大家还会看到Soc这个词，实际上就像是以前学的mcu：<a href="https://blog.csdn.net/lqingqing/article/details/51566841" title="MCU, SOC 区别">MCU, SOC<br>区别</a></p><p>2.关键名词：</p><p>可编程逻辑器件(PLD,Programmable Logic Device)</p><p>可编程整列逻辑(PAL,Progarmmable Array Logic)</p><p>CPLD(Complex Progarmmable Logic Device)</p><p>FPGA(Field Programmable Gate Array)</p><p>FPGA配置模式：并行主模式为一片FPGA加一片EPROM的方式；主从模式可以支持一片PROM编程多块FPGA；串行模式可以采用串行PROM编程FPGA；外设模式可以将FPGA作为微处理器的外设，由微处理器对其进行编程</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efb548d7fce00591ae02781195aab027.png" alt="da0a19b036704759be5eef2f40178dcd.png"></p><p>详细硬件介绍：参考图书或</p><p><a href="https://www.bilibili.com/video/BV1EE411475Z/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="从零开始系统学FPGA">从零开始系统学FPGA</a></p><h2 id="二-FPGA-AI"><a href="#二-FPGA-AI" class="headerlink" title="二.FPGA+AI"></a>二.FPGA+AI</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/89259418a2a5dcdcc118aea94879ed42.png" alt="0b2255268293419fa2598d8863ca129f.png"><br>用FPGA来干什么？方向FPGA+AI：<a href="https://zhuanlan.zhihu.com/p/428224002" title="Xilinx助力FPGA+AI时代">Xilinx助力FPGA+AI时代</a></p><p><a href="https://www.zhihu.com/tardis/zm/art/152167194?source_id=1005" title="两大FPGA公司的“AI技术路线">两大FPGA公司的“AI技术路线</a></p><p>FPGA在AI领域的优势：<a href="https://www.bilibili.com/read/cv13109378/?spm_id_from=333.999.collection.opus.click" title="FPGA图像处理的前景如何？">FPGA图像处理的前景如何？</a></p><h2 id="三-HDL"><a href="#三-HDL" class="headerlink" title="三.HDL"></a>三.HDL</h2><p>1.FPGA使用硬件描述语言，可参考：<a href="https://zhuanlan.zhihu.com/p/617299598" title="《Verilog》·第2章·硬件描述语言基础">《Verilog》·第2章·硬件描述语言基础</a></p><p>可能会用到的知识：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337168442583105536&__biz=MzIyMDc2NTQ0Mw==#wechat_redirect" title="基于Verilog的图像处理实现">基于Verilog的图像处理实现</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e33ffc8e402126dade14098a34c12b84.png" alt="01fbbd3b3ead49f68bc9187966e35cf5.png"><br>2.VHDL(VHSIC[Very-High-Speed Integrated Circuit] hardware Description<br>Language)</p><p>VHDL支持多层次抽象描述： <strong><strong>行为层次（Behavioral）关注模块功能描述和仿真验证；寄存器传输层次（RTL，Register Transfer<br>Level）关注模块的可综合电路的实现；逻辑门层次（Logic）考虑如何用门级电路实现给定功能；布图层次（Lay<br>Out）考虑如何将电路适配到FPGA的资源中。</strong></strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcec777e5ea768a2abd0eb8059465495.jpeg" alt="a66a88467432488caf83079131890d3d.jpeg"></p><p>VHDL基本设计单元：实体（Entity）、构造体（Architecture）、配置（Configuration）；包集合（Package）；库（Library）</p><p>3.Verilog HDL</p><h2 id="四-XILINX"><a href="#四-XILINX" class="headerlink" title="四.XILINX"></a>四.XILINX</h2><p>xilinx公司的产品系列：<a href="https://china.xilinx.com/products/silicon-devices/fpga.html" title="FPGA 和 3D IC (xilinx.com)">FPGA 和 3D IC<br>(xilinx.com)</a></p><p>文档搜索库：<a href="https://docs.xilinx.com/" title="Homepage • AMD Adaptive ComputingDocumentation Portal (xilinx.com)">Homepage • AMD Adaptive Computing Documentation Portal<br>(xilinx.com)</a></p><p>Artix-7官方文档：[搜索结果 • AMD 自适应计算文档门户<br>(xilinx.com)](<a href="https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&content-">https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&amp;content-</a><br>lang&#x3D;en-US “搜索结果 • AMD 自适应计算文档门户 (xilinx.com)“)</p><p>设计软件平台：</p><p>xilinx开发工具有哪些：<a href="https://www.bilibili.com/read/cv17335988/?spm_id_from=333.999.collection.opus.click" title="Vitis AI 系列视频 QA&amp;目录（待续）">Vitis AI 系列视频<br>QA&amp;目录（待续）</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e0feb3e8280ba4e06a7efb6f968a73b.png" alt="b6db89dc700f40f7bcd5b85b40226fe7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/477090c37771b370ac8383bca92b9df3.png" alt="2b70623234004a648a9341940d8cc42d.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a884e13a6ae351570f5d5a459a8e6615.png" alt="8bf4e434fdf24062be63b880cc577862.png"></p><p> Vitis-AI：[Vitis AI (xilinx.com)](<a href="https://china.xilinx.com/products/design-">https://china.xilinx.com/products/design-</a><br>tools&#x2F;vitis&#x2F;vitis-<br>ai.html#:~:text&#x3D;Vitis%E2%84%A2%20AI%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%20Xilinx%20%E7%9A%84%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%9C%A8%20Xilinx%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%8C%85%E6%8B%AC%E8%BE%B9%E7%BC%98%E5%99%A8%E4%BB%B6%E5%92%8C%20Alveo,Vitis%20AI%20%E4%BB%A5%E9%AB%98%E6%95%88%E6%98%93%E7%94%A8%E4%B8%BA%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E5%8F%AF%E5%9C%A8%20Xilinx%20FPGA%20%E5%92%8C%20ACAP%20%E4%B8%8A%E5%85%85%E5%88%86%E5%8F%91%E6%8C%A5%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8A%A0%E9%80%9F%E7%9A%84%E6%BD%9C%E5%8A%9B%E3%80%82.<br>“Vitis AI (xilinx.com)“)</p><p>Vitis-AI官方支持：<a href="https://china.xilinx.com/developer/products/vitis-ai.html" title="VitisAI 快速上手 (xilinx.com)">Vitis AI 快速上手<br>(xilinx.com)</a></p><p>视频：[Vitis AI 全流程讲解<br>(xilinx.com)](<a href="https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-">https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-</a><br>to-finish_FanZhang_region.html “Vitis AI 全流程讲解 (xilinx.com)“)</p><p>Vitis下载：<a href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vitis.html" title="下载 (xilinx.com)">下载<br>(xilinx.com)</a></p><p>注：Vitis是为无FPGA设计经验的人设计的软件开发平台；Vitis-AI是面向算法开发者进行深度学习开发的高级加速库和设计工具；频繁出现的DPU：<a href="https://zhuanlan.zhihu.com/p/145142691" title="科普 | 什么是DPU？">科普 | 什么是DPU？</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4c07fd2ab54f220e025e0ba093c633b.png" alt="7a9ddd30cbdf4a63b7835c9b544bbe84.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/715135ad31ba1890ad0059989b959629.png" alt="96dccbd6cf2047299a08800ca75c7427.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/28c6afc7b5621b2c4ef9da58d3121937.png"></p><p>Model Zoo：使用公共数据集训练良好的Caffe、pytorch、TensorFlow框架模型</p><p>处理流程：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f36b2ab3b83d541a095d93b84af4e6c3.png" alt="2504e79b6665483da00848b8f78ee776.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/09e7b9fd2103db6fbce09719a58a1d52.png" alt="4a08eebc031e484090a0653b6b345ce2.png"></p><p>相关问题对话ChatGPT：<a href="https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f">https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f</a></p><p>xilinx社区：<a href="https://xilinx.eetrend.com/" title="电子创新网赛灵思社区 | 电子创新网 (eetrend.com)">电子创新网赛灵思社区 | 电子创新网 (eetrend.com)</a></p><p>xilinx技术支持社区：<a href="https://support.xilinx.com/s/?language=zh_CN" title="主页 (xilinx.com)">主页 (xilinx.com)</a></p><h2 id="五-学习资源"><a href="#五-学习资源" class="headerlink" title="五.学习资源"></a>五.学习资源</h2><p>1.竞赛平台提供</p><p>FPGA创新大赛：<a href="http://fpga.icisc.cn/video?value=4" title="培训视频_全国大学生fpga创新设计竞赛官网">培训视频_全国大学生fpga创新设计竞赛官网</a></p><p>龙芯杯：[LoongsonEdu&#x2F;nscscc-wiki (gitee.com)](<a href="https://gitee.com/loongson-">https://gitee.com/loongson-</a><br>edu&#x2F;nscscc-wiki “LoongsonEdu&#x2F;nscscc-wiki (gitee.com)“)</p><p>英特尔杯：[英特尔杯在线培训中心](<a href="https://www.xn--48sz67d.xn--">https://www.xn--48sz67d.xn--</a><br>fiqs8s&#x2F;p&#x2F;t_pc&#x2F;course_pc_detail&#x2F;big_column&#x2F;p_624f9a63e4b04e8d902ce9ce<br>“英特尔杯在线培训中心”)</p><p>2.野火资源</p><p><a href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA系列Xilinx Artix7教学视频">FPGA系列Xilinx<br>Artix7教学视频</a></p><p><a href="https://doc.embedfire.com/products/link/zh/latest/index.html" title="野火产品资料下载中心">野火产品资料下载中心</a></p><p>3.图书资源</p><p>《XILINX FPGA设计基础》《XILINX FPGA权威设计指南》《野火FPGAVerilog开发实战指南》</p><p>4.b站资源</p><p>推荐up主视频：</p><p><a href="https://www.bilibili.com/video/BV1Dg4y1v7P8/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="第0期 - 介绍与规划 -基于FPGA的数字信号处理系统开发笔记">第0期 - 介绍与规划<br>-基于FPGA的数字信号处理系统开发笔记</a></p><p><a href="https://space.bilibili.com/505234/channel/collectiondetail?sid=308669" title="Vitis&#x2F;Vitis AI开发笔记">Vitis&#x2F;Vitis<br>AI开发笔记</a></p><p><a href="https://space.bilibili.com/473639301/channel/collectiondetail?sid=852953" title="ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis HLS开发">ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis<br>HLS开发</a></p><p><a href="https://space.bilibili.com/2139404925/channel/collectiondetail?sid=197586" title="FPGA图像处理">FPGA图像处理</a></p><p>5.正点原子资料</p><p>[MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档](<a href="http://www.openedv.com/docs/boards/fpga/zdyz-">http://www.openedv.com/docs/boards/fpga/zdyz-</a><br>MPSOC.html “MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档”)</p><h2 id="六-硬件命名规则"><a href="#六-硬件命名规则" class="headerlink" title="六.硬件命名规则"></a>六.硬件命名规则</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9226e376971648da400fbec74c13e90.png" alt="3e62452446cd4e6db0ddeefee5a67020.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/31c9c122639646bdec9d69319b9313b3.png" alt="b3c7340adb9443c79cae1972129a00b7.png"><br>芯片资源</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/03842299e0ad76ca983e82f57289b07c.png" alt="1efa2f0f7686467791b576d34bc3d035.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/798af551557b2512a1d100f95fed5b77.png" alt="445d93be180549c688a0fe8c5617979b.png"></p><h2 id="七-vivado使用介绍"><a href="#七-vivado使用介绍" class="headerlink" title="七.vivado使用介绍"></a>七.vivado使用介绍</h2><p>参考《xilinx fpga权威设计指南》</p><p>1.首先书目介绍了新一代UltraScale结构，介绍了其CLB，包含LUT、触发器、查找表什么的，以此构成多路复用器、进位逻辑、存储等基本结构。（粗略浅看未看完）</p><p>2.vivado以前的版本是个IDE，现在出现了GUI，前后者的关系类似Windows的shell和图形界面的关系。而在之前所使用的是 **XDC  **语言，由标准约束语言 **Tcl  **演变而来，二者相似。vivado工程目录下的 .Journal 文件和 .Log 文件则可以记录Tcl命令和执行反馈，据此可在工程调试中导出.Journal文件制成Tcl命令脚本，实现快速自动化处理。<a href="https://xilinx.eetrend.com/content/2019/100046350.html#:~:text=XDC%20%E6%98%AF%20Xilinx%20Design%20Constraints%20%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%8C%E4%BD%86%E5%85%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%9D%A5%E6%BA%90%E4%BA%8E%E4%B8%9A%E7%95%8C%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BA%A6%E6%9D%9F%E8%A7%84%E8%8C%83SDC%E3%80%82%20XDC%20%E5%9C%A8%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF,I%2FO%20%E7%AD%89%E8%AF%AD%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%9C%A8%20Vivado%20%E4%B8%AD%20source%20%E4%B8%80%E4%B8%AA%20Tcl%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%A1%A5%E5%85%85%E3%80%82" title="XDC时钟约束 | 电子创新网赛灵思社区">XDC时钟约束 | 电子创新网赛灵思社区</a></p><p>3.接下来介绍vivado集成开发界面：</p><p>打开主界面三栏：快速开始（包含打开&#x2F;创建工程、<strong>打开示例工程</strong><br>）、Task（IP核操作、硬件管理器【要连接板子，下载步骤时也要打开】、Tcl商店）、资料中心（文档、<strong>视频</strong> 、注释向导）</p><p>任意打开一个工程，主界面左侧<strong>FlowNavigator（流程向导）</strong> ，包含：工程管理器（添加原文件、IP目录）、IP<br>集成器（设计用户IP核）、仿真、<strong>RTL分析（RTL ANALYSIS【<a href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513" title="RTL闪退解决">RTL<br>闪退解决</a>】，生成网表图、硬件引脚连接，生成.XDC文件）、综合（SYNTHESIS）、实现（IMPLEMENTATION）</strong>、编程和调试（生成比特流、打开硬件管理器）</p><p>可参考：<a href="https://blog.csdn.net/wuzhikaidetb/article/details/128295529" title="Vivado的RTL分析（RTL analysis）、综合（synthesis）和实现（implementation）的区别？">Vivado的RTL分析（RTL<br>analysis）、综合（synthesis）和实现（implementation）的区别？</a></p><p><strong>源窗口Source</strong> ，用于管理工程源文件，Hierarchy（层次）将工程按层次分组展示，Compile<br>order可设置工程文件编译顺序，文件右键点击set as top可设置为顶层文件。</p><p>4.然后是高层次综合工具Vidado HLS</p><p>原理即<strong>将高级语言如c&#x2F;c++转换成RTL级实现，还支持OpenCV函数</strong></p><h2 id="八-FPGA-Arm-Cortex-M1软核配置"><a href="#八-FPGA-Arm-Cortex-M1软核配置" class="headerlink" title="八.FPGA Arm-Cortex-M1软核配置"></a>八.FPGA Arm-Cortex-M1软核配置</h2><pre><code>    打开vivado IP manager，搜索 arm 显示可使用的 arm 核——Arm-Cortex-M1，若未安装可点击链接下载。Arm 官网下载 IP 核需要提前一周注册，提供免费使用的 IP 核有 M1 和 M3。</code></pre><h2 id="九-xilinx-Zynq-UltraScale-MPSoC"><a href="#九-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="九.xilinx Zynq UltraScale+ MPSoC"></a>九.xilinx Zynq UltraScale+ MPSoC</h2><p>[Zynq UltraScale+ MPSoC](<a href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p><p><a href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivityfor ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p><p><a href="http://www.pynq.io/" title="PYNQ -Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p><pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132220627">https://blog.csdn.net/qq_32971095/article/details/132220627</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年电赛E题完整设计暨电赛全记录</title>
      <link href="/2023/08/07/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/08/07/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1">一.2023年E题完整设计</a></p><p><a href="about:blank#%3C1%3E%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88">&lt;1&gt;选择方案</a></p><p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务一：实现按键按下复位（基础部分）</a></p><p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务二：实现激光点绕边框一周（基础部分）</a></p><p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务三：实现激光点绕A4纸边缘一周（基础部分）</a></p><p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89">任务四：实现绿色激光追踪红色激光（发挥部分）</a></p><p><a href="about:blank#%3C2%3E%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D">&lt;2&gt;任务分配</a></p><p><a href="about:blank#%3C3%3E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">&lt;3&gt;代码分析</a></p><p><a href="about:blank#1.stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.stm32上关键源码分析</a></p><p><a href="about:blank#I.%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86">I.基本部分</a></p><p><a href="about:blank#II.%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81">II.模块代码</a></p><p><a href="about:blank#%281%29Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97">(1)Timer——定时器延时函数模块</a></p><p><a href="about:blank#%282%29servo_motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">(2)servo_motor——云台舵机控制模块</a></p><p><a href="about:blank#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC">①控制舵机的旋转</a></p><p><a href="about:blank#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9">②控制激光点到达某一像素点</a></p><p><a href="about:blank#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson%20nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87">③与上位机jetson<br>nano通讯接收点坐标</a></p><p><a href="about:blank#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC">④得到一点坐标对应的舵机pwm波OC值</a></p><p><a href="about:blank#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF">⑤控制激光点沿四边形巡线</a></p><p><a href="about:blank#III.%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86">III.主函数与中断函数部分</a></p><p><a href="about:blank#%281%29%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(1)红色激光云台</a></p><p><a href="about:blank#%282%29%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(2)绿色激光云台</a></p><p><a href="about:blank#2.jetson%20nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2.jetson<br>nano上关键源码分析</a></p><p><a href="about:blank#I.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4">I.相机参数的调整</a></p><p><a href="about:blank#II.%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95">II.关键识别算法</a></p><p><a href="about:blank#%281%29%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(1)铅笔线识别及顶点的计算</a></p><p><a href="about:blank#%282%29A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(2)A4纸顶点识别及巡线顶点的计算</a></p><p><a href="about:blank#%283%29%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89">(3)区分红绿激光</a></p><p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">二.学习资料分享</a></p><p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A">&lt;1&gt;学习笔记</a></p><p><a href="about:blank#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99%EF%BC%9A">&lt;2&gt;其他资料</a></p><p><a href="about:blank#%E4%B8%89.%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95">三.备赛阶段记录</a></p><p><a href="about:blank#%E5%9B%9B.%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD">四.电赛总结及经验教训</a></p><p><a href="about:blank#%3C1%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84%EF%BC%9A">&lt;1&gt;本次比赛作品的不足、改进之处</a></p><p><a href="about:blank#%3C2%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%EF%BC%9A">&lt;2&gt;本次比赛的经验教训</a></p><hr><p>“愿大家都少走弯路，在迷茫时看到希望！”</p><h3 id="一-2023年E题完整设计"><a href="#一-2023年E题完整设计" class="headerlink" title="一.2023年E题完整设计"></a>一.2023年E题完整设计</h3><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="&lt;1&gt;选择方案"></a>&lt;1&gt;选择方案</h3><h4 id="任务一：实现按键按下复位（基础部分）"><a href="#任务一：实现按键按下复位（基础部分）" class="headerlink" title="任务一：实现按键按下复位（基础部分）"></a>任务一：实现按键按下复位（基础部分）</h4><p>方法①：识别四顶点位置-&gt;连接对角线得到中心点-&gt;PID调节使激光点与中心点重合</p><p>方法②：识别四顶点位置-&gt;对角顶点坐标求平均值得中心点位置-&gt;PID调节使重合</p><p>方法③：固定所有器件位置，保证各点PWM值不变，得到中心点PWM固定值，开环设定</p><h4 id="任务二：实现激光点绕边框一周（基础部分）"><a href="#任务二：实现激光点绕边框一周（基础部分）" class="headerlink" title="任务二：实现激光点绕边框一周（基础部分）"></a>任务二：实现激光点绕边框一周（基础部分）</h4><p>步骤I：激光点由中心点到达边线左上角</p><p>步骤II：顺时针绕一圈</p><pre><code>    方法①：两点定线，先确定两点坐标，连线确定等分点，使用PID算法在等分点间移动    方法②：不使用PID，利用与目标点坐标差计算移动方向，每次移动距离为舵机最小精度值    方法③：求PWM和坐标(x,y)的函数关系（近似线性），直接设定PWM值到达指定点</code></pre><h4 id="任务三：实现激光点绕A4纸边缘一周（基础部分）"><a href="#任务三：实现激光点绕A4纸边缘一周（基础部分）" class="headerlink" title="任务三：实现激光点绕A4纸边缘一周（基础部分）"></a>任务三：实现激光点绕A4纸边缘一周（基础部分）</h4><p>（与任务二区别：矩形放置角度可以倾斜；要区分两矩形宽度以识别A4纸）</p><h4 id="任务四：实现绿色激光追踪红色激光（发挥部分）"><a href="#任务四：实现绿色激光追踪红色激光（发挥部分）" class="headerlink" title="任务四：实现绿色激光追踪红色激光（发挥部分）"></a>任务四：实现绿色激光追踪红色激光（发挥部分）</h4><p>方法①：区分红绿色激光并得到坐标-&gt;PID直接跟踪</p><h3 id="任务分配"><a href="#任务分配" class="headerlink" title="&lt;2&gt;任务分配"></a>&lt;2&gt;任务分配</h3><p>将上述任务分解成多个要完成的技术，以便分工：</p><p>1.硬件平台搭建</p><p>2.stm32控制算法：</p><p>①PID控制激光点移动到目标点算法（核心）</p><p>②舵机以最小分度值移动算法（细微调节）</p><p>③给定两点以及等分数计算所有等分点算法（线上移动减少偏差）</p><p>④在PID寻点时获取基本点（矩形顶点及中心）PWM值算法</p><p>⑤stm32和jetson nano的通信规则设计与数据互传</p><p>3.OpenCV识别算法</p><p>①识别铅笔线边框：灰度图转换-&gt;阈值分割成二值图-&gt;霍夫直线变换得到直线上两点（非端点）-&gt;从得到的多条直线中筛选去重-&gt;编写“已知两直线上两点求直线交点”算法-&gt;求得四端点</p><p>②识别A4纸边框：阈值分割后利用Harris角点检测出A4框的8个顶点-&gt;编写“从8个顶点中识别两两相邻顶点”算法-&gt;求得框中心线4顶点</p><p>③区分红绿激光点算法：转换到Hsv色彩空间-&gt;分别设置阈值，在Hsv空间中二值化图像提取红绿色区域以得到激光点坐标  </p><p>4.主函数（程序流程）设计</p><p>5.电赛报告书写</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="&lt;3&gt;代码分析"></a>&lt;3&gt;代码分析</h3><h4 id="1-stm32上关键源码分析"><a href="#1-stm32上关键源码分析" class="headerlink" title="1.stm32上关键源码分析"></a>1.stm32上关键源码分析</h4><h5 id="I-基本部分"><a href="#I-基本部分" class="headerlink" title="I.基本部分"></a>I.基本部分</h5><p>(1)引脚使用说明</p><pre><code>//*************************引脚使用说明*************************/*oled.hGPIOA PIN0/1bluetooth.hGPIOA PIN2/3joystick.hGPIOA PIN4/5 ADC1_CH4/5 GPIOB PIN11/12/13 EXTI12/13Pwm.hGPIOA PIN8/11 TIM1_CH1/4 50hzusart.hGPIOA PIN9/10 TX/RX Black/Whitebeep.hGPIOB PIN14led.hGPIOB PIN15Timer.hTIM2/3*/</code></pre><p>(2)头文件声明</p><pre><code>//************************头文件声明************************#include &quot;public.h&quot;//公用引用函数封装//#include &quot;bluetooth.h&quot;//蓝牙模块#include &quot;oled.h&quot;//OLED显示屏模块#include &quot;Pwm.h&quot;//PWM波生成模块#include &quot;servo_motor.h&quot;//云台控制函数模块#include &quot;joystick.h&quot;//摇杆控制模块#include &quot;string.h&quot;#include &quot;Delay.h&quot;#include &quot;Timer.h&quot;//定时器模块#include &quot;usart.h&quot;//uart通信模块#include &quot;beep.h&quot;//蜂鸣器模块#include &quot;led.h&quot;//led灯模块#include &quot;dma.h&quot;//dma数据转存模块</code></pre><p>(3)全局变量和宏定义声明</p><pre><code>//************************全局变量和宏定义声明************************//#define OpenLoop_OL//开环实现功能执行#define CloseLoop_CL//闭环实现功能执行extern float Voltage[2];//ad测量电压值[0.3.3]//ad.cextern char  USART_RX_INFO[USART_REC_LEN];//uart接收数据//usart.cextern int x,y;//激光当前坐标//servo_motor.cextern int Vertex[4][2];//四顶点位置//servo_motor.cextern int Vertex_Peak_Pos[4][2];extern int Vertex_A4[4][2];extern Pwm Center_Pwm;extern Pwm Peak_Pwm[4];extern Pwm A4_Pwm[4];int Programme_Progress=0;//比赛程序进度int order=0;//蓝牙接收到的命令int Main_Wait_Stop_Sign =1;//主程序等待标志位extern int JoyStick_Control_Stop_Sign;//摇杆控制程序结束标志位int Get_Depend_Point_Pos_Stop_Sign=1;int Get_A4_Point_Pos_Stop_Sign=1;extern int Follow_Track_Stop_Sign;//矩形寻迹结束标志位extern int Follow_Point_Stop_Sign;//绿激光跟随红激光结束标志位</code></pre><h5 id="II-模块代码"><a href="#II-模块代码" class="headerlink" title="II.模块代码"></a>II.模块代码</h5><h6 id="1-Timer——定时器延时函数模块"><a href="#1-Timer——定时器延时函数模块" class="headerlink" title="(1)Timer——定时器延时函数模块"></a>(1)Timer——定时器延时函数模块</h6><pre><code>#include &quot;Timer.h&quot;//TIM2/3void Timer_Init(void)&#123;RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);TIM_InternalClockConfig(TIM2);TIM_InternalClockConfig(TIM3);TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;TIM_TimeBaseInitStructure.TIM_Period = 60000 - 1;//分辨率1us,最大60msTIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);&#125;void Timer_delay_us(int xus)&#123;TIM_Cmd(TIM2,ENABLE); //启动定时器while(TIM2-&gt;CNT &lt; xus);TIM2-&gt;CNT = 0;TIM_Cmd(TIM2,DISABLE); //关闭定时器&#125;void Timer_delay_ms(int xms)&#123;int i=0;for(i=0;i&lt;xms;i++)Timer_delay_us(1000);&#125;//外部中断专用延时函数void EXIT_LINE_Timer_delay_us(int xus)&#123;TIM_Cmd(TIM3,ENABLE); //启动定时器while(TIM3-&gt;CNT &lt; xus);TIM3-&gt;CNT = 0;TIM_Cmd(TIM3,DISABLE); //关闭定时器&#125;void EXIT_LINE_Timer_delay_ms(int xms)&#123;int i=0;for(i=0;i&lt;xms;i++)EXIT_LINE_Timer_delay_us(1000);&#125;</code></pre><p><strong>说明：</strong></p><p>在Timer_Init()中开启了两个定时器TIM1&#x2F;2，由Timer_delay_us()和EXIT_LINE_Timer_delay_us()分别使用，分别在中断函数内外使用，<strong>避免重复调用冲突</strong></p><h6 id="2-servo-motor——云台舵机控制模块"><a href="#2-servo-motor——云台舵机控制模块" class="headerlink" title="(2)servo_motor——云台舵机控制模块"></a>(2)servo_motor——云台舵机控制模块</h6><h6 id="①控制舵机的旋转"><a href="#①控制舵机的旋转" class="headerlink" title="①控制舵机的旋转"></a>①控制舵机的旋转</h6><pre><code>int Oc_Lp[4]=&#123;750,750,750,750&#125;;int Oc_Vp[4]=&#123;763,763,763,763&#125;;/*********************************************************函数功能：云台水平方向旋转*********************************************************/void Spinnig_Level(int diff)&#123;if(diff&lt;0)&#123;Oc_Lp[0]=Oc_L=(Oc_L+diff)&lt;660?660:(Oc_L+diff);&#125;else if(diff&gt;0)&#123;Oc_Lp[0]=Oc_L=(Oc_L+diff)&gt;840?840:(Oc_L+diff);&#125;TIM_SetCompare1(TIM1,Oc_L);int i;for(i=3;i&gt;0;i--)Oc_Lp[i]=Oc_Lp[i-1];&#125;</code></pre><p><strong>说明：</strong></p><p>这里的Oc_Lp存储的是控制舵机的pwm波参数中的OC寄存器中的值，作为舵机运动最基本的函数，<br><em><strong>舵机的控制通过改变pwm波参数中的OC寄存器中的值实现</strong></em><br>。这里定义数组实现记忆功能，可存储前三次的OC值。并通过三元运算符设定上下限，将最终的OC值通过TIM_SetCompare1()设定。</p><h6 id="②控制激光点到达某一像素点"><a href="#②控制激光点到达某一像素点" class="headerlink" title="②控制激光点到达某一像素点"></a>②控制激光点到达某一像素点</h6><pre><code>/*********************************************************函数功能：云台控制激光点到达某一点函数参数：目标点的坐标*********************************************************/int x=360,y=360;//跟随点当前坐标int Reach_Pos_CL_Stop_Sign=1;//云台水平方向旋转PID值float Level_Kp=0.06;float Level_Ki=0.02;float Level_Kd=0.01;//云台竖直方向旋转PID值float Vert_Kp=0.06;float Vert_Ki=0.02;float Vert_Kd=0.01;void Reach_Pos_CL(int Target_X,int Target_Y,int Reach_Pos_CL_MODE)&#123;int Sign(int num);void Get_Point_Pos(void);int near(int Target_X,int Target_Y);int diff_x,diff_y;while(Reach_Pos_CL_Stop_Sign)&#123;Timer_delay_ms(30);Get_Point_Pos();if(near(Target_X,Target_Y)&lt;=6)&#123;Beep_Times(10,1,NORMAL_MODE);break;&#125;if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&gt;60)//用pid计算舵机单位数&#123;diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,Target_X,x,PID_REALIZE);diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,Target_Y,y,PID_REALIZE);&#125;else if(Reach_Pos_CL_MODE==MINMIZE_MODE)//以舵机最小分辨率为单位&#123;diff_x=-Sign(x-Target_X);diff_y=-Sign(y-Target_Y);&#125;else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&lt;=60)//用pid计算舵机单位数&#123;diff_x=-Sign(x-Target_X);diff_y=-Sign(y-Target_Y);Timer_delay_ms(30);&#125;Spinnig_Level(X_DIR*diff_x);Spinnig_Vert(Y_DIR*diff_y);Timer_delay_ms(20);&#125;&#125;int Sign(int num)&#123;if(num&gt;5)return 1;else if(num&lt;-5)return -1;else return 0;&#125;int my_abs(int a,int b)&#123;return a-b&gt;0?a-b:b-a;&#125;int near(int Target_X,int Target_Y)&#123;return my_abs(Target_X,x)+my_abs(Target_Y,y);&#125;</code></pre><p><strong>说明：</strong></p><p>输入参数：目标点像素坐标；追踪模式（PID【PID与最小精度混合】模式和最小精度值模式）</p><p><strong>追踪过程：</strong></p><p>——得到当前激光点坐标：Get_Point_Pos()</p><p>——如果接近目标点则蜂鸣器鸣叫并退出【near(Target_X,Target_Y)&lt;&#x3D;6，说明当前坐标与目标横纵坐标差之和{“距离”}小于6个像素】</p><p>——如果使用PID模式：</p><pre><code>    ——“距离”大于60时采用PID算法快速靠近，计算出OC变化值diff_x、diff_y    ——“距离”小于60时使用最小精度模式缓慢靠近，利用“符号函数sign()”计算diff</code></pre><p>——调用Spinnig_Level()、Spinnig_Level()进行水平和垂直舵机的旋转</p><h6 id="③与上位机jetson-nano通讯接收点坐标"><a href="#③与上位机jetson-nano通讯接收点坐标" class="headerlink" title="③与上位机jetson nano通讯接收点坐标"></a>③与上位机jetson nano通讯接收点坐标</h6><p><strong>a.激光点坐标的实时接收</strong></p><pre><code>/*********************************************************函数功能：stm32获取当前激光坐标*********************************************************/void Get_Point_Pos(void)&#123;if(USART_RX_INFO[0]==&#39;x&#39;)//检查数据定位是否正确(上位机发送信息为：x123y456)&#123;x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;&#125;if(USART_RX_INFO[4]==&#39;y&#39;)//检查数据定位是否正确(上位机发送信息为：x123y456)&#123;y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;&#125;&#125;</code></pre><p><strong>说明：</strong></p><p>规定上位机每次发送数据格式为：以#开头，以$结尾；stm32usart模块对接收数据进行解析</p><p>上位机坐标数据格式为：x123y456；123、456代表三位坐标值，字符’x’、’y’起定位作用</p><p>stm32对接收到的字符坐标进行解析如上</p><p><strong>b.特殊坐标接收</strong></p><pre><code>//********************************************************高级控制函数(CloseLoop--CL)********************************************************int Vertex_Peak_Pos[4][2];int Center_Pos[2];Pwm Center_Pwm;Pwm Peak_Pwm[4];Pwm A4_Pwm[4]; //获取重要点坐标void Get_Point_5(void)&#123;int i,j;while(1)&#123;for(i=0;i&lt;8;i++)&#123;if(USART_RX_INFO[4*i]==&#39;a&#39;+i)continue;else break;&#125;if(i==8)&#123;for(i=0;i&lt;4;i++)&#123;for(j=0;j&lt;2;j++)Vertex_Peak_Pos[i][j]=(USART_RX_INFO[4*(2*i+j)+1]-&#39;0&#39;)*100+(USART_RX_INFO[4*(2*i+j)+2]-&#39;0&#39;)*10+(USART_RX_INFO[4*(2*i+j)+3]-&#39;0&#39;);&#125;break;&#125;&#125;while(!(USART_RX_INFO[0]==&#39;i&#39;&amp;&amp;USART_RX_INFO[4]==&#39;j&#39;));Center_Pos[0]=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;Center_Pos[1]=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;Beep_Times(50,5,NORMAL_MODE);&#125;</code></pre><p><strong>说明：</strong></p><p>这里接收的是铅笔线框四个顶点的坐标和中心点坐标，但是一次发送的数据长度不能太长，这里拆分成两部分接收（数据格式为：axxxbxxxcxxx…hxxx共8组值四个坐标），<br><em><strong>关键在于两部分的衔接</strong></em></p><p>while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<em><strong>确保收到四个顶点坐标后持续等待中心点坐标的发送</strong></em></p><h6 id="④得到一点坐标对应的舵机pwm波OC值"><a href="#④得到一点坐标对应的舵机pwm波OC值" class="headerlink" title="④得到一点坐标对应的舵机pwm波OC值"></a>④得到一点坐标对应的舵机pwm波OC值</h6><pre><code>int sum_num(int *num,int n)&#123;int i,sum;for(i=sum=0;i&lt;n;i++)sum+=num[i];return sum;&#125;//获取目标点pwm值void Get_Pwm(int px,int py,Pwm *target_pwm,int n)&#123;Reach_Pos_CL(px,py,PID_MODE);target_pwm-&gt;level=sum_num(Oc_Lp,n)/n;target_pwm-&gt;vert=sum_num(Oc_Vp,n)/n;&#125;</code></pre><p><strong>说明：</strong></p><p>通过②控制函数控制激光点到达指定点后记录目标点pwm值并返回；Pwm结构体定义如下</p><pre><code>typedef struct Pwm&#123;int level;int vert;&#125;Pwm;</code></pre><p>可以通过改变参数n的值选择是否滤波，4&gt;n&gt;1时进行滤波，取前几次OC值的平均值，不建议滤波</p><h6 id="⑤控制激光点沿四边形巡线"><a href="#⑤控制激光点沿四边形巡线" class="headerlink" title="⑤控制激光点沿四边形巡线"></a>⑤控制激光点沿四边形巡线</h6><pre><code>//巡线void Follow_Track(int Vertex[4][2],int divide_num)&#123;int i,j;float sub_l,sub_v;Pwm Vertex_Pwm[4];for(i=0;i&lt;4;i++)Get_Pwm(Vertex[i][0],Vertex[i][1],&amp;Vertex_Pwm[i],1);for(i=0;i&lt;4;i++)&#123;sub_l=(Vertex_Pwm[(i+1)%4].level-Vertex_Pwm[i].level);//下一个顶点与当前顶点pwm之差sub_v=(Vertex_Pwm[(i+1)%4].vert-Vertex_Pwm[i].vert);//下一个顶点与当前顶点纵坐标之差for(j=0;j&lt;divide_num;j++)&#123;Reach_Pos_OL(Vertex_Pwm[i].level+j*sub_l/divide_num,Vertex_Pwm[i].vert+j*sub_v/divide_num);Timer_delay_ms(200);&#125;Reach_Pos_OL(Vertex_Pwm[(i+1)%4].level,Vertex_Pwm[(i+1)%4].vert);Timer_delay_ms(300);&#125;Beep_Times(50,5,NORMAL_MODE);&#125;</code></pre><p><strong>说明：</strong></p><p>输入参数：四边形顺时针顺序顶点坐标、每段等分数divide_num</p><p><strong>巡线过程：</strong></p><p>——得到四个顶点坐标对应的水平、数值舵机OC值</p><p>——在for循环内依次经过四个顶点，视作四个大任务</p><pre><code>    ——内部使用for循环分解小任务，根据等分段数divide_num计算等分点横纵pwm值并移动至</code></pre><p>——任务结束鸣叫示意</p><h5 id="III-主函数与中断函数部分"><a href="#III-主函数与中断函数部分" class="headerlink" title="III.主函数与中断函数部分"></a>III.主函数与中断函数部分</h5><h6 id="1-红色激光云台"><a href="#1-红色激光云台" class="headerlink" title="(1)红色激光云台"></a>(1)红色激光云台</h6><pre><code>//*************************主函数部分*************************//重新重启初值还原设置void Programme_Reset(void)&#123;Beep_Times(1000,1,NORMAL_MODE);Led_Times(1000,1,NORMAL_MODE);Programme_Progress=0;Main_Wait_Stop_Sign=1;JoyStick_Control_Stop_Sign=1;Follow_Track_Stop_Sign=1;Get_A4_Point_Pos_Stop_Sign=1;Get_Depend_Point_Pos_Stop_Sign=1;&#125;int main(void)&#123;//********************初始化程序********************Timer_Init();//定时器初始化//BlueToothInit(9600,USART_Parity_No,USART_StopBits_1,USART_WordLength_8b);//蓝牙初始化OLED_Init();//oled初始化Beep_Init();//蜂鸣器初始化Led_Init();//led灯初始化TIM1_PWM_Init(9999,143);//一周期20ms，分辨率20ms/10000）TIM_SetCompare1(TIM1,750);//对齐角度为90度(1.5ms)TIM_SetCompare4(TIM1,763);//对齐角度为90度(1.5ms)uart_init(115200);//uart1初始化JoyStick_Init();//JoyStick摇杆初始化//*************************比赛程序部分*************************while(1)&#123;int i;//重新重启初值还原设置Programme_Reset();//Reach_Pos_CL(50,50,PID_MODE);Axes_Init();//Follow_Track(Vertex_Peak_Pos,1);while(Main_Wait_Stop_Sign);//摇杆控制JoyStick_Control();//#ifdef OpenLoop_OL//Follow_Track_OL();//#endif//#ifdef CloseLoop_CL////等待上位机发送初始坐标//Get_Depend_Point_Pos();////环绕正方形顺时针旋转一周//while(Get_Depend_Point_Pos_Stop_Sign);//Follow_Track_CL(Vertex_Peak_Pos,2,PID_MODE);//#endifPwm_Track(Peak_Pwm,1);while(Follow_Track_Stop_Sign);Get_A4_Point_Pos();Timer_delay_ms(2000);//Follow_Track_CL(Vertex_A4,4,MINMIZE_MODE);//Follow_Track(Vertex_A4,4);for(i=0;i&lt;4;i++)Get_Pwm(Vertex_A4[i][0],Vertex_A4[i][1],&amp;A4_Pwm[i],1);Pwm_Track(A4_Pwm,6);while(Get_A4_Point_Pos_Stop_Sign);&#125;&#125;//*********************************************中断函数部分*********************************************//按键中断函数void EXTI15_10_IRQHandler()&#123;if (EXTI_GetITStatus(EXTI_Line11) == SET)&#123;EXIT_LINE_Timer_delay_ms(10);if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0)//软件防抖&#123;Beep_Times(50,2,EXIT_LINE_MODE);Reach_Pos_OL(Oc_L,Oc_V);//保持激光当前指向位置while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0); //等待按键松开//再次按下才退出EXIT_LINE_Timer_delay_ms(10);while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==1);EXIT_LINE_Timer_delay_ms(10);if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0);//软件防抖while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11==1)); //等待按键松开Beep_Times(50,2,EXIT_LINE_MODE);EXTI_ClearITPendingBit(EXTI_Line11);&#125;&#125;else if (EXTI_GetITStatus(EXTI_Line12) == SET)&#123;EXIT_LINE_Timer_delay_ms(10);if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0)//软件防抖&#123;Programme_Progress++;Beep_Times(500,1,EXIT_LINE_MODE);if(Programme_Progress==1)&#123;Main_Wait_Stop_Sign=0;&#125;else if(Programme_Progress==2)&#123;JoyStick_Control_Stop_Sign=0;&#125;else if(Programme_Progress==3)&#123;//Get_Depend_Point_Pos_Stop_Sign=0;Follow_Track_Stop_Sign=0;&#125;else if(Programme_Progress==4)&#123;Get_A4_Point_Pos_Stop_Sign=0;//Follow_Track_Stop_Sign=0;&#125;else if(Programme_Progress==5)&#123;//Get_A4_Point_Pos_Stop_Sign=0;&#125;else if(Programme_Progress==6)&#123;;&#125;else if(Programme_Progress==7)&#123;;&#125;else&#123;Programme_Reset();&#125;while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0); //等待按键松开EXTI_ClearITPendingBit(EXTI_Line12);&#125;&#125;else if (EXTI_GetITStatus(EXTI_Line13) == SET)&#123;EXIT_LINE_Timer_delay_ms(10);if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0)//软件防抖&#123;Beep_Times(50,3,EXIT_LINE_MODE);Reach_Pos_OL(Center_Pwm.level,Center_Pwm.vert);while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0); //等待按键松开//再次按下才退出EXIT_LINE_Timer_delay_ms(10);while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==1);EXIT_LINE_Timer_delay_ms(10);if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0);//软件防抖while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13==1)); //等待按键松开Beep_Times(50,3,EXIT_LINE_MODE);EXTI_ClearITPendingBit(EXTI_Line13);&#125;&#125;&#125;</code></pre><p><strong>说明：</strong></p><p>主函数与中断函数相辅相成，程序整体使用外部中断推进以及实现一些特殊功能（立即复位）；</p><p>由于主函数内小功能函数都借助while()循环实现，设置循环标志位Stop_Sign和程序阶段标志位Programme_Progress来推进主函数；</p><p>按下GPIOB,GPIO_Pin_12的按键触发中断，Programme_Progress++以及相应的Stop_Sign&#x3D;0，以控制目前运行小功能停止并进入下一阶段；</p><p>在程序开始和结束处执行Programme_Reset()函数，重置各标志位实现程序重新运行；</p><p><strong>注意：</strong></p><p>在中断函数内部涉及到的延时函数统统使用EXIT_LINE_Timer_delay_ms()函数，区别外部使用的Timer_delay_ms()函数，防止调用冲突程序卡死</p><h6 id="2-绿色激光云台"><a href="#2-绿色激光云台" class="headerlink" title="(2)绿色激光云台"></a>(2)绿色激光云台</h6><pre><code>//绿车int r_x=0,r_y=0;void Get_RaG_Point_Pos(void)&#123;if(USART_RX_INFO[0]==&#39;g&#39;&amp;&amp; USART_RX_INFO[8]==&#39;r&#39;&amp;&amp; USART_RX_INFO[4]==&#39;y&#39;&amp;&amp; USART_RX_INFO[12]==&#39;y&#39;)//检查数据定位是否正确(上位机发送信息为：x123y456)&#123;x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;r_x=(USART_RX_INFO[9]-&#39;0&#39;)*100+(USART_RX_INFO[10]-&#39;0&#39;)*10+USART_RX_INFO[11]-&#39;0&#39;;r_y=(USART_RX_INFO[13]-&#39;0&#39;)*100+(USART_RX_INFO[14]-&#39;0&#39;)*10+USART_RX_INFO[15]-&#39;0&#39;;&#125;&#125;void G_Follow_R(int Reach_Pos_CL_MODE)&#123;int Sign(int num);void Get_RaG_Point_Pos(void);int near(int r_x,int Target_Y);int diff_x,diff_y,dis;while(Reach_Pos_CL_Stop_Sign)&#123;if(x==0&amp;&amp;y==0)Reach_Pos_OL(750,750);Get_RaG_Point_Pos();dis=near(r_x,r_y);if(dis&lt;=20)&#123;Beep_Times(300,1,NORMAL_MODE);Led_Times(300,1,NORMAL_MODE);continue;&#125;if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&gt;60)//用pid计算舵机单位数&#123;Get_RaG_Point_Pos();diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,r_x,x,PID_REALIZE);diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,r_y,y,PID_REALIZE);&#125;else if(Reach_Pos_CL_MODE==MINMIZE_MODE)//以舵机最小分辨率为单位&#123;Get_RaG_Point_Pos();diff_x=-0.5*Sign(x-r_x);diff_y=-0.5*Sign(y-r_y);&#125;else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&lt;=60)//用pid计算舵机单位数&#123;Get_RaG_Point_Pos();diff_x=-0.4*Sign(x-r_x);diff_y=-0.4*Sign(y-r_y);&#125;Spinnig_Level(X_DIR*diff_x);Spinnig_Vert(Y_DIR*diff_y);Timer_delay_ms(20);&#125;&#125;</code></pre><p><strong>说明：</strong></p><p>上位机数据格式为：g123y123r123y123，实时传输红绿激光点两个坐标；</p><p>执行点到点的跟踪即可，在主函数中不断重复即可，即while(1)G_Follow_R(PID_MODE);</p><h4 id="2-jetson-nano上关键源码分析"><a href="#2-jetson-nano上关键源码分析" class="headerlink" title="2.jetson nano上关键源码分析"></a>2.jetson nano上关键源码分析</h4><p><strong>文件说明：</strong></p><p>mian_10、main_11、mian_12是测试函数，分别测试<strong>铅笔线识别效果</strong> 、<strong>A4纸识别效果</strong> 、<strong>红绿激光分别识别效果</strong><br>。设置了滑动条供<strong>调参</strong> 使用，确定好参数</p><p>q_1、q_2、q_3即为三个问题对应的程序，分别实现<strong>发送铅笔线顶点和中心坐标后实时传输红色激光点坐标</strong><br>、<strong>发送A4纸顶点坐标后实时传输红色激光点坐标</strong> 、<strong>实时传输红色和绿色激光点坐标</strong></p><h5 id="I-相机参数的调整"><a href="#I-相机参数的调整" class="headerlink" title="I.相机参数的调整"></a>I.相机参数的调整</h5><pre><code>string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)&#123;   return &quot;nvarguscamerasrc exposurecompensation=1 ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +       to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +       &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +       to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;&#125;</code></pre><p>这里设置好管道参数，主要调整曝光和饱和度，方便之后线条的检测以及红绿激光的区分</p><p>可以参考：<a href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p><h5 id="II-关键识别算法"><a href="#II-关键识别算法" class="headerlink" title="II.关键识别算法"></a>II.关键识别算法</h5><h6 id="1-铅笔线识别及顶点的计算"><a href="#1-铅笔线识别及顶点的计算" class="headerlink" title="(1)铅笔线识别及顶点的计算"></a>(1)铅笔线识别及顶点的计算</h6><p><strong>变量解析：</strong></p><pre><code>int Find = 0, l_x = 0, l_y = 0, r_x = 0, r_y = 0;int l[2][2],r[2][2],u[2][2],d[2][2];int ul[2],ur[2],dl[2],dr[2],ce[2];</code></pre><p>Find有效个数标志位，表示找到了几组有效的边上两点；</p><p>l_x、l_y、r_x、r_y寻找标志位，为1则分别表示上下左右边未找到有效值的两点值</p><p>l[2][2]、r[2][2]、u[2][2]、d[2][2]分别存储上下左右边上两点坐标</p><p>ul[2]、ur[2]、dl[2]、dr[2]、ce[2]分别存储最终的顶点和中心点坐标</p><p><strong>过程：</strong></p><p>——转换成灰度图-&gt;阈值划分成二制图-&gt;霍夫直线检测得到直线并输出直线上两点坐标</p><pre><code>    ——设计算法过滤筛选重复直线并存储两点坐标for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;                x1 = linesPPHT[i][0], y1 = linesPPHT[i][1], x2 = linesPPHT[i][2], y2 = linesPPHT[i][3];                line(image, Point(x1, y1), Point(x2, y2), Scalar(0), 1, 8);                if (x1 &lt; 150 &amp;&amp; x2 &lt; 150 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !l_x)&#123;Find++;l_x = (x2 + x1) / 2;l[0][0]=x1;l[0][1]=y1;l[1][0]=x2;l[1][1]=y2;&#125;                else if (y1 &lt; 150 &amp;&amp; y2 &lt; 150 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !l_y)&#123;Find++;l_y = (y1 + y2) / 2;u[0][0]=x1;u[0][1]=y1;u[1][0]=x2;u[1][1]=y2;&#125;                else if (x1 &gt; 570 &amp;&amp; x2 &gt; 570 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !r_x)&#123;Find++;r_x = (x2 + x1) / 2;r[0][0]=x1;r[0][1]=y1;r[1][0]=x2;r[1][1]=y2;&#125;                else if (y1 &gt; 570 &amp;&amp; y2 &gt; 570 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !r_y)&#123;Find++;r_y = (y1 + y2) / 2;d[0][0]=x1;d[0][1]=y1;d[1][0]=x2;d[1][1]=y2;&#125;            &#125;</code></pre><p>linesPPHT是霍夫直线检测函数的输出，linesPPHT.size()表示检测到直线的条数；这里根据直线上两点坐标值大小判断属于四条边的那一条；属于其中一条且之前未存储（标志位为1）（见if语句中的判断）则存储并将找点标志位Find+1；Find&#x3D;&#x3D;4时即寻找结束</p><p>——由于霍夫直线检测算法得到的并非顶点而是直线上两点，设计求两直线交点函数</p><pre><code>void crossline(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int cross[2])&#123;    cross[0]=(y3*x4*x2-y4*x3*x2-y3*x4*x1+y4*x3*x1-y1*x2*x4+y2*x1*x4+y1*x2*x3-y2*x1*x3)/(x4*y2-x4*y1-x3*y2+x3*y1-x2*y4+x2*y3+x1*y4-x1*y3);    cross[1]=(-y3*x4*y2+y4*x3*y2+y3*x4*y1-y4*x3*y1+y1*x2*y4-y1*x2*y3-y2*x1*y4+y2*x1*y3)/(y4*x2-y4*x1-y3*x2+x1*y3-y2*x4+y2*x3+y1*x4-y1*x3);&#125;</code></pre><p>输入的(x1,y1)~(x4,y4)是两条直线上四点坐标，输出交点坐标并赋值给cross；</p><pre><code>crossline(l[0][0],l[0][1],l[1][0],l[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ul);crossline(r[0][0],r[0][1],r[1][0],r[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ur);crossline(l[0][0],l[0][1],l[1][0],l[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dl);crossline(r[0][0],r[0][1],r[1][0],r[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dr);crossline(ul[0],ul[1],dr[0],dr[1],ur[0],ur[1],dl[0],dl[1],ce);</code></pre><p>输入之前得到的坐标计算四个顶点值和中心坐标</p><p>——向下位机stm32输出坐标</p><pre><code>sprintf(m,&quot;#a%03db%03dc%03dd%03de%03df%03dg%03dh%03d$\n&quot;,ul[0],ul[1],ur[0],ur[1],dr[0],dr[1],dl[0],dl[1]);uart.sendUart(m);usleep(50000);sprintf(m,&quot;#i%03dj%03d$\n&quot;,ce[0],ce[1]);uart.sendUart(m);</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png"></p><h6 id="2-A4纸顶点识别及巡线顶点的计算"><a href="#2-A4纸顶点识别及巡线顶点的计算" class="headerlink" title="(2)A4纸顶点识别及巡线顶点的计算"></a>(2)A4纸顶点识别及巡线顶点的计算</h6><p>过程：</p><p>——灰度图-&gt;二值化-&gt;角点检测得到角点坐标CornerImg</p><pre><code>    ——设计算法过滤筛选得到八个顶点P[8][2]（绝缘胶布内外边形成两个矩形）#define MAX_DIS 20int Is_Exit(int i, int j)&#123;    int k = 0;    for (k = 0; k &lt; Find; k++)     &#123;        if (myabs(P[k][0]-i)+ myabs(P[k][1]-j)&lt;MAX_DIS)return 1;    &#125;    return 0;&#125;int P[8][2] = &#123; 0 &#125;;int Find = 0;for (int j = 0; j &lt; CornerImg.rows; j++) &#123;    for (int i = 0; i &lt; CornerImg.cols; i++) &#123;        if (CornerImg.at&lt;float&gt;(j, i) &gt; 150.0f) &#123;            if (!Is_Exit(i, j))            &#123;                                            P[Find][0] = i;                P[Find][1] = j;                Find++;            &#125;        &#125;    &#125;&#125;</code></pre><p>Is_Exit()函数遍历已经视作有效的点，如果与当前坐标(i,j)接近则不存储；找到八个有效点退出</p><p>——设计根据八个顶点P[8][2]求得巡线四边形的顶点Vertex[4][2]（同一个角的内外顶点的中点）</p><pre><code>int Vertex[4][2] = &#123; 0 &#125;;int sign[8] = &#123; 0 &#125;;int i,j,k,dis,min = 1000;int temp1, temp2;for (k=0,i = 0; i &lt; 8; i++)&#123;    if (sign[i])continue;    min = 2000;    for (j = 0; j &lt; 8; j++)    &#123;        if (i == j||sign[j])continue;        dis = myabs(P[i][0] - P[j][0]) + myabs(P[i][1] - P[j][1]);        if (dis&lt; min)        &#123;            min = dis;            temp1 = i;            temp2 = j;        &#125;    &#125;    sign[temp1] = 1;    sign[temp2] = 1;    Vertex[k][0] = (P[temp1][0] + P[temp2][0])/2;    Vertex[k][1] = (P[temp1][1] + P[temp2][1])/2;    k++;&#125;</code></pre><p>这里使用for循环遍历P[8][2]中顶点，将距离最近的两点视为A4纸一个角内外两边的两个顶点，求其中点存储在Vertex[4][2]中</p><p>——设计算法使巡线的四个端点按照顺时针传输给下位机，否则巡线顺序错误</p><pre><code>int temp;//先整体按y值大小排序for(i=0;i&lt;4;i++)&#123;    for(min=Vertex[i][1],j=k=i;j&lt;4;j++)    &#123;        if(Vertex[j][1]&lt;=min)k=j;    &#125;    temp=Vertex[k][0];    Vertex[k][0]=Vertex[i][0];    Vertex[i][0]=temp;    temp=Vertex[k][1];    Vertex[k][1]=Vertex[i][1];    Vertex[i][1]=temp;&#125;//y值中等的两点按x值排序if(Vertex[1][0]&lt;Vertex[2][0])&#123;    temp=Vertex[1][0];    Vertex[1][0]=Vertex[2][0];    Vertex[2][0]=temp;    temp=Vertex[2][1];    Vertex[2][1]=Vertex[1][1];    Vertex[1][1]=temp;&#125;if(Vertex[0][0]&amp;&amp; Vertex[0][1]&amp;&amp;Vertex[1][0]&amp;&amp;Vertex[1][1]&amp;&amp;Vertex[3][0]&amp;&amp; Vertex[3][1]&amp;&amp;Vertex[2][0]&amp;&amp; Vertex[2][1])&#123;    sprintf(m,&quot;#k%03dl%03dm%03dn%03do%03dp%03dq%03dr%03d$\n&quot;, Vertex[0][0], Vertex[0][1],Vertex[1][0], Vertex[1][1],Vertex[3][0], Vertex[3][1],Vertex[2][0], Vertex[2][1]);    u.sendUart(m);&#125;</code></pre><p><strong>观察任意矩形顶点坐标规律，要顺时针发送，可将y值最小的作为第一个发送，y值最大的第三个发送，介于中间的两点按x值大小判断，x小的最后发送，大的第二个发送</strong></p><p>即先整体按y值大小排序，y值中等的两点按x值排序-&gt;排序后按<strong>0<del>1</del>3~2的顺序</strong> 发送坐标</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png"></p><h6 id="3-区分红绿激光"><a href="#3-区分红绿激光" class="headerlink" title="(3)区分红绿激光"></a>(3)区分红绿激光</h6><p><strong>过程如下：</strong></p><pre><code>Point color_recognite(Mat image, Scalar Low, Scalar High)&#123;    vector&lt;vector&lt;Point&gt;&gt; g_vContours;    vector&lt;Vec4i&gt; g_vHierarchy;    vector&lt;Mat&gt; hsvSplit;    double maxarea = 0;    int maxAreaIdx = 0;    Mat g_grayImage, hsv, g_cannyMat_output;    cvtColor(image, hsv, COLOR_BGR2HSV);    split(hsv, hsvSplit);    equalizeHist(hsvSplit[2], hsvSplit[2]);    merge(hsvSplit, hsv);    inRange(hsv, Low, High, g_grayImage);//二值化识别颜色    //开操作 (去除一些噪点)    Mat element = getStructuringElement(MORPH_RECT, Size(2, 2));    morphologyEx(g_grayImage, g_grayImage, MORPH_OPEN, element);    //闭操作 (连接一些连通域)    morphologyEx(g_grayImage, g_grayImage, MORPH_CLOSE, element);    //  Canny(g_grayImage, g_cannyMat_output, 80, 80 * 2, 3);    // 寻找轮廓    findContours(g_grayImage, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));    //假设contours是用findContours函数所得出的边缘点集    RotatedRect box;    Point centre;    if (g_vContours.size() != 0)    &#123;        for (int index = 0; index &lt; g_vContours.size(); index++)        &#123;            double tmparea = fabs(contourArea(g_vContours[index]));            if (tmparea &gt; maxarea)            &#123;                maxarea = tmparea;                maxAreaIdx = index;//记录最大轮廓的索引号            &#125;        &#125;        box = minAreaRect(g_vContours[maxAreaIdx]);        rectangle(image, box.boundingRect(), Scalar(0, 0, 255), 2);        centre = box.center;    &#125;    return centre;&#125;</code></pre><p>关键是调用inRange()函数HSV色彩空间二值化的阈值上下限设置</p><p>可以参考：<a href="https://blog.csdn.net/Home_Wood/article/details/88613977" title="OpenCV学习笔记-inRange()阈值操作函数怎么用_cv.inrange函数">OpenCV学习笔记-<br>inRange()阈值操作函数怎么用_cv.inrange函数</a></p><p>并设置滑动条调整参数获得经验值</p><p><strong>最终评判标准：</strong></p><p>激光在绝缘胶布上是能否识别（黑色胶布吸光；通过提高曝光，调参，增大激光功率等可以解决）</p><p>红绿激光靠近时能否区分（红绿在HSC空间互斥，更亮的会掩盖另一个；调inRange()参数解决）</p><h2 id="二-学习资料分享"><a href="#二-学习资料分享" class="headerlink" title="二.学习资料分享"></a>二.学习资料分享</h2><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="&lt;1&gt;学习笔记"></a>&lt;1&gt;学习笔记</h3><p><a href="https://blog.csdn.net/qq_32971095/article/details/131609797?spm=1001.2014.3001.5501" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131397697?spm=1001.2014.3001.5501" title="图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-CSDN博客">图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131503991?spm=1001.2014.3001.5501" title="图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-CSDN博客">图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131511658?spm=1001.2014.3001.5501" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-CSDN博客">图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131583041?spm=1001.2014.3001.5501" title="图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-CSDN博客">图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_32971095/article/details/131927399?spm=1001.2014.3001.5501" title="PID控制算法理解_switch_swq的博客-CSDN博客">PID控制算法理解_switch_swq的博客-<br>CSDN博客</a></p><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="&lt;2&gt;其他资料"></a>&lt;2&gt;其他资料</h3><p>1.<a href="https://space.bilibili.com/28143041/?spm_id_from=333.999.0.0" title="唐老师讲电赛的个人空间-唐老师讲电赛个人主页-哔哩哔哩视频">唐老师讲电赛的个人空间-唐老师讲电赛个人主页-<br>哔哩哔哩视频</a></p><p>2.电赛资料：<a href="https://pan.baidu.com/s/1ehPdgMU8T16tcQXeLU1xaQ?pwd=1234#list/path=%2F" title="电赛资料_免费高速下载|百度网盘-分享无限制 (baidu.com)">电赛资料_免费高速下载|百度网盘-分享无限制<br>(baidu.com)</a>提取码：1234</p><p>3.我的“电赛”、“VS Studio”、“cmake”、“opencv”、“makefile”、“linux、操作系统”、“stm32”收藏夹</p><p>3.以及上面笔记中所包含信息</p><h2 id="三-备赛阶段记录"><a href="#三-备赛阶段记录" class="headerlink" title="三.备赛阶段记录"></a><strong>三.备赛阶段记录</strong></h2><p>7.2.2023</p><ul><li>问题 <ol><li>Nano板子供电5v4A，需求电流较大</li><li>实验室现有开关电源模块似乎调不了5v，需自己设计电源模块</li><li>作为底层主要负责，如何为项目打下坚实基础</li><li>硬件使用有明确目标，如何学习</li></ol></li><li>解决 <ol><li>先不考虑电源模块，用适配器及直流电源供电</li><li>先把电机控制写好，提供友善接口</li><li>先用简单硬件过度，后期转高级的。如电机先用直流后用伺服。先拼起来，再细化雕琢</li></ol></li><li>收获 <ol><li>用vscode远程开发jetson，下载remote-ssh插件，ssh jetson@IP地址；快捷键ctrl+o调出要打开页面</li></ol></li></ul><p>7.3.2023</p><ul><li>问题 <ol><li>Stm32很多知识忘记，如定时器和A&#x2F;D、D&#x2F;A；是否需要复习，因复习耗时且不一定需要stm32</li><li>目前目标尚不明确</li></ol></li><li>解决 <ol><li>先将stm32相关知识看完，stm32作为保底</li><li>先搭一个蓝牙遥控小车！</li></ol></li><li>收获 <ol><li>修好了学长的小车，看到了PID实现双轮平衡小车的现象</li><li>学会了MG995型号舵机控制（控制脉冲占空比实现角度控制）</li><li>搭建了测试平台（OLED屏、蓝牙、i2c通讯）</li><li>搭建了简单的两轮遥控小车，采用直流电机控制，未加入PWM波调速，实现简单的前进、倒退、转弯。</li></ol></li></ul><p>7.4.2023</p><ul><li>问题 <ol><li>昨天做的小车电源直接冒烟，因为电源采用两节3.7V锂电池供电，buck升压到12V以匹配LM298N，电流过大</li></ol></li><li>解决 <ol><li>暂时给l298n提供5V电压，驱动能力下降，但系统可以运行。以后电源模块之后重新设计或使用小功率电机</li></ol></li><li>收获 <ol><li>主要将昨天搭好的小车完善，并加入了测压模块（利用STM32的ADC外设）</li><li>复习了stm32相关知识（外部中断，定制器TIM设置，定时器比较OC产生PWM波）</li><li>打开了jetson nano的摄像头，它睁开了眼</li></ol></li></ul><p>7.5.2023</p><ul><li>问题 <ol><li>编码器旋转无响应，电机也不动了</li><li>烧了一个stm32板子，当时接的自制稳压模块，之前都是好的，不知道什么原因</li></ol></li><li>解决 <ol><li>重新测试电机是否能正常工作</li><li>在小车到达前有时间学习MPU6050，相关姿态轨迹传输算法</li></ol></li><li>收获 <ol><li>在jetson nano上跑了例程及自己上传的几张图片</li><li>学会了linux的vim的使用</li><li>复习了stm32相关知识（定时器IC输入捕获模式）</li><li>学会了超声波测距CS100A模块和红外传感模块以及电机编码器部分</li></ol></li></ul><p>7.6.2023</p><ul><li>问题 <ol><li>如何解决电机编码器输出波形峰值小，stm32无法接收</li><li>Pwm波和电源需供电，不然波形失真</li></ol></li><li>解决 <ol><li>昨天电机不转是因为接线不紧，编码器不行是因为输出电压太小，只有0.5v左右</li><li>考虑IO口输出模式，不行加电压比较器，ref&#x3D;0.33V</li><li>要重新系统性设计电源了，所有信号共地！</li></ol></li><li>收获 <ol><li>拼好了大车，发现了诸多问题，舵机控制程序完成</li><li>浅浅学了PCB绘制流程</li></ol></li></ul><p>7.7.2023</p><ul><li>问题 <ol><li>控制函数太过简陋，后续仍需不断升级</li><li>图像识别进度为零</li></ol></li><li>解决 <ol><li>《基于opencv的数字图像处理技术》</li></ol></li><li>收获 <ol><li>用洞洞板搭建好了电源系统（12V-5V-3.7V），系统完全移植到大车</li><li>新车编码器输出足够大，无需放大器，编码器计数正常</li></ol></li></ul><p>7.8.2023</p><ul><li>收获 <ol><li>学会在Windows配置OpenCV环境，掌握OpenCV图像视频基本操作以及一些基础知识</li><li>PCB绘制进展</li></ol></li></ul><p>7.9.2023</p><ul><li>收获 <ol><li>学会在linux中运行调用OpenCV的c++文件（cmake的使用）</li><li>学习OpenCV基本数据结构和类的使用</li><li>进一步了解VS studio上编译选项配置以及debug和release的区别</li></ol></li></ul><p>7.10.2023</p><ul><li>收获 <ol><li>学会OpenCV灰度变换、直方图、边缘检测、霍夫检测直线和圆</li></ol></li></ul><p>7.11.2023</p><ul><li>问题 <ol><li>源码在linux上无法运行（OpenCV调用摄像头出问题，采用CMake方法编译）</li></ol></li><li>解决 <ol><li>今天下午加晚上未解决</li></ol></li><li>收获 <ol><li>学会阈值分割（图像二值化方法）</li></ol></li></ul><p>7.12.2023</p><ul><li>问题 <ol><li>C++无法编译成功，Mat类未定义引用（QT上编译）</li></ol></li><li>解决 <ol><li>使用python编写运行成功</li></ol></li><li>收获 <ol><li>看完特征提取和目标检测（HOG特征+SVM基本流程；LBP特征+级联分类器）</li></ol></li></ul><p>7.13.2023</p><ul><li>问题 <ol><li>依旧无法运行以C++运行OpenCV代码</li><li>可以运行的OpenCV代码不能直接以videocapture capture(0)的方法获取视频流</li></ol></li><li>解决 <ol><li>重新系统性安装OpenCV库并重走CMake流程</li><li>将视频流通过管道gstreamer传输</li></ol></li><li>收获 <ol><li>学会CMake以及基本编译链接流程</li><li>重新安装配置OpenCV4.8.0，成功在jetson nano上运行OpenCV代码</li></ol></li></ul><p>7.14.2023</p><ul><li>问题 <ol><li>但运行自己编写的直线检测程序过于卡顿，一秒一帧</li><li>蓝牙模块无法正常工作</li></ol></li><li>解决 <ol><li>霍夫直线检测运算量大，不使用该算法</li><li>调整视频大小及帧率</li><li>经检测应是蓝牙模块问题，重新购买</li></ol></li><li>收获 <ol><li>使用画好的pcb搭建小车，将全部器件搭载在小车上</li></ol></li></ul><p>7.15.2023</p><ul><li>问题 <ol><li>电机控制出错，一边电机不受控制</li><li>目前控制算法学的太少，但图像识别进展不够</li></ol></li><li>解决 <ol><li>GPIO口选到了下载口JTDI&#x2F;O，换GPIO口控制</li><li>先用超声波模块、MPU6050、红外传感等模块写避障、路径记录、寻迹等功能</li></ol></li><li>收获 <ol><li>学会jetson nano上的GPIO使用（基本和树莓派一样）</li><li>解决了电机的基本控制问题并将电机的四控制线改成了两根</li><li>jetson使用电池供电（器件全供地）；实现stm32与jetson nano的usart通信（照搬蓝牙）</li></ol></li></ul><p>7.16.2023</p><ul><li>问题 <ol><li>超声波测距模块中断代码写的不好，拔下模块进入while循环等待，系统卡住</li><li>拉肚子</li></ol></li><li>解决 <ol><li>使用static变量，进入中断模式改为EXTI_Trigger_Rising_Falling…</li><li>休息一天（今日中午至明天中午）</li></ol></li></ul><p>7.17.2023</p><ul><li>问题 <ol><li>欲添加mpu6050模块，但其与oled、蓝牙、超声波模块冲突（非引脚分配问题）</li></ol></li><li>解决 <ol><li>更改方案，debug试试。仍不行</li></ol></li></ul><p>7.18.2023</p><ul><li>问题 <ol><li>昨天问题仍然存在</li><li>多个中断之间不协调，影响超声波测距精度。以及测角度过于耗时</li></ol></li><li>解决 <ol><li>使用江科大自动化的例程代码，简洁明了，解决冲突</li><li>更改各个中断优先级，控制mpu6050的使用</li></ol></li><li>收获</li></ul><p>7.19.2023</p><ul><li>收获 <ol><li>学会PID算法</li><li>重新绘制PCB，解决若干问题</li></ol></li></ul><p>7.20.2023</p><ul><li>问题 <ol><li>SysTick定时器冲突问题（外部和中断同时调用delay_us函数会卡死）</li></ol></li><li>解决 <ol><li>避免了0.1s定时器中断（数据刷新）的SysTick定时函数</li></ol></li><li>收获 <ol><li>使用编码器利用PID编写行驶给定长度函数及测速</li></ol></li></ul><p>7.21.2023</p><ul><li>问题 <ol><li>后退时编码器反向计数，上限不明确，速度测算出现问题</li></ol></li><li>解决 <ol><li>通过TIM_EncoderInterfaceConfig设置编码器反转依旧向上计数</li></ol></li><li>收获 <ol><li>编写小车倒车定长距离</li></ol></li></ul><p>7.22.2023</p><ul><li>收获 <ol><li>编写小车以恒定速度行驶和拐弯90度算法</li></ol></li></ul><p>7.23.2023</p><ul><li>收获 <ol><li>焊好新到的板子</li></ol></li></ul><p>7.24.2023</p><ul><li>问题 <ol><li>Jetson配置难，yolo难跑通</li><li>要求设计完整程序，在jetson开机时自动执行</li></ol></li><li>解决 <ol><li>学习OpenCV备用</li><li>学习python或c++可执行文件Linux开机自动执行方法</li></ol></li></ul><p>7.25.2023</p><ul><li>问题 <ol><li>采用硬盘直接克隆方式克隆SD卡依旧无法启动jetson nano系统</li></ol></li><li>解决 <ol><li>烧录官方镜像文件，成功还原系统。并发现python和C++环境已经配好，之前不会用。解决yolov5摄像头实时检测问题，方案参考亚博论坛。C++也是，g++编译时加上一个参数就行</li></ol></li></ul><p>7.26.2023</p><ul><li>收获 <ol><li>看今年电赛器件清单，简单编写完云台代码，购买K210等器材</li></ol></li></ul><p>7.27.2023</p><ul><li>收获 <ol><li>简单编写完红外寻迹功能</li><li>解决nano开机启动python文件</li></ol></li></ul><p>7.28.2023</p><ul><li>问题 <ol><li>分析电赛清单，云台摄像头加激光笔应该涉及到动态物体追踪</li></ol></li><li>解决 <ol><li>学习视频目标跟踪</li></ol></li></ul><p>7.29.2023</p><ul><li>问题 <ol><li>Stm32定时器资源有限无法满足云台的加入</li></ol></li><li>解决 <ol><li>使用pca9685驱动</li></ol></li><li>收获 <ol><li>采用stm32管脚重定义解决pca9685驱动的使用问题</li></ol></li></ul><p>7.30.2023</p><ul><li>问题 <ol><li>Jetson nano的C++库不包含串口uart相关内容</li></ol></li><li>解决 <ol><li>使用其设备&#x2F;dev&#x2F;tthTSH1，研究网上代码</li></ol></li><li>收获 <ol><li>编写以及pca9685控制云台函数</li></ol></li></ul><p>7.31.2023</p><ul><li>问题 <ol><li>霍夫圆检测一定也不稳定</li></ol></li><li>解决 <ol><li>调整参数或使用深度学习识别物体的方法</li></ol></li><li>收获 <ol><li>终于解决串口通信问题，实现C++语言的nano和电脑以及stm32通信</li><li>完善霍夫圆检测代码，加入uart传输圆心坐标</li><li>学会nano开机自启动程序方法</li><li>编写stm32的PID点跟踪函数，实现点跟踪</li></ol></li></ul><p>8.1.2023</p><ul><li>问题 <ol><li>走定长不精确，大约是设定5cm行驶6cm这个比例</li></ol></li><li>收获 <ol><li>编写摇杆控制云台程序</li><li>发现之前使用的pid算法全犯了低级错误，本应用float定义PID值结果用了int，修改后大范围应用，各个控制加入PID平稳精确了很多</li></ol></li></ul><h2 id="四-电赛总结及经验教训"><a href="#四-电赛总结及经验教训" class="headerlink" title="四.电赛总结及经验教训"></a>四.电赛总结及经验教训</h2><h3 id="本次比赛作品的不足、改进之处"><a href="#本次比赛作品的不足、改进之处" class="headerlink" title="&lt;1&gt;本次比赛作品的不足、改进之处"></a>&lt;1&gt;本次比赛作品的不足、改进之处</h3><p>1.stm32和jetson<br>nano通讯不稳定（可能原因：杜邦线传输能力差、波特率可能设置高了【但低了影响系统处理速度】）（实际原因：while写成了if，导致时机很难对上，通信规则设计失误！）</p><p>2.stm32主函数设计不行，没花时间改进，想要重复运行某个程序只能重启，人机交互也不友好</p><p>3.比赛报告没有在头脑风暴之后就开始写，导致后期书写太急，不够规范</p><p>4.linux操作不熟，开机自启动程序出现问题，且jetson nano上的程序设计缺乏系统性结构性（每问都写了一个程序，而不是整合成一个大的测试程序）</p><p>5.所有任务完成太晚，没有留下时间仔细调试调参找问题。而且全流程过一遍后立马就要封箱了，急急忙忙乱改代码导致出现了<strong>意想不到的错误！再给一天就刚好了啊！！！</strong></p><h3 id="本次比赛的经验教训"><a href="#本次比赛的经验教训" class="headerlink" title="&lt;2&gt;本次比赛的经验教训"></a>&lt;2&gt;本次比赛的经验教训</h3><p>1.器件准备很重要：比赛发布器件清单后要备齐，最好每个器件都多买几个。以满足比赛器件需求并防止比赛时器件损坏！（本次比赛oled屏、舵机都反复坏过）</p><p>2.器件精度很重要：比赛前统计自己所有器件清单，并实测是否可以使用？精度如何？硬件精度不足会直接导致结果无法满足！（本次比赛刚开始使用的舵机为20kg大扭矩低精度，调了一晚PID参数舵机仍然运动不准，最后才发现是精度问题）</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/132150694">https://blog.csdn.net/qq_32971095/article/details/132150694</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> opencv </tag>
            
            <tag> c++ </tag>
            
            <tag> linux </tag>
            
            <tag> 嵌入式硬件 </tag>
            
            <tag> ubuntu </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID控制算法理解</title>
      <link href="/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一-简要回顾PID"><a href="#一-简要回顾PID" class="headerlink" title="一.简要回顾PID"></a>一.简要回顾PID</h2><p>*代码：</p><pre><code>//**********pid.h**********#ifndef _PID_H#define _PID_H#include &quot;public.h&quot;#define PID_REALIZE0//位置式PID#define PID_INCREASE 1//增量式PIDint Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode);#endif//**********pid.c**********#include &quot;pid.h&quot;//速度环控制int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode)&#123;int Pid_Num=0;//返回的控制值static float Error_k=0;static float Error_k1=0;static float Error_k2=0;Error_k=Target_Num-Current_Num;Error_k1=Error_k-Error_k1;if(PID_Mode==PID_INCREASE)&#123;Error_k2=Error_k-2*Error_k1+Error_k2;Pid_Num=kp*Error_k+ki*Error_k2+kd*Error_k1;&#125;else if(PID_Mode==PID_REALIZE)&#123;Pid_Num=kp*Error_k+kd*Error_k1;&#125;Error_k2=Error_k1;Error_k1=Error_k;return Pid_Num;&#125;</code></pre><p>*所需参数：KP&#x2F;KI&#x2F;KD&#x2F;当前值Curr_Num</p><p>*返回值：Pid_Num（根据实际情境确定其物理意义，比如可以是增量：如控制电机转速，Pid_Num为增量，可代表增加的电压值等；也可以是直接确定值：如控制小车行进距离，Pid_Num代表当前小车速度）</p><p>*位置式PID和增量式PID区别：<a href="https://blog.csdn.net/as480133937/article/details/89508034" title="位置式PID与增量式PID区别浅析">位置式PID与增量式PID区别浅析</a></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二-PID参数意义"><a href="#二-PID参数意义" class="headerlink" title="二.PID参数意义"></a>二.PID参数意义</h2><p>评估指标：最大超调量、上升时间、静差（稳定、准确、快速）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f816706c1aa1692d006fa201b2e511c2.png"></p><p> PID三参数：P用于提高响应速度，I减小静差、D减小静差</p><p>在实践生产工程中，不同的控制系统对控制器效果的要求不一样。比如平衡车、倒立摆对系统的快速性要求很高,响应太慢会导致系统失控。智能家居里面的门窗自动开合系统,对快速性要求就不高,但是对稳定性和准确性的要求就很高,所以需要严格控制系统的超调量和静差。</p><p>所以PID参数在不同的控制系统中是不一样的。只要我们理解了每个PID参数的作用,我们就可以应对工程中的各种项目的PID参数整定了。</p><p> 位置控制的调节经验可以总结为：先只使用P控制，增大P系数至系统震荡之后加入微分控制以增大阻尼,消除震荡之后再根据系统对响应和静差等的具体要求，调节P 和<br>I 参数。</p><p>一般而言,一个控制系统的控制难度,一般取决于系统的转动惯量和对响应的速度要求等。转动惯量越小、对响应速度要求越低, PID参数就越不敏感。</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131927399">https://blog.csdn.net/qq_32971095/article/details/131927399</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像识别小车（PCB设计）——电赛学习笔记（4）</title>
      <link href="/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
      <url>/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>学习来源：B站唐老师讲电赛——PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0<a href="https://www.bilibili.com/video/BV1Zg41127BV/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0_哔哩哔哩_bilibili">PCB设计极速入门，立创EDA+ALTIUM<br>DESIGNER<br>10.0_哔哩哔哩_bilibili</a></p><p>一.设计过程</p><p>使用嘉立创EDA加Altium Designer联合设计</p><p>1.嘉立创EDA：原理图绘制；器件选型；PCB生成；</p><p>ICEDA操作：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f20d7d97b76a22bfbc89dc11ba4cd542.png"></p><p>生成的pcd文件和原理图-导出-Altium Designer文件；转至 Altium Designer操作</p><p>2.Altium Designer：基础操作；使用规则（右键-设计-规则-desgin rules右键-导入规则-类型全选-<br>寻找规则文件）；字体大小调节（任意字右键-查找相似对象-text height-same-应用-修改text height）；shift s-DSD-<br>shift s-清除（右下角）；注意各个板层（顶层、底层；顶层走不通打过孔底层走；过孔尽量不经过焊盘）</p><p>调整好后新建PCB工程-右键添加现有文件-保存工程</p><p>走线（TAB键调出参数）</p><p>覆铜（放置多边形平面）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42fa1ac446e75661bc31d493a6a28d3c.png"></p><p> 打过孔</p><p>注意事项：芯片电源引脚加电容滤纹波</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c5d70666df4ea8e0417e843702022b96.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131583041">https://blog.csdn.net/qq_32971095/article/details/131583041</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV学习笔记——《基于OpenCV的数字图像处理》</title>
      <link href="/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/"/>
      <url>/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>源码下载：<a href="https://29.s.bookln.cn/q?c=120EL4LP111&sh=sh&vt_=1688811733923#1688811735786" title="下载资源包 (bookln.cn)">下载资源包<br>(bookln.cn)</a></strong></p><p><strong>常用函数库：</strong></p><p>**         英文：**<a href="https://docs.opencv.org/4.x/" title="OpenCV:OpenCV modules">OpenCV: OpenCV modules</a></p><p>**         中文：**<a href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/index.html" title="Welcome to opencv documentation! — OpenCV 2.3.2 documentation">Welcome to opencv documentation! — OpenCV 2.3.2<br>documentation</a></p><p><strong>jetson nano上的OpenCV使用：</strong><a href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</p><p><strong>学习OpenCV的推荐网站和文章：</strong></p><p><a href="https://learnopencv.com/getting-started-with-opencv/" title="Getting Started with OpenCV | LearnOpenCV">Getting Started with OpenCV | LearnOpenCV</a></p><p><a href="https://github.com/spmallick/learnopencv" title="spmallick&#x2F;learnopencv:Learn OpenCV : C++ and Python Examples (github.com)">spmallick&#x2F;learnopencv: Learn OpenCV : C++ and Python Examples<br>(github.com)</a></p><p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">一.图像相关知识</a></p><p><a href="about:blank#%E4%BA%8C.opencv%E7%AE%80%E4%BB%8B">二.opencv简介</a></p><p><a href="about:blank#%3C1%3E%EF%BC%88%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%EF%BC%88VS2019%EF%BC%89%E3%80%81%E6%BA%90%E7%A0%81%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%EF%BC%88CMake%EF%BC%89%E3%80%81%E8%B0%83%E7%94%A8%E5%8A%A8%2F%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81cv%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81OpenCV%20API%E7%89%B9%E7%82%B9%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3InputArray%2FOutputArray%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81OpenCV%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81HighGui%E6%A8%A1%E5%9D%97%EF%BC%89">&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV<br>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</a></p><p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">&lt;2&gt;示例代码：</a></p><p><a href="about:blank#1.%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%9A">1.展示图片：</a></p><p><a href="about:blank#2.%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91">2.播放视频</a></p><p><a href="about:blank#3.%E6%BB%91%E5%8A%A8%E6%9D%A1%E4%BD%BF%E7%94%A8%EF%BC%9A">3.滑动条使用：</a></p><p><a href="about:blank#4.%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%EF%BC%9A">4.鼠标事件响应：</a></p><p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B%EF%BC%9A">&lt;3&gt;练手：</a></p><p><a href="about:blank#1.%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4">1.打开摄像头</a></p><p><a href="about:blank#2.%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%8C%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%9A%82%E5%81%9C%2F%E6%92%AD%E6%94%BE">2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</a></p><p><a href="about:blank#%3C4%3Elinux%E4%B8%8A%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%EF%BC%9A%E5%8F%82%E8%80%83%EF%BC%9ALinux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8CC%2B%2B%20OpenCV%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3_linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%A5%BDopencv%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%A0%E8%BD%BD_Adenialzz%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2">&lt;4&gt;linux上编译运行：参考：Linux下编译、链接、加载运行C++<br>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客</a></p><p><a href="about:blank#%E4%B8%89.OpenCV%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">三.OpenCV基本数据结构和基本组件</a></p><p><a href="about:blank#%3C1%3E%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%83%8F%E5%AE%B9%E5%99%A8Mat%E7%B1%BB%EF%BC%9B%E7%82%B9Point%E7%B1%BB%EF%BC%9B%E9%A2%9C%E8%89%B2Scalar%E7%B1%BB%EF%BC%9B%E5%B0%BA%E5%AF%B8Size%E7%B1%BB%EF%BC%9B%E7%9F%A9%E5%BD%A2Rect%E7%B1%BB%EF%BC%9B%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2RotatedRect%E7%B1%BB%EF%BC%9B%E5%9B%BA%E5%AE%9A%E5%90%91%E9%87%8FVec%E7%B1%BB%EF%BC%9B%E5%A4%8D%E6%95%B0%E7%B1%BBcomplexf%EF%BC%89">&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</a></p><p><a href="about:blank#%C2%A0%3C2%3E%E7%BB%83%E6%89%8B%E4%BB%A3%E7%A0%81"> &lt;2&gt;练手代码</a></p><p><a href="about:blank#1.Mat%E7%B1%BB%E6%93%8D%E4%BD%9C">1.Mat类操作</a></p><p><a href="about:blank#2.%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E6%B5%81%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2">2.摄像头图像流极坐标变换</a></p><p><a href="about:blank#3.%E8%AF%BB%E5%8F%96%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0RGB%E5%80%BC%EF%BC%88%E5%B7%A6%E9%94%AE%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%B8%85%E7%A9%BA%EF%BC%89">3.读取图像像素RGB值（左键显示，右键清空）</a></p><p><a href="about:blank#4.%E5%88%9B%E5%BB%BA%E4%B8%80%E5%AE%9A%E5%B0%BA%E5%AF%B83%E9%80%9A%E9%81%93RGB%E5%9B%BE%E5%83%8F%EF%BC%8C%E5%B9%B6%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE%E5%85%B6%E5%83%8F%E7%B4%A0%E5%80%BC%EF%BC%8C%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%80%E7%BB%BF%E8%89%B2%E5%B9%B3%E9%9D%A2">4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</a></p><p><a href="about:blank#%E5%9B%9B.%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">四.数字图像灰度变换与空间滤波</a></p><p><a href="about:blank#%3C1%3E%EF%BC%88%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%EF%BC%9A%E7%BA%BF%E6%80%A7%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%EF%BC%9B%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9A%E6%A6%82%E7%8E%87%E3%80%81%E7%B4%AF%E8%AE%A1%EF%BC%89">&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</a></p><p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p><p><a href="about:blank#1.%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">1.灰度变换函数</a></p><p><a href="about:blank#2.%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88%E6%A6%82%E7%8E%87%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%89%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0">2.直方图（概率直方图）绘制函数</a></p><p><a href="about:blank#%E4%B8%83.%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2">七.图像分割</a></p><p><a href="about:blank#%3C1%3E%EF%BC%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%EF%BC%9A%E7%AE%97%E5%AD%90%EF%BC%9A%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%EF%BC%88Sobel%2FPrewitt%2FRoberts%EF%BC%89%E3%80%81%E4%BA%8C%E9%98%B6%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%2FLOG%2FCanny%EF%BC%89%E3%80%81%E6%B7%B7%E5%90%88%EF%BC%9B%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%EF%BC%88%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%EF%BC%89%EF%BC%9A%E7%9B%B4%E7%BA%BF%EF%BC%89">&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</a></p><p><a href="about:blank#%EF%BC%88%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%E3%80%90%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E3%80%91%EF%BC%9A%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%EF%BC%89">（几何形状检测【霍夫变换】：直线、圆）</a></p><p><a href="about:blank#%EF%BC%88%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E3%80%90%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%91%EF%BC%9A%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E3%80%90OTSU%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%95%E3%80%91%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</a></p><p><a href="about:blank#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">​编辑<br>&lt;2&gt;示例代码</a></p><p><a href="about:blank#1.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%92%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B">1.霍夫直线变换和霍夫圆检测</a></p><p><a href="about:blank#2.OTSU%E6%96%B9%E6%B3%95%E5%92%8C%E4%B8%89%E8%A7%92%E6%B3%95%E6%B1%82%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC">2.OTSU方法和三角法求全局阈值</a></p><p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B">&lt;3&gt;练手</a></p><p><a href="about:blank#1.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8">1.边缘检测二阶导数算子使用</a></p><p><a href="about:blank#2.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%8F%8A%E9%9C%8D%E5%A4%AB%E5%9C%86%E7%9A%84%E6%A3%80%E6%B5%8B">2.霍夫直线变换及霍夫圆的检测</a></p><p><a href="about:blank#3.linux%EF%BC%88ubuntu18%EF%BC%89%E4%B8%8A%E5%AE%9E%E7%8E%B0%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%EF%BC%88%E5%8F%AF%E8%B0%83%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89">3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</a></p><p><a href="about:blank#4.%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%EF%BC%88OTSU%2F%E4%B8%89%E8%A7%92%E6%B3%95%2F%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</a></p><p><a href="about:blank#5.%E8%AF%86%E5%88%AB%E8%BD%A6%E9%81%93%EF%BC%88%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%81%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%EF%BC%89">5.识别车道（二值化、边缘检测、霍夫直线变换）</a></p><p><a href="about:blank#%E4%B9%9D.%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%92%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">九.特征提取和目标检测</a></p><p>[&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-<br>LIKE）（分类：SVM&#x2F;级联分类器）](about:blank#%3C1%3E%EF%BC%88%E7%89%B9%E5%BE%81%EF%BC%9AHOG%2FLBP%2FHAAR-<br>LIKE%EF%BC%89%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%9ASVM%2F%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%89)</p><p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p><p><a href="about:blank#1.HOG%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%2BSVM">1.HOG特征提取+SVM</a></p><p>[2.获取LBP&#x2F;MB-LBP特征函数](about:blank#2.%E8%8E%B7%E5%8F%96LBP%2FMB-<br>LBP%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0)</p><p><a href="about:blank#3.cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E4%BD%BF%E7%94%A8">3.cascade级联分类器使用</a></p><hr><h2 id="一-图像相关知识"><a href="#一-图像相关知识" class="headerlink" title="一.图像相关知识"></a>一.图像相关知识</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb52f259aeff1a793a7899f7f1678e8e.jpeg"></p><h2 id="二-opencv简介"><a href="#二-opencv简介" class="headerlink" title="二.opencv简介"></a>二.opencv简介</h2><h5 id="（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV"><a href="#（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV" class="headerlink" title="&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV"></a>&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV</h5><p>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be8b3f267f375a33f3365797cbf719bd.jpeg"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7637aa7bab9d022a85a835b6b07b0818.jpeg"></p><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="&lt;2&gt;示例代码："></a>&lt;2&gt;示例代码：</h5><h6 id="1-展示图片："><a href="#1-展示图片：" class="headerlink" title="1.展示图片："></a>1.展示图片：</h6><pre><code>int main()&#123;namedWindow(&quot;lena&quot;, WINDOW_NORMAL);//setWindowProperty(&quot;lena&quot;, WND_PROP_FULLSCREEN, WINDOW_FULLSCREEN);setWindowTitle(&quot;lena&quot;, &quot;Lena经典图像窗口&quot;);//resizeWindow(&quot;lena&quot;, 400, 300);//moveWindow(&quot;lena&quot;, 0, 0);createTrackbar(&quot;t1&quot;, &quot;lena&quot;, NULL, 10, NULL, NULL);Mat img = imread(&quot;lena512color.tiff&quot;); //读取图像if (img.empty()) &#123;return -1; //如果读取图像失败，则返回&#125;imshow(&quot;lena&quot;, img); //显示图像waitKey(0); //等待用户输入    std::cout &lt;&lt; &quot;Hello World!\n&quot;; &#125;</code></pre><h6 id="2-播放视频"><a href="#2-播放视频" class="headerlink" title="2.播放视频"></a>2.播放视频</h6><pre><code>void PlayVideo()&#123;cv::VideoCapture capture(&quot;D:/files/picture and video/C0056.MP4&quot;);int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数double dblStartFrames = dblFrameCnt / 2; //播放起始帧数capture.set(CAP_PROP_POS_FRAMES, dblStartFrames); //从视频中间开始播放cv::namedWindow(&quot;video&quot;,0 );resizeWindow(&quot;video&quot;, 800, 600);while (capture.isOpened()) &#123;Mat frame;capture &gt;&gt; frame;if (frame.empty()) &#123;break;&#125;imshow(&quot;video&quot;, frame);waitKey(10);&#125;&#125;</code></pre><h6 id="3-滑动条使用："><a href="#3-滑动条使用：" class="headerlink" title="3.滑动条使用："></a>3.滑动条使用：</h6><pre><code>滑动条的使用实例const int g_nMaxAlphaValue = 100; //Alpha值的最大值int g_nCurAlphaValue;   //当前滑动条对应的值Mat g_srcImg1; //第1张图像Mat g_srcImg2; //第2张图像Mat g_mixImg;  //混合图像const char cszWindowName[] = &quot;mix&quot;;//拖动滑动条的响应函数void on_Trackbar(int, void *)&#123;//求出当前alpha值相对于最大值的比例double dblAlphaValue = double(g_nCurAlphaValue)/double(g_nMaxAlphaValue);//则beta值为1减去alpha值double dblBetaValue = 1.0 - dblAlphaValue;//根据alpha和beta的值，对两张图像进行线性混合addWeighted(g_srcImg1, dblAlphaValue, g_srcImg2, dblBetaValue, 0.0, g_mixImg);//显示混合图像的效果imshow(cszWindowName, g_mixImg);if (0 == g_nCurAlphaValue) &#123;imwrite(&quot;mix0.jpg&quot;, g_mixImg);&#125;if (50 == g_nCurAlphaValue) &#123;imwrite(&quot;mix50.jpg&quot;, g_mixImg);&#125;if (100 == g_nCurAlphaValue) &#123;imwrite(&quot;mix100.jpg&quot;, g_mixImg);&#125;&#125;int main(int argc, char ** argv)&#123;//加载图像 (两图像的尺寸需相同)g_srcImg1 = imread(&quot;lenna.bmp&quot;, IMREAD_COLOR);if (g_srcImg1.empty()) &#123;std::cout &lt;&lt; &quot;读取第1张图像失败&quot; &lt;&lt; std::endl;return -1;&#125;g_srcImg2 = imread(&quot;tiffany.bmp&quot;, IMREAD_COLOR);if (g_srcImg2.empty())&#123;std::cout &lt;&lt; &quot;读取第2张图像失败&quot; &lt;&lt; std::endl;return -1;&#125;// 设置滑动条的初值为70g_nCurAlphaValue = 0;//创建窗口，自动调整大小namedWindow(&quot;mix&quot;, WINDOW_AUTOSIZE);//在创建的窗体中创建一个滑动条控件char TrackbarName[50];sprintf_s(TrackbarName, &quot;透明度 %d&quot;, g_nMaxAlphaValue);createTrackbar(TrackbarName, cszWindowName, &amp;g_nCurAlphaValue, g_nMaxAlphaValue, on_Trackbar);//调用一次回调函数，以显示图像on_Trackbar(g_nCurAlphaValue, 0);waitKey(0);return 0;&#125;</code></pre><h6 id="4-鼠标事件响应："><a href="#4-鼠标事件响应：" class="headerlink" title="4.鼠标事件响应："></a>4.鼠标事件响应：</h6><pre><code>Rect g_rectangle; //记录要绘制的矩形位置bool g_bDrawingBox = false;//是否进行绘制RNG g_rng(12345);  //随机数对象const String strWndName = &quot;MouseWnd&quot;;void DrawRactangle(Mat &amp; img, Rect rect)&#123;//每次绘制矩形的颜色都是随机产生的rectangle(img, rect, Scalar(g_rng.uniform(0, 255), \g_rng.uniform(0, 255), g_rng.uniform(0, 255)), 4);&#125;void onMouseCallback(int event, int x, int y, int flags, void * param)&#123;//将画矩形的图像作为参数传入回调函数Mat &amp;image = *(Mat*)param;switch (event)&#123;//鼠标移动时改变窗口的大小case EVENT_MOUSEMOVE://如果g_bDrawingBox为真，则记录矩形信息到g_rectangle中if (g_bDrawingBox) &#123;g_rectangle.width = x - g_rectangle.x;g_rectangle.height = y - g_rectangle.y;&#125;break;//左键按下时记录窗口的起始位置case EVENT_LBUTTONDOWN:g_bDrawingBox = true;//记录g_rectangle的起点g_rectangle = Rect(x, y, 0, 0); break;//左键抬起时将当前绘制的矩形信息写入到图像中case EVENT_LBUTTONUP:// 标识符为falseg_bDrawingBox = false;//向起点左边绘制if (g_rectangle.width &lt; 0) &#123;g_rectangle.x += g_rectangle.width;g_rectangle.width *= -1;&#125;//向起点上边绘制if (g_rectangle.height &lt; 0) &#123;g_rectangle.y += g_rectangle.height;g_rectangle.height *= -1;&#125;//调用函数进行绘制DrawRactangle(image, g_rectangle);break;&#125;&#125;int main(int argc, char ** argv)&#123;//准备参数g_rectangle = Rect(-1, -1, 0, 0);Mat srcImage(600, 800, CV_8UC3, Scalar(255,255,255)), tempImage;srcImage.copyTo(tempImage);g_rectangle = Rect(-1, -1, 0, 0);// 设置鼠标操作回调函数namedWindow(strWndName);setMouseCallback(strWndName, onMouseCallback, (void *)&amp;srcImage);// 程序主循环，当进行绘制的标识符为真的时候进行绘制while (true)&#123;//复制原图到临时变量，这样可以清除上一次的鼠标拖动结果srcImage.copyTo(tempImage); if (g_bDrawingBox)&#123;//在鼠标拖动时，每次都对图像进行临时绘制Rect rectCur = g_rectangle;//鼠标向上或向左移动时，需要对坐标进行处理if (rectCur.width &lt; 0) &#123;rectCur.x += rectCur.width;rectCur.width *= -1;&#125;if (rectCur.height &lt; 0) &#123;rectCur.y += rectCur.height;rectCur.height *= -1;&#125;DrawRactangle(tempImage, rectCur);&#125;imshow(strWndName, tempImage);if (waitKey(10) == 27) // 按下ESC键，程序退出break;&#125;return 0;&#125;</code></pre><h5 id="练手："><a href="#练手：" class="headerlink" title="&lt;3&gt;练手："></a>&lt;3&gt;练手：</h5><h6 id="1-打开摄像头"><a href="#1-打开摄像头" class="headerlink" title="1.打开摄像头"></a>1.打开摄像头</h6><pre><code>#include &quot;pch.h&quot;                //viscalC++预编译头文件#include &lt;iostream&gt;             //C++标准输入、输出流#include &lt;opencv.hpp&gt;           //OpenCV头文件#include &lt;highgui.hpp&gt;          //GUI界面头文件using namespace cv;             //打开cv的名词空间#pragma comment(lib, &quot;opencv_world480d.lib&quot;)//打开动态库int main()&#123;cv::namedWindow(&quot;camera&quot;, 0);    //新建名为“camera”的窗口VideoCapture capture(0);         //打开ID为0的摄像头Mat frame;                       //新建Mat变量（矩阵）while (capture.isOpened())&#123;capture &gt;&gt; frame;            //用重载运算符方式获取视频帧if (frame.empty())break;imshow(&quot;camera&quot;, frame);     //在名为“camera”的窗口显示捕获帧waitKey(10);                 //刷新图像，否则无法正常显示&#125;&#125;</code></pre><h6 id="2-视频播放器，滑动条控制进度，双击暂停-播放"><a href="#2-视频播放器，滑动条控制进度，双击暂停-播放" class="headerlink" title="2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放"></a>2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</h6><pre><code>#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;opencv.hpp&gt;#include &lt;highgui.hpp&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)const char* trackname = &quot;progress&quot;;const char* windowname = &quot;videoplayer&quot;;const char* filepath = &quot;D:/files/picture and video/C0056.MP4&quot;;cv::VideoCapture capture(filepath, CAP_ANY);int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数const int g_nMaxProgressValue = 100;//Alpha值的最大值int g_nCurProgressValue;//当前滑动条对应的值int Cur_Frame;//记录暂停时的帧数Mat frame;int sign = 0;int main()&#123;void on_Trackbar(int, void*);void onMouseCallback(int event, int x, int y, int flags, void* param);cv::namedWindow(windowname,0);setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);resizeWindow(windowname, 400, 300);moveWindow(windowname, 0, 0);createTrackbar(trackname, windowname, &amp;g_nCurProgressValue, g_nMaxProgressValue, on_Trackbar);setMouseCallback(windowname, onMouseCallback, (void*)NULL);while(capture.isOpened())&#123;Cur_Frame = capture.get(CAP_PROP_POS_FRAMES);//获取当前播放帧数//判断是否双击，双击则暂停播放if (sign)&#123;capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);&#125;capture &gt;&gt; frame;//如果播放完毕，等待按键，直接退出if (Cur_Frame == dblFrameCnt)&#123;waitKey(0);break;&#125;imshow(windowname, frame);//中途按ESC可以直接退出if (waitKey(1) == 27)break;&#125;&#125;//滑动条回调函数void on_Trackbar(int, void*)&#123;capture.set(CAP_PROP_POS_FRAMES, g_nCurProgressValue * dblFrameCnt / g_nMaxProgressValue); //从视频中间开始播放capture &gt;&gt; frame;&#125;//鼠标回调函数void onMouseCallback(int event, int x, int y, int flags, void* param)&#123;if(event==EVENT_LBUTTONDBLCLK)sign = (sign + 1) % 2;&#125;</code></pre><p>注意控制输出暂停的方法：</p><p>1.waitKey等待：键盘控制，可参考其他博主</p><p>2.一直输出上一帧：即本人使用方法</p><pre><code>capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);</code></pre><p>3.直接用system（“pause”）  </p><h5 id="4-linux上编译运行：参考：-Linux下编译、链接、加载运行C"><a href="#4-linux上编译运行：参考：-Linux下编译、链接、加载运行C" class="headerlink" title="**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++"></a>**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++</h5><p>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客](<a href="https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506</a><br>“Linux下编译、链接、加载运行C++ OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客”)**</p><p><strong>CMakeLists.txt编辑：<a href="https://www.cnblogs.com/kuliuheng/p/9431275.html" title="[CMAKE]详解CMakeLists.txt文件 - VictoKu - 博客园 (cnblogs.com)">[CMAKE] 详解CMakeLists.txt文件 - VictoKu - 博客园<br>(cnblogs.com)</a></strong></p><p><strong>或参考：jetson nano上的OpenCV使用：<a href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</strong></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="三-OpenCV基本数据结构和基本组件"><a href="#三-OpenCV基本数据结构和基本组件" class="headerlink" title="三.OpenCV基本数据结构和基本组件"></a>三.OpenCV基本数据结构和基本组件</h2><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p>&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</p><p>（辅助对象：迭代参数TermCriteria类；范围range类；指针Ptr类）</p><p>（工具和系统函数：数学、内存管理、性能优化、异常处理函数）</p><p>（图像绘制图形函数：线、矩形、圆、折线）</p><p>（图像保存函数；图像几何操作函数：均匀调整（尺寸）、仿射变换、对数极坐标变换）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1811f91ca180329611fd9be36e5e02b.jpeg"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c2fcbc408c51032f372737fcdbc6a410.jpeg"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4891ab8394f175c44875a74ca770271d.jpeg"></p><h5 id="练手代码"><a href="#练手代码" class="headerlink" title="&lt;2&gt;练手代码"></a>&lt;2&gt;练手代码</h5><h6 id="1-Mat类操作"><a href="#1-Mat类操作" class="headerlink" title="1.Mat类操作"></a>1.Mat类操作</h6><pre><code>int main()&#123;namedWindow(&quot;image&quot;, WINDOW_NORMAL);setWindowTitle(&quot;image&quot;, &quot;image:&quot;);Mat img(Size(200, 100), CV_8UC3, Scalar(80, 160, 240));imshow(&quot;image&quot;, img);waitKey(0);return -1;&#125;</code></pre><h6 id="2-摄像头图像流极坐标变换"><a href="#2-摄像头图像流极坐标变换" class="headerlink" title="2.摄像头图像流极坐标变换"></a>2.摄像头图像流极坐标变换</h6><pre><code>const int g_nMaxValue = 100; //滑条值的最大值int g_nCurValue = 0;   //当前滑动条对应的值int main()&#123;void on_Trackbar(int, void*);namedWindow(&quot;Polor&quot;, WINDOW_NORMAL);Mat frame;VideoCapture capture(0);int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度createTrackbar(&quot;zoom factor&quot;, &quot;Polor&quot;, &amp;g_nCurValue, g_nMaxValue, on_Trackbar);while (capture.isOpened())&#123;capture &gt;&gt; frame;if (frame.empty())break;logPolar(frame, frame, Point2i(nWidth / 2, nHeight / 2), g_nCurValue, WARP_FILL_OUTLIERS);imshow(&quot;Polor&quot;, frame);waitKey(1);&#125;&#125;void on_Trackbar(int, void*)&#123;;&#125;</code></pre><h5 id="3-读取图像像素RGB值（左键显示，右键清空）"><a href="#3-读取图像像素RGB值（左键显示，右键清空）" class="headerlink" title="3.读取图像像素RGB值（左键显示，右键清空）"></a>3.读取图像像素RGB值（左键显示，右键清空）</h5><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)const char* filepath = &quot;/test2.png&quot;;const char* windowname = &quot;window&quot;;const char* windowtitle = &quot;image&quot;;const char* trackname = &quot;fontscale&quot;;int fontscale = 1;·//字体大小及线条粗细const int max_fontscale = 100;Mat img = imread(filepath, IMREAD_COLOR);Mat draw_board = img.clone();//图片拷贝以实现清除char string[5];int main()&#123;void on_Trackbar(int, void*);void onMouseCallback(int event, int x, int y, int flags, void* param);namedWindow(windowname, WINDOW_NORMAL);createTrackbar(trackname, windowname, &amp;fontscale, max_fontscale, on_Trackbar);setMouseCallback(windowname, onMouseCallback, (void*)NULL);if (draw_board.empty())return -1;while (!draw_board.empty())&#123;imshow(windowname, draw_board);if (waitKey(1) == 27)break;&#125;return 0;&#125;void on_Trackbar(int, void*)&#123;;&#125;void onMouseCallback(int event, int x, int y, int flags, void* param)&#123;if (event == EVENT_LBUTTONDOWN)&#123;//读取鼠标所指像素的值int rgb[3] = &#123; img.at&lt;cv::Vec3b&gt;(x, y)[2],img.at&lt;cv::Vec3b&gt;(x, y)[1], img.at&lt;cv::Vec3b&gt;(x, y)[0] &#125;;//putText不支持\n换行，只能手动计算间隔：y + fontscale * 10 * ifor (int i = 0; i &lt; 3; i++) &#123;sprintf_s(string, &quot;%d&quot;, rgb[i]);//文字写入图像putText(draw_board, string, Point(x, y + fontscale * 10 * i), FONT_HERSHEY_PLAIN, fontscale, Scalar(rgb[2], rgb[1], rgb[0]), fontscale, 8, false);&#125;&#125;if (event == EVENT_RBUTTONDOWN)&#123;//使显示图像为原始图像，即清零draw_board = img.clone();&#125;&#125;</code></pre><p>注：</p><p>①.at()函数访问多通道Mat数据元素时为只能用at()函数，且注意at&lt;&gt;内为 Vec3b</p><pre><code>at&lt;cv::Vec3b&gt;(x, y)[i]</code></pre><p>②.putText()函数无法实现换行，需手动计算</p><h6 id="4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"><a href="#4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面" class="headerlink" title="4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"></a>4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</h6><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)const char* filepath = &quot;test2.png&quot;;const char* windowname = &quot;window&quot;;const char* windowtitle = &quot;image&quot;;const char* trackname = &quot;fontscale&quot;;#define WIDTH 800#define HEIGHT 600int main()&#123;namedWindow(windowname, WINDOW_NORMAL);Mat img(WIDTH, HEIGHT, CV_8UC3, Scalar(0, 0, 0));for (int i = 0; i &lt; WIDTH; i++) &#123;for (int j = 0; j &lt; HEIGHT; j++) &#123;for (int k = 0; k &lt; 3; k++) &#123;img.at&lt;Vec3b&gt;(i, j)[k] = (i * j * k) % 256;&#125;&#125;&#125;Point p1(200, 50), p2(400, 200);rectangle(img,p1,p2,Scalar(0,255,0),8,8,0);imshow(windowname, img);//imwrite(&quot;C:/Users/user/Desktop/1.png&quot;, img);waitKey(0);&#125;</code></pre><h2 id="四-数字图像灰度变换与空间滤波"><a href="#四-数字图像灰度变换与空间滤波" class="headerlink" title="四.数字图像灰度变换与空间滤波"></a>四.数字图像灰度变换与空间滤波</h2><h5 id="（灰度变换：线性、非线性；直方图：概率、累计）"><a href="#（灰度变换：线性、非线性；直方图：概率、累计）" class="headerlink" title="&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）"></a>&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/10f1536c594c088a66be8508027e04c3.jpeg"></p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-灰度变换函数"><a href="#1-灰度变换函数" class="headerlink" title="1.灰度变换函数"></a>1.灰度变换函数</h6><p>①对数变换</p><pre><code>//对数变换void LogTransform(Mat srcImg, Mat &amp;dstImg, const float c=1.0f)&#123;if (srcImg.empty())&#123;cout &lt;&lt; &quot;No data&quot; &lt;&lt; endl;return;&#125;//Mat dstMat = Mat::zeros(srcImg.size(), srcImg.type());add(srcImg, Scalar(1.0), srcImg);  //计算 s+1srcImg.convertTo(srcImg, CV_32F);  //转化为32位浮点型cv::log(srcImg, dstImg); //计算log(1+s)dstImg = c*dstImg;//归一化处理normalize(dstImg, dstImg, 0, 255, NORM_MINMAX);//cout &lt;&lt; dstImg &lt;&lt; endl;cout &lt;&lt; dstImg.elemSize() &lt;&lt; endl;//将dstImg转换到CV_8U类型convertScaleAbs(dstImg, dstImg);return;&#125;</code></pre><p><strong>②*伽马变换</strong></p><pre><code>//伽马校正void MyGammaCorrection(const Mat&amp; src, Mat&amp; dst, float fGamma)&#123;//CV_Assert(src.data);if (src.empty())&#123;return;&#125;//只处理位深度为8位的图像CV_Assert(src.depth() != sizeof(uchar));//创建查找表unsigned char lut[256];for (int i = 0; i &lt; 256; i++)&#123;lut[i] = saturate_cast&lt;uchar&gt;(pow((float)(i / 255.0),\fGamma) * 255.0f);&#125;dst = src.clone();const int channels = dst.channels();switch (channels)&#123;case 1:&#123;//MatIterator_&lt;uchar&gt; it;//for (it = dst.begin&lt;uchar&gt;(); it != dst.end&lt;uchar&gt;(); it++)//*it = lut[(*it)];for (int j = 0; j &lt; dst.rows; j++)&#123;for (int i = 0; i &lt; dst.cols; i++)&#123;unsigned char val = dst.at&lt;uchar&gt;(j, i);dst.at&lt;uchar&gt;(j, i) = lut[val];&#125;&#125;break;&#125;case 3:&#123;MatIterator_&lt;Vec3b&gt; it;for (it = dst.begin&lt;Vec3b&gt;(); it != dst.end&lt;Vec3b&gt;(); it++)&#123;(*it)[0] = lut[((*it)[0])];(*it)[1] = lut[((*it)[1])];(*it)[2] = lut[((*it)[2])];&#125;break;&#125;&#125;&#125;</code></pre><p>注：saturate_cast&lt;&gt;的使用（防止颜色溢出）参考：<a href="https://blog.csdn.net/qq_15698613/article/details/84557588?spm=1001.2014.3001.5506" title="【OpenCV】中saturate_cast&lt;uchar&gt;的含义和用法是什么？_人工智能博士的博客-CSDN博客">【OpenCV】中saturate_cast<uchar>的含义和用法是什么？_人工智能博士的博客-<br>CSDN博客</uchar></a></p><h6 id="2-直方图（概率直方图）绘制函数"><a href="#2-直方图（概率直方图）绘制函数" class="headerlink" title="2.直方图（概率直方图）绘制函数"></a>2.直方图（概率直方图）绘制函数</h6><p>①灰度直方图</p><pre><code>//灰度直方图void DrawGrayImgHist(const Mat &amp;srcImg)&#123;if (1 != srcImg.channels())&#123;return;&#125;int channels = 0;Mat dstHist;int histSize[] = &#123; 256 &#125;;    float midRanges[] = &#123; 0, 256 &#125;;const float *ranges[] = &#123; midRanges &#125;;calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \1, histSize, ranges, true, true);//最终绘制的直方图图像，大小是256×256Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);double dblHistMaxValue;//求得直方图的最大值minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);//将像素的个数整合到图像的最大范围内  for (int i = 0; i &lt;= 255; i++)&#123;int value = cvRound(dstHist.at&lt;float&gt;(i)\* 255 / dblHistMaxValue);line(histImage, Point(i, histImage.rows - 1), \Point(i, histImage.rows - 1 - value), Scalar(255));&#125;imshow(&quot;直方图&quot;, histImage);imwrite(&quot;desert_hist_规定化之后.bmp&quot;, histImage);&#125;</code></pre><p>注：<a href="https://www.cnblogs.com/bjxqmy/p/12386274.html" title="minMaxLoc 寻找图像全局最大最小值">minMaxLoc 寻找图像全局最大最小值</a></p><p>②RGB彩色直方图</p><pre><code>//RGB彩色直方图void DrawRGBImgHist(const Mat &amp;srcImg)&#123;if (srcImg.empty() || srcImg.channels() != 3)&#123;return;&#125;//分割成3个单通道图像 ( R, G 和 B )vector&lt;Mat&gt; rgb_planes;split(srcImg, rgb_planes);// 设定bin数目int histSize = 256;// 设定取值范围 ( R,G,B) )float range[] = &#123; 0, 256 &#125;;const float* histRange = &#123; range &#125;;bool uniform = true;bool accumulate = true;Mat r_hist, g_hist, b_hist;//计算直方图:calcHist(&amp;rgb_planes[0], 1, 0, Mat(), r_hist, 1, \&amp;histSize, &amp;histRange, uniform, accumulate);calcHist(&amp;rgb_planes[1], 1, 0, Mat(), g_hist, 1, \&amp;histSize, &amp;histRange, uniform, accumulate);calcHist(&amp;rgb_planes[2], 1, 0, Mat(), b_hist, 1,\&amp;histSize, &amp;histRange, uniform, accumulate);// 创建直方图画布int hist_w = 256; int hist_h = 200;int bin_w = cvRound((double)hist_w / histSize);Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));// 将直方图归一化到范围 [ 0, histImage.rows ]normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX);normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX);normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX);// 在直方图画布上画出直方图，3个直方图叠加在一起，用不同的颜色表示for (int i = 1; i &lt; histSize; i++)&#123;line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at&lt;float&gt;(i - 1))),Point(bin_w*(i), hist_h - cvRound(r_hist.at&lt;float&gt;(i))),Scalar(0, 0, 255), 2, 8, 0);line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at&lt;float&gt;(i - 1))),Point(bin_w*(i), hist_h - cvRound(g_hist.at&lt;float&gt;(i))),Scalar(0, 255, 0), 2, 8, 0);line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at&lt;float&gt;(i - 1))),Point(bin_w*(i), hist_h - cvRound(b_hist.at&lt;float&gt;(i))),Scalar(255, 0, 0), 2, 8, 0);&#125;// 显示直方图imshow(&quot;RGB彩色图像直方图&quot;, histImage);imwrite(&quot;./colorhist_for_beatuty_after_qualization.bmp&quot;, histImage);waitKey(0);&#125;</code></pre><p>③累计直方图</p><pre><code>//画累积直方图void DrawAccumulateImgHist(const Mat &amp;srcImg)&#123;if (1 != srcImg.channels())&#123;return;&#125;int channels = 0;Mat dstHist;int histSize[] = &#123; 256 &#125;;float midRanges[] = &#123; 0, 256 &#125;;const float *ranges[] = &#123; midRanges &#125;;calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \1, histSize, ranges, true, true);//对直方图进行累积for (int i = 1; i &lt; dstHist.rows; i++)&#123;dstHist.at&lt;float&gt;(i) += dstHist.at&lt;float&gt;(i-1);&#125;//最终绘制的直方图图像，大小是256×256Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);double dblHistMaxValue;//求得直方图的最大值minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);//将像素的个数整合到图像的最大范围内  for (int i = 0; i &lt; 256; i++)&#123;int value = cvRound(dstHist.at&lt;float&gt;(i)\* 255 / dblHistMaxValue);line(histImage, Point(i, histImage.rows - 1), \Point(i, histImage.rows - 1 - value), Scalar(255));&#125;imshow(&quot;累积直方图&quot;, histImage);imwrite(&quot;./accumlate.bmp&quot;, histImage);&#125;</code></pre><h2 id="七-图像分割"><a href="#七-图像分割" class="headerlink" title="七.图像分割"></a>七.图像分割</h2><h5 id="（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）"><a href="#（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）" class="headerlink" title="&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）"></a>&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</h5><h5 id="（几何形状检测【霍夫变换】：直线、圆）"><a href="#（几何形状检测【霍夫变换】：直线、圆）" class="headerlink" title="（几何形状检测【霍夫变换】：直线、圆）"></a>（几何形状检测【霍夫变换】：直线、圆）</h5><h5 id="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"><a href="#（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）" class="headerlink" title="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"></a>（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42061b3c66f846c840087275d00ada91.jpeg"></p><h5 id="-2"><a href="#-2" class="headerlink" title></a></h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e731b3257fee71a5ec24342e7b18efb.jpeg"><br>&lt;2&gt;示例代码</p><h6 id="1-霍夫直线变换和霍夫圆检测"><a href="#1-霍夫直线变换和霍夫圆检测" class="headerlink" title="1.霍夫直线变换和霍夫圆检测"></a>1.霍夫直线变换和霍夫圆检测</h6><pre><code>void DetectLines()&#123;Mat matSrc = imread(&quot;Hough_src_clr.png&quot;, IMREAD_GRAYSCALE);Mat matEdge;//Canny算子计算图像边缘Canny(matSrc, matEdge, 250, 200, 3, false);imshow(&quot;原图像&quot;, matSrc);imshow(&quot;Canny边缘&quot;, matEdge);imwrite(&quot;hough_src_gray.bmp&quot;, matSrc);imwrite(&quot;hough_src_canny.bmp&quot;, matEdge);std::vector&lt;Vec2f&gt; linesSHT;//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300HoughLines(matEdge, linesSHT, 1, CV_PI / 180, 280);Mat matSHT = matSrc.clone();for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;//直线的rho和theta值float rho = linesSHT[i][0], theta = linesSHT[i][1];//pt1和pt2是直线的两个端点Point pt1, pt2;double a = cos(theta), b = sin(theta);double x0 = a * rho, y0 = b * rho;pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数pt1.y = cvRound(y0 + 2000 * (a));pt2.x = cvRound(x0 - 2000 * (-b));pt2.y = cvRound(y0 - 2000 * (a));line(matSHT, pt1, pt2, Scalar(255), 4);&#125;imshow(&quot;SHT直线检测结果&quot;, matSHT);imwrite(&quot;hough_Lines_SHT.bmp&quot;, matSHT);Mat matPPHT = matSrc.clone();std::vector&lt;Vec4i&gt; linesPPHT;//累计概率霍夫变换检测直线，得到的是直线的起止端点HoughLinesP(matEdge, linesPPHT, 1, CV_PI / 180, 280, 100, 50);for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;//直接绘制直线line(matPPHT, Point(linesPPHT[i][0], linesPPHT[i][1]),Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);&#125;imshow(&quot;PPHT直线检测结果&quot;, matPPHT);imwrite(&quot;Hough_lines_PPHT.bmp&quot;, matPPHT);waitKey(0);&#125;void DetectCircles()&#123;Mat src;src = imread(&quot;HoughCircles_src_clr.jpg&quot;, IMREAD_GRAYSCALE);//imwrite(&quot;HoughCircles_src_gray.bmp&quot;, src);vector&lt;Vec3f&gt; circles;HoughCircles(src, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);//在原图中画出圆心和圆  for (size_t i = 0; i &lt; circles.size(); i++)&#123;//提取出圆心坐标  Point center(round(circles[i][0]), round(circles[i][1]));//提取出圆半径  int radius = round(circles[i][2]);//圆心  circle(src, center, 3, Scalar(255), -1, 4, 0);//圆  circle(src, center, radius, Scalar(255), 3, 4, 0);&#125;//imwrite(&quot;HoughCircles_circles.bmp&quot;, src);imshow(&quot;Circle&quot;, src);waitKey(0);&#125;</code></pre><h6 id="2-OTSU方法和三角法求全局阈值"><a href="#2-OTSU方法和三角法求全局阈值" class="headerlink" title="2.OTSU方法和三角法求全局阈值"></a>2.OTSU方法和三角法求全局阈值</h6><pre><code>//OTSU方法求阈值int OtsuBinary(Mat src)&#123;long lPixCnt = src.rows * src.cols;long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图for (int i = 0; i &lt; src.rows; i++) &#123;for (int j = 0; j &lt; src.cols; j++) &#123;unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);histogram[nCurVal]++;&#125;&#125;int nThreshold = 0;long sum0 = 0, sum1 = 0; //存储前景的灰度总和和背景灰度总和  long cnt0 = 0, cnt1 = 0; //前景像素总个数和背景像素总个数  double w0 = 0, w1 = 0; //前景和背景所占整幅图像的比例  double u0 = 0, u1 = 0;  //前景和背景的平均灰度  double variance = 0; //类间方差  double maxVariance = 0; //用来存储最大类间方差for (int i = 1; i &lt; 256; i++) //遍历所有灰度级别&#123;sum0 = 0;    cnt0 = 0;  w0 = 0;sum1 = 0;    cnt1 = 0;  w1 = 0;for (int j = 0; j &lt; i; j++) &#123;cnt0 += histogram[j]; //前景像素总和sum0 += j * histogram[j]; //前景灰度值总和&#125;//前景部分灰度均值u0 = cnt0 &gt; 0 ? double(sum0) / cnt0 : 0;w0 = (double)cnt0 / lPixCnt; //前景部分所占的比例for (int j = i; j &lt;= 255; j++) &#123;cnt1 += histogram[j]; //背景像素个数sum1 += j * histogram[j]; //背景部分灰度值总和&#125;//背景部分灰度均值u1 = cnt1 &gt; 0 ? double(sum1) / cnt1 : 0;w1 = 1 - w0;  //背景部分所占的比例//分割阈值为i时的类间方差variance = w0 * w1 * (u0 - u1) * (u0 - u1);if (variance &gt; maxVariance) &#123;maxVariance = variance;nThreshold = i;&#125;&#125;return nThreshold;&#125;//三角法求阈值int TriangleBinary(Mat src)&#123;long lPixCnt = src.rows * src.cols;long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图for (int i = 0; i &lt; src.rows; i++) &#123;for (int j = 0; j &lt; src.cols; j++) &#123;unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);histogram[nCurVal]++;&#125;&#125;//左右边界int left_bound = 0, right_bound = 0;//直方图最高峰和相应的灰度值int max_ind = 0, maxPeak = 0;int temp;bool isflipped = false;// 找到最左边零的位置for (int i = 0; i &lt; 256; i++) &#123;if (histogram[i] &gt; 0) &#123;left_bound = i;break;&#125;&#125;//位置再移动一个步长，即为最左侧零位置 if (left_bound &gt; 0)left_bound--;// 找到最右边零点位置for (int i = 255; i &gt; 0; i--) &#123;if (histogram[i] &gt; 0) &#123;right_bound = i;break;&#125;&#125;// 位置再移动一个步长，即为最右侧零位置 if (right_bound &lt; 255)right_bound++;// 在直方图上寻找最亮的点Hmaxfor (int i = 0; i &lt; 256; i++) &#123;if (histogram[i] &gt; maxPeak) &#123;maxPeak = histogram[i];max_ind = i;&#125;&#125;// 如果最大值落在靠左侧这样就无法满足三角法求阈值， //所以要检测是否最大值是否靠近左侧// 如果靠近左侧则通过翻转到右侧位置。if (max_ind - left_bound &lt; right_bound - max_ind) &#123;isflipped = true;int i = 0;int j = 255;// 左右交换while (i &lt; j) &#123;temp = histogram[i]; histogram[i] = histogram[j]; histogram[j] = temp;i++; j--;&#125;left_bound = 255 - right_bound;max_ind = 255 - max_ind;&#125;// 计算求得阈值double thresh = left_bound;double maxDist = 0, tempDist;double peakIdxBound = left_bound - max_ind;for (int i = left_bound + 1; i &lt;= max_ind; i++)&#123;// 计算距离tempDist = maxPeak * i + peakIdxBound * histogram[i];if (tempDist &gt; maxDist) &#123;maxDist = tempDist;thresh = i;&#125;&#125;thresh--;if (isflipped) &#123;thresh = 255 - thresh;&#125;return thresh;&#125;//手动二值化处理Mat Binbary(Mat src, int nThreshold)&#123;//遍历每个像素，对图像进行二值化Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC1);for (int i = 0; i &lt; src.rows; i++) &#123;for (int j = 0; j &lt; src.cols; j++) &#123;if (src.at&lt;uchar&gt;(i, j) &gt; nThreshold)dst.at&lt;uchar&gt;(i, j) = 255;&#125;&#125;return dst;&#125;</code></pre><p>*<strong>注：</strong></p><p><strong>①二值化的原图都是灰度图，产生灰度图方法见后</strong></p><p><strong>②对于固定场景摄像头读取图像可以先调用以上函数求出全局阈值，之后使用cv::threshold()函数时直接调用该阈值，减少每帧计算阈值时间</strong></p><h5 id="练手"><a href="#练手" class="headerlink" title="&lt;3&gt;练手"></a>&lt;3&gt;练手</h5><h6 id="1-边缘检测二阶导数算子使用"><a href="#1-边缘检测二阶导数算子使用" class="headerlink" title="1.边缘检测二阶导数算子使用"></a>1.边缘检测二阶导数算子使用</h6><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)#define IMAGE_TEST#ifdef IMAGE_TESTconst char* filepath = &quot;./Test.jpg&quot;;Mat img = imread(filepath, IMREAD_COLOR);Mat draw_board = img.clone();//图片拷贝以实现清除#endif#ifdef CAMERA_TESTVideoCapture capture(0);Mat image;#endif // CAMERA_TESTint main()&#123;void changing(void);changing();&#125;//拉普拉斯高通滤波void changing(void)&#123;Mat LoG_Image(const Mat &amp; image, int kervalue = 3, double sigma = 1.0f);#ifdef IMAGE_TESTMat image = imread(filepath, IMREAD_COLOR);if (image.empty()) &#123;std::cout &lt;&lt; &quot;打开图片失败,请检查&quot; &lt;&lt; std::endl;return;&#125;imshow(&quot;原图像&quot;, image);Mat matDst;//Laplacian(image, matDst, image.depth(), 5);     //拉普拉斯算子//matDst = LoG_Image(image, 3, 1.0f);//LOG算子Canny(image, matDst, 80, 150, 3, false);//canny算子imwrite(&quot;changing.bmp&quot;, matDst);imshow(&quot;变换效果&quot;, matDst);waitKey(0);#endif#ifdef CAMERA_TESTwhile (capture.isOpened())&#123;capture &gt;&gt; image;if (image.empty())break;Mat matDst;//Laplacian(image, matDst, image.depth(), 5);//拉普拉斯算子//matDst = LoG_Image(image, 3, 1.0f);//LOG算子Canny(image, matDst, 100, 500, 3, false);//canny算子imshow(&quot;变换效果&quot;, matDst);if (waitKey(1) == 27)break;&#125;#endif&#125;//图像LoG算子运算Mat LoG_Image(const Mat&amp; image, int kervalue = 3, double sigma = 1.0f)&#123;//首先对图像做高斯平滑Mat matTemp;GaussianBlur(image, matTemp, Size(kervalue, kervalue), sigma, sigma, BORDER_DEFAULT);//通过拉普拉斯算子做边缘检测Mat laplacian = Mat::zeros(image.rows, image.cols, CV_32FC1);Laplacian(matTemp, laplacian, CV_32FC1, 3);//求得最大边缘值double dblMaxVal = 0;minMaxLoc(laplacian, NULL, &amp;dblMaxVal);Mat dstImg;convertScaleAbs(laplacian, dstImg);imwrite(&quot;edge.bmp&quot;, dstImg);Mat result = Mat::zeros(image.rows, image.cols, CV_8UC1);//过零点交叉，寻找边缘像素for (int i = 1; i &lt; result.rows - 1; i++) &#123;for (int j = 1; j &lt; result.cols - 1; j++) &#123;if (laplacian.at&lt;float&gt;(i, j) &lt; 0.1 * dblMaxVal) &#123;continue;&#125;//水平、垂直、45度方向，135度4个方向过零点判定if (laplacian.at&lt;float&gt;(i - 1, j) \* laplacian.at&lt;float&gt;(i + 1, j) &lt; 0)result.at&lt;uchar&gt;(i, j) = 255;if (laplacian.at&lt;float&gt;(i, j + 1) \* laplacian.at&lt;float&gt;(i, j - 1) &lt; 0)result.at&lt;uchar&gt;(i, j) = 255;if (laplacian.at&lt;float&gt;(i + 1, j + 1) \* laplacian.at&lt;float&gt;(i - 1, j - 1) &lt; 0)result.at&lt;uchar&gt;(i, j) = 255;if (laplacian.at&lt;float&gt;(i - 1, j + 1) \* laplacian.at&lt;float&gt;(i + 1, j - 1) &lt; 0)result.at&lt;uchar&gt;(i, j) = 255;&#125;&#125;return result;&#125;//Canny算子计算图像的梯度和方向void CannyEdgeAndDirection(const Mat&amp; src)&#123;Mat magX = Mat(src.rows, src.cols, CV_32FC1);Mat magY = Mat(src.rows, src.cols, CV_32FC1);Mat slopes = Mat(src.rows, src.cols, CV_32FC1);Sobel(src, magX, CV_32FC1, 1, 0, 3);//水平梯度Sobel(src, magY, CV_32FC1, 1, 0, 3);//垂直梯度//梯度方向divide(magY, magX, slopes);//梯度幅值Mat magnitude;sqrt(magX * magX + magY * magY, magnitude);&#125;</code></pre><h6 id="2-霍夫直线变换及霍夫圆的检测"><a href="#2-霍夫直线变换及霍夫圆的检测" class="headerlink" title="2.霍夫直线变换及霍夫圆的检测"></a>2.霍夫直线变换及霍夫圆的检测</h6><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)VideoCapture capture(0);Mat image;//#define SHT//SHT检测直线//#define PPHT//PPHT检测直线#define HCD//霍夫圆检测int main()&#123;while (capture.isOpened())&#123;capture &gt;&gt; image;if (image.empty())break;Mat matCanny;Mat matDst;Canny(image, matCanny, 100, 300, 3, false);//canny算子#ifdef SHTstd::vector&lt;Vec2f&gt; linesSHT;//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 280);//直线在原图上绘制matDst = image.clone();for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;//直线的rho和theta值float rho = linesSHT[i][0], theta = linesSHT[i][1];//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）Point pt1, pt2;double a = cos(theta), b = sin(theta);double x0 = a * rho, y0 = b * rho;pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数pt1.y = cvRound(y0 + 2000 * (a));pt2.x = cvRound(x0 - 2000 * (-b));pt2.y = cvRound(y0 - 2000 * (a));line(matDst, pt1, pt2, Scalar(255), 4);&#125;#endif // SHT标准霍夫变换#ifdef PPHTmatDst = image.clone();std::vector&lt;Vec4i&gt; linesPPHT;//累计概率霍夫变换检测直线，得到的是直线的起止端点HoughLinesP(matCanny, linesPPHT, 1, CV_PI / 180, 220, 100, 50);for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;//直接绘制直线line(matDst, Point(linesPPHT[i][0], linesPPHT[i][1]),Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);&#125;#endif // PPHT累计概率霍夫变换#ifdef HCDcvtColor(image, matDst, COLOR_BGR2GRAY);std::vector&lt;Vec3f&gt; circles;HoughCircles(matDst, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);//在原图中画出圆心和圆  for (size_t i = 0; i &lt; circles.size(); i++) &#123;//提取出圆心坐标  Point center(round(circles[i][0]), round(circles[i][1]));//提取出圆半径  int radius = round(circles[i][2]);//圆心  circle(matDst, center, 3, Scalar(255), -1, 4, 0);//圆  circle(matDst, center, radius, Scalar(255), 3, 4, 0);&#125;#endif // HCD霍夫圆检测imshow(&quot;检测结果&quot;, matDst);if (waitKey(1) == 27)break;&#125;&#125;</code></pre><h6 id="3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"><a href="#3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）" class="headerlink" title="3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"></a>3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</h6><p>参数见：<a href="https://www.cnblogs.com/bjxqmy/p/12333022.html" title="opencv ——HoughCircles 霍夫圆变换原理及圆检测">opencv —— HoughCircles<br>霍夫圆变换原理及圆检测</a></p><p>二值化函数threshold参数：<a href="https://blog.csdn.net/u012566751/article/details/77046445" title="OpenCV基础——threshold函数的使用">OpenCV基础——threshold函数的使用</a></p><pre><code>#include &quot;opencv2/opencv.hpp&quot;#include &quot;opencv2/highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;VideoCapture capture(0);Mat image;const char* windowname=&quot;win&quot;;int max_r=100;int min_r=60;int min_d=80;int t_hold=45;int param1=100;int param2=10;const int t_max=255;const int r_max=1000;const int d_max=100;const int p1_max=200;const int p2_max=200;int main()&#123;    void on_Trackbar_1(int, void*);    void on_Trackbar_2(int, void*);    void on_Trackbar_3(int, void*);    void on_Trackbar_4(int, void*);    void on_Trackbar_5(int, void*);    void on_Trackbar_6(int, void*);    namedWindow(windowname,0);    setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);    resizeWindow(windowname, 400, 300);    moveWindow(windowname, 0, 0);    createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);    createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);    createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);    createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);    createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);    createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);while (capture.isOpened())&#123;capture &gt;&gt; image;if (image.empty())break;Mat matCanny;        Mat BinImg;        Mat matDst;        cvtColor(image, matDst, COLOR_BGR2GRAY);threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV);        Canny(BinImg, matCanny, 100, 300, 3, false);//canny算子        std::vector&lt;Vec3f&gt; circles;HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);//在原图中画出圆心和圆  for (size_t i = 0; i &lt; circles.size(); i++) &#123;//提取出圆心坐标  Point center(round(circles[i][0]), round(circles[i][1]));//提取出圆半径  int radius = round(circles[i][2]);//圆心  circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);//圆  circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);&#125;        imshow(&quot;matCanny&quot;, matCanny);        imshow(&quot;BinImg&quot;, BinImg);imshow(windowname, image);if (waitKey(1) == 27)break;&#125;&#125;void on_Trackbar_1(int, void*)&#123;    ;&#125;void on_Trackbar_2(int, void*)&#123;    ;&#125;void on_Trackbar_3(int, void*)&#123;    ;&#125;void on_Trackbar_4(int, void*)&#123;    ;&#125;void on_Trackbar_5(int, void*)&#123;    ;&#125;void on_Trackbar_6(int, void*)&#123;    ;&#125;</code></pre><p>注：OpenCV提供的SHT输出极坐标下直线的rho和theta值，需根据经验值推算该直线上的两点以绘图；而PPHT直接返回线段两端两点坐标</p><p>*注：图像灰度化的方法：可参考<a href="https://blog.csdn.net/qq_36853469/article/details/106416128" title="OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客">OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客</a></p><h6 id="4-阈值分割（OTSU-三角法-自适应阈值）"><a href="#4-阈值分割（OTSU-三角法-自适应阈值）" class="headerlink" title="4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）"></a>4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</h6><pre><code>#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)VideoCapture capture(0);Mat image;int main()&#123;int OtsuBinary(Mat src);int TriangleBinary(Mat src);Mat gray, dst;capture &gt;&gt; image;cvtColor(image, gray, COLOR_BGR2GRAY);int nThreshold = OtsuBinary(gray);//int nThreshold = TriangleBinary(gray);while(capture.isOpened())&#123;capture &gt;&gt; image;if (image.empty())break;cvtColor(image, gray, COLOR_BGR2GRAY);//用OTSU方法//threshold(gray, dst, nThreshold, 255, THRESH_BINARY);//threshold(gray, dst, 0, 255, THRESH_BINARY | THRESH_OTSU);//用三角法//threshold(gray, dst, nThreshold, 255, THRESH_BINARY);//threshold(gray, dst, 0, 255, THRESH_BINARY|THRESH_TRIANGLE);//自适应阈值adaptiveThreshold(gray, dst, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 7, 5);imshow(&quot;BinbaryImage&quot;, dst);if (waitKey(1) == 27)break;&#125;&#125;</code></pre><p>*<strong>注：自适应阈值保留信息更多，注意使用场合</strong></p><h6 id="5-识别车道（二值化、边缘检测、霍夫直线变换）"><a href="#5-识别车道（二值化、边缘检测、霍夫直线变换）" class="headerlink" title="5.识别车道（二值化、边缘检测、霍夫直线变换）"></a><strong>5.识别车道（二值化、边缘检测、霍夫直线变换）</strong></h6><pre><code>#include &quot;opencv.hpp&quot;#include &quot;highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;#pragma comment(lib,&quot;opencv_world480d.lib&quot;)int main() &#123;Mat image = imread(&quot;car_track.jpg&quot;, IMREAD_GRAYSCALE);Mat BinImg;threshold(image, BinImg, 150, 255, THRESH_BINARY);imwrite(&quot;BinImg.jpg&quot;, BinImg);Mat matCanny;Canny(BinImg, matCanny, 100, 300, 3, false);//canny算子imwrite(&quot;CannyImg.jpg&quot;, matCanny);Mat matDst = image.clone();std::vector&lt;Vec2f&gt; linesSHT;//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为100HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 100);//直线在原图上绘制matDst = image.clone();for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;//直线的rho和theta值float rho = linesSHT[i][0], theta = linesSHT[i][1];//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）Point pt1, pt2;double a = cos(theta), b = sin(theta);double x0 = a * rho, y0 = b * rho;pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数pt1.y = cvRound(y0 + 2000 * (a));pt2.x = cvRound(x0 - 2000 * (-b));pt2.y = cvRound(y0 - 2000 * (a));line(matDst, pt1, pt2, Scalar(255), 8);&#125;imshow(&quot;car_track&quot;, matDst);waitKey(0);imwrite(&quot;car_track_show.jpg&quot;, matDst);&#125;</code></pre><p>处理结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f19fbe807f911ee210017b64ea64ea.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/699cf9a73e9c5db8f5837d0018fe3604.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/4fa8e85338396b037d05b85d40503c9d.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/a35992394ee154df3670b102dfe9543c.jpeg"></p><h2 id="九-特征提取和目标检测"><a href="#九-特征提取和目标检测" class="headerlink" title="九.特征提取和目标检测"></a>九.特征提取和目标检测</h2><h5 id="（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）"><a href="#（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）" class="headerlink" title="&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）"></a>&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd37be7931389615cbb559ae52a7a7ff.jpeg"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70661001c310f47939567a8a92d0512d.jpeg"></p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-HOG特征提取-SVM"><a href="#1-HOG特征提取-SVM" class="headerlink" title="1.HOG特征提取+SVM"></a>1.HOG特征提取+SVM</h6><pre><code>//SVM参考代码#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;windows.h&gt;//#include &lt;afxwin.h&gt;#include &lt;stack&gt;#include &quot;opencv.hpp&quot;using namespace cv;using namespace std;using namespace cv::ml;#ifdef _DEBUG#pragma comment(lib, &quot;opencv_world480d.lib&quot;)#else#pragma comment(lib, &quot;opencv_world480.lib&quot;)#endif//************************************const char* file_path = &quot;E:/测试视频数据/Video_2016_8_26__10_10_48.mp4&quot;;//************************************vector&lt; float &gt; get_svm_detector(const Ptr&lt; SVM &gt;&amp; svm)&#123;//得到支持向量Mat sv = svm-&gt;getSupportVectors();const int sv_total = sv.rows;//得到支持向量对应的系数值Mat alpha, svidx;double rho = svm-&gt;getDecisionFunction(0, alpha, svidx);CV_Assert(alpha.total() == 1 &amp;&amp; svidx.total() == 1 &amp;&amp; sv_total == 1);CV_Assert((alpha.type() == CV_64F &amp;&amp; alpha.at&lt;double&gt;(0) == 1.) ||(alpha.type() == CV_32F &amp;&amp; alpha.at&lt;float&gt;(0) == 1.f));CV_Assert(sv.type() == CV_32F);//将支持向量的值写入一个vector返回vector&lt; float &gt; hog_detector(sv.cols + 1);memcpy(&amp;hog_detector[0], sv.ptr(), sv.cols * sizeof(hog_detector[0]));hog_detector[sv.cols] = (float)-rho;return hog_detector;&#125;//sampleMat是采样矩阵,labelMat是类别矩阵,nCurRows当前是矩阵的行数//提取正样本HOG特征void PosData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)&#123;vector&lt;String&gt; files; //文件名列表//************************************glob(&quot;pos_src/*.*&quot;, files); //搜索positive目录下所有文件//************************************for (size_t i = 0; i &lt; files.size(); ++i) &#123;Mat imgSrc = imread(files[i], IMREAD_GRAYSCALE); //加载图像if (imgSrc.empty()) &#123;cout &lt;&lt; files[i] &lt;&lt; &quot; is invalid!&quot; &lt;&lt; endl;continue;&#125;Mat imgDst;resize(imgSrc, imgDst, hog.winSize); //将正例缩放到检测窗口大小vector&lt;float&gt; featureVec;hog.compute(imgDst, featureVec, Size(8, 8), Size(0, 0));//将特征向量加入采样矩阵for (int i = 0; i &lt; featureVec.size(); i++) &#123;sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];&#125;nRowIdx++;Labels.push_back(+1); //正样本类别为+1 cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;&#125;&#125;//提取负样本HOG特征void NegData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)&#123;vector&lt;String&gt; files; //文件名列表//************************************glob(&quot;neg_src/*.*&quot;, files); //搜索positive目录下所有文件//************************************Rect box;box.width = hog.winSize.width;box.height = hog.winSize.height;for (size_t i = 0; i &lt; files.size(); ++i) &#123;Mat img = imread(files[i], IMREAD_GRAYSCALE);if (img.empty()) &#123;continue;&#125;Mat matDst;if (img.cols &lt;= hog.winSize.width + 1 || img.rows &lt;= hog.winSize.height + 1) &#123;//cout &lt;&lt; &quot;image too small&quot; &lt;&lt; endl;resize(img, matDst, hog.winSize);&#125;else &#123;//随机选择窗口位置box.x = rand() % (img.cols - box.width);box.y = rand() % (img.rows - box.height);matDst = img(box);&#125;vector&lt;float&gt; featureVec;hog.compute(matDst, featureVec, Size(8, 8), Size(0, 0));//将特征向量加入采样矩阵for (int i = 0; i &lt; featureVec.size(); i++) &#123;sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];&#125;nRowIdx++;Labels.push_back(-1);//负样本类别为-1 cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;&#125;&#125;void TrainSVMModel()&#123;//车牌检测window大小为128X48,block大小为16X16,cell大小为8X8，滑动窗口大小为8X8HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), cv::Size(8, 8), 9);int nVecLen = hog.getDescriptorSize();//样本的特征向量，行数等于正负样本个数，列数等于HOG特征向量长度Mat sampleFeatureMat = Mat::zeros(9689, nVecLen, CV_32FC1);//样本的类别向量，行数等于所有样本的个数，列数等于1；1表示正样本，-1表示负样本vector&lt;int&gt; Labels;int nRowIdx = 0;PosData(hog, sampleFeatureMat, Labels, nRowIdx);NegData(hog, sampleFeatureMat, Labels, nRowIdx);Ptr&lt;SVM&gt; svm = SVM::create(); //创建一个SVM分类器svm-&gt;setCoef0(0.0);svm-&gt;setDegree(3);svm-&gt;setGamma(0);svm-&gt;setKernel(SVM::LINEAR);svm-&gt;setNu(0.5);svm-&gt;setP(0.1);svm-&gt;setC(0.01);svm-&gt;setType(SVM::EPS_SVR); //分类器类型为EPS_SVR//************************************//训练结束条件：要么达到1000次，要么两次误差小于1e-3svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 1e-3));//************************************svm-&gt;train(sampleFeatureMat, ROW_SAMPLE, Labels);//svm-&gt;trainAuto();//直接将支持向量系数写入文本文件，以方便在检测器的头文件中导入vector&lt;float&gt; vecHogCof = get_svm_detector(svm);//************************************//支持向量结果保存ofstream file(&quot;dector.txt&quot;);//************************************for (int i = 0; i &lt; vecHogCof.size(); i++) &#123;file &lt;&lt; vecHogCof[i] &lt;&lt; &quot;,&quot;;&#125;file.close();&#125;void TestSVMModel()&#123;//************************************//SVM检测器系数向量都放在hogCof数组中(detect.txt中内容，模型建立好后可直接调用)float hogCof[] = &#123;......&#125;;//************************************//创建HOG检测器，参数与训练时的参数相同//在这里特别注意将nLevels参数从默认64修改为4，可以加快检测速度HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), \cv::Size(8, 8), 9, 1, -1.0, HOGDescriptor::L2Hys, 0.2, false, 4);const int vecLen = sizeof(hogCof) / sizeof(float);vector&lt;float&gt; vecHogCof(hogCof, hogCof + vecLen);hog.setSVMDetector(vecHogCof); //设置HOG检测器的系数//打开一个视频文件VideoCapture cap;cap.open(file_path);if (!cap.isOpened()) &#123;return;&#125;Mat frame;int nFrmIdx = 0;while (true) &#123;cap &gt;&gt; frame;if (frame.empty()) &#123;break;&#125;vector&lt;Rect&gt; detections; //检测到目标矩形位置vector&lt;double&gt; foundWeights; //检测到的权重hog.detectMultiScale(frame, detections, foundWeights, 0.5, Size(8, 8), Size(0, 0), 1.1, 3.0, false);for (int i = 0; i &lt; detections.size(); i++) &#123;if (frame.rows - detections[i].y &lt; 200)continue;rectangle(frame, detections[i], Scalar(0, 0, 255), 4);&#125;imshow(&quot;LP HOG Detection&quot;, frame);if (detections.size() &gt; 0) &#123;char szFileName[100] = &#123; 0 &#125;;sprintf_s(szFileName, &quot;%03d.jpg&quot;, nFrmIdx++);imwrite(szFileName, frame);&#125;waitKey(40);&#125;&#125;int mian()&#123;TestSVMModel();&#125;</code></pre><p>注：</p><p>①.&#x2F;&#x2F;*…*之间的是copy代码时要修改的地方</p><p>②.void TrainSVMModel()求出支持向量系数，保存在文件中，之后可以直接复制其中数值以调用</p><h6 id="2-获取LBP-MB-LBP特征函数"><a href="#2-获取LBP-MB-LBP特征函数" class="headerlink" title="2.获取LBP&#x2F;MB-LBP特征函数"></a>2.获取LBP&#x2F;MB-LBP特征函数</h6><pre><code>//使用函数模板，保证函数对所有类型图像都适用//_tp参数可以是uchar,float等template &lt;typename _tp&gt;//原始LBP特征void getOriginLBPFeature(InputArray _src, OutputArray _dst)&#123;Mat src = _src.getMat();Mat srcExtented;//对图像边界进行扩充，边界像素采用复制的形式copyMakeBorder(src, srcExtented, 1, 1, 1, 1, BORDER_REPLICATE);//输出图像与原图像大小相同_dst.create(src.rows, src.cols, CV_8UC1);Mat dst = _dst.getMat();dst.setTo(0);for (int i = 0; i &lt; src.rows; i++) &#123;for (int j = 0; j &lt; src.cols; j++) &#123;//中心像素的值_tp center = srcExtented.at&lt;_tp&gt;(i + 1, j + 1);unsigned char lbpCode = 0; //LBP编码值lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j) &gt; center) &lt;&lt; 7; //左上角lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 1) &gt; center) &lt;&lt; 6; //上边lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 2) &gt; center) &lt;&lt; 5; //右上角lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j + 2) &gt; center) &lt;&lt; 4; //右边lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 2) &gt; center) &lt;&lt; 3; //右下角lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 1) &gt; center) &lt;&lt; 2; //下边lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j) &gt; center) &lt;&lt; 1; //左下角lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j) &gt; center) &lt;&lt; 0; //左边dst.at&lt;uchar&gt;(i, j) = lbpCode;&#125;&#125;&#125;//MB-LBP特征void getMultiScaleBlockLBPFeature(InputArray _src, OutputArray _dst, int scale)&#123;Mat src = _src.getMat();int cellSize = scale / 3;int offset = cellSize / 2;Mat srcExtented;//图像扩大一圈copyMakeBorder(src, srcExtented, offset, offset, offset, offset, BORDER_REFLECT);//以当前点为中心，计算每个cell的像素均值Mat cellImage(src.rows, src.cols, CV_8UC1);for (int i = 0; i &lt; src.rows; i++) &#123;for (int j = 0; j &lt; src.cols; j++) &#123;int temp = 0;for (int m = -offset; m &lt; offset + 1; m++) &#123;for (int n = -offset; n &lt; offset + 1; n++) &#123;temp += srcExtented.at&lt;uchar&gt;(i + n + offset, j + m + offset);&#125;&#125;temp /= (cellSize * cellSize);cellImage.at&lt;uchar&gt;(i, j) = uchar(temp);&#125;&#125;getOriginLBPFeature&lt;uchar&gt;(cellImage, _dst);&#125;</code></pre><h6 id="3-cascade级联分类器使用"><a href="#3-cascade级联分类器使用" class="headerlink" title="3.cascade级联分类器使用"></a>3.cascade级联分类器使用</h6><pre><code>//级联分类器实现人脸检测void DetectFaces()&#123;//创建一个级联分类器对象，并加载分类器文件//CascadeClassifier faceDetector(&quot;haarcascade_frontalface_alt2.xml&quot;);CascadeClassifier faceDetector(&quot;cascade.xml&quot;);if (faceDetector.empty()) &#123;return;&#125;VideoCapture cap(0); //打开USB摄像头if (!cap.isOpened()) &#123;return;&#125;Mat frame;while (true) &#123;cap &gt;&gt; frame; //从摄像头获取一帧图像if (frame.empty())break;std::vector&lt;cv::Rect&gt; objects;//使用级联分类器检测人脸faceDetector.detectMultiScale(frame, objects);//对人脸图像进行标记for (int i = 0; i &lt; objects.size(); i++) &#123;static int nIdx = 0;char szFileName[100] = &#123; 0 &#125;;sprintf_s(szFileName, &quot;detectedHeadShoulder/%03d.jpg&quot;, nIdx++);//sprintf_s(szFileName, &quot;DetetecdFaces/%03d.jpg&quot;, nIdx++);cv::rectangle(frame, objects[i], Scalar(0, 0, 255), 4);imwrite(szFileName, frame);&#125;imshow(&quot;人脸检测结果&quot;, frame); //显示人脸检测结果if (waitKey(25) == 27) //暂停25ms，如果按ESC键则退出break;&#125;cap.release(); //释放摄像头对象return;&#125;</code></pre><p>注：分类器文件生成使用opencv_traincacade.exe；创建正样本.vec文件使用opencv_creatsamples.exe；可视化过程使用opencv_visualisation.exe</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131609797">https://blog.csdn.net/qq_32971095/article/details/131609797</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像识别小车（电机部分）——电赛学习笔记（2）</title>
      <link href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
      <url>/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><hr><h2 id="图片来源：B站唐老师讲电赛"><a href="#图片来源：B站唐老师讲电赛" class="headerlink" title="_  图片来源：B站唐老师讲电赛_"></a><strong>_  图片来源：B站唐老师讲电赛_</strong></h2><p><strong>目录</strong></p><p><a href="about:blank#%C2%A0%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90%EF%BC%9AB%E7%AB%99%E5%94%90%E8%80%81%E5%B8%88%E8%AE%B2%E7%94%B5%E8%B5%9B"><br>图片来源：B站唐老师讲电赛</a></p><p><a href="about:blank#%E4%B8%80.%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84">一.电机部分结构</a></p><p><a href="about:blank#%E4%BA%8C.%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">二.步进电机示例</a></p><p><a href="about:blank#%E4%B8%89.%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">三.伺服电机示例</a></p><p><a href="about:blank#%E5%9B%9B.%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%A1%88">四.我们的方案</a></p><hr><h2 id="一-电机部分结构"><a href="#一-电机部分结构" class="headerlink" title="一.电机部分结构"></a>一.电机部分结构</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcfec2f6ed3a3e801301c91dfeb4307d.jpeg"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b68a6432253fb37113bcd87a78d6af13.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/99f4e23df848c63b9a836035426fe043.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5483b488abe59c6b56599034cee91db9.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/36766f56d5dbe1c3b71e1d2f8cc63d56.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f23bb2de689dbeadc754dd5f58a19811.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/f2fe3b27147efcb57b0964d81171b5b5.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4547084918f7ca3e14a1a6aaf1c3ea0c.png"></p><h2 id="二-步进电机示例"><a href="#二-步进电机示例" class="headerlink" title="二.步进电机示例"></a>二.步进电机示例</h2><p>1.驱动器：L298N（CSDN搜索使用方法）；控制器：stm32；电源暂时用12V直流源</p><p>2.控制：全速模式：in1、in2一低一高控制正反转，全低不转。</p><p>pwm控制模式：使能端连接单片机IO口，通过产生pwm波占空比控制速度（相当于有效电压控制）</p><p>3.编码器：将编码器产生脉冲当做外部时钟传入单片机定时器，定时读取并清零</p><p>4.涉及知识：定时器（内部定时器产生pwm波，外部作为编码计数）</p><p>5.示例代码：</p><p>可参考：<a href="https://blog.csdn.net/weixin_65683639/article/details/130562162" title="直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-CSDN博客">直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-<br>CSDN博客</a></p><h2 id="三-伺服电机示例"><a href="#三-伺服电机示例" class="headerlink" title="三.伺服电机示例"></a>三.伺服电机示例</h2><p>MG995型伺服电机：</p><p>1.结构：可参考：</p><p><a href="https://blog.csdn.net/he__yuan/article/details/79195435?spm=1001.2014.3001.5506" title="MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-CSDN博客">MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-<br>CSDN博客</a></p><p>2.控制：通过PWM波占空比控制</p><p>固定20ms周期pwm波通过定时器输出  </p><p>TIM1_PWM_Init(199,7199);        &#x2F;&#x2F;(7200<em>200)&#x2F;72000000&#x3D;0.02&#x3D;20ms；（分频</em>周期数）</p><p>占空比通过函数TIM_SetCompare1（TIM1,num）控制，其中num是低电平占周期数</p><p>0.5ms对应195，2.5ms对应175</p><p>四.具体器件</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/79abef952376244b07db4ca4c37604b6.png"></p><h2 id="四-我们的方案"><a href="#四-我们的方案" class="headerlink" title="四.我们的方案"></a>四.我们的方案</h2><p>后轮电机：MG513直流减速电机（霍尔编码器）</p><p>前轮转向电机（采用阿克曼转向结构）：舵机MG995</p><p>机械臂电机：舵机MG995</p><p>后轮电机驱动：l298n电机驱动模块</p><p>舵机驱动：pca9685 PWM伺服驱动器模块</p><p>超声波测距：cs100a超声波模块</p><p>蓝牙：JDY-31蓝牙模块</p><p>显示屏：SSD1306 OLED IIC显示屏</p><p>稳压芯片：lm2596可调稳压模块*2（12V-5V-3.3V）</p><p>电池：12V3A锂电池（最大电流6A）</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131503991">https://blog.csdn.net/qq_32971095/article/details/131503991</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像识别小车（jetson nano部分）——电赛学习笔记（3）</title>
      <link href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
      <url>/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p><p><a href="about:blank#1.jetson%20nano%E8%B4%AD%E4%B9%B0%E5%95%86%E5%AE%B6%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81">1.jetson<br>nano购买商家及技术支持</a></p><p><a href="about:blank#2.%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2.相关环境配置</a></p><p><a href="about:blank#3.%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD">3.做好系统备份</a></p><p><a href="about:blank#%E4%B8%80.vscode%E8%BF%9C%E7%A8%8Bssh%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5%EF%BC%89">一.vscode远程ssh操作</a></p><p><a href="about:blank#%3C1%3E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5">&lt;1&gt;局域网连接</a></p><p><a href="about:blank#%3C2%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E">&lt;2&gt;电脑直连</a></p><p><a href="about:blank#%3C3%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E%2BVNC%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">&lt;3&gt;电脑直连+VNC远程桌面</a></p><p><a href="about:blank#%E4%BA%8C.%E6%9D%BF%E8%BD%BD%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%99%E7%A8%8B%EF%BC%9A">二.板载摄像头教程：</a></p><p><a href="about:blank#%E4%B8%89.%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B">三.运行例程</a></p><p><a href="about:blank#%E5%9B%9B.GPIO%E4%BD%BF%E7%94%A8">四.GPIO使用</a></p><p><a href="about:blank#GPIO%E5%BA%93%E7%9A%84API%E7%94%A8%E6%B3%95">GPIO库的API用法</a></p><p><a href="about:blank#1.%E5%AF%BC%E5%85%A5%E5%BA%93">1.导入库</a></p><p><a href="about:blank#2.%E5%BC%95%E8%84%9A%E7%BC%96%E5%8F%B7">2.引脚编号</a></p><p><a href="about:blank#3.%E8%AD%A6%E5%91%8A">3.警告</a></p><p><a href="about:blank#4.%E8%AE%BE%E7%BD%AE%E9%80%9A%E9%81%93">4.设置通道</a></p><p><a href="about:blank#5.%E8%BE%93%E5%85%A5">5.输入</a></p><p><a href="about:blank#6.%E8%BE%93%E5%87%BA">6.输出</a></p><p><a href="about:blank#set%20first%20channel%20to%20HIGH%20and%20rest%20to%20LOW">set first channel to HIGH and rest to<br>LOW</a></p><p><a href="about:blank#7.%E6%B8%85%E7%90%86">7.清理</a></p><p><a href="about:blank#8.jetson%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E5%92%8C%E5%BA%93%E7%89%88%E6%9C%AC">8.jetson模块信息和库版本</a></p><p><a href="about:blank#9.%E4%B8%AD%E6%96%AD">9.中断</a></p><p><a href="about:blank#wait_for_edge%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">wait_for_edge（）函数</a></p><p><a href="about:blank#timeout%20is%20in%20milliseconds">timeout is in milliseconds</a></p><p><a href="about:blank#event_detected%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">event_detected（）函数</a></p><p><a href="about:blank#set%20rising%20edge%20detection%20on%20the%20channel">set rising edge detection on the<br>channel</a></p><p><a href="about:blank#%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E8%BE%B9%E7%BC%98%E6%97%B6%E8%BF%90%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">当检测到边缘时运行回调函数</a></p><p><a href="about:blank#define%20callback%20function">define callback function</a></p><p><a href="about:blank#add%20rising%20edge%20detection">add rising edge detection</a></p><p><a href="about:blank#bouncetime%20set%20in%20milliseconds">bouncetime set in<br>milliseconds</a></p><p><a href="about:blank#10.%E6%A3%80%E6%9F%A5GPIO%E9%80%9A%E9%81%93%E7%9A%84%E5%8A%9F%E8%83%BD">10.检查GPIO通道的功能</a></p><p><a href="about:blank#11.%20PWM">11. PWM</a></p><p><a href="about:blank#%E4%BA%94.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1">五.串口通信</a></p><p><a href="about:blank#%3C1%3EUART">&lt;1&gt;UART</a></p><p><a href="about:blank#1.python%E4%BB%A3%E7%A0%81%EF%BC%9AJetsonHacksNano%2FUARTDemo%3A%20UART%20Demo%20Code%20%28github.com%29">1.python代码：JetsonHacksNano&#x2F;UARTDemo: UART Demo Code<br>(github.com)</a></p><p><a href="about:blank#3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点</a></p><p><a href="about:blank#2.C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%9AUart%20c%2B%2B%20class%20for%20Nvidia%20Jetson%20Nano">2.C++代码：Uart c++ class for Nvidia Jetson<br>Nano</a></p><p><a href="about:blank#%E4%BA%94.%E5%9C%A8jetson%20nano%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV">六.在jetson<br>nano上使用OpenCV</a></p><p><a href="about:blank#%E4%B8%83.jetson%20nano%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">七.jetson<br>nano开机自启动程序</a></p><p><a href="about:blank#%E5%85%AB.%E5%AE%9E%E6%88%98%E7%A8%8B%E5%BA%8F">八.实战程序</a></p><p><a href="about:blank#1.jetson%20nano%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%B0%86%E5%9C%86%E5%BF%83%E5%9D%90%E6%A0%87%E9%80%9A%E8%BF%87uart%E4%BC%A0%E7%BB%99stm32">1.jetson<br>nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</a></p><hr><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><h5 id="1-jetson-nano购买商家及技术支持"><a href="#1-jetson-nano购买商家及技术支持" class="headerlink" title="1.jetson nano购买商家及技术支持"></a><strong>1.jetson nano购买商家及技术支持</strong></h5><p>***<strong>选购亚博，支持相关开源资料，资料网址：<a href="https://www.yahboom.com/study/jetson-nano" title="JETSON NANO B01(yahboom.com)">JETSON NANO B01<br>(yahboom.com)</a></strong></p><p>***<strong>常见问题及解答：<a href="https://www.yuque.com/yahboomtechnology/yahboom_support/kgdd5m#NLt6t" title="Jetson nano A01&#x2F;B01 (yuque.com)">Jetson nano A01&#x2F;B01<br>(yuque.com)</a></strong></p><h5 id="2-相关环境配置"><a href="#2-相关环境配置" class="headerlink" title="2.相关环境配置"></a>2.相关环境配置</h5><p>&lt;1&gt;亚博已经在SD卡中将环境配好，插上即可直接使用</p><p>&lt;2&gt;***<strong>自行烧录镜像，配置环境</strong> ：</p><p>下载之前要格式化SD卡或者U盘，具体操作见“jetson—主板—2.Jetson Nano B01基础教程”，然后烧录镜像文件：</p><p>亚博资料里的 “jetson—主板—附录—镜像” 包含**<code>已安装：</code>**</p><p><strong><code>CUDA10.2、CUDNNv8、tensorRT、opencv4.1.1、python2、python3、tensorflow2.3、jetpack4.6.1、yolov5、jetson- inference包（包括相关模型）、jetson-gpio库、安装pytorch1.8和torchvesion0.9、安装node v15.0.1、npm7.2.3，jupyter，已开启VNC服务，还有其他课程中所用到的模块。</code></strong></p><p>以及Swap空间配置，Jtop安装，只需要TF&#x2F;U盘扩容即可</p><p>减少自行配置的麻烦。</p><p>如果要从零开始自己配置，“jetson—主板—2.Jetson Nano B01基础教程” 和“4.系统基础设置教程”中包括了大部分操作，甚至包括空环境下载</p><h5 id="3-做好系统备份"><a href="#3-做好系统备份" class="headerlink" title="3.做好系统备份"></a>3.做好系统备份</h5><p>如果只是使用亚博官方提供的版本库，可以只用 “jetson—主板—附录—镜像”<br>中的镜像文件作为备份。如果自行配置了其他环境，建议备份系统，可在“jetson—主板—4.系统基础设置教程” 找到具体操作。</p><h2 id="一-vscode远程ssh操作"><a href="#一-vscode远程ssh操作" class="headerlink" title="一.vscode远程ssh操作"></a>一.vscode远程ssh操作</h2><h3 id="局域网连接"><a href="#局域网连接" class="headerlink" title="&lt;1&gt;局域网连接"></a>&lt;1&gt;局域网连接</h3><p>1.将jetson连接至路由器——电脑使用该路由wifi——打开VS Code——下载ssh-<br>remote插件——jetson上终端ifconfig查ip——vscode按格式输入：ssh<br>jetson@IP地址——输入密码登录（原始默认用户名为jetson，密码为yahboom）</p><p>2.crtl+o选择要打开的文件或侧栏资源管理器选择，文件可在主机写好直接拖入jetson；终端写入代码并操作</p><h3 id="电脑直连"><a href="#电脑直连" class="headerlink" title="&lt;2&gt;电脑直连"></a>&lt;2&gt;电脑直连</h3><p>参考：<a href="https://blog.51cto.com/u_15906550/5921556#:~:text=Jetson,Nano%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E6%9C%ACssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9CjetsonnanoSD%E5%8D%A1%E6%88%90%E5%8A%9F%E7%83%A7%E5%BD%95%E5%B9%B6%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B0%86Jetsonnano%E5%92%8C%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%BB%99%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8F%B3%E5%87%BBwlan%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E6%89%BE%E5%88%B0IP%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%89%93%E5%BC%80cmd%EF%BC%9Aarp-a%E8%BF%9E%E6%8E%A5ssh%E5%8D%B3%E5%8F%AF%E3%80%82" title="Jetson Nano——通过网线实现笔记本ssh远程连接">Jetson<br>Nano——通过网线实现笔记本ssh远程连接</a></p><h3 id="电脑直连-VNC远程桌面"><a href="#电脑直连-VNC远程桌面" class="headerlink" title="&lt;3&gt;电脑直连+VNC远程桌面"></a>&lt;3&gt;电脑直连+VNC远程桌面</h3><p>jetson nano上设置：[Jetson nano 通过 vnc<br>实现远程桌面控制（已在nano实现）](<a href="https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171299147716800184169928&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171299147716800184169928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>top_positive~default-1-122121251-null-<br>null.142%5Ev100%5Epc_search_result_base9&amp;utm_term&#x3D;jetson%20nano%20vnc&amp;spm&#x3D;1018.2226.3001.4187<br>“Jetson nano 通过 vnc 实现远程桌面控制（已在nano实现）”)</p><p>下载VNC Viewer软件并连接（端口号参考&lt;2&gt;），效果如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png"></p><p> 如果无法连接检查接口是否插好，如果成功会有一个不同于端口地址的地址：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/938609aaeb57355774c771bab4569295.png"></p><p>如果vnc server显示窗口过小，打开终端输入以下命令调整分辨率：</p><pre><code>xrandr --fb 1920x1080</code></pre><h2 id="二-板载摄像头教程："><a href="#二-板载摄像头教程：" class="headerlink" title="二.板载摄像头教程："></a>二.板载摄像头教程：</h2><p><strong>获取摄像头相关参数：[linux查看摄像头分辨率参数](<a href="https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20">https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20</a><br>–list-<br>devices%2F%2F%E9%80%9A%E8%BF%87v4l2%E6%9F%A5%E7%9C%8B%E6%91%84%E5%83%8F%E5%A4%B4%E8%AE%BE%E5%A4%87%20%2F%2F%E5%BD%93%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%91%84%E5%83%8F%E5%A4%B4%E6%97%B6%EF%BC%8C%E6%8C%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95,sudo%20rmmod%20uvcvideo%2F%2F%E7%A7%BB%E9%99%A4%E6%A8%A1%E5%9D%97%20sudo%20modprobe%20uvcvideo%20nodrop%3D1%20timeout%3D5000<br>“linux查看摄像头分辨率参数”)</strong></p><pre><code>Driver Info (not using libv4l2):        Driver name   : tegra-video        Card type     : vi-output, imx219 8-0010        Bus info      : platform:54080000.vi:4        Driver version: 4.9.255        Capabilities  : 0x84200001                Video Capture                Streaming                Extended Pix Format                Device Capabilities        Device Caps   : 0x04200001                Video Capture                Streaming                Extended Pix FormatPriority: 2Video input : 0 (Camera 4: ok)Format Video Capture:        Width/Height      : 3264/2464        Pixel Format      : &#39;RG10&#39;        Field             : None        Bytes per Line    : 6528        Size Image        : 16084992        Colorspace        : sRGB        Transfer Function : Default (maps to sRGB)        YCbCr/HSV Encoding: Default (maps to ITU-R 601)        Quantization      : Default (maps to Full Range)        Flags             : Camera Controls                     group_hold 0x009a2003 (bool)   : default=0 value=0 flags=execute-on-write                    sensor_mode 0x009a2008 (int64)  : min=0 max=0 step=0 default=0 value=0 flags=slider                           gain 0x009a2009 (int64)  : min=0 max=0 step=0 default=0 value=16 flags=slider                       exposure 0x009a200a (int64)  : min=0 max=0 step=0 default=0 value=13 flags=slider                     frame_rate 0x009a200b (int64)  : min=0 max=0 step=0 default=0 value=2000000 flags=slider                    bypass_mode 0x009a2064 (intmenu): min=0 max=1 default=0 value=0                override_enable 0x009a2065 (intmenu): min=0 max=1 default=0 value=0                   height_align 0x009a2066 (int)    : min=1 max=16 step=1 default=1 value=1                     size_align 0x009a2067 (intmenu): min=0 max=2 default=0 value=0               write_isp_format 0x009a2068 (bool)   : default=0 value=0       sensor_signal_properties 0x009a2069 (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload        sensor_image_properties 0x009a206a (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload      sensor_control_properties 0x009a206b (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload              sensor_dv_timings 0x009a206c (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload               low_latency_mode 0x009a206d (bool)   : default=0 value=0               preferred_stride 0x009a206e (int)    : min=0 max=65535 step=1 default=0 value=0                   sensor_modes 0x009a2082 (int)    : min=0 max=30 step=1 default=30 value=6 flags=read-only</code></pre><p><strong>注意jetson nano要连接显示屏</strong></p><p>jetson@yahboom:&#x2F;home$ <strong>nvgstcapture-1.0  **                              **<br>&#x2F;&#x2F;打开摄像头命令</strong></p><p><strong>响应：</strong><br>Encoder null, cannot set bitrate!<br>Encoder Profile &#x3D; High<br>Supported resolutions in case of ARGUS Camera                      <strong>&#x2F;&#x2F;设置分辨率</strong><br>  (2) : 640x480<br>  (3) : 1280x720<br>  (4) : 1920x1080<br>  (5) : 2104x1560<br>  (6) : 2592x1944<br>  (7) : 2616x1472<br>  (8) : 3840x2160<br>  (9) : 3896x2192<br>  (10): 4208x3120<br>  (11): 5632x3168<br>  (12): 5632x4224</p><p>Runtime ARGUS Camera Commands:</p><p>  <strong>Help : ‘h’<br>  Quit : ‘q’</strong><br>  Set Capture Mode:<br>      mo:<val><br>          (1): image<br>          (2): video<br>  Get Capture Mode:<br>      gmo<br>  Set sensor orientation:<br>      so:<val><br>          (0): none<br>          (1): Rotate counter-clockwise 90 degrees<br>          (2): Rotate 180 degrees<br>          (3): Rotate clockwise 90 degrees<br>  Get sensor orientation:<br>      gso<br>  Set sensor mode:<br>      smo:<val> e.g., smo:1<br>  Get sensor mode:<br>      gsmo<br>  Set Whitebalance Mode:<br><strong>&#x2F;&#x2F;更改相机参数（曝光、饱和度等等）</strong><br>      wb:<val><br>          (0): off<br>          (1): auto<br>          (2): incandescent<br>          (3): fluorescent<br>          (4): warm-fluorescent<br>          (5): daylight<br>          (6): cloudy-daylight<br>          (7): twilight<br>          (8): shade<br>          (9): manual<br>  Get Whitebalance Mode:<br>      gwb<br>  Set Saturation (0 to 2):<br>      st:<val> e.g., st:1.25<br>  Get Saturation:<br>      gst<br>  Set Exposure Compensation (-2 to 2):<br>      ec:<val> e.g., ec:-2<br>  Get Exposure Compensation:<br>      gec<br>  Set Auto Whitebalance Lock:<br>      awbl:<val> e.g., awbl:0<br>  Get Auto Whitebalance Lock:<br>      awbl<br>  Set Auto Exposure Lock:<br>      ael:<val> e.g., ael:0<br>  Get Auto Exposure Lock:<br>      gael<br>  Set TNR Mode:<br>      tnrm:<val> e.g., tnrm:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get TNR Mode:<br>      gtnrm<br>  Set TNR Strength (-1 to 1):<br>      tnrs:<val> e.g., tnrs:0.5<br>  Get TNR Strength:<br>      gtnrs<br>  Set EE Mode:<br>      eem:<val> e.g., eem:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get EE Mode:<br>      geem<br>  Set EE Strength (-1 to 1):<br>      ees:<val> e.g., ees:0.5<br>  Get EE Strength:<br>      gees<br>  Set Auto Exposure Anti-Banding (0 to 3):<br>      aeab:<val> e.g., aeab:2<br>          (0): OFF<br>          (1): MODE AUTO<br>          (2): MODE 50HZ<br>          (3): MODE 60HZ<br>  Get Auto Exposure Anti-Banding:<br>      gaeab<br>  Set Gain Range:<br>      gr:<val><space><val> e.g., gr:1 16<br>  Get Gain Range:<br>      ggr<br>  Set Exposure Time Range:<br>      etr:<val><space><val> e.g., etr:34000 35000<br>  Get Exposure Time Range:<br>      getr<br>  Set ISP Digital Gain Range:<br>      dgr:<val><space><val> e.g., dgr:2 152<br>  Get ISP Digital Gain Range:<br>      gdgr<br>  <strong>Capture: enter ‘j’ OR<br>           followed by a timer (e.g., jx5000, capture after 5 seconds) OR<br>           followed by multishot count (e.g., j:6, capture 6 images)<br>           timer&#x2F;multihot values are optional, capture defaults to single shot with timer&#x3D;0s<br>  Start Recording : enter ‘1’<br>  Stop Recording  : enter ‘0’</strong><br>  Video <strong>snapshot</strong>  : enter ‘2’ (While recording video)<br>  Get Preview Resolution:<br>      gpcr<br>  Get Image Capture Resolution:<br>      gicr<br>  Get Video Capture Resolution:<br>      gvcr</val></space></val></val></space></val></val></space></val></val></val></val></val></val></val></val></val></val></val></val></val></val></p><p>Runtime encoder configuration options:</p><p>  Set Encoding Bit-rate(in bytes):<br>      br:<val> e.g., br:4000000<br>  Get Encoding Bit-rate(in bytes):<br>      gbr<br>  Set Encoding Profile(only for H.264):<br>      ep:<val> e.g., ep:1<br>          (0): Baseline<br>          (1): Main<br>          (2): High<br>  Get Encoding Profile(only for H.264):<br>      gep<br>  Force IDR Frame on video Encoder(only for H.264):<br>      Enter ‘f’ </val></val></p><p>bitrate &#x3D; 4000000<br>Encoder Profile &#x3D; High<br>Encoder control-rate &#x3D; 1<br>Encoder EnableTwopassCBR &#x3D; 0<br>Opening in BLOCKING MODE</p><p>摘自亚博教程：命令</p><ol><li>--prev_res 预览视屏的分辨率，高度和宽度，用的是CSI摄像头的话范围是 2 to 12 (5632x4224)</li></ol><p>e.g.,  nvgstcapture-1.0 –prev-res&#x3D;3</p><ol><li>--cus-prev-res 自定义预览分辨率，宽度和高度，仅支持CSI摄像头</li></ol><p>e.g., nvgstcapture-1.0 –cus-prev-res&#x3D;1920x1080</p><p>多个命令同时使用的话用！隔开</p><p>想关掉摄像头的额话，直接在终端输入q再按回车</p><p>想捕获图片的话，在终端输入j再按回车，图片将保存当前目录下</p><p><strong>关键参数的调整</strong> ：<a href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p><h2 id="三-运行例程"><a href="#三-运行例程" class="headerlink" title="三.运行例程"></a>三.运行例程</h2><ul><li><p>MIPI CSI cameras (<code>csi://0</code>)</p></li><li><p>V4L2 cameras (<code>/dev/video0</code>)</p></li><li><p>RTP&#x2F;RTSP streams (<code>rtsp://username:password@ip:port</code>)</p><p>在&#x2F;home&#x2F;jetson&#x2F;jetson-inference&#x2F;build&#x2F;aarch64&#x2F;bin 中打开终端</p><p>输入示例(c++)(python 加.py即可)<br>.&#x2F;imagenet images&#x2F;orange_0.jpg images&#x2F;test&#x2F;output_0.jpg<br>.&#x2F;imagenet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;图像分类推理<br>.&#x2F;detectnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;目标检测推理<br>.&#x2F;segnet –network&#x3D;<model> csi:&#x2F;&#x2F;0           &#x2F;&#x2F;语义分割<br>.&#x2F;posenet &#x2F;dev&#x2F;video0                        &#x2F;&#x2F;姿态估计<br>.&#x2F;posenet –network&#x3D;resnet18-hand csi:&#x2F;&#x2F;0    &#x2F;&#x2F;手部姿态<br>.&#x2F;actionnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;动作识别<br>.&#x2F;backgroundnet csi:&#x2F;&#x2F;0                      &#x2F;&#x2F;背景去除<br>.&#x2F;depthnet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;单眼深度</model></p></li></ul><h2 id="四-GPIO使用"><a href="#四-GPIO使用" class="headerlink" title="四.GPIO使用"></a>四.GPIO使用</h2><p><strong>Python版使用说明</strong> ：<a href="https://github.com/NVIDIA/jetson-gpio" title="NVIDIA&#x2F;jetson-gpio: APython library that enables the use of Jetson&#39;s GPIOs">NVIDIA&#x2F;jetson-gpio: A Python library that enables the use of<br>Jetson’s GPIOs</a></p><p><strong>C++版使用说明</strong> ：<a href="https://github.com/pjueon/JetsonGPIO" title="pjueon&#x2F;JetsonGPIO: A C++library that enables the use of Jetson&#39;s GPIOs">pjueon&#x2F;JetsonGPIO: A C++ library that enables the use of<br>Jetson’s GPIOs</a></p><h4 id="GPIO库的API用法"><a href="#GPIO库的API用法" class="headerlink" title="GPIO库的API用法"></a>GPIO库的API用法</h4><p>Jetson GPIO库提供了RPi.GPIO库提供的所有公共API。下面讨论每种API的用法：</p><h5 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h5><p>要导入Jetson.GPIO模块，请使用：</p><p>import Jetson.GPIO as GPIO</p><p>通过这种方式，您可以在应用程序的其余部分中将该模块称为GPIO。模块也可以使用RPi的名称导入。GPIO代替了Jetson。GPIO用于使用RPi库的现有代码。</p><h5 id="2-引脚编号"><a href="#2-引脚编号" class="headerlink" title="2.引脚编号"></a>2.引脚编号</h5><p>Jetson<br>GPIO库提供了四种给IO引脚编号的方法。前两个对应于RPi.GPIO库提供的模式，即BOARD和BCM，分别引用40引脚GPIO接头连接器的引脚号和Broadcom<br>SoC GPIO编号。其余两种模式CVM和TEGRA_SOC使用字符串代替数字，而数字分别对应于CVM CVB连接器和Tegra SoC上的信号名称。</p><p>要指定您正在使用哪种模式（强制性），请使用以下函数调用：</p><p>GPIO.setmode(GPIO.BOARD)# or</p><p>GPIO.setmode(GPIO.BCM)# or</p><p>GPIO.setmode(GPIO.CVM)# or</p><p>GPIO.setmode(GPIO.TEGRA_SOC)</p><p>要检查已设置的模式，可以调用：</p><p>mode &#x3D; GPIO.getmode()</p><p>该模式必须为GPIO.BOARD，GPIO.BCM，GPIO.CVM，GPIO.TEGRA_SOC或无。</p><p>可参考：<a href="https://blog.csdn.net/cynophile/article/details/99310678" title="Jetson Nano GPIO使用、四种模式以及串口解释">Jetson Nano<br>GPIO使用、四种模式以及串口解释</a></p><h5 id="3-警告"><a href="#3-警告" class="headerlink" title="3.警告"></a>3.警告</h5><p>您尝试使用的GPIO可能已在当前应用程序外部使用。在这种情况下，如果使用的GPIO配置为除默认方向（输入）以外的任何值，Jetson<br>GPIO库将向您发出警告。如果在设置模式和通道之前尝试清理，它也会警告您。要禁用警告，请使用：</p><p>GPIO.setwarnings(False)</p><h5 id="4-设置通道"><a href="#4-设置通道" class="headerlink" title="4.设置通道"></a>4.设置通道</h5><p>在用作输入或输出之前，必须先设置GPIO通道。要将通道配置为输入，请调用：</p><p>GPIO.setup(channel, GPIO.IN)</p><p>要将通道设置为输出，请调用：</p><p>GPIO.setup(channel, GPIO.OUT)</p><p>也可以为输出通道指定一个初始值：</p><p>GPIO.setup(channel, GPIO.OUT, initial&#x3D;GPIO.HIGH)</p><p>将一个通道设置为输出时，也可以一次设置多个通道：</p><p>channels &#x3D; [18, 12, 13]</p><p>GPIO.setup(channels, GPIO.OUT)</p><h5 id="5-输入"><a href="#5-输入" class="headerlink" title="5.输入"></a>5.输入</h5><p>要读取通道的值，请使用：</p><p>GPIO.input(channel)</p><p>这将返回GPIO.LOW或GPIO.HIGH。</p><h5 id="6-输出"><a href="#6-输出" class="headerlink" title="6.输出"></a>6.输出</h5><p>要设置配置为输出的引脚的值，请使用：</p><p>GPIO.output(channel, state)</p><p>状态可以是GPIO.LOW或GPIO.HIGH。</p><p>您还可以输出到频道列表或元组：</p><p>channels &#x3D; [18, 12, 13] # or use tuples</p><p>GPIO.output(channels, GPIO.HIGH) # or GPIO.LOW</p><h6 id="set-first-channel-to-HIGH-and-rest-to-LOW"><a href="#set-first-channel-to-HIGH-and-rest-to-LOW" class="headerlink" title="set first channel to HIGH and rest to LOW"></a>set first channel to HIGH and rest to LOW</h6><p>GPIO.output(channel, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH))</p><h5 id="7-清理"><a href="#7-清理" class="headerlink" title="7.清理"></a>7.清理</h5><p>在程序结束时，最好清理通道，以便将所有引脚设置为默认状态。要清理所有使用的通道，请使用：</p><p>GPIO.cleanup()</p><p>如果您不想清除所有通道，也可以清除单个通道或通道列表或元组：</p><p>GPIO.cleanup(chan1) # cleanup only chan1</p><p>GPIO.cleanup([chan1, chan2]) # cleanup only chan1 and chan2</p><p>GPIO.cleanup((chan1, chan2)) # does the same operation as previous statement</p><h5 id="8-jetson模块信息和库版本"><a href="#8-jetson模块信息和库版本" class="headerlink" title="8.jetson模块信息和库版本"></a>8.jetson模块信息和库版本</h5><p>要获取有关Jetson模块的信息，请使用&#x2F;阅读：</p><p>GPIO.JETSON_INFO</p><p>这为Python字典提供了以下键：P1_REVISION，RAM，REVISION，TYPE，MANUFACTURER和PROCESSOR。字典中的所有值都是字符串，但P1_REVISION是整数。</p><p>要获取有关库版本的信息，请使用&#x2F;阅读：</p><p>GPIO.VERSION</p><p>这提供了XYZ版本格式的字符串。</p><h5 id="9-中断"><a href="#9-中断" class="headerlink" title="9.中断"></a>9.中断</h5><p>除了繁忙的轮询外，该库还提供了三种监视输入事件的方法：</p><h6 id="wait-for-edge（）函数"><a href="#wait-for-edge（）函数" class="headerlink" title="wait_for_edge（）函数"></a>wait_for_edge（）函数</h6><p>该函数阻塞调用线程，直到检测到提供的边缘为止。该函数可以如下调用：</p><p>GPIO.wait_for_edge(channel, GPIO.RISING)</p><p>第二个参数指定要检测的边缘，可以是GPIO.RISING，GPIO.FALLING或GPIO.BOTH。如果只想将等待时间限制为指定的时间，则可以选择设置超时：</p><h6 id="timeout-is-in-milliseconds"><a href="#timeout-is-in-milliseconds" class="headerlink" title="timeout is in milliseconds"></a>timeout is in milliseconds</h6><p>GPIO.wait_for_edge(channel, GPIO.RISING, timeout&#x3D;500)</p><p>该函数返回检测到边缘的通道；如果发生超时，则返回无。</p><h6 id="event-detected（）函数"><a href="#event-detected（）函数" class="headerlink" title="event_detected（）函数"></a>event_detected（）函数</h6><p>此功能可用于定期检查自上次通话以来是否发生了事件。该函数可以如下设置和调用：</p><h6 id="set-rising-edge-detection-on-the-channel"><a href="#set-rising-edge-detection-on-the-channel" class="headerlink" title="set rising edge detection on the channel"></a>set rising edge detection on the channel</h6><p>GPIO.add_event_detect(channel, GPIO.RISING)</p><p>run_other_code()</p><p>if GPIO.event_detected(channel):</p><p>do_something()</p><p>和以前一样，您可以检测GPIO.RISING，GPIO.FALLING或GPIO.BOTH的事件。</p><h6 id="当检测到边缘时运行回调函数"><a href="#当检测到边缘时运行回调函数" class="headerlink" title="当检测到边缘时运行回调函数"></a>当检测到边缘时运行回调函数</h6><p>此功能可用于为回调函数运行第二个线程。因此，响应边缘，回调函数可以与主程序并发运行。可以按以下方式使用此功能：</p><h6 id="define-callback-function"><a href="#define-callback-function" class="headerlink" title="define callback function"></a>define callback function</h6><p>def callback_fn(channel):</p><p>print(“Callback called from channel %s” % channel)</p><h6 id="add-rising-edge-detection"><a href="#add-rising-edge-detection" class="headerlink" title="add rising edge detection"></a>add rising edge detection</h6><p>GPIO.add_event_detect(channel, GPIO.RISING, callback&#x3D;callback_fn)</p><p>如果需要，还可以添加多个回调：</p><p>def callback_one(channel):</p><p>print(“First Callback”)</p><p>def callback_two(channel):</p><p>print(“Second Callback”)</p><p>GPIO.add_event_detect(channel, GPIO.RISING)</p><p>GPIO.add_event_callback(channel, callback_one)</p><p>GPIO.add_event_callback(channel, callback_two)</p><p>在这种情况下，这两个回调是顺序运行的，而不是同时运行，因为只有线程运行所有回调函数。</p><p>为了通过将多个事件折叠为一个事件来防止多次调用回调函数，可以选择设置反跳时间：</p><h6 id="bouncetime-set-in-milliseconds"><a href="#bouncetime-set-in-milliseconds" class="headerlink" title="bouncetime set in milliseconds"></a>bouncetime set in milliseconds</h6><p>GPIO.add_event_detect(channel, GPIO.RISING,<br>callback&#x3D;callback_fn,bouncetime&#x3D;200)</p><p>如果不再需要边缘检测，可以按以下步骤将其删除：</p><p>GPIO.remove_event_detect(channel)</p><h5 id="10-检查GPIO通道的功能"><a href="#10-检查GPIO通道的功能" class="headerlink" title="10.检查GPIO通道的功能"></a>10.检查GPIO通道的功能</h5><p>此功能使您可以检查提供的GPIO通道的功能：</p><p>GPIO.gpio_function(channel)</p><p>该函数返回GPIO.IN或GPIO.OUT。</p><h5 id="11-PWM"><a href="#11-PWM" class="headerlink" title="11. PWM"></a>11. PWM</h5><p>请参阅samples&#x2F;simple_pwm.py有关如何使用PWM通道的详细信息。</p><p>Jetson.GPIO库仅在附带硬件PWM控制器的引脚上支持PWM。与RPi.GPIO库不同，Jetson.GPIO库不实现软件仿真的PWM。Jetson<br>Nano支持2个PWM通道，而Jetson AGX Xavier支持3个PWM通道。Jetson TX1和TX2不支持任何PWM通道。</p><p>系统引脚复用器必须配置为将硬件PWM控制器连接到相关引脚。如果未配置pinmux，则PWM信号将不会到达引脚！Jetson.GPIO库不会动态修改pinmux配置来实现此目的。阅读L4T文档以获取有关如何配置pinmux的详细信息</p><p>完整英文版说明见: <a href="https://github.com/NVIDIA/jetson-gpio">https://github.com/NVIDIA/jetson-gpio</a></p><h2 id="五-串口通信"><a href="#五-串口通信" class="headerlink" title="五.串口通信"></a>五.串口通信</h2><h5 id="UART"><a href="#UART" class="headerlink" title="&lt;1&gt;UART"></a>&lt;1&gt;UART</h5><h6 id="1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code"><a href="#1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code" class="headerlink" title="1.python代码 ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code"></a><strong>1.python代码</strong> ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code</h6><p>(github.com)](<a href="https://github.com/JetsonHacksNano/UARTDemo">https://github.com/JetsonHacksNano/UARTDemo</a><br>“JetsonHacksNano&#x2F;UARTDemo: UART Demo Code (github.com)“)</p><p>jetson nano的串口的TXD和RXD引脚分别对应物理引脚8,10</p><p>开启串口权限，注意这个权限关机后就也被关闭，下次需要重新开启</p><pre><code>sudo chmod 777 /dev/ttyTHS1</code></pre><p>如果要永久打开，可参考：<a href="https://codeleading.com/article/76115811693/" title="永久修改jetsonnano上电启动串口权限">永久修改jetson<br>nano上电启动串口权限</a></p><h5 id="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"><a href="#注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点" class="headerlink" title="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"></a>注意事项：<strong>如果使用USB转TTL模块电脑和nano进行通信注意一下几点</strong></h5><pre><code>    1.杜邦线不可太长，太长会乱码    2.出现只能收不能发的情况是电压不足导致的，把usb转ttl模块的5V口和nano的5V进行连接    3.如果线合理，但出现乱码，波特率、奇偶校验、停止位检查是否一致    4.其它情况：[串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据](https://blog.csdn.net/lxj362343/article/details/89646731 &quot;串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据&quot;)</code></pre><h6 id="2-C-代码：-Uart-c-class-for-Nvidia-Jetson"><a href="#2-C-代码：-Uart-c-class-for-Nvidia-Jetson" class="headerlink" title="2.C++代码：[Uart c++ class for Nvidia Jetson"></a>2.C++代码：[Uart c++ class for Nvidia Jetson</h6><p>Nano](<a href="https://github.com/MathieuBahin/JetsonNanoUart/tree/master">https://github.com/MathieuBahin/JetsonNanoUart/tree/master</a> “Uart c++<br>class for Nvidia Jetson Nano”)</p><p>在四中的C++版GPIO库中并未包括uart相关内容，但是利用jetson nano设备中的</p><pre><code>/dev/ttyTHS1</code></pre><p>进行系统调用，可实现串口通信。</p><p>但github上的C++ uart代码比较复杂，且只适用于特点场景，笔者修改了部分内容如下：</p><pre><code>//uart.h#ifndef _UART_H#define _UART_H// Define Constantsconst char *uart_target = &quot;/dev/ttyTHS1&quot;;#define     NSERIAL_CHAR   256#define     VMINX          1#define     BAUDRATE       B115200class Uart &#123;private:  /* data */  int fid;public:  char serial_message[NSERIAL_CHAR];  Uart ();  void sendUart(char *msg);  void readUart();  void closeUart();&#125;;#endif/************************************//* @auteur Mathieu Bahin            *//* @date_création mars 2020         *//* @version 1.0                     *//* @email bahin.mathieu@gmail.com   *//************************************/#include &quot;uart.h&quot;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;       // Used for UART#include &lt;sys/fcntl.h&gt;    // Used for UART#include &lt;termios.h&gt;      // Used for UART#include &lt;string.h&gt;using namespace std;Uart :: Uart ()&#123;  int ii, jj, kk;  // SETUP SERIAL WORLD  struct termios  port_options;   // Create the structure  tcgetattr(fid, &amp;port_options);// Get the current attributes of the Serial port  //------------------------------------------------  //  OPEN THE UART  //------------------------------------------------  // The flags (defined in fcntl.h):  //Access modes (use 1 of these):  //O_RDONLY - Open for reading only.  //O_RDWR   - Open for reading and writing.  //O_WRONLY - Open for writing only.  //    O_NDELAY / O_NONBLOCK (same function)  //               - Enables nonblocking mode. When set read requests on the file can return immediately with a failure status  //                 if there is no input immediately available (instead of blocking). Likewise, write requests can also return  //   immediately with a failure status if the output can&#39;t be written immediately.  //                 Caution: VMIN and VTIME flags are ignored if O_NONBLOCK flag is set.  //    O_NOCTTY - When set and path identifies a terminal device, open() shall not cause the terminal device to become the controlling terminal for the process.fid = open(&quot;/dev/ttyTHS1&quot;, O_RDWR | O_NOCTTY | O_NDELAY);//Open in non blocking read/write mode  fid = open(uart_target, O_RDWR | O_NOCTTY );  tcflush(fid, TCIFLUSH);  tcflush(fid, TCIOFLUSH);  if (fid == -1)  &#123;    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);  &#125;  //------------------------------------------------  // CONFIGURE THE UART  //------------------------------------------------  // flags defined in /usr/include/termios.h - see http://pubs.opengroup.org/onlinepubs/007908799/xsh/termios.h.html  //Baud rate:  //         - B1200, B2400, B4800, B9600, B19200, B38400, B57600, B115200,  //           B230400, B460800, B500000, B576000, B921600, B1000000, B1152000,  //           B1500000, B2000000, B2500000, B3000000, B3500000, B4000000  //CSIZE: - CS5, CS6, CS7, CS8  //CLOCAL - Ignore modem status lines  //CREAD  - Enable receiver  //IGNPAR = Ignore characters with parity errors  //ICRNL  - Map CR to NL on input (Use for ASCII comms where you want to auto correct end of line characters - don&#39;t use for bianry comms!)  //PARENB - Parity enable  //PARODD - Odd parity (else even)//*******************************begin::uart参数设置************************************  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit  port_options.c_cflag &amp;= ~CSIZE;            // Clears the mask for setting the data size  port_options.c_cflag |=  CS8;               // Set the data bits = 8  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing  port_options.c_lflag = 0;               //  enable raw input instead of canonical,  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character  port_options.c_cc[VTIME] = 0;           // Wait indefinetly  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed//********************************end::uart参数设置*************************************  // Set the attributes to the termios structure  int att = tcsetattr(fid, TCSANOW, &amp;port_options);  if (att != 0 )  &#123;    printf(&quot;\nERROR in Setting port attributes&quot;);  &#125;  else  &#123;    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);  &#125;  // Flush Buffers  tcflush(fid, TCIFLUSH);  tcflush(fid, TCIOFLUSH);&#125;void Uart :: sendUart(char *msg)&#123;  //--------------------------------------------------------------  // TRANSMITTING BYTES  //--------------------------------------------------------------  char tx_buffer[256]=&#123;0&#125;;  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;    tx_buffer[i] = msg[i];  &#125;  printf(&quot;%s\n&quot;,tx_buffer);  if (fid != -1)  &#123;    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));//Filestream, bytes to write, number of bytes to write    printf(&quot;Count = %d\n&quot;, count);    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);  &#125;&#125;void Uart :: readUart()&#123;  //--------------------------------------------------------------  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED  //--------------------------------------------------------------  unsigned char rx_buffer[VMINX];  bool          pickup = true;  int ii;  int           rx_length;  int           nread = 0;  //更新缓存  tcflush(fid, TCIOFLUSH);  //清空接收区  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;  while (pickup &amp;&amp; fid != -1)  &#123;    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)    if (rx_length&gt;=0)    &#123;      if (nread&lt;=NSERIAL_CHAR-1)&#123;        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time      &#125;      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾    &#125;    nread++;  &#125;&#125;void Uart :: closeUart()&#123;  //-------------------------------------------  //  CLOSE THE SERIAL PORT  //-------------------------------------------  close(fid);&#125;//*******************************begin::测试程序************************************int main(int argc, char *argv[]) &#123;  Uart u;  int i;  char m[256]=&quot;hello world!&quot;;  u.sendUart(&quot;%s&quot;,&quot;hello world!\r\n&quot;);  u.sendUart(m);     while (1)  &#123;    u.readUart();    if(strlen(u.serial_message)!=0)    &#123;      for(i=0;u.serial_message[i]!=&#39;$&#39;;i++)    //自定协议规定以$结尾      &#123;        printf(&quot;%c &quot;,u.serial_message[i]);      &#125;    &#125;    printf(&quot;\n&quot;);      &#125;  u.closeUart();  return 0;&#125;//********************************end::测试程序*************************************</code></pre><p><strong>其中删去了大部分不必要片段，并加入了Uart_Printf()函数，用法同printf()</strong></p><p>测试结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6af7567db40ef98ffaec08066206ca83.png"></p><p>&lt;2&gt;IIC</p><h2 id="六-在jetson-nano上使用OpenCV"><a href="#六-在jetson-nano上使用OpenCV" class="headerlink" title="六.在jetson nano上使用OpenCV"></a>六.在jetson nano上使用OpenCV</h2><p>&lt;1&gt;<strong>python打开摄像头：参考[通过OpenCV调用CSI和USB摄像头](<a href="https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169070226116800188569163&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169070226116800188569163&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduend~default-2-123967404-null-<br>null.142%5Ev91%5Einsert_down28v1,239%5Ev12%5Econtrol2&amp;utm_term&#x3D;jetsonnano%E8%B0%83%E7%94%A8usb%E6%91%84%E5%83%8F%E5%A4%B4&amp;spm&#x3D;1018.2226.3001.4187<br>“通过OpenCV调用CSI和USB摄像头”)</strong></p><p><strong>C++打开，示例如下：</strong></p><pre><code>//适用于jetson nano上的模版#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/objdetect.hpp&gt;#include &lt;opencv2/imgproc/types_c.h&gt;#include &lt;opencv2/videoio.hpp&gt;using namespace std;using namespace cv;string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)&#123;    return &quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +        to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +        &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +        to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;&#125;int main()&#123;    int capture_width = 1280;    int capture_height = 720;    int display_width = 1280;    int display_height = 720;    int framerate = 60;    int flip_method = 0;    //创建管道    string pipeline = gstreamer_pipeline(capture_width,        capture_height,        display_width,        display_height,        framerate,        flip_method);    std::cout &lt;&lt; &quot;使用gstreamer管道: \n\t&quot; &lt;&lt; pipeline &lt;&lt; &quot;\n&quot;;    //管道与视频流绑定    VideoCapture cap(pipeline, CAP_GSTREAMER);    //创建显示窗口    namedWindow(&quot;CSI Camera&quot;, WINDOW_AUTOSIZE);    Mat img;    //逐帧显示    while (true)    &#123;        cap.read(img);        imshow(&quot;CSI Camera&quot;, img);        if (waitKey(10) == 27)break;    &#125;    cap.release();    destroyAllWindows();&#125;</code></pre><p>&lt;2&gt;使用官方自带的4.1.1版本OpenCV</p><p>自带的OpenCV文件夹在**&#x2F;usr&#x2F;share&#x2F;opencv4** 中，**~&#x2F;sample&#x2F;cpp  **内含众多示例代码</p><p>运行示例代码时使用g++编译，命令为：</p><pre><code>g++ name.cpp -o name `pkg-config --cflags --libs opencv4`</code></pre><p>命令行输入如下命令即可运行：</p><pre><code>./name parameters</code></pre><p>其中name为编写的程序名，parameters程序具体需要的参数</p><p>因为官方镜像所有的环境都是配好的，g++编译时加入<code>pkg-config --cflags --libs opencv4</code>就可运行。想要下载全新版本自己配置并了解其中的原理可以参考下面的资料</p><p>&lt;3&gt;自己配置其他版本OpenCV参考资料</p><p> 1.jetson nano上开发环境配置及使用QT(C++)或VsCode编写运行(Python)<a href="https://blog.csdn.net/qianbin3200896/article/details/103760640?spm=1001.2014.3001.5506#t6" title="Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）">Jetson Nano<br>从入门到实战（案例：Opencv配置、人脸检测、二维码检测）</a></p><p>2.使用CMake编译链接(C++)</p><p><a href="https://blog.csdn.net/weixin_43717839/article/details/128032486?spm=1001.2014.3001.5506" title="【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-CSDN博客">【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-<br>CSDN博客</a></p><p>3.使用g++命令(C++)</p><p>4.配置最新版或其他版本OpenCV：<a href="https://blog.csdn.net/s15810751918/article/details/107705387?spm=1001.2014.3001.5506" title="linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-CSDN博客">linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-<br>CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_47665864/article/details/128945476?spm=1001.2014.3001.5506" title="如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-CSDN博客">如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-<br>CSDN博客</a></p><h2 id="七-jetson-nano开机自启动程序"><a href="#七-jetson-nano开机自启动程序" class="headerlink" title="七.jetson nano开机自启动程序"></a>七.jetson nano开机自启动程序</h2><p>步骤：</p><p>1.打开文件：</p><pre><code>/usr/bin/yoyo.sh</code></pre><p>2.写入命令（开机自动执行的命令），例如：</p><pre><code>cd /home/jetson/test/circle_control./circle</code></pre><p>注：终端路径转至&#x2F;home&#x2F;jetson&#x2F;test&#x2F;circle_control，执行.&#x2F;circle文件</p><p>3.终端执行:</p><pre><code>sudo systemctl daemon-reloadsudo systemctl enable start.servicesudo reboot</code></pre><h2 id="八-实战程序"><a href="#八-实战程序" class="headerlink" title="八.实战程序"></a>八.实战程序</h2><h5 id="1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"><a href="#1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32" class="headerlink" title="1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"></a>1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</h5><pre><code>//*************circle.cpp**************#include &quot;opencv2/opencv.hpp&quot;#include &quot;opencv2/highgui.hpp&quot;#include &lt;iostream&gt;using namespace cv;//begin::uart部分************************************************************************#include &quot;uart.h&quot;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;       // Used for UART#include &lt;sys/fcntl.h&gt;    // Used for UART#include &lt;termios.h&gt;      // Used for UART#include &lt;string.h&gt;using namespace std;Uart :: Uart ()&#123;  int ii, jj, kk;  struct termios  port_options;   // Create the structure  tcgetattr(fid, &amp;port_options);// Get the current attributes of the Serial port  fid = open(uart_target, O_RDWR | O_NOCTTY );  tcflush(fid, TCIFLUSH);  tcflush(fid, TCIOFLUSH);  if (fid == -1)  &#123;    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);  &#125;  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit  port_options.c_cflag &amp;= ~CSIZE;            // Clears the mask for setting the data size  port_options.c_cflag |=  CS8;               // Set the data bits = 8  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing  port_options.c_lflag = 0;               //  enable raw input instead of canonical,  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character  port_options.c_cc[VTIME] = 0;           // Wait indefinetly  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed  // Set the attributes to the termios structure  int att = tcsetattr(fid, TCSANOW, &amp;port_options);  if (att != 0 )  &#123;    printf(&quot;\nERROR in Setting port attributes&quot;);  &#125;  else  &#123;    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);  &#125;  // Flush Buffers  tcflush(fid, TCIFLUSH);  tcflush(fid, TCIOFLUSH);&#125;void Uart :: sendUart(char *msg)&#123;  //--------------------------------------------------------------  // TRANSMITTING BYTES  //--------------------------------------------------------------  char tx_buffer[256]=&#123;0&#125;;  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;    tx_buffer[i] = msg[i];  &#125;  printf(&quot;%s\n&quot;,tx_buffer);  if (fid != -1)  &#123;    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));//Filestream, bytes to write, number of bytes to write    printf(&quot;Count = %d\n&quot;, count);    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);  &#125;&#125;void Uart :: readUart()&#123;  //--------------------------------------------------------------  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED  //--------------------------------------------------------------  unsigned char rx_buffer[VMINX];  bool          pickup = true;  int ii;  int           rx_length;  int           nread = 0;  //更新缓存  tcflush(fid, TCIOFLUSH);  //清空接收区  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;  while (pickup &amp;&amp; fid != -1)  &#123;    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)    if (rx_length&gt;=0)    &#123;      if (nread&lt;=NSERIAL_CHAR-1)&#123;        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time      &#125;      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾    &#125;    nread++;  &#125;&#125;int Uart :: fputc(int ch, FILE *f)&#123;write(fid, &amp;ch, 1);return ch;&#125;void Uart :: Uart_Printf(char *format, ...)&#123;char String[256];va_list arg;va_start(arg, format);vsprintf(String, format, arg);va_end(arg);sendUart(String);&#125;void Uart :: closeUart()&#123;  //-------------------------------------------  //  CLOSE THE SERIAL PORT  //-------------------------------------------  close(fid);&#125;//end::uart部分**************************************************************************const char* windowname=&quot;win&quot;;int max_r=100;int min_r=60;int min_d=80;int t_hold=25;int param1=100;int param2=20;const int t_max=255;const int r_max=1000;const int d_max=100;const int p1_max=200;const int p2_max=200;int main()&#123;  VideoCapture capture(0);  Mat image;Mat matCanny;  Mat BinImg;  Mat matDst;  Uart u;  void on_Trackbar_1(int, void*);  void on_Trackbar_2(int, void*);  void on_Trackbar_3(int, void*);  void on_Trackbar_4(int, void*);  void on_Trackbar_5(int, void*);  void on_Trackbar_6(int, void*);  namedWindow(windowname,0);  setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);  resizeWindow(windowname, 400, 300);  moveWindow(windowname, 0, 0);  createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);  createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);  createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);  createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);  createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);  createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);while (capture.isOpened())&#123;capture &gt;&gt; image;if (image.empty())break;    cvtColor(image, matDst, COLOR_BGR2GRAY);threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV|THRESH_OTSU);    Canny(BinImg, matCanny, 100, 300, 3, false);//canny算子        std::vector&lt;Vec3f&gt; circles;HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);//在原图中画出圆心和圆  for (size_t i = 0; i &lt; circles.size(); i++) &#123;//提取出圆心坐标  Point center(round(circles[i][0]), round(circles[i][1]));//提取出圆半径  int radius = round(circles[i][2]);//圆心  circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);//圆  circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);&#125;    printf(&quot;x:%d\ny:%d\n&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));    u.Uart_Printf(&quot;#x%dy%d$&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));    imshow(&quot;matCanny&quot;, matCanny);    imshow(&quot;BinImg&quot;, BinImg);imshow(windowname, image);if (waitKey(1) == 27)break;&#125;  u.closeUart();  return 0;&#125;void on_Trackbar_1(int, void*)&#123;    ;&#125;void on_Trackbar_2(int, void*)&#123;    ;&#125;void on_Trackbar_3(int, void*)&#123;    ;&#125;void on_Trackbar_4(int, void*)&#123;    ;&#125;void on_Trackbar_5(int, void*)&#123;    ;&#125;void on_Trackbar_6(int, void*)&#123;    ;&#125;</code></pre><p>使用说明：</p><p>使用前打开串口权限；程序使用usb摄像头；要将uart.h包含到该文件（circle.cpp）同目录下；</p><p>该目录下打开终端输入：<br>进行编译产生可执行文件</p><pre><code>g++ circle.cpp -o circle `pkg-config --cflags --libs opencv4`</code></pre><p>该目录下打开终端输入：<br>即可运行</p><pre><code>./circle</code></pre><p>注：霍夫圆检测不太稳定，会显示core出错，重启即可，也可以在启动时调节各个参数使稳定</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131511658">https://blog.csdn.net/qq_32971095/article/details/131511658</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像识别小车（电源部分）——电赛学习笔记（1）</title>
      <link href="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="学习资料来源：B站唐老师讲电赛"><a href="#学习资料来源：B站唐老师讲电赛" class="headerlink" title="学习资料来源：B站唐老师讲电赛"></a><em><strong>学习资料来源：B站唐老师讲电赛</strong></em></h2><p><strong>目录</strong></p><p><a href="about:blank#%E4%B8%80.%E7%BA%BF%E6%80%A7%E7%94%B5%E6%BA%90%EF%BC%88%E7%BA%BF%E6%80%A7%E7%A8%B3%E5%8E%8B%E5%99%A8LDO%EF%BC%89%EF%BC%9AVin%E3%80%81Vout%EF%BC%9B%E5%8E%8B%E5%B7%AE%EF%BC%88Vin-V%E5%B7%AE%3EVout%E6%97%B6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0%E3%80%81Ci%E3%80%81Co%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9%EF%BC%8C%E9%99%8D%E5%99%AA%EF%BC%89">一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作）<br>、Ci、Co（输入输出滤波电容，降噪）</a></p><p><a href="about:blank#1.%E5%8F%82%E6%95%B0%EF%BC%9AVi%EF%BC%8CVo%EF%BC%88%E5%8F%AF%E8%B0%83%EF%BC%8C%E7%94%B5%E9%98%BB%E5%88%86%E5%8E%8B%EF%BC%89%EF%BC%8C%E5%8E%8B%E9%99%8D%EF%BC%8C%E8%BE%93%E5%87%BA%E7%94%B5%E6%B5%81Io%EF%BC%88max%EF%BC%89%EF%BC%8C%EF%BC%88%E5%99%AA%E5%A3%B0%EF%BC%8C%E9%9D%99%E6%80%81%E7%94%B5%E6%B5%81Iq%EF%BC%8C%E6%95%88%E7%8E%87%3DVo%2FVi%EF%BC%8C%E8%80%97%E6%95%A3%E5%8A%9F%E7%8E%87%3Dv%E5%B7%AE*Iload%EF%BC%89">1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*Iload）</a></p><p><a href="about:blank#2.PCB">        2.PCB</a></p><p><a href="about:blank#%C2%A0%E4%BA%8C.%E7%94%B5%E5%AE%B9%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E7%94%B5%E8%8D%B7%E6%B3%B5%EF%BC%89"><br>二.电容式开关电源（电荷泵）</a></p><p><a href="about:blank#1%C2%B7%E7%A8%B3%E5%8E%8B%E5%9E%8B%E7%94%B5%E8%8D%B7%E6%B3%B5%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%88%E9%A3%9E%E8%B7%A8%E7%94%B5%E5%AE%B9%EF%BC%8CS1%E3%80%81S3%2FS2%E3%80%81S4%E5%88%87%E6%8D%A2%E5%BC%80%E5%85%B3%EF%BC%8CC1%E5%85%85%E6%94%BE%E7%94%B5%EF%BC%89%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B4%9F%E5%8E%8B">1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）​编辑<br>负压</a></p><p><a href="about:blank#PCB%EF%BC%9A">PCB：</a></p><p><a href="about:blank#%E4%B8%89.%E7%94%B5%E6%84%9F%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E5%8F%82%E6%95%B0%EF%BC%9AVI%EF%BC%9BV0%EF%BC%9BIO%EF%BC%9B%E5%BC%80%E5%85%B3%E8%AF%84%E7%8E%87Fsw%EF%BC%9BEN%EF%BC%9BFB%EF%BC%89">三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</a></p><p><a href="about:blank#*%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B%EF%BC%9A">*设计实例：</a></p><p><a href="about:blank#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">解决方案：</a></p><hr><h2 id><a href="#" class="headerlink" title></a></h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d33cf8d47d4d2de8371c40cc43edf710.png"></p><h2 id="一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）"><a href="#一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）" class="headerlink" title="一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）"></a>一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）</h2><p>常用：LM1117</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7603ed872f9f27c253be1de796edc562.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/32f005e1cec50c5099ca1201cacda1cb.png"></p><p>（模电达林顿管）</p><h3 id="1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）"><a href="#1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）" class="headerlink" title="1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I load ）"></a>1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I <em>load</em> ）</h3><p>建立元件参数表</p><p>线性电源无法并联扩流</p><h4 id="2-PCB"><a href="#2-PCB" class="headerlink" title="2.PCB"></a>2.PCB</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/516abda141133974961903290093a41b.png"></p><p>PCB例子：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1e1e1ee1439d5fa0b8dc96cc70d84a13.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/d4a91d9caca72e80e2bb1c0717d16977.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb3f95733581716c40d244efdb00fbb5.png">散热面积大，VCC连GND先过C</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a094e2dea7328ad1cc700b48f97748b4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7b1902e953d9978de38505d24f1141f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6edd9ed81123ce89e76fcd672972982.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae73145b8a1e4c2a6707fbf38c1d0486.png"></p><h2 id="二-电容式开关电源（电荷泵）"><a href="#二-电容式开关电源（电荷泵）" class="headerlink" title="二.电容式开关电源（电荷泵）"></a>二.电容式开关电源（电荷泵）</h2><p>常用：HX4002（2.7~5.5-&gt;5）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c570bfe596d08bd80536caa7bc3996b7.png"></p><h3 id="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）"><a href="#1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）" class="headerlink" title="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）"></a>1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e956f406406b2a825f0b7d7c9b99a6.png"><br>负压</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/203446207be2fbe6c344b483e902a9e9.png"></p><p>半压（两跨容，串联充电，并联充电）、倍压反之</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3c11d9321a69b002cc2346187f8b3f9.png"></p><p>ESR（等效串联电阻）；为防电流过大，跨容选2倍手册推荐大小；</p><p>减小纹波：加大跨容&#x2F;减小ESR；ESR：MLCC&lt;钽&lt;固态&lt;高频低阻电解&lt;电解</p><h3 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a62028779584be27bedc9a881cf1b0af.png"></p><p>2.稳压型（加入稳压模块）</p><h2 id="三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"><a href="#三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）" class="headerlink" title="三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"></a>三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cccdb639def67c103b72fc6c89d6bfbe.png"></p><p>1.开关关充电，开L&#x2F;C双供电</p><p>二极管续流（肖特基&#x2F;快恢复，损耗：导通压*电流）<img src="https://i-blog.csdnimg.cn/blog_migrate/01519524c2764e4bb98ef2d0d4a94422.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2abc250f6c37683f7865759f76cd83e7.png"></p><p> 改成负压输出的改造（接地端与原输出端互换）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d21361e0b91acac3643071203b9c022.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df20a2e55b8792485d63db18ccf2a9e6.png"></p><p>  例：SY8120I稳压芯片结构<br><img src="https://i-blog.csdnimg.cn/blog_migrate/28a2114b9b75501ad4ca1dd053b2eddd.png"></p><p>FB接内部误差放大器反相输入端，正向端接0.6V参考，根据RH&#x2F;RL得Vo</p><h3 id="设计实例："><a href="#设计实例：" class="headerlink" title="*设计实例："></a>*设计实例：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/284bbac4e893f0274aa71c622f768211.png"></p><p> 注：内部电磁干扰问题（EMI），造成高频振铃信号</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/35d73073e335edcb4b1485cfe40bd770.png"></p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/580b343296343253de0d82c49beb967e.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/131397697">https://blog.csdn.net/qq_32971095/article/details/131397697</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS学习笔记（一）</title>
      <link href="/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong><strong>FreeRTOS学习笔记</strong></strong></p><p><strong><strong>第一天摘要：</strong></strong></p><p>Key：</p><p>移植方法，TCB的结构及创建,任务栈，列表和列表项定义及相关函数</p><p>实践：rtos移植执行led闪烁</p><p>注意点：keil下载device要正确；内存不够删去不需要的heap.c及其他内 核等多余文件（MemMang,RVDS）</p><p>代码风格：</p><p>FreeRTOS 中详细的数据类型重定义在 portmacro.h 这个头文件中实现，具体 如下</p><p>1.2.4.2 变量名 在 FreeRTOS 中，定义变量的时候往往会把变量的类型当作前缀加在变量上，<br>这样的好处是让用户一看到这个变量就知道该变量的类型。比如 char 型变量的 10 前缀是 c，short 型变量的前缀是 s，long 型变量的前缀是<br>l，portBASE_TYPE 类 型变量的前缀是 x。还有其他的数据类型，比如数据结构，任务句柄，队列句柄 等定义的变量名的前缀也是 x。<br>如果一个变量是无符号型的那么会有一个前缀 u，如果是一个指针变量则会 有一个前缀 p。因此，当我们定义一个无符号的 char 型变量的时候会加一个 uc<br>前缀，当定义一个 char 型的指针变量的时候会有一个 pc 前缀。 1.2.4.3 函数名<br>函数名包含了函数返回值的类型、函数所在的文件名和函数的功能，如果是 私有的函数则会加一个 prv（private）的前缀。特别的，在函数名中加入了函<br>数所在的文件名，这极大的帮助了用户提高寻找函数定义的效率和了解函数作用 的目的，具体的举例如下： ①vTaskPrioritySet()函数的返回值为<br>void 型，在 task.c 这个文件中定 义。 ②xQueueReceive()函数的返回值为 portBASE_TYPE 型，在 queue.c 这个<br>文件中定义。 ③vSemaphoreCreateBinary()函数的返回值为 void 型，在 semphr.h 这个 文件中定义。</p><p><strong><strong>移植：</strong></strong></p><p>FreeRTOSConfig.h 是直接从 demo 文件夹下面拷贝过来的，该头文件对裁 剪整个 FreeRTOS<br>所需的功能的宏均做了定义，有些宏定义被使能，有些宏定义 被失能，一开始我们只需要配置最简单的功能即可。要想随心所欲的配置 FreeRTOS<br>的功能，我们必须对这些宏定义的功能有所掌握，下面我们先简单的 介绍下这些宏定义的含义，然后再对这些宏定义进行修改。 注意：此<br>FreeRTOSConfig.h 文件内容与我们从 demo 移植过来的 FreeRTOSConfig.h 文件不一样，因为这是我们修改过的<br>FreeRTOSConfig.h 文 件，并不会影响 FreeRTOS 的功能，我们只是添加了一些中文注释，并且把相关<br>的头文件进行分类，方便查找宏定义以及阅读，仅此而已。强烈建议使用我们修 加工过的 FreeRTOSConfig.h 文件。若你在移植时直接使用我们工程中<br>FreeRTOSConfig.h 文件，编译会出现报错，因为里面 PendSV_Handler 和 SVC_Handler 函数重定义，需在<br>stm32f10x_it.c 文件中注释掉这两个函数方可， 后面会有讲解，此处先略过</p><p>还需要注意的是：中断优先级 0（具有最高的逻辑优先级）不能被 basepri<br>寄存器屏蔽，因此，configMAX_SYSCALL_INTERRUPT_PRIORITY 绝不可以设置成 0。</p><p>修改 stm32f10x_it.c 文件 SysTick 中断服务函数是一个非常重要的函数，FreeRTOS 所有跟时间相关的<br>事情都在里面处理，SysTick 就是 FreeRTOS 的一个心跳时钟，驱动着 FreeRTOS 的运行</p><p>FreeRTOS 帮 我们实现了 SysTick 的启动的配置：在 port.c 文件中已经实现<br>vPortSetupTimerInterrupt()函数，并且 FreeRTOS 通用的 SysTick 中断服务 函数也实现了：在 port.c<br>文件中已经实现 xPortSysTickHandler()函数，所以 移植的时候只需要我们在 stm32f10x_it.c<br>文件中实现我们对应（STM32）平台 上的 SysTick_Handler()函数即可</p><p><strong><strong>延时函数实现：</strong></strong></p><p>&#x2F;&#x2F;reload 为 24 位寄存器,最大 值:16777216,在 72M 下,约合 0.233s 左右</p><p>void delay_us(u32 nus) {</p><p>u32 ticks;</p><p> u32 told,tnow,tcnt&#x3D;0;</p><p>u32 reload&#x3D;SysTick-&gt;LOAD; &#x2F;&#x2F;LOAD 的值</p><p>ticks&#x3D;nus*fac_us; &#x2F;&#x2F;需要的节拍数</p><p>told&#x3D;SysTick-&gt;VAL; &#x2F;&#x2F;刚进入时的计数器值</p><p>while(1) {</p><p>tnow&#x3D;SysTick-&gt;VAL;</p><p>if(tnow!&#x3D;told) {</p><p>if(tnow&lt;told)tcnt+&#x3D;told-tnow; &#x2F;&#x2F;这里注意一下 SYSTICK 是一个递 减的计数器就可以了.</p><p>else tcnt+&#x3D;reload-tnow+told;</p><p>told&#x3D;tnow;</p><p>if(tcnt&gt;&#x3D;ticks)break; &#x2F;&#x2F;时间超过&#x2F;等于要延迟的时间,则 退出. } }; }</p><p>delay_us()是 us 级延时函数，delay_ms 和 delay_xms()都是 ms 级的延 时函数，delay_us()和<br>delay_xms()不会导致任务切换。delay_ms()其实就是对 FreeRTOS 中的延时函数 vTaskDelay()的简单封装，所以在使用<br>delay_ms()的 时候就会导致任务切换</p><p>任务栈其实就是一个预先定义好的全局数组，数据类型为 StackType_t，大小由 TASK1_STACK_SIZE 这个宏来定义，默认为 128，单位为<br>字，即 512 字节，这也是 FreeRTOS 推荐的最小的任务栈。在 FreeRTOS 中， 凡是涉及到数据类型的地方，FreeRTOS 都会将标准的 C<br>数据类型用 typedef 重新取一个类型名。这些经过重定义的数据类型放在 portmacro.h 这个头文件。</p><p>正如我们所说的那样，任务是一个独立的、无限循环且不能返回的函数</p><p><strong><strong>3.2.3 定义任务控制块</strong></strong><strong><strong>：</strong></strong></p><p>typedef struct tskTaskControlBlock {</p><p>volatile StackType_t <em>pxTopOfStack; &#x2F;</em> 栈顶 *&#x2F; (1)</p><p>ListItem_t xStateListItem; &#x2F;* 任务节点 *&#x2F; (2)</p><p>StackType_t <em>pxStack; &#x2F;</em> 任务栈起始地址 *&#x2F; (3)</p><p>&#x2F;* 任务名称，字符串形式 *&#x2F;(4)</p><p>char pcTaskName[ configMAX_TASK_NAME_LEN ];</p><p>} tskTCB; typedef</p><p><strong><strong>3.2.4 列表和列表项</strong></strong>  :</p><p>要想看懂 FreeRTOS 源码并学习其原理，有一个东西需要理解，那就是 FreeRTOS 的列表和列表项。列表和列表项是 FreeRTOS<br>的一个数据结构， FreeRTOS 大量使用到了列表和列表项，它是 FreeRTOS 的基石。要想深入学习 并理解<br>FreeRTOS，那么列表和列表项就必须首先掌握，否则后面根本就没法进 行</p><p>列表项就是存放在列表中的项目，FreeRTOS 提供了两种列表项：列表项和 迷你列表项。这两个都在文件 list.h 中有定义</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/18f990da82a5f9f6eb5a94ff344eb171.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/0de18e0f75c2b0b544e7ae7f4a1ed981.png"></p><p>3.2.4.2.1 列表初始化 新创建或者定义的列表需要对其做初始化处理，列表的初始化其实就是初始 化列表结构体 List_t<br>中的各个成员变量，列表的初始化通过函数 vListInitialise()来完成，此函数在 list.c 中有定义（<strong><strong>P58</strong></strong> ）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/76ca02bd0d186b50e841cd1a219d975d.png"></p><p>3.2.4.3.1 列表项插入函数 列表项的插入操作通过函数 vListInsert()来完成，函数原型如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be08fad541f38dea7f1d9a44896cd77f.png"></p><p>通过图可以看出，列表是一个环形的，即环形列表</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2048995ef80bb90a1f07f009b28c3884.png"></p><p>vListInsertEnd()插入列表的顺序问题（<strong><strong>P66</strong></strong> ）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/300cd190948f1391a19e5ae37f8638bd.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b7d15078dd210766f248d74c83c7ffd.png"></p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/130351060">https://blog.csdn.net/qq_32971095/article/details/130351060</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> c++ </tag>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫学习笔记</title>
      <link href="/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>注释给了一些要点</p><p>用requests库爬取时网页可能加载不完整，故用selenium库，加sleep延时使加载充分</p><p>主要利用re库，利用正则表达式提取html文件中的信息</p><p>threading是多线程运行，节省时间</p><p>如何使用？</p><pre><code>    配置selenium库，下载chomedriver，网上有教程    更改range函数的范围就可以对该范围内用户信息爬取</code></pre><p>存在问题：</p><pre><code>    太慢    不稳定，会漏用户，测试中            用正则表达式麻烦</code></pre><p>改进：</p><pre><code>    学习xpath、scrapy爬虫框架、线程池等from selenium import webdriverimport reimport timeimport threadingdef blbl_uid_get(uid):    url=&quot;https://space.bilibili.com/&quot;+str(uid)        # 不开网页显示    option = webdriver.ChromeOptions()    option.add_argument(&quot;headless&quot;)    # 使用selenium模块得到网页完整源码    driver=webdriver.Chrome(chrome_options=option)    driver.get(url)     respond=driver.page_source    time.sleep(8)    # 网页内容爬取测试    # with open(&quot;blbl.html&quot;,&quot;wb+&quot;) as f:    #     f.write(respond.encode())    up_name=re.findall(r&#39;&lt;span id=&quot;h-name&quot;&gt;\s*(.*?)\s*&lt;/span&gt;&#39;,respond,re.S)    up_fans=re.findall(r&#39;&lt;p id=&quot;n-fs&quot; class=&quot;n-data-v space-fans&quot;&gt;\s*(.*?)\s*&lt;/p&gt;&#39;,respond,re.S)    # 网页还是缺失了部分信息如下    # zan_num=re.findall(r&#39;视频、动态、专栏累计获赞([^&quot;]*)&#39;,respond,re.S)    # watch_num=re.findall(r&#39;截止昨天，播放数总计为([^&quot;]*)&#39;,respond,re.S)    # read_num=re.findall(r&#39;截止昨天，阅读数总计为([^&quot;]*)&#39;,respond,re.S)    if len(up_fans)!=0 and len(up_name)!=0:        # 摘取要寻找的信息        record=&quot;&quot;        record=up_name[0]+&quot; &quot;+up_fans[0]+&#39;\n&#39;# +&quot; &quot;+zan_num[0]+&quot; &quot;+watch_num[0]+&quot; &quot;+read_num[0]        # 写入文件        with open(&quot;up_fans.txt&quot;,&quot;a+&quot;) as f:            f.write(record)            f.close()    # 一定要quit    driver.quit()# 并发执行爬虫for i in range(348651384,348651400):    t = threading.Thread(target=blbl_uid_get, args=(i,))    t.start()</code></pre><p>结果：</p><p>70975784467_bili 0<br>chnksxf 0<br>深蓝色五角枫 8<br>-SWQ- 27<br>w773727 0<br>If-There-If 2<br>bili75588510448 0<br>u723510 1<br>o206413 0<br>10292619012_bili 1<br>丶帝丶弑 0<br>t252791 0<br>why13643485777 0<br>丁嘉丽12334 0<br>80204814302_bili 0<br>ddzn17ZXZ 1</p><p>结论：显然，-SWQ-在一定范围内粉丝最多</p><p>2023年3月20日21:40:43更新</p><p>学习了xpath语言，利用lxml库，可以代替re正则表达式</p><p>相比正则表达式，xpath更加简单简洁！</p><p>注意tree的两种创建方式的不同：本地文件和网络请求</p><p>使用xpath要注重标签之间的结构！找好属性即其值，尽量缩小范围，不然很容易多得！</p><pre><code>from selenium import webdriverimport timeimport threadingfrom lxml import etreedef blbl_uid_get(uid):    url=&quot;https://space.bilibili.com/&quot;+str(uid)        # 不开网页显示    option = webdriver.ChromeOptions()    option.add_argument(&quot;headless&quot;)    # 使用selenium模块得到网页完整源码    driver=webdriver.Chrome(chrome_options=option)    driver.get(url)     time.sleep(2)    respond=driver.page_source    with open(&quot;blbl_xpath.html&quot;,&quot;wb&quot;) as f:        f.write(respond.encode())    # 利用xpath提取内容(本地调用方式！)    # paser=etree.HTMLParser(encoding=&#39;utf-8&#39;)    # tree=etree.parse(&#39;blbl_xpath.html&#39;,parser=paser)    # 利用xpath提取内容(互联网中响应)    tree=etree.HTML(respond)    up_name=tree.xpath(&#39;//div[@class=&quot;h-basic&quot;]//span[@id=&quot;h-name&quot;]/text()&#39;)    fans_num=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-fs&quot;]/text()&#39;)[0].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)    # statistics=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-bf&quot;]/text()&#39;)    work_title=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//a[@class=&quot;title&quot;]/text()&#39;)    work_length=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;length&quot;]/text()&#39;)    work_play=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;play&quot;]/text()&#39;)    work_time=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;time&quot;]/text()&#39;)    min_num=min(len(work_time),len(work_length),len(work_title),len(work_play))    # 摘取要寻找的信息    record=&quot;&quot;    record=&quot;up昵称:&quot;+up_name[0]+&quot;\n&quot;+&quot;粉丝数:&quot;+fans_num+&#39;\n&#39;    if(min_num!=0):        record+=&#39;代表作:&#39;+&#39;\n&#39;        for i in range(0,min_num):            record+=&quot;作品名:&quot;+work_title[i]+&quot;\n&quot;+&quot;时长:&quot;+work_length[i]+&quot;\n&quot;+&quot;播放量:&quot;+work_play[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)+&quot;\n&quot;+&quot;发布时间:&quot;+work_time[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)    record+=&#39;\n\n&#39;    # 写入文件    with open(&quot;blbl_xpath_2.txt&quot;,&quot;w+&quot;,encoding=&#39;utf-8&#39;) as f:        f.write(record)        f.close()        # 一定要quit    driver.quit()# 并发执行爬虫for i in range(348651375,348651390):    t = threading.Thread(target=blbl_uid_get, args=(i,))    t.start()</code></pre><p>结果如下：</p><p>up昵称:68228791709_bili<br>粉丝数:0</p><p>up昵称:-SWQ-<br>粉丝数:27<br>代表作:<br>作品名:《刺客信条》6分49秒极限攀爬，同步率1000%<br>时长:04:18<br>播放量:164<br>发布时间:2022-3-20作品名:《消逝的光芒》对断桥、云端的向往以及信仰之跃<br>时长:09:35<br>播放量:419<br>发布时间:2022-2-1作品名:《生化危机2重制版》克莱尔打光弹药后手刃威廉G4<br>时长:12:14<br>播放量:310<br>发布时间:2022-2-1作品名:在西电中秋快乐的一天<br>时长:07:07<br>播放量:166<br>发布时间:2021-9-22作品名:4年菜鸡唯一一次五杀<br>时长:00:52<br>播放量:158<br>发布时间:2021-9-10作品名:沙雕室友们的日常<br>时长:00:21<br>播放量:51<br>发布时间:2020-8-22作品名:2020班级元旦晚会快来康康<br>时长:03:03<br>播放量:109<br>发布时间:2020-1-12作品名:社会我祥哥，同学冒死拍班主任<br>时长:00:13<br>播放量:114<br>发布时间:2019-8-19作品名:【建筑模型】建模锦标赛中华庭院模型展示<br>时长:02:39<br>播放量:2797<br>发布时间:2019-8-19</p><p>up昵称:p604904<br>粉丝数:0</p><p>up昵称:78992601564_bili<br>粉丝数:0</p><p>up昵称:10292619012_bili<br>粉丝数:1</p><p>up昵称:DMAP_<br>粉丝数:9<br>代表作:<br>作品名:拍拍猫猫<br>时长:02:03<br>播放量:89<br>发布时间:2022-11-29</p><p>up昵称:82212894921_bili<br>粉丝数:0</p><p>up昵称:bili75588510448<br>粉丝数:0</p><p>up昵称:丁嘉丽12334<br>粉丝数:0</p><p>up昵称:68228791709_bili<br>粉丝数:0</p><p>up昵称:80204814302_bili<br>粉丝数:0</p><p>up昵称:t229231<br>粉丝数:0</p><p>up昵称:chnksxf<br>粉丝数:0</p><p>up昵称:GH952105677<br>粉丝数:0</p><p>up昵称:52393731947_bili<br>粉丝数:0</p><p>up昵称:流口水的南方<br>粉丝数:0</p><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/129629331">https://blog.csdn.net/qq_32971095/article/details/129629331</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小学</title>
      <link href="/2022/09/14/%E5%B0%8F%E5%AD%A6/"/>
      <url>/2022/09/14/%E5%B0%8F%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="小学"><a href="#小学" class="headerlink" title="小学"></a><center>小学</center></h1><p>&emsp;转眼十年过去了，回想十年前，我是一个上三年级的小学生，生活在一个宁静的小镇，每天坐着电瓶车上学，在后座一遍遍地看着相同的田园风光。校园门口散乱地站着一些家长和小孩，门口有两个检查红领巾的，没带就不给进，胖胖的保安站在门沿上，一会又回屋坐一会，进来是广阔的大广场，介于新老教学楼之间，地面是白色的，而且很粗糙，让人感觉很踏实很舒服。学校里古朴的水泥圆形小花坛种着青松，针叶在花坛上铺了浅浅一层，我们就在上面扣洞打弹子，同样古朴的还有学校后面的幽深小花园，有着小窗，长板凳的教室，背面爬满爬山虎的教学楼。一下课我们就奔进小花园嬉戏，花园对面就是我上大小班的地方，小学和学前班连在一起，九年的记忆也都在这了。后来到了高年级去楼上上课，下课便懒得下楼，就靠在教室窗前或是走廊窗前望着远处的校园，或是在教室的桌上拍卡牌。放学了大家一直都排着两人一排的整齐队伍，一个班一个班地离校，我爸或是我妈站在约定的位置等我出来。后来学校还开拓了一部分地，建起了一座5楼还是7楼高的新楼，我只去过几次，一次是建好后去帮忙打扫，一次是去楼顶的大会议室看电影《疯狂的石头》，一次是去上科学了还玩了显微镜，全班只有我会调，一次是去搬书，瞥见了里面上课的人。学校的奠基碑是个神秘的东西，大家都以为是什么墓碑，穿着恐怖的传说。旁边就是计算机教室，上过几次但记不得玩的什么了。夹在计算机教室和老教学楼之间是少年宫，之前听人说校长在那，在那旁边玩得都少，没什么印象，只有以前在那里面学笛子记得一点东西。老教学楼靠后有个公共场所，记得在那门前我进行过几次秘密交易，让同学帮买充值卡然后就在那给我，然后回家充奥奇传说年费和生死狙击的点券。四年级还是五年级学校组织去芜湖方特游乐园玩了一次，仍然记得楼上高年级搞不到出去玩都在走廊一排趴着看的景象。六年级时有次运动会，我投实心球的每天都跟同桌去学前班前的场地上训练，训练到黄昏，太阳的金光洒满天空，满满变暗就回家。比赛那天我也是瞎投的，不过这次运动会，几个年纪的人都去了，走上我从来不知道的小路，到了另一个小学，看到了我不曾看到过的广阔校园，草皮操场…<br>&emsp;几个印象深刻的事情：三年级的一天，我们又在欺负小刘，然后没想什么，我把他课本撕了，然后被项老师逮到训了一顿。三年级的一天正在上课，据说一只大狼狗跑到了学校了，大家都紧张兮兮，关上了门，还有人把高高的窗户关上了，好像跑进来的是一只狮子，我也不禁开始幻想僵尸进入校园，于是封闭教室抗击，末日生存之类的，后来看到大狗从教室旁的走廊被牵走才恢复上课。五年级的一天我跟最好的朋友打架，大打出手，把桌子都干翻了，但只是扭抱地打，后来被班主任叫到办公室训了一顿，让我们下课在教室我们外面罚站一个星期。还是五年级，班主任让我评一个什么大奖，一个年级只有三个人左右，应该都是极品学兼优的了，评奖还花了整整一上午，站在大广场上面对国旗，校乐队还表演了一下，学校大领导颁了个什么奖，然后结束后，就有人叫无去玩跷跷板，那时一个木板架在分叉树上，两边的人来回踩，然后被人抓了，被吴老师狠批了一顿。<br>&emsp;后来记得高中毕业的暑假偶然的机会路过了小学，大广场上建了一个大礼堂，还有一个大屏幕挡住了视野，很浓的现代气息，校园显得有些臃肿，原本教学楼红色的瓷砖墙被扒了粉刷上了土黄色，有些惋惜。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业</title>
      <link href="/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<ul><li>问题描述：</li></ul><p>编写一个程序，可以在命令行输入参数，完成指定文件的缩放，并存储到新文件，命令行参数如下</p><p>zoom file1.bmp 200 file2.bmp</p><p>第一个参数为可执行程序名称，第二个参数为原始图像文件名，第三个参数为缩放比例（百分比），第四个参数为新文件名</p><ul><li>问题分析：</li></ul><ol><li>综述：</li></ol><p>要实现对bmp图像操作，首先要知道bmp图像的存储机理（图像信息如何以二进制信息存储）及文件包含的内容；其次知晓基本的图像缩放算法即可；最后要知晓如何读取和存储文件信息。</p><ol><li>实现时的困难：<br>1. 定义何种类型变量？<br>2. 文件大小如何读取、计算？<br>3. 像素信息如何读取、写入？</li><li>对应解决方案<br>1. 首先创建全局变量，如src_：原图宽高；dst_：缩放后宽高；各函数都可对其进行访问；其次用一个字符数组typedef unsigned char pixel[3];存储一个像素的RGB信息；对于缩放比例用double height_zoom_rate,width_zoom_rate;操作更精准，计算缩放后像素用类型转换即可，如：dst_width&#x3D;(int)(width_zoom_rate<em>src_width); 而在访问文件文件头和信息头时，定义unsigned char <em>buf&#x3D;NULL,<em>bui&#x3D;NULL;方便逐个字节访问，也可以处理小端对齐。<br>2. 即如何根据字节小端对齐计算文件大小；前面已经用buf、bui逐个访问文件头，信息头的每个字节数据，故如：b_size&#x3D;bui[23]<em>16</em>16</em>16</em>16</em>16<em>16+bui[22]<em>16</em>16</em>16*16+bui[21]<em>16</em>16+bui[20];</li></ol><p>可以读取图像大小；而：</p><p>f_size&#x3D;dst_width*dst_height+54;则可计算操作后的文件大小</p><ol><li><pre><code>1. 每个像素的RGB信息各占一个字节，用fgetc即可读取每个字节。读取完一行的像素后，通过计算填充字节个数（pad_num=(4-(src_width*3)%4)%4;），再用fgetc读掉填充字节，即可读取下一行。写入时采用三个字节为一组（即一个像素的RGB信息），结合最近邻插入法用fwrite写入fwrite(&amp;info[si*src_width+sj],sizeof(pixel),1,fp_n);</code></pre></li></ol><p>再用fputc（0，fp_n）写入填充字节数。</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&quot;bmp.h&quot;extern double height_zoom_rate,width_zoom_rate;int main(int argc, char* argv[]) &#123;//打开文件 FILE*fp=fopen(argv[1],&quot;rb&quot;),*fp_n = fopen(argv[3], &quot;wb&quot;);//读取文件头、信息头 read_bmp_head(fp);//读取像素信息 read_bmp_data(fp);//计算长宽缩放比例 width_zoom_rate=height_zoom_rate=(atoi(argv[2]) /100.0);//结合最近邻插入法写入缩放后的图像信息 write_data(fp_n);//展示操作好的图像信息 read_bmp_head(fp_n);//关闭两个图像文件 fclose(fp);fclose(fp_n);return 0;&#125;/*头文件使用说明：在主程序中：extern double height_zoom_rate,width_zoom_rate;并赋值方可正常运行包含三个函数：void read_bmp_head(FILE*fp)； void read_bmp_data(FILE*fp)；void write_data(FILE* fp_n)； */ #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//改对取模数为1个字节（默认为8，只可是2^n）#pragma pack(1)//存储一个像素信息的三元素字符数组 typedef unsigned char pixel[3];//文件头信息typedef struct tagBITMAPFILEHEADER&#123;unsigned short bfType; //保存图片类型。 &#39;BM&#39;(1-2字节) unsigned long bfSize;  //位图文件的大小，以字节为单位（3-6字节，低位在前）unsigned short bfReserved1;//位图文件保留字，必须为0(7-8字节）unsigned short bfReserved2;//位图文件保留字，必须为0(9-10字节）unsigned long bfOffBits;  //RGB数据偏移地址,位图数据的起始位置，以相对于位图（11-14字节，低位在前）&#125;BITMAP_FILE_HEADER;//信息头信息typedef struct tagBITMAPINFOHEADER&#123;unsigned long biSize;  //本结构所占用字节数（15-18字节）unsigned long  biWidth;  //位图的宽度，以像素为单位（19-22字节）unsigned long  biHeight;  //位图的高度，以像素为单位（23-26字节）unsigned short biPlanes;  //目标设备的级别，必须为1(27-28字节）unsigned short biBitCount;  //每个像素所需的位数，必须是1（双色）（29-30字节）,4(16色），8(256色）16(高彩色)或24（真彩色）之一unsigned long  biCompression;//位图压缩类型，必须是0（不压缩），（31-34字节）//1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之一unsigned long  biSizeImage;  //位图的大小(其中包含了为了补齐每行字节数是4的倍数而添加的空字节)，以字节为单位（35-38字节）unsigned long  biXPelsPerMeter;//位图水平分辨率，每米像素数（39-42字节）unsigned long  biYPelsPerMeter;//位图垂直分辨率，每米像素数（43-46字节)unsigned long  biClrUsed;  //位图实际使用的颜色表中的颜色数（47-50字节）unsigned long  biClrImportant; //位图显示过程中重要的颜色数（51-54字节）&#125;BITMAP_INFO_HEADER;//全局变量说明：src_：原图宽高；dst_：缩放后宽高；pad_num：每行补齐空字节数；//f_size: bfSize; b_size: biSizeImage; _zoom_rate: 宽高缩放倍数；sign：是否没计算过宽高标志 int sign1=1;int src_width,src_height,dst_width,dst_height;int pad_num,f_size,b_size;double height_zoom_rate,width_zoom_rate;unsigned char *buf=NULL,*bui=NULL;//创建两个结构体存储文件头和信息头信息 BITMAP_FILE_HEADER file_head;BITMAP_INFO_HEADER info_head;//info指向像素信息的头地址，以info[i](=*(info+i))访问第i个像素 pixel *info=NULL;//读取文件头和信息头的信息 void read_bmp_head(FILE*fp)&#123;if ( fp == NULL ) &#123;printf(&quot;file doesn&#39;t exist!\n&quot;);exit(0);&#125;rewind(fp); //读取信息 fread(&amp;file_head, sizeof(BITMAP_FILE_HEADER), 1, fp);fread(&amp;info_head, sizeof(BITMAP_INFO_HEADER), 1, fp);//因为信息是小端对齐，以字节为单位方便读取 buf=(unsigned char*)&amp;file_head;printf(&quot;\nbfType:\t\t%c %c&quot;,buf[1],buf[0]);f_size=buf[5]*16*16*16*16*16*16+buf[4]*16*16*16*16+buf[3]*16*16+buf[2];printf(&quot;\nbfSize:\t\t%02x %02x %02x %02x   ----   %d&quot;,buf[5],buf[4],buf[3],buf[2],f_size);printf(&quot;\nbfReserved1:\t%02x %02x\nbfReserved2:\t%02x %02x&quot;,buf[7],buf[6],buf[9],buf[8]);printf(&quot;\nbf0ffbits:\t%02x %02x %02x %02x&quot;,buf[13],buf[12],buf[11],buf[10]); printf(&quot;\n\n&quot;); bui=(unsigned char*)&amp;info_head;printf(&quot;\nbiSize:\t\t%02x %02x %02x %02x&quot;,bui[3],bui[2],bui[1],bui[0]);src_width=bui[7]*16*16*16*16*16*16+bui[6]*16*16*16*16+bui[5]*16*16+bui[4];src_height=bui[11]*16*16*16*16*16*16+bui[10]*16*16*16*16+bui[9]*16*16+bui[8];printf(&quot;\nbiWidth:\t%02x %02x %02x %02x   ----   %d&quot;,bui[7],bui[6],bui[5],bui[4],src_width);printf(&quot;\nbiHeight:\t%02x %02x %02x %02x   ----   %d&quot;,bui[11],bui[10],bui[9],bui[8],src_height);printf(&quot;\nbiPlans:\t%02x %02x&quot;,bui[13],bui[12]);printf(&quot;\nbiBitCount:\t%02x %02x&quot;,bui[15],bui[14]);printf(&quot;\nbiCompression:\t%02x %02x %02x %02x&quot;,bui[19],bui[18],bui[17],bui[16]);b_size=bui[23]*16*16*16*16*16*16+bui[22]*16*16*16*16+bui[21]*16*16+bui[20];printf(&quot;\nbiSizeImage:\t%02x %02x %02x %02x   ----   %d&quot;,bui[23],bui[22],bui[21],bui[20],b_size);printf(&quot;\nbiXPelsPerMeter:%02x %02x %02x %02x&quot;,bui[27],bui[26],bui[25],bui[24]);printf(&quot;\nbiYPelsPerMeter:%02x %02x %02x %02x&quot;,bui[31],bui[30],bui[29],bui[28]);printf(&quot;\nbiClrUsed:\t%02x %02x %02x %02x&quot;,bui[35],bui[34],bui[33],bui[32]);printf(&quot;\nbiClrImportant:\t%02x %02x %02x %02x\n&quot;,bui[39],bui[38],bui[37],bui[36]);sign1=0; &#125;//将照片像素信息读取，通过全局变量info访问 void read_bmp_data(FILE*fp)&#123;void read_bmp_head(FILE*fp);if ( fp == NULL ) &#123;printf(&quot;file doesn&#39;t exist!\n&quot;);exit(0);&#125;//判断是否计算好了图像的长宽，没有则执行 if(sign1)&#123;rewind(fp);read_bmp_head(fp);&#125;int i,j,k;//填充字节数 pad_num=(4-(src_width*3)%4)%4;//开辟空间 info=(pixel*)malloc(src_width*src_height*sizeof(pixel));//读取像素信息RGB for(i=0;i&lt;src_height;i++)&#123;for(j=0;j&lt;src_width;j++)&#123;info[i*src_width+j][0]=fgetc(fp);info[i*src_width+j][1]=fgetc(fp);info[i*src_width+j][2]=fgetc(fp);&#125;//读掉填充字节 for(k=0;k&lt;pad_num;k++)fgetc(fp);&#125;&#125;//将信息写入新文件 void write_data(FILE* fp_n) &#123;rewind(fp_n);dst_width=(int)(width_zoom_rate*src_width);dst_height=(int)(height_zoom_rate*src_height);//文件头信息修改、拷贝（小对齐，故用&amp;、&gt;&gt;位操作） int f_size=dst_width*dst_height+54,i,j,k;buf[2]=0x000000FF&amp;f_size;buf[3]=(0x0000FF00&amp;f_size)&gt;&gt;8;buf[4]=(0x00FF0000&amp;f_size)&gt;&gt;16;buf[5]=(0xFF000000&amp;f_size)&gt;&gt;24;for(i=0;i&lt;14;i++)fputc(buf[i],fp_n);//信息头信息修改、拷贝 bui[4]=0x000000FF&amp;dst_width;bui[5]=(0x0000FF00&amp;dst_width)&gt;&gt;8;bui[6]=(0x00FF0000&amp;dst_width)&gt;&gt;16;bui[7]=(0xFF000000&amp;dst_width)&gt;&gt;24;bui[8]=0x000000FF&amp;dst_height;bui[9]=(0x0000FF00&amp;dst_height)&gt;&gt;8;bui[10]=(0x00FF0000&amp;dst_height)&gt;&gt;16;bui[11]=(0xFF000000&amp;dst_height)&gt;&gt;24;pad_num= (4-(dst_width*3)%4)%4;b_size=dst_height*(dst_width+pad_num)*3;bui[20]=0x000000FF&amp;b_size;bui[21]=(0x0000FF00&amp;b_size)&gt;&gt;8;bui[22]=(0x00FF0000&amp;b_size)&gt;&gt;16;bui[23]=(0xFF000000&amp;b_size)&gt;&gt;24; for(i=0;i&lt;40;i++)fputc(bui[i],fp_n);int si,sj;//像素信息写入 for(i=0;i&lt;dst_height;i++)&#123;si=i/height_zoom_rate;for(j=0;j&lt;dst_width;j++)&#123;//最近邻插入法 sj=j/width_zoom_rate;fwrite(&amp;info[si*src_width+sj],sizeof(pixel),1,fp_n);&#125;for(k=0;k&lt;pad_num;k++)fputc(0,fp_n);&#125;/*//不行的写法！低效且数值越界 for(i=0;i&lt;dst_height;i++)&#123;for(j=0;j&lt;dst_width;j++)&#123;//最近邻插入法 fwrite(&amp;info[(int)(i*src_width/height_zoom_rate+j/width_zoom_rate)],sizeof(pixel),1,fp_n);&#125;for(k=0;k&lt;pad_num;k++)fputc(0,fp_n);&#125;*/&#125;</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/124532108">https://blog.csdn.net/qq_32971095/article/details/124532108</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单文件数据库-模拟图书馆管理系统-西安电子科技大学大一程序基础设计课程设计作业</title>
      <link href="/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>命令行参数如下：</p><p>Libsim –a(-u) xxxx</p><p>第一个参数为可执行程序名称；第二个参数为用户身份，-a表示管理员，-u表示读者；第三个参数为用户名</p><ul><li>问题分析：</li></ul><p>由于无法直接在文件中插入数据（不是简单覆盖），固采用将文件数据提取为链表的方法，对链表进行操作，最后将链表信息导入文件中。</p><ol><li>实现时的困难：<br>1. 如何实现管理员和读者双菜单？<br>2. 文件该以哪种方式打开？<br>3. 文件信息读取不全是什么造成的？<br>4. 操作后再读取文件出错，打开文件信息连在一起？<br>5. 删除最后一个数据时出错？<br>6. 如果用户输入的操作都无效（要修改的信息不存在）怎么办？</li><li>对应解决方案<br>1. 判断命令行参数信息，用if判断语句分别进入功能即可。<br>2. 操作者只需选择“r（只读）”和“a+（追加）”方式打开文件，防止文件数据意外损失。其中在只有管理员增加数据时才用“a+”，其他模式均以“r”方式打开！<br>3. 因为程序有继续操作选项，而上次操作后文件标志已经为EOF，采用rewind函数即可将文件标志位重置<br>4. 在写入、修改、删除信息时注意最后写入换行符，保证文件可读性以及下一次操作可行<br>5. 因为采用的是链表操作，删除非末尾元素时，下一个链节内容完全拷贝到要删字节，再释放下一个链节即可。但是链表尾指向NULL，访问NULL会出错，要单独考虑。<br>6. 定义变量int sign &#x3D; 0；只有操作有效时sign &#x3D; 1，进入下一步操作，防止文件信息丢失。</li></ol><pre><code>//程序基本配置文件：1.文件名为“book.txt”的文件；2.文件名为“reader.txt”的文件 #define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//测试方式选择：1.AUTO：命令行运行；2.标准文件流读入数据；3.手动输入输出数据（用哪个将另外两个#define注释掉即可） //#define AUTO//#define MANUAL1#define MANUAL2#define LEN1 sizeof(book_info)#define LEN2 sizeof(reader_info)//定义两个结构体，分别存储书本信息和读者借阅信息 typedef struct Book &#123;char code[20];char title[100];int number;struct Book* next;&#125;book_info;typedef struct Reader &#123;char order[20];char name[100];char borrow_code[20];struct Reader* next;&#125;reader_info;const char* book_format = &quot;%s %s %d&quot;, * reader_format = &quot;%s %s %s&quot;;char file_name[101] = &#123; 0 &#125;;int main(int argc, char* argv[]) &#123;void format_judge(char* type, char* name);FILE* open_file();void function(char* type, char* name);char type[3], name[100];#ifdef AUTOstrcpy(type, argv[1]);strcpy(name, argv[2]);#endif#ifdef MANUAL1freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif #ifdef MANUAL2printf(&quot;Enter user&#39;s type(-a/-u) and username:\n&quot;);scanf(&quot;%s %s&quot;, type, name);#endif //输入参数格式正误判断 format_judge(type, name);//操作函数 function(type, name);return 0;&#125;//打开文件函数 FILE* open_file() &#123;FILE* fp;char  ope_way[3] = &#123; 0 &#125;;//输入文件名和打开方式 printf(&quot;Enter the path of data:&quot;);scanf(&quot;%s&quot;, file_name);//*****注意操作者只需选择“r（只读）”和“a+（追加）”方式打开文件，防止文件数据意外损失！！！ printf(&quot;Enter the way to operate(r/a+):&quot;);scanf(&quot;%s&quot;, ope_way);//如果文件不存在，报错 if ((fp = fopen(file_name, ope_way)) == NULL) &#123;printf(&quot;File not exist\n&quot;);exit(0);&#125;return fp;&#125;//显示文件的所有信息 void show_file(FILE* fp) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;//文件位置标志重置，以输出完整程序 rewind(fp);char c;//当文件位置为EOF(文件尾) while (!feof(fp)) &#123;c = fgetc(fp);printf(&quot;%c&quot;, c);&#125;printf(&quot;\n&quot;);&#125;//命令行输入参数判断 void format_judge(char* type, char* name) &#123;if (type[0] != &#39;-&#39; || (type[1] != &#39;a&#39; &amp;&amp; type[1] != &#39;u&#39;)) &#123;printf(&quot;Format Error!\n&quot;);exit(0);&#125;&#125;//覆盖文件函数，用于一次操作结束后将新文件内的数据覆盖到老文件上 //参数列表：指向原文件指针，指向操作产生的新文件的指针 void revise_file(FILE* fp, FILE* fp_n) &#123;if (fp_n == NULL) &#123;printf(&quot;New file failed to open\n&quot;);return;&#125;char c;fclose(fp);//以“w”方式打开文件，文件原内容擦除 fopen(file_name, &quot;w&quot;);rewind(fp_n);//一个字符一个字符地拷贝到原文件中 while ((c = fgetc(fp_n)) != EOF) &#123;fputc(c, fp);&#125;fclose(fp);&#125;//功能集成函数//参数列表：用户类型（-a：管理员/-u：用户）；用户名 void function(char* type, char* name) &#123;FILE* open_file();void add_info(FILE * fp, int object);void revise_info(FILE * fp, int object);void delete_info(FILE * fp, int object);void borrow_book(FILE * fp, FILE * fp_r);void return_book(FILE * fp_r);void search_info(FILE * fp, FILE * fp_r);//定义变量：1.option：操作类型；2.object：操作对象；3.sign：判断是否继续操作标志；4.fp：打开文件指针；5.fp_r:读者信息文件指针 int option, object, sign = 1;FILE* fp = NULL, * fp_r = NULL;//管理员模式 if (type[1] == &#39;a&#39;) &#123;printf(&quot;Administrator, what do you want to do\n\t1.Add information\n\t2.Revise information\n\t3.Delete information\n\t4.Show all the information\nOperate object:\n\t1.book\n\t2.reader\nAnswer:&quot;);while (sign) &#123;scanf(&quot;%d%d&quot;, &amp;option, &amp;object);//进入功能选择，详细见后面各功能函数 switch (option) &#123;case 1: //增加数据 &#123;fp = open_file();add_info(fp, object);break;&#125;case 2: //修改数据 &#123;fp = open_file();revise_info(fp, object);break;&#125;case 3: //删除数据 &#123;fp = open_file();delete_info(fp, object);break;&#125;case 4: //总览数据 &#123;if (object == 1) &#123;fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);show_file(fp);&#125;else &#123;fp_r = fopen(&quot;reader.txt&quot;, &quot;r&quot;);show_file(fp_r);&#125;break;&#125;default:printf(&quot;Option Error\n&quot;);&#125;//是否继续进行操作 printf(&quot;Continue to operate\n\t1-&gt;yes\n\t0-&gt;no\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;sign);&#125;fclose(fp);fclose(fp_r);&#125;//用户模式 else &#123;printf(&quot;User, what do you want to do\n\t1.Borrow books\n\t2.Return books\n\t3.Search information\nAnswer:&quot;);while (sign) &#123;scanf(&quot;%d&quot;, &amp;option);switch (option) &#123;case 1: //借书 &#123;fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);fp_r = fopen(&quot;reader.txt&quot;, &quot;a+&quot;);if (fp == NULL || fp_r == NULL) &#123;printf(&quot;File missing\n&quot;);&#125;else borrow_book(fp, fp_r);break;&#125;case 2: //还书 &#123;fp_r = fopen(&quot;reader.txt&quot;, &quot;r+&quot;);strcpy(file_name, &quot;reader.txt\0&quot;);if (fp_r == NULL) &#123;printf(&quot;File missing\n&quot;);&#125;else return_book(fp_r);break;&#125;case 3: //查数据 &#123;fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);fp_r = fopen(&quot;reader.txt&quot;, &quot;r&quot;);if (fp == NULL || fp_r == NULL) &#123;printf(&quot;File missing\n&quot;);&#125;else search_info(fp, fp_r);break;&#125;default:printf(&quot;Option Error\n&quot;);&#125;printf(&quot;Continue to operate\n\t1-&gt;yes\n\t0-&gt;no\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;sign);&#125;fclose(fp);&#125;&#125;//添加数据函数//参数列表：指向操作文件的指针；操作对象 void add_info(FILE* fp, int object) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;//定义变量：1.num：操作次数；2.book：添加的图书信息的结构体；3.reader：添加的借阅信息结构体 int num;book_info book;reader_info reader;//添加图书信息 if (object == 1) &#123;printf(&quot;How many books you want to add\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);//提示输入图书信息的格式 printf(&quot;Information format:book_number title amount\nEnter:\n&quot;);while (num--) &#123;scanf(book_format, &amp;book.code, &amp;book.title, &amp;book.number);fprintf(fp, book_format, book.code, book.title, book.number);//*****注意添加完后换行！ fprintf(fp, &quot;\n&quot;);&#125;printf(&quot;Succeed to operate\n&quot;);&#125;//添加借阅者信息 else if (object == 2) &#123;printf(&quot;How many readers you want to add\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);printf(&quot;Information format:reader_number name book_code\nEnter:\n&quot;);while (num--) &#123;scanf(reader_format, &amp;reader.order, &amp;reader.name, &amp;reader.borrow_code);fprintf(fp, reader_format, reader.order, reader.name, reader.borrow_code);fprintf(fp, &quot;\n&quot;);&#125;printf(&quot;Succeed to operate\n&quot;);&#125;else printf(&quot;Object error\n&quot;);&#125;//修改数据函数//参数列表：指向操作文件的指针；操作对象 void revise_info(FILE* fp, int object) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;rewind(fp);book_info* original_information_input_b(FILE * fp);reader_info* original_information_input_r(FILE * fp);void information_save_b(book_info * head, FILE * fp_n);void information_save_r(reader_info * head, FILE * fp_n);book_info* get_adress_b(book_info * head_adress, char* search);reader_info* get_adress_r(reader_info * head_adress, char* search);void revise_file(FILE * fp, FILE * fp_n);//定义变量：1.num:操作数；2.sign：操作是否有效标志；3.search：搜素信息（图书号或书名或读者编号或人名）；4.fp_n:指向新文件（存贮操作后的信息）的指针 int num, sign = 0;char search[100] = &#123; 0 &#125;;FILE* fp_n = NULL;//修改图书信息 if (object == 1) &#123;//定义变量：1.head：存储了图书信息的链表头；2. book：存贮修改信息的结构体；3.locat：指向修改数据所在链节的指针  book_info* head = original_information_input_b(fp), book, * locat;printf(&quot;How many books you want to revise\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Enter book_code or title:&quot;);//输入要找的图书号或书名 scanf(&quot;%s&quot;, search);//得到所在链表的位置，如果不存在，locat=NULL，不进行下列操作 locat = get_adress_b(head, search);if (locat != NULL) &#123;printf(&quot;Enter the new information(Format:book_number title amount):&quot;);//输入要用于替换的数据 scanf(book_format, &amp;book.code, &amp;book.title, &amp;book.number);strcpy(locat-&gt;code, book.code);strcpy(locat-&gt;title, book.title);locat-&gt;number = book.number;//操作有效 sign = 1;&#125;&#125;//如果输入的书本都不存在，即操作无效，不进行下列操作，防止书本信息文件内容被清空（revise_file函数有以“w”方式打开文件，文件内容清空） if (sign) &#123;//打开存储修改信息的新文件“book_n.txt” fp_n = fopen(&quot;book_n.txt&quot;, &quot;w+&quot;);//将链表信息存入新文件 information_save_b(head, fp_n);//拷贝新文件中信息到原文件 revise_file(fp, fp_n);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;if (object == 2) &#123;reader_info* head = original_information_input_r(fp), reader, * locat = head;//确认是否修改找到信息（针对一个人借多本书的情况） int answer;printf(&quot;How many readers you want to revise\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Enter reader_order or name\n:&quot;);scanf(&quot;%s&quot;, search);while (locat != NULL) &#123;//*****得到该读者的第一条信息(注意搜索起点是locat，结合while循环实现搜索所有而非第一个出现的)！ locat = get_adress_r(locat, reader.order);if (locat != NULL) &#123;//输出该条信息的内容 printf(reader_format, locat-&gt;order, locat-&gt;name, locat-&gt;borrow_code);printf(&quot;\nRevise or not\n\t1.yes\n\t2.no\nAnswer:&quot;);//确认是否修改该条信息 scanf(&quot;%d&quot;, &amp;answer);if (answer == 1) &#123;printf(&quot;Enter the new information(Format:reader_order name borrow_code):\n&quot;);scanf(reader_format, &amp;reader.order, &amp;reader.name, &amp;reader.borrow_code);strcpy(locat-&gt;order, reader.order);strcpy(locat-&gt;name, reader.name);strcpy(locat-&gt;borrow_code, reader.borrow_code);sign = 1;&#125;//标记为指向下一个 locat = locat-&gt;next;&#125;&#125;&#125;if (sign == 1) &#123;fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);information_save_r(head, fp_n);revise_file(fp, fp_n);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;&#125;//删除数据函数//参数列表：指向操作文件的指针；操作对象 void delete_info(FILE* fp, int object) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;rewind(fp);book_info* original_information_input_b(FILE * fp);reader_info* original_information_input_r(FILE * fp);book_info* get_adress_b(book_info * head_adress, char* search);reader_info* get_adress_r(reader_info * head_adress, char* search);void information_save_b(book_info * head, FILE * fp_n);void information_save_r(reader_info * head, FILE * fp_n);void revise_file(FILE * fp, FILE * fp_n);int num, answer, sign = 0;char search[100];if (object == 1) &#123;//定义变量：3.free_adress：指向要删除数据链节的指针 book_info* head = original_information_input_b(fp), * locat = NULL, * free_adress = NULL;printf(&quot;How many books you want to delete\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Search book_code or title to delete:&quot;);scanf(&quot;%s&quot;, search);locat = get_adress_b(head, search);//删除链节的方式采用复制——释放法，即将下一个链节内容完全拷贝到要删字节，再释放下一个链节 if (locat != NULL) &#123;//不是链表尾的情况 if (locat-&gt;next != NULL) &#123;free_adress = locat-&gt;next;*locat = *(locat-&gt;next);free(free_adress);&#125;//*****链表尾的情况！（locat-&gt;next=NULL！访问会出错！） else &#123;book_info* taget = head;//找到要删链节的上一个链节 for (; taget-&gt;next != locat; taget = taget-&gt;next);//将上一个链节的指向该为NULL，即可去除原先链表尾 taget-&gt;next = NULL;free(locat);&#125;sign = 1;&#125;&#125;if (sign) &#123;FILE* fp_n = fopen(&quot;book_n.txt&quot;, &quot;w+&quot;);information_save_b(head, fp_n);revise_file(fp, fp_n);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;//删除读者信息，基本和修改读者信息部分相同 if (object == 2) &#123;reader_info* head = original_information_input_r(fp), * locat = head, * free_adress = NULL;printf(&quot;How many readers you want to delete\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Search reader_order or name to delete:&quot;);scanf(&quot;%s&quot;, search);while (locat != NULL) &#123;locat = get_adress_r(locat, search);if (locat != NULL) &#123;printf(&quot;This person&#39;s one record:&quot;);printf(reader_format, locat-&gt;order, locat-&gt;name, locat-&gt;borrow_code);printf(&quot;\nDelelt this record or not?\n\t1.yes\n\t2.no\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;answer);if (answer == 1) &#123;if (locat-&gt;next != NULL) &#123;free_adress = locat-&gt;next;*locat = *(locat-&gt;next);free(free_adress);&#125;else &#123;reader_info* taget = head;for (; taget-&gt;next != locat; taget = taget-&gt;next);taget-&gt;next = NULL;free(locat);&#125;sign = 1;&#125;locat = locat-&gt;next;&#125;&#125;&#125;if (sign) &#123;FILE* fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);information_save_r(head, fp_n);revise_file(fp, fp_n);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;&#125;//借书函数 //参数列表：指向图书信息文件的指针；指向读者信息文件的指针 void borrow_book(FILE* fp, FILE* fp_r) &#123;if (fp == NULL || fp_r == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;rewind(fp);book_info* original_information_input_b(FILE * fp);book_info* get_adress_b(book_info * head_adress, char* search);int num, answer;char search[100];book_info* head = original_information_input_b(fp), * locat;//询问是否列出馆藏图书列表 printf(&quot;Show book list\n\t1.yes\n\t2.no\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;answer);if (answer == 1)show_file(fp);printf(&quot;How many books you want to borrow\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Search book_code or title to borrow:&quot;);scanf(&quot;%s&quot;, search);locat = get_adress_b(head, search);if (locat != NULL) &#123;char order[20], name[100];printf(&quot;Enter your personal_order and your name:&quot;);scanf(&quot;%s%s&quot;, order, name);//将借阅信息存储到读者信息文件 fprintf(fp_r, reader_format, order, name, locat-&gt;code);fprintf(fp_r, &quot;\n&quot;);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;&#125;//还书函数//参数列表：指向读者信息文件的指针 void return_book(FILE* fp) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return;&#125;rewind(fp);reader_info* original_information_input_r(FILE * fp);reader_info* get_adress_r(reader_info * head_adress, char* search);void information_save_r(reader_info * head, FILE * fp_n);int num, sign = 0;reader_info reader, * head = original_information_input_r(fp), * locat = head;printf(&quot;How many books you want to return\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Enter your person_order name and book_code:&quot;);scanf(reader_format, reader.order, reader.name, reader.borrow_code);//*****同时判断读者编号和姓名是否符合,直到链表尾 (注意下一次搜寻的起始地址为locat-&gt;next！)for (; locat != NULL &amp;&amp; strcmp(locat-&gt;order, reader.order) != 0; locat = get_adress_r(locat-&gt;next, reader.name));if (locat != NULL) &#123;if (locat-&gt;next != NULL) &#123;reader_info* free_adress = locat-&gt;next;*locat = *(locat-&gt;next);free(free_adress);&#125;else &#123;reader_info* taget = head;for (; taget-&gt;next != locat; taget = taget-&gt;next);taget-&gt;next = NULL;free(locat);&#125;sign = 1;&#125;else printf(&quot;Record doesn&#39;t exist\n&quot;);&#125;if (sign) &#123;FILE* fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);information_save_r(head, fp_n);revise_file(fp, fp_n);printf(&quot;Succeed to operate\n&quot;);&#125;&#125;//查数据函数//参数列表：指向图书信息文件的指针；指向读者信息文件的指针 void search_info(FILE* fp, FILE* fp_r) &#123;book_info* original_information_input_b(FILE * fp);reader_info* original_information_input_r(FILE * fp);book_info* get_adress_b(book_info * head_adress, char* search);reader_info* get_adress_r(reader_info * head_adress, char* search);int answer, num, i = 1;char search[100];printf(&quot;Want to know what\n\t1.Show all books\n\t2.Search one book\n\t3.Remain to return\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;answer);//展示所有馆藏图书 if (answer == 1) show_file(fp);//输入图书号或书名看有没有 else if (answer == 2) &#123;book_info* head = original_information_input_b(fp);printf(&quot;How many books you want to search\nAnswer:&quot;);scanf(&quot;%d&quot;, &amp;num);while (num--) &#123;printf(&quot;Search book_code or title to show:&quot;);scanf(&quot;%s&quot;, search);book_info* locat = get_adress_b(head, search);if (locat != NULL) &#123;printf(book_format, locat-&gt;code, locat-&gt;title, locat-&gt;number);printf(&quot;\n&quot;);reader_info* head_r = original_information_input_r(fp_r), * locat_r = head_r;printf(&quot;Borrow record:\n&quot;);for (i = 1; locat_r != NULL; locat_r = locat_r-&gt;next, i++) &#123;if (strcmp(locat-&gt;code, locat_r-&gt;borrow_code) == 0)printf(&quot;%d : %s %s\n&quot;, i, locat_r-&gt;order, locat_r-&gt;name);&#125;&#125;&#125;&#125;//输入个人信息查找待还图书 else if (answer == 3) &#123;reader_info reader, * head = original_information_input_r(fp_r), * locat = head;printf(&quot;Enter your personal_order and name:&quot;);scanf(&quot;%s%s&quot;, reader.order, reader.name);while (locat != NULL) &#123;for (; locat != NULL &amp;&amp; strcmp(locat-&gt;name, reader.name) != 0 &amp;&amp; strcmp(locat-&gt;order, reader.order) != 0; locat = get_adress_r(locat-&gt;next, reader.order));if (locat == NULL)break;else &#123;printf(&quot;Borrowed book %d:&quot;, i++);printf(&quot;%s&quot;, locat-&gt;borrow_code);printf(&quot;\n&quot;);locat = locat-&gt;next;&#125;&#125;&#125;&#125;//创建链表函数，将图书信息文件提取成链表//参数列表：指向图书信息文件指针；返回值：链表链头 book_info* original_information_input_b(FILE* fp) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return NULL;&#125;//定义变量：1.head：链表头；2.当前链表操作位置指针；3.暂存数据的结构体 book_info* head = NULL, * p = NULL, temp;int i = 0;//从文件中读取信息直道文件尾 while (fscanf(fp, book_format, &amp;temp.code, &amp;temp.title, &amp;temp.number) != EOF) &#123;i++;//如果是链表头，开辟空间地址即为head，不是表头则依照赋值表达式的右结合性将链表进行延伸 if (i == 1)head = p = (book_info*)malloc(LEN1);else p = p-&gt;next = (book_info*)malloc(LEN1);strcpy(p-&gt;code, temp.code);strcpy(p-&gt;title, temp.title);p-&gt;number = temp.number;&#125;//链表尾部处理 if (i != 0)p-&gt;next = NULL;return head;&#125;//创建链表函数，将读者信息文件提取成链表//参数列表：指向读者信息文件指针 返回值：链表链头reader_info* original_information_input_r(FILE* fp) &#123;if (fp == NULL) &#123;printf(&quot;File failed to open\n&quot;);return NULL;&#125;reader_info* head = NULL, * p = NULL, temp;int i = 0;while (fscanf(fp, reader_format, &amp;temp.order, &amp;temp.name, &amp;temp.borrow_code) != EOF) &#123;i++;if (i == 1)head = p = (reader_info*)malloc(LEN2);else p = p-&gt;next = (reader_info*)malloc(LEN2);strcpy(p-&gt;order, temp.order);strcpy(p-&gt;name, temp.name);strcpy(p-&gt;borrow_code, temp.borrow_code);&#125;if (i != 0)p-&gt;next = NULL;return head;&#125;//保存链表信息函数，将图书信息链表保存到新文件中 //参数列表：指向图书信息新文件指针 void information_save_b(book_info* head, FILE* fp_n) &#123;book_info* p = head;for (; p != NULL; p = p-&gt;next) &#123;fprintf(fp_n, book_format, p-&gt;code, p-&gt;title, p-&gt;number);fprintf(fp_n, &quot;\n&quot;);&#125;&#125;//保存链表信息函数，将读者信息链表保存到新文件中 //参数列表：指向读者信息新文件指针 void information_save_r(reader_info* head, FILE* fp_n) &#123;reader_info* p = head;for (; p != NULL; p = p-&gt;next) &#123;fprintf(fp_n, reader_format, p-&gt;order, p-&gt;name, p-&gt;borrow_code);fprintf(fp_n, &quot;\n&quot;);&#125;&#125;//搜索信息函数 //参数列表：指向图书信息新文件指针 返回值：所找链节地址，无返回NULL book_info* get_adress_b(book_info* head_adress, char* search) &#123;//定义变量：1.search_adress：当前搜索链节地址 book_info* search_adress = head_adress;//先对图书号进行匹配，是否满足输入的信息 for (; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;code, search) != 0; search_adress = search_adress-&gt;next);//如果没有，重置当前搜索地址，再和书名进行匹配 if (search_adress == NULL) &#123;for (search_adress = head_adress; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;title, search) != 0; search_adress = search_adress-&gt;next);if (search_adress != NULL)return search_adress;else &#123;printf(&quot;This book doesn&#39;t exist\n&quot;);return NULL;&#125;&#125;else return search_adress;&#125;//搜索信息函数//参数列表：指向读者信息新文件指针 返回值：所找链节地址，无返回NULLreader_info* get_adress_r(reader_info* head_adress, char* search) &#123;reader_info* search_adress = head_adress;for (; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;order, search) != 0; search_adress = search_adress-&gt;next);if (search_adress == NULL) &#123;for (search_adress = head_adress; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;name, search) != 0; search_adress = search_adress-&gt;next);if (search_adress != NULL)return search_adress;else &#123;printf(&quot;This person doesn&#39;t exist\n&quot;);return NULL;&#125;&#125;else return search_adress;&#125;</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/124508883">https://blog.csdn.net/qq_32971095/article/details/124508883</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVa232解答</title>
      <link href="/2022/04/20/UVa232%E8%A7%A3%E7%AD%94/"/>
      <url>/2022/04/20/UVa232%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<pre><code>    输入一个r行c列（1 &lt;= r,c &lt;= 10）的网格，黑格用*号表示，每个白格都填有一个字母。如果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边界），则称这个白格是一个起始格。首先把所有起始格从左到右，从上到下顺序编号1，2，3，……要求找出所有横向单词。这些单词必须从一个起始格开始，向右延伸到一个黑格的左边或者整个网格的最右边。最后找出所有的竖向单词。#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;time.h&gt;#define ROW 100#define COL 100char matrix[ROW][COL] = &#123;0&#125;;//#define LOCALint judge(char str[ROW][COL], int r, int c) &#123;    if (str[r][c] != &#39;*&#39;) &#123;        if (r == 0 || c == 0 || str[r - 1][c] == &#39;*&#39; || str[r][c - 1] == &#39;*&#39;)return 1;        else return 0;    &#125;    else return 0;    &#125;int main() &#123;#ifdef LOCAL    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif    int i, j, k, r, c, Num = 1, num = 1;    while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) == 2 &amp;&amp; r != 0) &#123;        num = 1;        for ( i = 0; i &lt; r; i++)&#123;            scanf(&quot;%s&quot;, matrix[i]);        &#125;        printf(&quot;puzzle #%d:\nAcross\n&quot;, Num++);        for (i = 0; i &lt; r; i++) &#123;            for (j = 0; j &lt; c; j++) &#123;                if (judge(matrix, i, j)) &#123;                    printf(&quot;%3d.%c&quot;, num++,matrix[i][j]);                    for (k = j+1; k &lt; c &amp;&amp; matrix[i][k] != &#39;*&#39;; k++) &#123;                        if (judge(matrix, i, k))num++;                        printf(&quot;%c&quot;, matrix[i][k]);                    &#125;                    j = k;                    printf(&quot;\n&quot;);                &#125;            &#125;        &#125;        printf(&quot;DOWN\n&quot;);        num = 1;        for (j = 0; j &lt; c; j++) &#123;            for (i = 0; i &lt; r; i++) &#123;                if (judge(matrix, i, j)) &#123;                    printf(&quot;%3d.%c&quot;, num++, matrix[i][j]);                    for (k = i+1; k &lt; r &amp;&amp; matrix[k][j] != &#39;*&#39;; k++) &#123;                        if (judge(matrix, k, j))num++;                        printf(&quot;%c&quot;, matrix[k][j]);                    &#125;                    i = k;                    printf(&quot;\n&quot;);                &#125;            &#125;        &#125;        printf(&quot;\n&quot;);    &#125;    //printf(&quot;TIME USED: %.5f&quot;, (double)clock() / CLOCKS_PER_SEC);&#125;</code></pre><p>本文转自 <a href="https://blog.csdn.net/qq_32971095/article/details/124302787">https://blog.csdn.net/qq_32971095/article/details/124302787</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
