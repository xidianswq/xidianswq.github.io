<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Zhi Mang Xing:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@200..900&family=Permanent+Marker&family=Satisfy&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xidianswq.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#e6c35c","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="目录">
<meta property="og:type" content="article">
<meta property="og:title" content="2023年电赛E题完整设计暨电赛全记录">
<meta property="og:url" content="https://xidianswq.github.io/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:description" content="目录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png">
<meta property="article:published_time" content="2023-08-07T15:56:59.000Z">
<meta property="article:modified_time" content="2025-02-09T06:33:32.554Z">
<meta property="article:author" content="SWQ">
<meta property="article:tag" content="stm32">
<meta property="article:tag" content="opencv">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="嵌入式硬件">
<meta property="article:tag" content="ubuntu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png">

<link rel="canonical" href="https://xidianswq.github.io/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2023年电赛E题完整设计暨电赛全记录 | Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="Switch" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to My Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">46</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">216</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xidianswq.github.io/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻扬，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2023年电赛E题完整设计暨电赛全记录
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar" color=f6416c></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-07 23:56:59" itemprop="dateCreated datePublished" datetime="2023-08-07T23:56:59+08:00">2023-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" class="post-meta-item leancloud_visitors" data-flag-title="2023年电赛E题完整设计暨电赛全记录" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1">一.2023年E题完整设计</a></p>
<p><a href="about:blank#%3C1%3E%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88">&lt;1&gt;选择方案</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务一：实现按键按下复位（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务二：实现激光点绕边框一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务三：实现激光点绕A4纸边缘一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89">任务四：实现绿色激光追踪红色激光（发挥部分）</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D">&lt;2&gt;任务分配</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">&lt;3&gt;代码分析</a></p>
<p><a href="about:blank#1.stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.stm32上关键源码分析</a></p>
<p><a href="about:blank#I.%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86">I.基本部分</a></p>
<p><a href="about:blank#II.%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81">II.模块代码</a></p>
<p><a href="about:blank#%281%29Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97">(1)Timer——定时器延时函数模块</a></p>
<p><a href="about:blank#%282%29servo_motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">(2)servo_motor——云台舵机控制模块</a></p>
<p><a href="about:blank#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC">①控制舵机的旋转</a></p>
<p><a href="about:blank#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9">②控制激光点到达某一像素点</a></p>
<p><a href="about:blank#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson%20nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87">③与上位机jetson
nano通讯接收点坐标</a></p>
<p><a href="about:blank#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC">④得到一点坐标对应的舵机pwm波OC值</a></p>
<p><a href="about:blank#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF">⑤控制激光点沿四边形巡线</a></p>
<p><a href="about:blank#III.%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86">III.主函数与中断函数部分</a></p>
<p><a href="about:blank#%281%29%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(1)红色激光云台</a></p>
<p><a href="about:blank#%282%29%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(2)绿色激光云台</a></p>
<p><a href="about:blank#2.jetson%20nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2.jetson
nano上关键源码分析</a></p>
<p><a href="about:blank#I.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4">I.相机参数的调整</a></p>
<p><a href="about:blank#II.%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95">II.关键识别算法</a></p>
<p><a href="about:blank#%281%29%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(1)铅笔线识别及顶点的计算</a></p>
<p><a href="about:blank#%282%29A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(2)A4纸顶点识别及巡线顶点的计算</a></p>
<p><a href="about:blank#%283%29%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89">(3)区分红绿激光</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">二.学习资料分享</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A">&lt;1&gt;学习笔记</a></p>
<p><a href="about:blank#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99%EF%BC%9A">&lt;2&gt;其他资料</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95">三.备赛阶段记录</a></p>
<p><a href="about:blank#%E5%9B%9B.%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD">四.电赛总结及经验教训</a></p>
<p><a href="about:blank#%3C1%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84%EF%BC%9A">&lt;1&gt;本次比赛作品的不足、改进之处</a></p>
<p><a href="about:blank#%3C2%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%EF%BC%9A">&lt;2&gt;本次比赛的经验教训</a></p>
<hr>
<p>“愿大家都少走弯路，在迷茫时看到希望！”</p>
<h3 id="一-2023年E题完整设计"><a href="#一-2023年E题完整设计" class="headerlink" title="一.2023年E题完整设计"></a>一.2023年E题完整设计</h3><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="&lt;1&gt;选择方案"></a>&lt;1&gt;选择方案</h3><h4 id="任务一：实现按键按下复位（基础部分）"><a href="#任务一：实现按键按下复位（基础部分）" class="headerlink" title="任务一：实现按键按下复位（基础部分）"></a>任务一：实现按键按下复位（基础部分）</h4><p>方法①：识别四顶点位置-&gt;连接对角线得到中心点-&gt;PID调节使激光点与中心点重合</p>
<p>方法②：识别四顶点位置-&gt;对角顶点坐标求平均值得中心点位置-&gt;PID调节使重合</p>
<p>方法③：固定所有器件位置，保证各点PWM值不变，得到中心点PWM固定值，开环设定</p>
<h4 id="任务二：实现激光点绕边框一周（基础部分）"><a href="#任务二：实现激光点绕边框一周（基础部分）" class="headerlink" title="任务二：实现激光点绕边框一周（基础部分）"></a>任务二：实现激光点绕边框一周（基础部分）</h4><p>步骤I：激光点由中心点到达边线左上角</p>
<p>步骤II：顺时针绕一圈</p>
<pre><code>    方法①：两点定线，先确定两点坐标，连线确定等分点，使用PID算法在等分点间移动

    方法②：不使用PID，利用与目标点坐标差计算移动方向，每次移动距离为舵机最小精度值

    方法③：求PWM和坐标(x,y)的函数关系（近似线性），直接设定PWM值到达指定点
</code></pre>
<h4 id="任务三：实现激光点绕A4纸边缘一周（基础部分）"><a href="#任务三：实现激光点绕A4纸边缘一周（基础部分）" class="headerlink" title="任务三：实现激光点绕A4纸边缘一周（基础部分）"></a>任务三：实现激光点绕A4纸边缘一周（基础部分）</h4><p>（与任务二区别：矩形放置角度可以倾斜；要区分两矩形宽度以识别A4纸）</p>
<h4 id="任务四：实现绿色激光追踪红色激光（发挥部分）"><a href="#任务四：实现绿色激光追踪红色激光（发挥部分）" class="headerlink" title="任务四：实现绿色激光追踪红色激光（发挥部分）"></a>任务四：实现绿色激光追踪红色激光（发挥部分）</h4><p>方法①：区分红绿色激光并得到坐标-&gt;PID直接跟踪</p>
<h3 id="任务分配"><a href="#任务分配" class="headerlink" title="&lt;2&gt;任务分配"></a>&lt;2&gt;任务分配</h3><p>将上述任务分解成多个要完成的技术，以便分工：</p>
<p>1.硬件平台搭建</p>
<p>2.stm32控制算法：</p>
<p>①PID控制激光点移动到目标点算法（核心）</p>
<p>②舵机以最小分度值移动算法（细微调节）</p>
<p>③给定两点以及等分数计算所有等分点算法（线上移动减少偏差）</p>
<p>④在PID寻点时获取基本点（矩形顶点及中心）PWM值算法</p>
<p>⑤stm32和jetson nano的通信规则设计与数据互传</p>
<p>3.OpenCV识别算法</p>
<p>①识别铅笔线边框：灰度图转换-&gt;阈值分割成二值图-&gt;霍夫直线变换得到直线上两点（非端点）-&gt;从得到的多条直线中筛选去重-&gt;编写“已知两直线上两点求直线交点”算法-&gt;求得四端点</p>
<p>②识别A4纸边框：阈值分割后利用Harris角点检测出A4框的8个顶点-&gt;编写“从8个顶点中识别两两相邻顶点”算法-&gt;求得框中心线4顶点</p>
<p>③区分红绿激光点算法：转换到Hsv色彩空间-&gt;分别设置阈值，在Hsv空间中二值化图像提取红绿色区域以得到激光点坐标  </p>
<p>4.主函数（程序流程）设计</p>
<p>5.电赛报告书写</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="&lt;3&gt;代码分析"></a>&lt;3&gt;代码分析</h3><h4 id="1-stm32上关键源码分析"><a href="#1-stm32上关键源码分析" class="headerlink" title="1.stm32上关键源码分析"></a>1.stm32上关键源码分析</h4><h5 id="I-基本部分"><a href="#I-基本部分" class="headerlink" title="I.基本部分"></a>I.基本部分</h5><p>(1)引脚使用说明</p>
<p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>引脚使用说明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>
​    &#x2F;*
​    oled.h				GPIOA PIN0&#x2F;1
​    bluetooth.h			GPIOA PIN2&#x2F;3
​    joystick.h			GPIOA PIN4&#x2F;5 ADC1_CH4&#x2F;5 GPIOB PIN11&#x2F;12&#x2F;13 EXTI12&#x2F;13
​    Pwm.h				GPIOA PIN8&#x2F;11 TIM1_CH1&#x2F;4 50hz
​    usart.h				GPIOA PIN9&#x2F;10 TX&#x2F;RX Black&#x2F;White
​    beep.h				GPIOB PIN14
​    led.h				GPIOB PIN15
​    Timer.h				TIM2&#x2F;3
​    *&#x2F;</p>
<p>(2)头文件声明</p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>头文件声明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
​    #include “public.h”				&#x2F;&#x2F;公用引用函数封装
​    &#x2F;&#x2F;#include “bluetooth.h”		&#x2F;&#x2F;蓝牙模块
​    #include “oled.h”				&#x2F;&#x2F;OLED显示屏模块
​    #include “Pwm.h”				&#x2F;&#x2F;PWM波生成模块
​    #include “servo_motor.h”		&#x2F;&#x2F;云台控制函数模块
​    #include “joystick.h”			&#x2F;&#x2F;摇杆控制模块
​    #include “string.h”				
​    #include “Delay.h”				
​    #include “Timer.h”				&#x2F;&#x2F;定时器模块
​    #include “usart.h”				&#x2F;&#x2F;uart通信模块
​    #include “beep.h”				&#x2F;&#x2F;蜂鸣器模块
​    #include “led.h”				&#x2F;&#x2F;led灯模块
​    #include “dma.h”				&#x2F;&#x2F;dma数据转存模块</p>
<p>(3)全局变量和宏定义声明</p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>全局变量和宏定义声明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
​    &#x2F;&#x2F;#define OpenLoop_OL		&#x2F;&#x2F;开环实现功能执行
​    #define CloseLoop_CL		&#x2F;&#x2F;闭环实现功能执行
​<br>    extern float Voltage[2];	&#x2F;&#x2F;ad测量电压值[0.3.3]			&#x2F;&#x2F;ad.c
    extern char  USART_RX_INFO[USART_REC_LEN];	&#x2F;&#x2F;uart接收数据	&#x2F;&#x2F;usart.c
    extern int x,y;				&#x2F;&#x2F;激光当前坐标					&#x2F;&#x2F;servo_motor.c
    extern int Vertex[4][2];	&#x2F;&#x2F;四顶点位置						&#x2F;&#x2F;servo_motor.c
    extern int Vertex_Peak_Pos[4][2];
    extern int Vertex_A4[4][2];
    extern Pwm Center_Pwm;
    extern Pwm Peak_Pwm[4];
    extern Pwm A4_Pwm[4];</p>
<pre><code>int Programme_Progress=0;					//比赛程序进度
int order=0;								//蓝牙接收到的命令
int Main_Wait_Stop_Sign =1;					//主程序等待标志位
extern int JoyStick_Control_Stop_Sign;		//摇杆控制程序结束标志位
int Get_Depend_Point_Pos_Stop_Sign=1;
int Get_A4_Point_Pos_Stop_Sign=1;
extern int Follow_Track_Stop_Sign;			//矩形寻迹结束标志位
extern int Follow_Point_Stop_Sign;			//绿激光跟随红激光结束标志位
</code></pre>
<h5 id="II-模块代码"><a href="#II-模块代码" class="headerlink" title="II.模块代码"></a>II.模块代码</h5><h6 id="1-Timer——定时器延时函数模块"><a href="#1-Timer——定时器延时函数模块" class="headerlink" title="(1)Timer——定时器延时函数模块"></a>(1)Timer——定时器延时函数模块</h6><p>​<br>​    #include “Timer.h”
​<br>    &#x2F;&#x2F;TIM2&#x2F;3</p>
<pre><code>void Timer_Init(void)
&#123;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	
	TIM_InternalClockConfig(TIM2);
	TIM_InternalClockConfig(TIM3);
	
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = 60000 - 1;	//分辨率1us,最大60ms
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);
	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);
	
&#125;

void Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM2,ENABLE); //启动定时器
	while(TIM2-&gt;CNT &lt; xus);
	TIM2-&gt;CNT = 0;
	TIM_Cmd(TIM2,DISABLE); //关闭定时器
&#125;

void Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)Timer_delay_us(1000);
&#125;

//外部中断专用延时函数
void EXIT_LINE_Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM3,ENABLE); //启动定时器
	while(TIM3-&gt;CNT &lt; xus);
	TIM3-&gt;CNT = 0;
	TIM_Cmd(TIM3,DISABLE); //关闭定时器
&#125;

void EXIT_LINE_Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)EXIT_LINE_Timer_delay_us(1000);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>在Timer_Init()中开启了两个定时器TIM1&#x2F;2，由Timer_delay_us()和EXIT_LINE_Timer_delay_us()分别使用，分别在中断函数内外使用，<strong>避免重复调用冲突</strong></p>
<h6 id="2-servo-motor——云台舵机控制模块"><a href="#2-servo-motor——云台舵机控制模块" class="headerlink" title="(2)servo_motor——云台舵机控制模块"></a>(2)servo_motor——云台舵机控制模块</h6><h6 id="①控制舵机的旋转"><a href="#①控制舵机的旋转" class="headerlink" title="①控制舵机的旋转"></a>①控制舵机的旋转</h6><p>​<br>​    int Oc_Lp[4]&#x3D;{750,750,750,750};
​    int Oc_Vp[4]&#x3D;{763,763,763,763};
​    &#x2F;*********************************************************
​    函数功能：云台水平方向旋转
​    *********************************************************&#x2F;
​    void Spinnig_Level(int diff)
​    {
​    	if(diff&lt;0)
​    	{
​    		Oc_Lp[0]&#x3D;Oc_L&#x3D;(Oc_L+diff)&lt;660?660:(Oc_L+diff);
​    	}
​    	else if(diff&gt;0)
​    	{
​    		Oc_Lp[0]&#x3D;Oc_L&#x3D;(Oc_L+diff)&gt;840?840:(Oc_L+diff);	
​    	}
​    	TIM_SetCompare1(TIM1,Oc_L);	
​    	int i;
​    	for(i&#x3D;3;i&gt;0;i–)Oc_Lp[i]&#x3D;Oc_Lp[i-1];
​    }</p>
<p><strong>说明：</strong></p>
<p>这里的Oc_Lp存储的是控制舵机的pwm波参数中的OC寄存器中的值，作为舵机运动最基本的函数，
<em><strong>舵机的控制通过改变pwm波参数中的OC寄存器中的值实现</strong></em>
。这里定义数组实现记忆功能，可存储前三次的OC值。并通过三元运算符设定上下限，将最终的OC值通过TIM_SetCompare1()设定。</p>
<h6 id="②控制激光点到达某一像素点"><a href="#②控制激光点到达某一像素点" class="headerlink" title="②控制激光点到达某一像素点"></a>②控制激光点到达某一像素点</h6><p>​<br>​    &#x2F;*********************************************************
​    函数功能：云台控制激光点到达某一点
​    函数参数：目标点的坐标
​    *********************************************************&#x2F;
​    int x&#x3D;360,y&#x3D;360;		&#x2F;&#x2F;跟随点当前坐标
​    int Reach_Pos_CL_Stop_Sign&#x3D;1;
​    &#x2F;&#x2F;云台水平方向旋转PID值
​    float Level_Kp&#x3D;0.06;
​    float Level_Ki&#x3D;0.02;
​    float Level_Kd&#x3D;0.01;
​    &#x2F;&#x2F;云台竖直方向旋转PID值
​    float Vert_Kp&#x3D;0.06;
​    float Vert_Ki&#x3D;0.02;
​    float Vert_Kd&#x3D;0.01;
​    void Reach_Pos_CL(int Target_X,int Target_Y,int Reach_Pos_CL_MODE)
​    {
​    	int Sign(int num);
​    	void Get_Point_Pos(void);
​    	int near(int Target_X,int Target_Y);
​    	
    	int diff_x,diff_y;
    	while(Reach_Pos_CL_Stop_Sign)
    	{
    		Timer_delay_ms(30);
    		Get_Point_Pos();
    		if(near(Target_X,Target_Y)&lt;&#x3D;6)
    		{
    			Beep_Times(10,1,NORMAL_MODE);
    			break;
    		}
    		if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; near(Target_X,Target_Y)&gt;60)					&#x2F;&#x2F;用pid计算舵机单位数
    		{
    			diff_x&#x3D;Pid_Control(Level_Kp,Level_Ki,Level_Kd,Target_X,x,PID_REALIZE);
    			diff_y&#x3D;Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,Target_Y,y,PID_REALIZE);
    		}
    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;MINMIZE_MODE)		&#x2F;&#x2F;以舵机最小分辨率为单位
    		{
    			diff_x&#x3D;-Sign(x-Target_X);
    			diff_y&#x3D;-Sign(y-Target_Y);
    		}
    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; near(Target_X,Target_Y)&lt;&#x3D;60)					&#x2F;&#x2F;用pid计算舵机单位数
    		{
    			diff_x&#x3D;-Sign(x-Target_X);
    			diff_y&#x3D;-Sign(y-Target_Y);
    			Timer_delay_ms(30);
    		}
    		Spinnig_Level(X_DIR<em>diff_x);
    		Spinnig_Vert(Y_DIR</em>diff_y);
    		Timer_delay_ms(20);
    	}
    }</p>
<pre><code>int Sign(int num)
&#123;
	if(num&gt;5)return 1;
	else if(num&lt;-5)return -1;
	else return 0;
&#125;

int my_abs(int a,int b)
&#123;
	return a-b&gt;0?a-b:b-a;
&#125;

int near(int Target_X,int Target_Y)
&#123;
	return my_abs(Target_X,x)+my_abs(Target_Y,y);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：目标点像素坐标；追踪模式（PID【PID与最小精度混合】模式和最小精度值模式）</p>
<p><strong>追踪过程：</strong></p>
<p>——得到当前激光点坐标：Get_Point_Pos()</p>
<p>——如果接近目标点则蜂鸣器鸣叫并退出【near(Target_X,Target_Y)&lt;&#x3D;6，说明当前坐标与目标横纵坐标差之和{“距离”}小于6个像素】</p>
<p>——如果使用PID模式：</p>
<pre><code>    ——“距离”大于60时采用PID算法快速靠近，计算出OC变化值diff_x、diff_y

    ——“距离”小于60时使用最小精度模式缓慢靠近，利用“符号函数sign()”计算diff
</code></pre>
<p>——调用Spinnig_Level()、Spinnig_Level()进行水平和垂直舵机的旋转</p>
<h6 id="③与上位机jetson-nano通讯接收点坐标"><a href="#③与上位机jetson-nano通讯接收点坐标" class="headerlink" title="③与上位机jetson nano通讯接收点坐标"></a>③与上位机jetson nano通讯接收点坐标</h6><p><strong>a.激光点坐标的实时接收</strong></p>
<p>​<br>​    &#x2F;*********************************************************
​    函数功能：stm32获取当前激光坐标
​    *********************************************************&#x2F;
​    void Get_Point_Pos(void)
​    {
​    	if(USART_RX_INFO[0]&#x3D;&#x3D;’x’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)
​    	{
​    		x&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;
​    	}
​    	if(USART_RX_INFO[4]&#x3D;&#x3D;’y’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)
​    	{
​    		y&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;
​    	}
​    }</p>
<p><strong>说明：</strong></p>
<p>规定上位机每次发送数据格式为：以#开头，以$结尾；stm32usart模块对接收数据进行解析</p>
<p>上位机坐标数据格式为：x123y456；123、456代表三位坐标值，字符’x’、’y’起定位作用</p>
<p>stm32对接收到的字符坐标进行解析如上</p>
<p><strong>b.特殊坐标接收</strong></p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>高级控制函数(CloseLoop–CL)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
​    int Vertex_Peak_Pos[4][2];
​    int Center_Pos[2];
​    Pwm Center_Pwm;
​    Pwm Peak_Pwm[4];
​    Pwm A4_Pwm[4]; 
​    &#x2F;&#x2F;获取重要点坐标
​    void Get_Point_5(void)
​    {
​    	int i,j;
​    	while(1)
​    	{
​    		for(i&#x3D;0;i&lt;8;i++)
​    		{
​    			if(USART_RX_INFO[4<em>i]&#x3D;&#x3D;’a’+i)continue;
​    			else break;
​    		}
​    		if(i&#x3D;&#x3D;8)
​    		{
​    			for(i&#x3D;0;i&lt;4;i++)
​    			{
​    				for(j&#x3D;0;j&lt;2;j++)Vertex_Peak_Pos[i][j]&#x3D;(USART_RX_INFO[4</em>(2<em>i+j)+1]-‘0’)<em>100+(USART_RX_INFO[4</em>(2</em>i+j)+2]-‘0’)<em>10+(USART_RX_INFO[4</em>(2*i+j)+3]-‘0’);
​    			}
​    			break;
​    		}
​    	}
​    	
    	while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));
    	
    	Center_Pos[0]&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;
    	Center_Pos[1]&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;
    	Beep_Times(50,5,NORMAL_MODE);
    	
    }</p>
<p><strong>说明：</strong></p>
<p>这里接收的是铅笔线框四个顶点的坐标和中心点坐标，但是一次发送的数据长度不能太长，这里拆分成两部分接收（数据格式为：axxxbxxxcxxx…hxxx共8组值四个坐标），
<em><strong>关键在于两部分的衔接</strong></em></p>
<p>while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<em><strong>确保收到四个顶点坐标后持续等待中心点坐标的发送</strong></em></p>
<h6 id="④得到一点坐标对应的舵机pwm波OC值"><a href="#④得到一点坐标对应的舵机pwm波OC值" class="headerlink" title="④得到一点坐标对应的舵机pwm波OC值"></a>④得到一点坐标对应的舵机pwm波OC值</h6><p>​<br>​    int sum_num(int *num,int n)
​    {
​    	int i,sum;
​    	for(i&#x3D;sum&#x3D;0;i&lt;n;i++)sum+&#x3D;num[i];
​    	return sum;
​    }	
​    &#x2F;&#x2F;获取目标点pwm值
​    void Get_Pwm(int px,int py,Pwm *target_pwm,int n)
​    {
​    	Reach_Pos_CL(px,py,PID_MODE);
​    	target_pwm-&gt;level&#x3D;sum_num(Oc_Lp,n)&#x2F;n;
​    	target_pwm-&gt;vert&#x3D;sum_num(Oc_Vp,n)&#x2F;n;
​    }</p>
<p><strong>说明：</strong></p>
<p>通过②控制函数控制激光点到达指定点后记录目标点pwm值并返回；Pwm结构体定义如下</p>
<p>​<br>​    typedef struct Pwm{
​    	int level;
​    	int vert;
​    }Pwm;</p>
<p>可以通过改变参数n的值选择是否滤波，4&gt;n&gt;1时进行滤波，取前几次OC值的平均值，不建议滤波</p>
<h6 id="⑤控制激光点沿四边形巡线"><a href="#⑤控制激光点沿四边形巡线" class="headerlink" title="⑤控制激光点沿四边形巡线"></a>⑤控制激光点沿四边形巡线</h6><p>​<br>​    &#x2F;&#x2F;巡线
​    void Follow_Track(int Vertex[4][2],int divide_num)
​    {
​    	int i,j;
​    	float sub_l,sub_v;
​    	Pwm Vertex_Pwm[4];
​    	for(i&#x3D;0;i&lt;4;i++)Get_Pwm(Vertex[i][0],Vertex[i][1],&amp;Vertex_Pwm[i],1);
​    	
    	for(i&#x3D;0;i&lt;4;i++)
    	{
    		sub_l&#x3D;(Vertex_Pwm[(i+1)%4].level-Vertex_Pwm[i].level);	&#x2F;&#x2F;下一个顶点与当前顶点pwm之差
    		sub_v&#x3D;(Vertex_Pwm[(i+1)%4].vert-Vertex_Pwm[i].vert);	&#x2F;&#x2F;下一个顶点与当前顶点纵坐标之差
    		for(j&#x3D;0;j&lt;divide_num;j++)
    		{
    			Reach_Pos_OL(Vertex_Pwm[i].level+j<em>sub_l&#x2F;divide_num,Vertex_Pwm[i].vert+j</em>sub_v&#x2F;divide_num);
    			Timer_delay_ms(200);
    		}
    		Reach_Pos_OL(Vertex_Pwm[(i+1)%4].level,Vertex_Pwm[(i+1)%4].vert);
    		Timer_delay_ms(300);
    	}
    	
    	Beep_Times(50,5,NORMAL_MODE);
    }</p>
<p><strong>说明：</strong></p>
<p>输入参数：四边形顺时针顺序顶点坐标、每段等分数divide_num</p>
<p><strong>巡线过程：</strong></p>
<p>——得到四个顶点坐标对应的水平、数值舵机OC值</p>
<p>——在for循环内依次经过四个顶点，视作四个大任务</p>
<pre><code>    ——内部使用for循环分解小任务，根据等分段数divide_num计算等分点横纵pwm值并移动至
</code></pre>
<p>——任务结束鸣叫示意</p>
<h5 id="III-主函数与中断函数部分"><a href="#III-主函数与中断函数部分" class="headerlink" title="III.主函数与中断函数部分"></a>III.主函数与中断函数部分</h5><h6 id="1-红色激光云台"><a href="#1-红色激光云台" class="headerlink" title="(1)红色激光云台"></a>(1)红色激光云台</h6><p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>主函数部分</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>
​    &#x2F;&#x2F;重新重启初值还原设置
​    void Programme_Reset(void)
​    {
​    	Beep_Times(1000,1,NORMAL_MODE);
​    	Led_Times(1000,1,NORMAL_MODE);
​    	Programme_Progress&#x3D;0;
​    	
    	Main_Wait_Stop_Sign&#x3D;1;
    	JoyStick_Control_Stop_Sign&#x3D;1;
    	Follow_Track_Stop_Sign&#x3D;1;
    	
    	Get_A4_Point_Pos_Stop_Sign&#x3D;1;
    	Get_Depend_Point_Pos_Stop_Sign&#x3D;1;
    }</p>
<pre><code>int main(void)
&#123;	
	//********************初始化程序********************
	Timer_Init();				//定时器初始化
//	BlueToothInit(9600,USART_Parity_No,USART_StopBits_1,USART_WordLength_8b);	//蓝牙初始化
	OLED_Init();				//oled初始化
	Beep_Init();				//蜂鸣器初始化
	Led_Init();					//led灯初始化
	TIM1_PWM_Init(9999,143);	//一周期20ms，分辨率20ms/10000）
	TIM_SetCompare1(TIM1,750);	//对齐角度为90度(1.5ms)
	TIM_SetCompare4(TIM1,763);	//对齐角度为90度(1.5ms)
	uart_init(115200);			//uart1初始化
	JoyStick_Init();			//JoyStick摇杆初始化
			
	//*************************比赛程序部分*************************
	while(1)
	&#123;
		int i;
		//重新重启初值还原设置
		Programme_Reset();
//		Reach_Pos_CL(50,50,PID_MODE);
		
		Axes_Init();
		
//		Follow_Track(Vertex_Peak_Pos,1);
		
		while(Main_Wait_Stop_Sign);
		//摇杆控制
		JoyStick_Control();
</code></pre>
<p>​    		
​    &#x2F;&#x2F;#ifdef OpenLoop_OL
​    &#x2F;&#x2F;			Follow_Track_OL();
​    &#x2F;&#x2F;#endif			
​    &#x2F;&#x2F;#ifdef CloseLoop_CL
​    &#x2F;&#x2F;		&#x2F;&#x2F;等待上位机发送初始坐标
​    &#x2F;&#x2F;		Get_Depend_Point_Pos();
​    &#x2F;&#x2F;		&#x2F;&#x2F;环绕正方形顺时针旋转一周
​    &#x2F;&#x2F;		while(Get_Depend_Point_Pos_Stop_Sign);
​<br>    		&#x2F;&#x2F;Follow_Track_CL(Vertex_Peak_Pos,2,PID_MODE);
    		
    &#x2F;&#x2F;#endif</p>
<pre><code>		Pwm_Track(Peak_Pwm,1);
		while(Follow_Track_Stop_Sign);
				
		Get_A4_Point_Pos();
		Timer_delay_ms(2000);
//		Follow_Track_CL(Vertex_A4,4,MINMIZE_MODE);
//		Follow_Track(Vertex_A4,4);
		for(i=0;i&lt;4;i++)Get_Pwm(Vertex_A4[i][0],Vertex_A4[i][1],&amp;A4_Pwm[i],1);
		Pwm_Track(A4_Pwm,6);
		while(Get_A4_Point_Pos_Stop_Sign);
		
	&#125;
&#125;
</code></pre>
<p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>中断函数部分</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>
​    &#x2F;&#x2F;按键中断函数
​    void EXTI15_10_IRQHandler()
​    {
​    	if (EXTI_GetITStatus(EXTI_Line11) &#x3D;&#x3D; SET)
​    	{
​    		EXIT_LINE_Timer_delay_ms(10);										
​    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖
​    		{
​    			Beep_Times(50,2,EXIT_LINE_MODE);
​    			Reach_Pos_OL(Oc_L,Oc_V);						&#x2F;&#x2F;保持激光当前指向位置
​    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开
​<br>    			&#x2F;&#x2F;再次按下才退出
    			EXIT_LINE_Timer_delay_ms(10);
    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;1);		
    			EXIT_LINE_Timer_delay_ms(10);										
    			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0);		&#x2F;&#x2F;软件防抖
    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11&#x3D;&#x3D;1)); 	&#x2F;&#x2F;等待按键松开
    			Beep_Times(50,2,EXIT_LINE_MODE);
    			
    			EXTI_ClearITPendingBit(EXTI_Line11);
    		}
    	}
    	
    	else if (EXTI_GetITStatus(EXTI_Line12) &#x3D;&#x3D; SET)
    	{
    		EXIT_LINE_Timer_delay_ms(10);										
    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖
    		{
    			Programme_Progress++;
    			Beep_Times(500,1,EXIT_LINE_MODE);
    			if(Programme_Progress&#x3D;&#x3D;1)
    			{
    				Main_Wait_Stop_Sign&#x3D;0;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;2)
    			{
    				JoyStick_Control_Stop_Sign&#x3D;0;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;3)
    			{
    &#x2F;&#x2F;				Get_Depend_Point_Pos_Stop_Sign&#x3D;0;
    				Follow_Track_Stop_Sign&#x3D;0;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;4)
    			{
    				Get_A4_Point_Pos_Stop_Sign&#x3D;0;
    &#x2F;&#x2F;				Follow_Track_Stop_Sign&#x3D;0;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;5)
    			{
    &#x2F;&#x2F;				Get_A4_Point_Pos_Stop_Sign&#x3D;0;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;6)
    			{
    				;
    			}
    			else if(Programme_Progress&#x3D;&#x3D;7)
    			{
    				;
    			}
    			else
    			{
    				Programme_Reset();
    			}
    			
    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开
    			EXTI_ClearITPendingBit(EXTI_Line12);
    		}
    		
    	}
    	
    	else if (EXTI_GetITStatus(EXTI_Line13) &#x3D;&#x3D; SET)
    	{
    		EXIT_LINE_Timer_delay_ms(10);										
    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖
    		{
    			Beep_Times(50,3,EXIT_LINE_MODE);
    			
    			Reach_Pos_OL(Center_Pwm.level,Center_Pwm.vert);
    			
    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开</p>
<pre><code>			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13==1)); 	//等待按键松开
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line13);
		&#125;
	&#125;	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>主函数与中断函数相辅相成，程序整体使用外部中断推进以及实现一些特殊功能（立即复位）；</p>
<p>由于主函数内小功能函数都借助while()循环实现，设置循环标志位Stop_Sign和程序阶段标志位Programme_Progress来推进主函数；</p>
<p>按下GPIOB,GPIO_Pin_12的按键触发中断，Programme_Progress++以及相应的Stop_Sign&#x3D;0，以控制目前运行小功能停止并进入下一阶段；</p>
<p>在程序开始和结束处执行Programme_Reset()函数，重置各标志位实现程序重新运行；</p>
<p><strong>注意：</strong></p>
<p>在中断函数内部涉及到的延时函数统统使用EXIT_LINE_Timer_delay_ms()函数，区别外部使用的Timer_delay_ms()函数，防止调用冲突程序卡死</p>
<h6 id="2-绿色激光云台"><a href="#2-绿色激光云台" class="headerlink" title="(2)绿色激光云台"></a>(2)绿色激光云台</h6><p>​<br>​    &#x2F;&#x2F;绿车
​    int r_x&#x3D;0,r_y&#x3D;0;
​    void Get_RaG_Point_Pos(void)
​    {
​    	if(USART_RX_INFO[0]&#x3D;&#x3D;’g’&amp;&amp; USART_RX_INFO[8]&#x3D;&#x3D;’r’&amp;&amp; USART_RX_INFO[4]&#x3D;&#x3D;’y’&amp;&amp; USART_RX_INFO[12]&#x3D;&#x3D;’y’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)
​    	{
​    		x&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;
​    		y&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;
​    		r_x&#x3D;(USART_RX_INFO[9]-‘0’)<em>100+(USART_RX_INFO[10]-‘0’)<em>10+USART_RX_INFO[11]-‘0’;
​    		r_y&#x3D;(USART_RX_INFO[13]-‘0’)<em>100+(USART_RX_INFO[14]-‘0’)<em>10+USART_RX_INFO[15]-‘0’;
​    	}
​    }
​<br>    void G_Follow_R(int Reach_Pos_CL_MODE)
    {
    	int Sign(int num);
    	void Get_RaG_Point_Pos(void);
    	int near(int r_x,int Target_Y);
    	
    	int diff_x,diff_y,dis;
    	while(Reach_Pos_CL_Stop_Sign)
    	{
    		if(x&#x3D;&#x3D;0&amp;&amp;y&#x3D;&#x3D;0)Reach_Pos_OL(750,750);
    		Get_RaG_Point_Pos();
    		dis&#x3D;near(r_x,r_y);
    		if(dis&lt;&#x3D;20)
    		{
    			Beep_Times(300,1,NORMAL_MODE);
    			Led_Times(300,1,NORMAL_MODE);
    			continue;
    		}
    		if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; dis&gt;60)					&#x2F;&#x2F;用pid计算舵机单位数
    		{
    			Get_RaG_Point_Pos();
    			diff_x&#x3D;Pid_Control(Level_Kp,Level_Ki,Level_Kd,r_x,x,PID_REALIZE);
    			diff_y&#x3D;Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,r_y,y,PID_REALIZE);
    		}
    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;MINMIZE_MODE)		&#x2F;&#x2F;以舵机最小分辨率为单位
    		{
    			Get_RaG_Point_Pos();
    			diff_x&#x3D;-0.5</em>Sign(x-r_x);
    			diff_y&#x3D;-0.5</em>Sign(y-r_y);
    		}
    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; dis&lt;&#x3D;60)					&#x2F;&#x2F;用pid计算舵机单位数
    		{
    			Get_RaG_Point_Pos();
    			diff_x&#x3D;-0.4</em>Sign(x-r_x);
    			diff_y&#x3D;-0.4</em>Sign(y-r_y);</p>
<pre><code>		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>上位机数据格式为：g123y123r123y123，实时传输红绿激光点两个坐标；</p>
<p>执行点到点的跟踪即可，在主函数中不断重复即可，即while(1)G_Follow_R(PID_MODE);</p>
<h4 id="2-jetson-nano上关键源码分析"><a href="#2-jetson-nano上关键源码分析" class="headerlink" title="2.jetson nano上关键源码分析"></a>2.jetson nano上关键源码分析</h4><p><strong>文件说明：</strong></p>
<p>mian_10、main_11、mian_12是测试函数，分别测试<strong>铅笔线识别效果</strong> 、<strong>A4纸识别效果</strong> 、<strong>红绿激光分别识别效果</strong>
。设置了滑动条供<strong>调参</strong> 使用，确定好参数</p>
<p>q_1、q_2、q_3即为三个问题对应的程序，分别实现<strong>发送铅笔线顶点和中心坐标后实时传输红色激光点坐标</strong>
、<strong>发送A4纸顶点坐标后实时传输红色激光点坐标</strong> 、<strong>实时传输红色和绿色激光点坐标</strong></p>
<h5 id="I-相机参数的调整"><a href="#I-相机参数的调整" class="headerlink" title="I.相机参数的调整"></a>I.相机参数的调整</h5><p>​<br>​    string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
​    {
​       return “nvarguscamerasrc exposurecompensation&#x3D;1 ! video&#x2F;x-raw(memory:NVMM), width&#x3D;(int)” + to_string(capture_width) + “, height&#x3D;(int)” +
​           to_string(capture_height) + “, format&#x3D;(string)NV12, framerate&#x3D;(fraction)” + to_string(framerate) +
​           “&#x2F;1 ! nvvidconv flip-method&#x3D;” + to_string(flip_method) + “ ! video&#x2F;x-raw, width&#x3D;(int)” + to_string(display_width) + “, height&#x3D;(int)” +
​           to_string(display_height) + “, format&#x3D;(string)BGRx ! videoconvert ! video&#x2F;x-raw, format&#x3D;(string)BGR ! appsink”;
​    }</p>
<p>这里设置好管道参数，主要调整曝光和饱和度，方便之后线条的检测以及红绿激光的区分</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI
图像质量</a></p>
<h5 id="II-关键识别算法"><a href="#II-关键识别算法" class="headerlink" title="II.关键识别算法"></a>II.关键识别算法</h5><h6 id="1-铅笔线识别及顶点的计算"><a href="#1-铅笔线识别及顶点的计算" class="headerlink" title="(1)铅笔线识别及顶点的计算"></a>(1)铅笔线识别及顶点的计算</h6><p><strong>变量解析：</strong></p>
<p>​<br>​    int Find &#x3D; 0, l_x &#x3D; 0, l_y &#x3D; 0, r_x &#x3D; 0, r_y &#x3D; 0;
​    int l[2][2],r[2][2],u[2][2],d[2][2];
​    int ul[2],ur[2],dl[2],dr[2],ce[2];</p>
<p>Find有效个数标志位，表示找到了几组有效的边上两点；</p>
<p>l_x、l_y、r_x、r_y寻找标志位，为1则分别表示上下左右边未找到有效值的两点值</p>
<p>l[2][2]、r[2][2]、u[2][2]、d[2][2]分别存储上下左右边上两点坐标</p>
<p>ul[2]、ur[2]、dl[2]、dr[2]、ce[2]分别存储最终的顶点和中心点坐标</p>
<p><strong>过程：</strong></p>
<p>——转换成灰度图-&gt;阈值划分成二制图-&gt;霍夫直线检测得到直线并输出直线上两点坐标</p>
<pre><code>    ——设计算法过滤筛选重复直线并存储两点坐标
</code></pre>
<p>​<br>​    for (size_t i &#x3D; 0; i &lt; linesPPHT.size(); i++) {
​                    x1 &#x3D; linesPPHT[i][0], y1 &#x3D; linesPPHT[i][1], x2 &#x3D; linesPPHT[i][2], y2 &#x3D; linesPPHT[i][3];
​                    line(image, Point(x1, y1), Point(x2, y2), Scalar(0), 1, 8);
​<br>                    if (x1 &lt; 150 &amp;&amp; x2 &lt; 150 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !l_x){Find++;l_x &#x3D; (x2 + x1) &#x2F; 2;l[0][0]&#x3D;x1;l[0][1]&#x3D;y1;l[1][0]&#x3D;x2;l[1][1]&#x3D;y2;}
                    else if (y1 &lt; 150 &amp;&amp; y2 &lt; 150 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !l_y){Find++;l_y &#x3D; (y1 + y2) &#x2F; 2;u[0][0]&#x3D;x1;u[0][1]&#x3D;y1;u[1][0]&#x3D;x2;u[1][1]&#x3D;y2;}
                    else if (x1 &gt; 570 &amp;&amp; x2 &gt; 570 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !r_x){Find++;r_x &#x3D; (x2 + x1) &#x2F; 2;r[0][0]&#x3D;x1;r[0][1]&#x3D;y1;r[1][0]&#x3D;x2;r[1][1]&#x3D;y2;}
                    else if (y1 &gt; 570 &amp;&amp; y2 &gt; 570 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !r_y){Find++;r_y &#x3D; (y1 + y2) &#x2F; 2;d[0][0]&#x3D;x1;d[0][1]&#x3D;y1;d[1][0]&#x3D;x2;d[1][1]&#x3D;y2;}
                }</p>
<p>linesPPHT是霍夫直线检测函数的输出，linesPPHT.size()表示检测到直线的条数；这里根据直线上两点坐标值大小判断属于四条边的那一条；属于其中一条且之前未存储（标志位为1）（见if语句中的判断）则存储并将找点标志位Find+1；Find&#x3D;&#x3D;4时即寻找结束</p>
<p>——由于霍夫直线检测算法得到的并非顶点而是直线上两点，设计求两直线交点函数</p>
<p>​<br>​    void crossline(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int cross[2])
​    {
​        cross[0]&#x3D;(y3<em>x4</em>x2-y4<em>x3</em>x2-y3<em>x4</em>x1+y4<em>x3</em>x1-y1<em>x2</em>x4+y2<em>x1</em>x4+y1<em>x2</em>x3-y2<em>x1</em>x3)&#x2F;(x4<em>y2-x4</em>y1-x3<em>y2+x3</em>y1-x2<em>y4+x2</em>y3+x1<em>y4-x1</em>y3);
​        cross[1]&#x3D;(-y3<em>x4</em>y2+y4<em>x3</em>y2+y3<em>x4</em>y1-y4<em>x3</em>y1+y1<em>x2</em>y4-y1<em>x2</em>y3-y2<em>x1</em>y4+y2<em>x1</em>y3)&#x2F;(y4<em>x2-y4</em>x1-y3<em>x2+x1</em>y3-y2<em>x4+y2</em>x3+y1<em>x4-y1</em>x3);
​    }</p>
<p>输入的(x1,y1)~(x4,y4)是两条直线上四点坐标，输出交点坐标并赋值给cross；</p>
<p>​<br>​    crossline(l[0][0],l[0][1],l[1][0],l[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ul);
​    crossline(r[0][0],r[0][1],r[1][0],r[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ur);
​    crossline(l[0][0],l[0][1],l[1][0],l[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dl);
​    crossline(r[0][0],r[0][1],r[1][0],r[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dr);
​<br>    crossline(ul[0],ul[1],dr[0],dr[1],ur[0],ur[1],dl[0],dl[1],ce);</p>
<p>输入之前得到的坐标计算四个顶点值和中心坐标</p>
<p>——向下位机stm32输出坐标</p>
<p>​<br>​    sprintf(m,”#a%03db%03dc%03dd%03de%03df%03dg%03dh%03d$\n”,ul[0],ul[1],ur[0],ur[1],dr[0],dr[1],dl[0],dl[1]);
​    uart.sendUart(m);
​    usleep(50000);
​    sprintf(m,”#i%03dj%03d$\n”,ce[0],ce[1]);
​    uart.sendUart(m);</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png"></p>
<h6 id="2-A4纸顶点识别及巡线顶点的计算"><a href="#2-A4纸顶点识别及巡线顶点的计算" class="headerlink" title="(2)A4纸顶点识别及巡线顶点的计算"></a>(2)A4纸顶点识别及巡线顶点的计算</h6><p>过程：</p>
<p>——灰度图-&gt;二值化-&gt;角点检测得到角点坐标CornerImg</p>
<pre><code>    ——设计算法过滤筛选得到八个顶点P[8][2]（绝缘胶布内外边形成两个矩形）
</code></pre>
<p>​<br>​    #define MAX_DIS 20
​    int Is_Exit(int i, int j)
​    {
​        int k &#x3D; 0;
​        for (k &#x3D; 0; k &lt; Find; k++) 
​        {
​            if (myabs(P[k][0]-i)+ myabs(P[k][1]-j)&lt;MAX_DIS)return 1;
​        }
​        return 0;
​    }</p>
<p>​<br>​    int P[8][2] &#x3D; { 0 };
​    int Find &#x3D; 0;
​<br>    for (int j &#x3D; 0; j &lt; CornerImg.rows; j++) {
        for (int i &#x3D; 0; i &lt; CornerImg.cols; i++) {
            if (CornerImg.at<float>(j, i) &gt; 150.0f) {
                if (!Is_Exit(i, j))
                {<br>                    P[Find][0] &#x3D; i;
                    P[Find][1] &#x3D; j;
                    Find++;
                }
            }
        }
    }</p>
<p>Is_Exit()函数遍历已经视作有效的点，如果与当前坐标(i,j)接近则不存储；找到八个有效点退出</p>
<p>——设计根据八个顶点P[8][2]求得巡线四边形的顶点Vertex[4][2]（同一个角的内外顶点的中点）</p>
<p>​<br>​    int Vertex[4][2] &#x3D; { 0 };
​    int sign[8] &#x3D; { 0 };
​    int i,j,k,dis,min &#x3D; 1000;
​    int temp1, temp2;
​    for (k&#x3D;0,i &#x3D; 0; i &lt; 8; i++)
​    {
​        if (sign[i])continue;
​        min &#x3D; 2000;
​        for (j &#x3D; 0; j &lt; 8; j++)
​        {
​            if (i &#x3D;&#x3D; j||sign[j])continue;
​            dis &#x3D; myabs(P[i][0] - P[j][0]) + myabs(P[i][1] - P[j][1]);
​            if (dis&lt; min)
​            {
​                min &#x3D; dis;
​                temp1 &#x3D; i;
​                temp2 &#x3D; j;
​            }
​        }
​        sign[temp1] &#x3D; 1;
​        sign[temp2] &#x3D; 1;
​        Vertex[k][0] &#x3D; (P[temp1][0] + P[temp2][0])&#x2F;2;
​        Vertex[k][1] &#x3D; (P[temp1][1] + P[temp2][1])&#x2F;2;
​        k++;
​    }</p>
<p>这里使用for循环遍历P[8][2]中顶点，将距离最近的两点视为A4纸一个角内外两边的两个顶点，求其中点存储在Vertex[4][2]中</p>
<p>——设计算法使巡线的四个端点按照顺时针传输给下位机，否则巡线顺序错误</p>
<p>​<br>​    int temp;
​    &#x2F;&#x2F;先整体按y值大小排序
​    for(i&#x3D;0;i&lt;4;i++)
​    {
​        for(min&#x3D;Vertex[i][1],j&#x3D;k&#x3D;i;j&lt;4;j++)
​        {
​            if(Vertex[j][1]&lt;&#x3D;min)k&#x3D;j;
​        }
​        temp&#x3D;Vertex[k][0];
​        Vertex[k][0]&#x3D;Vertex[i][0];
​        Vertex[i][0]&#x3D;temp;
​        temp&#x3D;Vertex[k][1];
​        Vertex[k][1]&#x3D;Vertex[i][1];
​        Vertex[i][1]&#x3D;temp;
​    }
​    &#x2F;&#x2F;y值中等的两点按x值排序
​    if(Vertex[1][0]&lt;Vertex[2][0])
​    {
​        temp&#x3D;Vertex[1][0];
​        Vertex[1][0]&#x3D;Vertex[2][0];
​        Vertex[2][0]&#x3D;temp;
​        temp&#x3D;Vertex[2][1];
​        Vertex[2][1]&#x3D;Vertex[1][1];
​        Vertex[1][1]&#x3D;temp;
​    }</p>
<p>​<br>​    if(Vertex[0][0]&amp;&amp; Vertex[0][1]&amp;&amp;Vertex[1][0]&amp;&amp;Vertex[1][1]&amp;&amp;Vertex[3][0]&amp;&amp; Vertex[3][1]&amp;&amp;Vertex[2][0]&amp;&amp; Vertex[2][1])
​    {
​        sprintf(m,”#k%03dl%03dm%03dn%03do%03dp%03dq%03dr%03d$\n”, Vertex[0][0], Vertex[0][1],Vertex[1][0], Vertex[1][1],Vertex[3][0], Vertex[3][1],Vertex[2][0], Vertex[2][1]);
​        u.sendUart(m);
​    }</p>
<p><strong>观察任意矩形顶点坐标规律，要顺时针发送，可将y值最小的作为第一个发送，y值最大的第三个发送，介于中间的两点按x值大小判断，x小的最后发送，大的第二个发送</strong></p>
<p>即先整体按y值大小排序，y值中等的两点按x值排序-&gt;排序后按<strong>0<del>1</del>3~2的顺序</strong> 发送坐标</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png"></p>
<h6 id="3-区分红绿激光"><a href="#3-区分红绿激光" class="headerlink" title="(3)区分红绿激光"></a>(3)区分红绿激光</h6><p><strong>过程如下：</strong></p>
<p>​<br>​    Point color_recognite(Mat image, Scalar Low, Scalar High)
​    {
​<br>        vector&lt;vector<Point>&gt; g_vContours;
        vector<Vec4i> g_vHierarchy;
        vector<Mat> hsvSplit;
        double maxarea &#x3D; 0;
        int maxAreaIdx &#x3D; 0;
        Mat g_grayImage, hsv, g_cannyMat_output;</p>
<pre><code>    cvtColor(image, hsv, COLOR_BGR2HSV);
    split(hsv, hsvSplit);
    equalizeHist(hsvSplit[2], hsvSplit[2]);
    merge(hsvSplit, hsv);
    inRange(hsv, Low, High, g_grayImage);//二值化识别颜色

    //开操作 (去除一些噪点)
    Mat element = getStructuringElement(MORPH_RECT, Size(2, 2));
    morphologyEx(g_grayImage, g_grayImage, MORPH_OPEN, element);

    //闭操作 (连接一些连通域)
    morphologyEx(g_grayImage, g_grayImage, MORPH_CLOSE, element);
    //  Canny(g_grayImage, g_cannyMat_output, 80, 80 * 2, 3);

    // 寻找轮廓
    findContours(g_grayImage, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));

    //假设contours是用findContours函数所得出的边缘点集
    RotatedRect box;
    Point centre;

    if (g_vContours.size() != 0)
    &#123;
        for (int index = 0; index &lt; g_vContours.size(); index++)
        &#123;
            double tmparea = fabs(contourArea(g_vContours[index]));
            if (tmparea &gt; maxarea)
            &#123;
                maxarea = tmparea;
                maxAreaIdx = index;//记录最大轮廓的索引号
            &#125;
        &#125;

        box = minAreaRect(g_vContours[maxAreaIdx]);
        rectangle(image, box.boundingRect(), Scalar(0, 0, 255), 2);
        centre = box.center;
    &#125;
    return centre;
&#125;
</code></pre>
<p>关键是调用inRange()函数HSV色彩空间二值化的阈值上下限设置</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Home_Wood/article/details/88613977" title="OpenCV学习笔记-inRange()阈值操作函数怎么用_cv.inrange函数">OpenCV学习笔记-
inRange()阈值操作函数怎么用_cv.inrange函数</a></p>
<p>并设置滑动条调整参数获得经验值</p>
<p><strong>最终评判标准：</strong></p>
<p>激光在绝缘胶布上是能否识别（黑色胶布吸光；通过提高曝光，调参，增大激光功率等可以解决）</p>
<p>红绿激光靠近时能否区分（红绿在HSC空间互斥，更亮的会掩盖另一个；调inRange()参数解决）</p>
<h2 id="二-学习资料分享"><a href="#二-学习资料分享" class="headerlink" title="二.学习资料分享"></a>二.学习资料分享</h2><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="&lt;1&gt;学习笔记"></a>&lt;1&gt;学习笔记</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797?spm=1001.2014.3001.5501" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-
CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697?spm=1001.2014.3001.5501" title="图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-CSDN博客">图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-
CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991?spm=1001.2014.3001.5501" title="图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-CSDN博客">图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-
CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?spm=1001.2014.3001.5501" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-CSDN博客">图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-
CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041?spm=1001.2014.3001.5501" title="图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-CSDN博客">图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-
CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399?spm=1001.2014.3001.5501" title="PID控制算法理解_switch_swq的博客-CSDN博客">PID控制算法理解_switch_swq的博客-
CSDN博客</a></p>
<h3 id="其他资料"><a href="#其他资料" class="headerlink" title="&lt;2&gt;其他资料"></a>&lt;2&gt;其他资料</h3><p>1.<a target="_blank" rel="noopener" href="https://space.bilibili.com/28143041/?spm_id_from=333.999.0.0" title="唐老师讲电赛的个人空间-唐老师讲电赛个人主页-哔哩哔哩视频">唐老师讲电赛的个人空间-唐老师讲电赛个人主页-
哔哩哔哩视频</a></p>
<p>2.电赛资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ehPdgMU8T16tcQXeLU1xaQ?pwd=1234#list/path=%2F" title="电赛资料_免费高速下载|百度网盘-分享无限制 (baidu.com)">电赛资料_免费高速下载|百度网盘-分享无限制
(baidu.com)</a>提取码：1234</p>
<p>3.我的“电赛”、“VS Studio”、“cmake”、“opencv”、“makefile”、“linux、操作系统”、“stm32”收藏夹</p>
<p>3.以及上面笔记中所包含信息</p>
<h2 id="三-备赛阶段记录"><a href="#三-备赛阶段记录" class="headerlink" title="三.备赛阶段记录"></a><strong>三.备赛阶段记录</strong></h2><p>7.2.2023</p>
<ul>
<li>问题 <ol>
<li>Nano板子供电5v4A，需求电流较大</li>
<li>实验室现有开关电源模块似乎调不了5v，需自己设计电源模块</li>
<li>作为底层主要负责，如何为项目打下坚实基础</li>
<li>硬件使用有明确目标，如何学习</li>
</ol>
</li>
<li>解决 <ol>
<li>先不考虑电源模块，用适配器及直流电源供电</li>
<li>先把电机控制写好，提供友善接口</li>
<li>先用简单硬件过度，后期转高级的。如电机先用直流后用伺服。先拼起来，再细化雕琢</li>
</ol>
</li>
<li>收获 <ol>
<li>用vscode远程开发jetson，下载remote-ssh插件，ssh jetson@IP地址；快捷键ctrl+o调出要打开页面</li>
</ol>
</li>
</ul>
<p>7.3.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32很多知识忘记，如定时器和A&#x2F;D、D&#x2F;A；是否需要复习，因复习耗时且不一定需要stm32</li>
<li>目前目标尚不明确</li>
</ol>
</li>
<li>解决 <ol>
<li>先将stm32相关知识看完，stm32作为保底</li>
<li>先搭一个蓝牙遥控小车！</li>
</ol>
</li>
<li>收获 <ol>
<li>修好了学长的小车，看到了PID实现双轮平衡小车的现象</li>
<li>学会了MG995型号舵机控制（控制脉冲占空比实现角度控制）</li>
<li>搭建了测试平台（OLED屏、蓝牙、i2c通讯）</li>
<li>搭建了简单的两轮遥控小车，采用直流电机控制，未加入PWM波调速，实现简单的前进、倒退、转弯。</li>
</ol>
</li>
</ul>
<p>7.4.2023</p>
<ul>
<li>问题 <ol>
<li>昨天做的小车电源直接冒烟，因为电源采用两节3.7V锂电池供电，buck升压到12V以匹配LM298N，电流过大</li>
</ol>
</li>
<li>解决 <ol>
<li>暂时给l298n提供5V电压，驱动能力下降，但系统可以运行。以后电源模块之后重新设计或使用小功率电机</li>
</ol>
</li>
<li>收获 <ol>
<li>主要将昨天搭好的小车完善，并加入了测压模块（利用STM32的ADC外设）</li>
<li>复习了stm32相关知识（外部中断，定制器TIM设置，定时器比较OC产生PWM波）</li>
<li>打开了jetson nano的摄像头，它睁开了眼</li>
</ol>
</li>
</ul>
<p>7.5.2023</p>
<ul>
<li>问题 <ol>
<li>编码器旋转无响应，电机也不动了</li>
<li>烧了一个stm32板子，当时接的自制稳压模块，之前都是好的，不知道什么原因</li>
</ol>
</li>
<li>解决 <ol>
<li>重新测试电机是否能正常工作</li>
<li>在小车到达前有时间学习MPU6050，相关姿态轨迹传输算法</li>
</ol>
</li>
<li>收获 <ol>
<li>在jetson nano上跑了例程及自己上传的几张图片</li>
<li>学会了linux的vim的使用</li>
<li>复习了stm32相关知识（定时器IC输入捕获模式）</li>
<li>学会了超声波测距CS100A模块和红外传感模块以及电机编码器部分</li>
</ol>
</li>
</ul>
<p>7.6.2023</p>
<ul>
<li>问题 <ol>
<li>如何解决电机编码器输出波形峰值小，stm32无法接收</li>
<li>Pwm波和电源需供电，不然波形失真</li>
</ol>
</li>
<li>解决 <ol>
<li>昨天电机不转是因为接线不紧，编码器不行是因为输出电压太小，只有0.5v左右</li>
<li>考虑IO口输出模式，不行加电压比较器，ref&#x3D;0.33V</li>
<li>要重新系统性设计电源了，所有信号共地！</li>
</ol>
</li>
<li>收获 <ol>
<li>拼好了大车，发现了诸多问题，舵机控制程序完成</li>
<li>浅浅学了PCB绘制流程</li>
</ol>
</li>
</ul>
<p>7.7.2023</p>
<ul>
<li>问题 <ol>
<li>控制函数太过简陋，后续仍需不断升级</li>
<li>图像识别进度为零</li>
</ol>
</li>
<li>解决 <ol>
<li>《基于opencv的数字图像处理技术》</li>
</ol>
</li>
<li>收获 <ol>
<li>用洞洞板搭建好了电源系统（12V-5V-3.7V），系统完全移植到大车</li>
<li>新车编码器输出足够大，无需放大器，编码器计数正常</li>
</ol>
</li>
</ul>
<p>7.8.2023</p>
<ul>
<li>收获 <ol>
<li>学会在Windows配置OpenCV环境，掌握OpenCV图像视频基本操作以及一些基础知识</li>
<li>PCB绘制进展</li>
</ol>
</li>
</ul>
<p>7.9.2023</p>
<ul>
<li>收获 <ol>
<li>学会在linux中运行调用OpenCV的c++文件（cmake的使用）</li>
<li>学习OpenCV基本数据结构和类的使用</li>
<li>进一步了解VS studio上编译选项配置以及debug和release的区别</li>
</ol>
</li>
</ul>
<p>7.10.2023</p>
<ul>
<li>收获 <ol>
<li>学会OpenCV灰度变换、直方图、边缘检测、霍夫检测直线和圆</li>
</ol>
</li>
</ul>
<p>7.11.2023</p>
<ul>
<li>问题 <ol>
<li>源码在linux上无法运行（OpenCV调用摄像头出问题，采用CMake方法编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>今天下午加晚上未解决</li>
</ol>
</li>
<li>收获 <ol>
<li>学会阈值分割（图像二值化方法）</li>
</ol>
</li>
</ul>
<p>7.12.2023</p>
<ul>
<li>问题 <ol>
<li>C++无法编译成功，Mat类未定义引用（QT上编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>使用python编写运行成功</li>
</ol>
</li>
<li>收获 <ol>
<li>看完特征提取和目标检测（HOG特征+SVM基本流程；LBP特征+级联分类器）</li>
</ol>
</li>
</ul>
<p>7.13.2023</p>
<ul>
<li>问题 <ol>
<li>依旧无法运行以C++运行OpenCV代码</li>
<li>可以运行的OpenCV代码不能直接以videocapture capture(0)的方法获取视频流</li>
</ol>
</li>
<li>解决 <ol>
<li>重新系统性安装OpenCV库并重走CMake流程</li>
<li>将视频流通过管道gstreamer传输</li>
</ol>
</li>
<li>收获 <ol>
<li>学会CMake以及基本编译链接流程</li>
<li>重新安装配置OpenCV4.8.0，成功在jetson nano上运行OpenCV代码</li>
</ol>
</li>
</ul>
<p>7.14.2023</p>
<ul>
<li>问题 <ol>
<li>但运行自己编写的直线检测程序过于卡顿，一秒一帧</li>
<li>蓝牙模块无法正常工作</li>
</ol>
</li>
<li>解决 <ol>
<li>霍夫直线检测运算量大，不使用该算法</li>
<li>调整视频大小及帧率</li>
<li>经检测应是蓝牙模块问题，重新购买</li>
</ol>
</li>
<li>收获 <ol>
<li>使用画好的pcb搭建小车，将全部器件搭载在小车上</li>
</ol>
</li>
</ul>
<p>7.15.2023</p>
<ul>
<li>问题 <ol>
<li>电机控制出错，一边电机不受控制</li>
<li>目前控制算法学的太少，但图像识别进展不够</li>
</ol>
</li>
<li>解决 <ol>
<li>GPIO口选到了下载口JTDI&#x2F;O，换GPIO口控制</li>
<li>先用超声波模块、MPU6050、红外传感等模块写避障、路径记录、寻迹等功能</li>
</ol>
</li>
<li>收获 <ol>
<li>学会jetson nano上的GPIO使用（基本和树莓派一样）</li>
<li>解决了电机的基本控制问题并将电机的四控制线改成了两根</li>
<li>jetson使用电池供电（器件全供地）；实现stm32与jetson nano的usart通信（照搬蓝牙）</li>
</ol>
</li>
</ul>
<p>7.16.2023</p>
<ul>
<li>问题 <ol>
<li>超声波测距模块中断代码写的不好，拔下模块进入while循环等待，系统卡住</li>
<li>拉肚子</li>
</ol>
</li>
<li>解决 <ol>
<li>使用static变量，进入中断模式改为EXTI_Trigger_Rising_Falling…</li>
<li>休息一天（今日中午至明天中午）</li>
</ol>
</li>
</ul>
<p>7.17.2023</p>
<ul>
<li>问题 <ol>
<li>欲添加mpu6050模块，但其与oled、蓝牙、超声波模块冲突（非引脚分配问题）</li>
</ol>
</li>
<li>解决 <ol>
<li>更改方案，debug试试。仍不行</li>
</ol>
</li>
</ul>
<p>7.18.2023</p>
<ul>
<li>问题 <ol>
<li>昨天问题仍然存在</li>
<li>多个中断之间不协调，影响超声波测距精度。以及测角度过于耗时</li>
</ol>
</li>
<li>解决 <ol>
<li>使用江科大自动化的例程代码，简洁明了，解决冲突</li>
<li>更改各个中断优先级，控制mpu6050的使用</li>
</ol>
</li>
<li>收获</li>
</ul>
<p>7.19.2023</p>
<ul>
<li>收获 <ol>
<li>学会PID算法</li>
<li>重新绘制PCB，解决若干问题</li>
</ol>
</li>
</ul>
<p>7.20.2023</p>
<ul>
<li>问题 <ol>
<li>SysTick定时器冲突问题（外部和中断同时调用delay_us函数会卡死）</li>
</ol>
</li>
<li>解决 <ol>
<li>避免了0.1s定时器中断（数据刷新）的SysTick定时函数</li>
</ol>
</li>
<li>收获 <ol>
<li>使用编码器利用PID编写行驶给定长度函数及测速</li>
</ol>
</li>
</ul>
<p>7.21.2023</p>
<ul>
<li>问题 <ol>
<li>后退时编码器反向计数，上限不明确，速度测算出现问题</li>
</ol>
</li>
<li>解决 <ol>
<li>通过TIM_EncoderInterfaceConfig设置编码器反转依旧向上计数</li>
</ol>
</li>
<li>收获 <ol>
<li>编写小车倒车定长距离</li>
</ol>
</li>
</ul>
<p>7.22.2023</p>
<ul>
<li>收获 <ol>
<li>编写小车以恒定速度行驶和拐弯90度算法</li>
</ol>
</li>
</ul>
<p>7.23.2023</p>
<ul>
<li>收获 <ol>
<li>焊好新到的板子</li>
</ol>
</li>
</ul>
<p>7.24.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson配置难，yolo难跑通</li>
<li>要求设计完整程序，在jetson开机时自动执行</li>
</ol>
</li>
<li>解决 <ol>
<li>学习OpenCV备用</li>
<li>学习python或c++可执行文件Linux开机自动执行方法</li>
</ol>
</li>
</ul>
<p>7.25.2023</p>
<ul>
<li>问题 <ol>
<li>采用硬盘直接克隆方式克隆SD卡依旧无法启动jetson nano系统</li>
</ol>
</li>
<li>解决 <ol>
<li>烧录官方镜像文件，成功还原系统。并发现python和C++环境已经配好，之前不会用。解决yolov5摄像头实时检测问题，方案参考亚博论坛。C++也是，g++编译时加上一个参数就行</li>
</ol>
</li>
</ul>
<p>7.26.2023</p>
<ul>
<li>收获 <ol>
<li>看今年电赛器件清单，简单编写完云台代码，购买K210等器材</li>
</ol>
</li>
</ul>
<p>7.27.2023</p>
<ul>
<li>收获 <ol>
<li>简单编写完红外寻迹功能</li>
<li>解决nano开机启动python文件</li>
</ol>
</li>
</ul>
<p>7.28.2023</p>
<ul>
<li>问题 <ol>
<li>分析电赛清单，云台摄像头加激光笔应该涉及到动态物体追踪</li>
</ol>
</li>
<li>解决 <ol>
<li>学习视频目标跟踪</li>
</ol>
</li>
</ul>
<p>7.29.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32定时器资源有限无法满足云台的加入</li>
</ol>
</li>
<li>解决 <ol>
<li>使用pca9685驱动</li>
</ol>
</li>
<li>收获 <ol>
<li>采用stm32管脚重定义解决pca9685驱动的使用问题</li>
</ol>
</li>
</ul>
<p>7.30.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson nano的C++库不包含串口uart相关内容</li>
</ol>
</li>
<li>解决 <ol>
<li>使用其设备&#x2F;dev&#x2F;tthTSH1，研究网上代码</li>
</ol>
</li>
<li>收获 <ol>
<li>编写以及pca9685控制云台函数</li>
</ol>
</li>
</ul>
<p>7.31.2023</p>
<ul>
<li>问题 <ol>
<li>霍夫圆检测一定也不稳定</li>
</ol>
</li>
<li>解决 <ol>
<li>调整参数或使用深度学习识别物体的方法</li>
</ol>
</li>
<li>收获 <ol>
<li>终于解决串口通信问题，实现C++语言的nano和电脑以及stm32通信</li>
<li>完善霍夫圆检测代码，加入uart传输圆心坐标</li>
<li>学会nano开机自启动程序方法</li>
<li>编写stm32的PID点跟踪函数，实现点跟踪</li>
</ol>
</li>
</ul>
<p>8.1.2023</p>
<ul>
<li>问题 <ol>
<li>走定长不精确，大约是设定5cm行驶6cm这个比例</li>
</ol>
</li>
<li>收获 <ol>
<li>编写摇杆控制云台程序</li>
<li>发现之前使用的pid算法全犯了低级错误，本应用float定义PID值结果用了int，修改后大范围应用，各个控制加入PID平稳精确了很多</li>
</ol>
</li>
</ul>
<h2 id="四-电赛总结及经验教训"><a href="#四-电赛总结及经验教训" class="headerlink" title="四.电赛总结及经验教训"></a>四.电赛总结及经验教训</h2><h3 id="本次比赛作品的不足、改进之处"><a href="#本次比赛作品的不足、改进之处" class="headerlink" title="&lt;1&gt;本次比赛作品的不足、改进之处"></a>&lt;1&gt;本次比赛作品的不足、改进之处</h3><p>1.stm32和jetson
nano通讯不稳定（可能原因：杜邦线传输能力差、波特率可能设置高了【但低了影响系统处理速度】）（实际原因：while写成了if，导致时机很难对上，通信规则设计失误！）</p>
<p>2.stm32主函数设计不行，没花时间改进，想要重复运行某个程序只能重启，人机交互也不友好</p>
<p>3.比赛报告没有在头脑风暴之后就开始写，导致后期书写太急，不够规范</p>
<p>4.linux操作不熟，开机自启动程序出现问题，且jetson nano上的程序设计缺乏系统性结构性（每问都写了一个程序，而不是整合成一个大的测试程序）</p>
<p>5.所有任务完成太晚，没有留下时间仔细调试调参找问题。而且全流程过一遍后立马就要封箱了，急急忙忙乱改代码导致出现了<strong>意想不到的错误！再给一天就刚好了啊！！！</strong></p>
<h3 id="本次比赛的经验教训"><a href="#本次比赛的经验教训" class="headerlink" title="&lt;2&gt;本次比赛的经验教训"></a>&lt;2&gt;本次比赛的经验教训</h3><p>1.器件准备很重要：比赛发布器件清单后要备齐，最好每个器件都多买几个。以满足比赛器件需求并防止比赛时器件损坏！（本次比赛oled屏、舵机都反复坏过）</p>
<p>2.器件精度很重要：比赛前统计自己所有器件清单，并实测是否可以使用？精度如何？硬件精度不足会直接导致结果无法满足！（本次比赛刚开始使用的舵机为20kg大扭矩低精度，调了一晚PID参数舵机仍然运动不准，最后才发现是精度问题）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132150694">https://blog.csdn.net/qq_32971095/article/details/132150694</a>，如有侵权，请联系删除。</p>

    </div>

    
    
    

    
      <div>
        
<div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">
            <center><i>> --------------- THE END -------------- <</i></center>
        </div>
    
</div>
      </div>
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/stm32/" rel="tag"># stm32</a>
              <a href="/tags/opencv/" rel="tag"># opencv</a>
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/" rel="tag"># 嵌入式硬件</a>
              <a href="/tags/ubuntu/" rel="tag"># ubuntu</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%E2%80%94%E2%80%94PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" rel="prev" title="电赛学习笔记(5)——PID控制算法理解">
      <i class="fa fa-chevron-left"></i> 电赛学习笔记(5)——PID控制算法理解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/" rel="next" title="FPGA学习笔记(1)——FPGA基本概念及资源整理">
      FPGA学习笔记(1)——FPGA基本概念及资源整理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">一.2023年E题完整设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">&lt;1&gt;选择方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">任务一：实现按键按下复位（基础部分）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">任务二：实现激光点绕边框一周（基础部分）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">任务三：实现激光点绕A4纸边缘一周（基础部分）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">任务四：实现绿色激光追踪红色激光（发挥部分）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D"><span class="nav-number">3.</span> <span class="nav-text">&lt;2&gt;任务分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">&lt;3&gt;代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">1.stm32上关键源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#I-%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86"><span class="nav-number">4.1.1.</span> <span class="nav-text">I.基本部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#II-%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">II.模块代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">(1)Timer——定时器延时函数模块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-servo-motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">(2)servo_motor——云台舵机控制模块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">①控制舵机的旋转</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">②控制激光点到达某一像素点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson-nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87"><span class="nav-number">4.1.2.5.</span> <span class="nav-text">③与上位机jetson nano通讯接收点坐标</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC"><span class="nav-number">4.1.2.6.</span> <span class="nav-text">④得到一点坐标对应的舵机pwm波OC值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF"><span class="nav-number">4.1.2.7.</span> <span class="nav-text">⑤控制激光点沿四边形巡线</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#III-%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">III.主函数与中断函数部分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">(1)红色激光云台</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">(2)绿色激光云台</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-jetson-nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">2.jetson nano上关键源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#I-%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-number">4.2.1.</span> <span class="nav-text">I.相机参数的调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#II-%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.2.</span> <span class="nav-text">II.关键识别算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">(1)铅笔线识别及顶点的计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">(2)A4纸顶点识别及巡线顶点的计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">(3)区分红绿激光</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB"><span class="nav-number"></span> <span class="nav-text">二.学习资料分享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">&lt;1&gt;学习笔记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99"><span class="nav-number">2.</span> <span class="nav-text">&lt;2&gt;其他资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95"><span class="nav-number"></span> <span class="nav-text">三.备赛阶段记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD"><span class="nav-number"></span> <span class="nav-text">四.电赛总结及经验教训</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84"><span class="nav-number">1.</span> <span class="nav-text">&lt;1&gt;本次比赛作品的不足、改进之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD"><span class="nav-number">2.</span> <span class="nav-text">&lt;2&gt;本次比赛的经验教训</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description">舟遥遥以轻扬，风飘飘而吹衣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">216</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qm.qq.com/q/fJkfzkochO" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;q&#x2F;fJkfzkochO" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/348651384" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;348651384" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/profiles/76561199188319035/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;profiles&#x2F;76561199188319035&#x2F;" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://c6.y.qq.com/base/fcgi-bin/u?__=sZVdegbNTeC3" title="Music → https:&#x2F;&#x2F;c6.y.qq.com&#x2F;base&#x2F;fcgi-bin&#x2F;u?__&#x3D;sZVdegbNTeC3" rel="noopener" target="_blank"><i class="fa fa-music fa-fw"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1309889000&auto=1&height=66"></iframe>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-8 ~ 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

<script src="/js/floating-history.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'H2FYHQwVGaUkawg5DkrA6d6M-gzGzoHsz',
      appKey     : 'zndS0u9Qj7qj8CqnJINs2MGT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://h2fyhqwv.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>
