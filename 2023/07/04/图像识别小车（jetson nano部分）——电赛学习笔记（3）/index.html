<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录 零.前言 1.jetsonnano购买商家及技术支持 2.相关环境配置 3.做好系统备份 一.vscode远程ssh操作 &lt;1&gt;局域网连接 &lt;2&gt;电脑直连 &lt;3&gt;电脑直连+VNC远程桌面 二.板载摄像头教程： 三.运行例程 四.GPIO使用 GPIO库的API用法 1.导入库 2.引脚编号 3.警告 4.设置通道 5.输入 6.输出 set first c">
<meta property="og:type" content="article">
<meta property="og:title" content="图像识别小车（jetson nano部分）——电赛学习笔记（3）">
<meta property="og:url" content="http://example.com/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:description" content="目录 零.前言 1.jetsonnano购买商家及技术支持 2.相关环境配置 3.做好系统备份 一.vscode远程ssh操作 &lt;1&gt;局域网连接 &lt;2&gt;电脑直连 &lt;3&gt;电脑直连+VNC远程桌面 二.板载摄像头教程： 三.运行例程 四.GPIO使用 GPIO库的API用法 1.导入库 2.引脚编号 3.警告 4.设置通道 5.输入 6.输出 set first c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/938609aaeb57355774c771bab4569295.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/6af7567db40ef98ffaec08066206ca83.png">
<meta property="article:published_time" content="2023-07-04T14:30:36.000Z">
<meta property="article:modified_time" content="2025-02-08T03:45:06.147Z">
<meta property="article:author" content="SWQ">
<meta property="article:tag" content="None">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png">

<link rel="canonical" href="http://example.com/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>图像识别小车（jetson nano部分）——电赛学习笔记（3） | Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图像识别小车（jetson nano部分）——电赛学习笔记（3）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 22:30:36" itemprop="dateCreated datePublished" datetime="2023-07-04T22:30:36+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p>
<p><a href="about:blank#1.jetson%20nano%E8%B4%AD%E4%B9%B0%E5%95%86%E5%AE%B6%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81">1.jetson<br>nano购买商家及技术支持</a></p>
<p><a href="about:blank#2.%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2.相关环境配置</a></p>
<p><a href="about:blank#3.%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD">3.做好系统备份</a></p>
<p><a href="about:blank#%E4%B8%80.vscode%E8%BF%9C%E7%A8%8Bssh%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5%EF%BC%89">一.vscode远程ssh操作</a></p>
<p><a href="about:blank#%3C1%3E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5">&lt;1&gt;局域网连接</a></p>
<p><a href="about:blank#%3C2%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E">&lt;2&gt;电脑直连</a></p>
<p><a href="about:blank#%3C3%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E%2BVNC%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">&lt;3&gt;电脑直连+VNC远程桌面</a></p>
<p><a href="about:blank#%E4%BA%8C.%E6%9D%BF%E8%BD%BD%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%99%E7%A8%8B%EF%BC%9A">二.板载摄像头教程：</a></p>
<p><a href="about:blank#%E4%B8%89.%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B">三.运行例程</a></p>
<p><a href="about:blank#%E5%9B%9B.GPIO%E4%BD%BF%E7%94%A8">四.GPIO使用</a></p>
<p><a href="about:blank#GPIO%E5%BA%93%E7%9A%84API%E7%94%A8%E6%B3%95">GPIO库的API用法</a></p>
<p><a href="about:blank#1.%E5%AF%BC%E5%85%A5%E5%BA%93">1.导入库</a></p>
<p><a href="about:blank#2.%E5%BC%95%E8%84%9A%E7%BC%96%E5%8F%B7">2.引脚编号</a></p>
<p><a href="about:blank#3.%E8%AD%A6%E5%91%8A">3.警告</a></p>
<p><a href="about:blank#4.%E8%AE%BE%E7%BD%AE%E9%80%9A%E9%81%93">4.设置通道</a></p>
<p><a href="about:blank#5.%E8%BE%93%E5%85%A5">5.输入</a></p>
<p><a href="about:blank#6.%E8%BE%93%E5%87%BA">6.输出</a></p>
<p><a href="about:blank#set%20first%20channel%20to%20HIGH%20and%20rest%20to%20LOW">set first channel to HIGH and rest to<br>LOW</a></p>
<p><a href="about:blank#7.%E6%B8%85%E7%90%86">7.清理</a></p>
<p><a href="about:blank#8.jetson%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E5%92%8C%E5%BA%93%E7%89%88%E6%9C%AC">8.jetson模块信息和库版本</a></p>
<p><a href="about:blank#9.%E4%B8%AD%E6%96%AD">9.中断</a></p>
<p><a href="about:blank#wait_for_edge%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">wait_for_edge（）函数</a></p>
<p><a href="about:blank#timeout%20is%20in%20milliseconds">timeout is in milliseconds</a></p>
<p><a href="about:blank#event_detected%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">event_detected（）函数</a></p>
<p><a href="about:blank#set%20rising%20edge%20detection%20on%20the%20channel">set rising edge detection on the<br>channel</a></p>
<p><a href="about:blank#%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E8%BE%B9%E7%BC%98%E6%97%B6%E8%BF%90%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">当检测到边缘时运行回调函数</a></p>
<p><a href="about:blank#define%20callback%20function">define callback function</a></p>
<p><a href="about:blank#add%20rising%20edge%20detection">add rising edge detection</a></p>
<p><a href="about:blank#bouncetime%20set%20in%20milliseconds">bouncetime set in<br>milliseconds</a></p>
<p><a href="about:blank#10.%E6%A3%80%E6%9F%A5GPIO%E9%80%9A%E9%81%93%E7%9A%84%E5%8A%9F%E8%83%BD">10.检查GPIO通道的功能</a></p>
<p><a href="about:blank#11.%20PWM">11. PWM</a></p>
<p><a href="about:blank#%E4%BA%94.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1">五.串口通信</a></p>
<p><a href="about:blank#%3C1%3EUART">&lt;1&gt;UART</a></p>
<p><a href="about:blank#1.python%E4%BB%A3%E7%A0%81%EF%BC%9AJetsonHacksNano%2FUARTDemo%3A%20UART%20Demo%20Code%20%28github.com%29">1.python代码：JetsonHacksNano&#x2F;UARTDemo: UART Demo Code<br>(github.com)</a></p>
<p><a href="about:blank#3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点</a></p>
<p><a href="about:blank#2.C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%9AUart%20c%2B%2B%20class%20for%20Nvidia%20Jetson%20Nano">2.C++代码：Uart c++ class for Nvidia Jetson<br>Nano</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%9C%A8jetson%20nano%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV">六.在jetson<br>nano上使用OpenCV</a></p>
<p><a href="about:blank#%E4%B8%83.jetson%20nano%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">七.jetson<br>nano开机自启动程序</a></p>
<p><a href="about:blank#%E5%85%AB.%E5%AE%9E%E6%88%98%E7%A8%8B%E5%BA%8F">八.实战程序</a></p>
<p><a href="about:blank#1.jetson%20nano%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%B0%86%E5%9C%86%E5%BF%83%E5%9D%90%E6%A0%87%E9%80%9A%E8%BF%87uart%E4%BC%A0%E7%BB%99stm32">1.jetson<br>nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</a></p>
<hr>
<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><h5 id="1-jetson-nano购买商家及技术支持"><a href="#1-jetson-nano购买商家及技术支持" class="headerlink" title="1.jetson nano购买商家及技术支持"></a><strong>1.jetson nano购买商家及技术支持</strong></h5><p>***<strong>选购亚博，支持相关开源资料，资料网址：<a target="_blank" rel="noopener" href="https://www.yahboom.com/study/jetson-nano" title="JETSON NANO B01
(yahboom.com)">JETSON NANO B01<br>(yahboom.com)</a></strong></p>
<p>***<strong>常见问题及解答：<a target="_blank" rel="noopener" href="https://www.yuque.com/yahboomtechnology/yahboom_support/kgdd5m#NLt6t" title="Jetson nano A01&#x2F;B01 (yuque.com)">Jetson nano A01&#x2F;B01<br>(yuque.com)</a></strong></p>
<h5 id="2-相关环境配置"><a href="#2-相关环境配置" class="headerlink" title="2.相关环境配置"></a>2.相关环境配置</h5><p>&lt;1&gt;亚博已经在SD卡中将环境配好，插上即可直接使用</p>
<p>&lt;2&gt;***<strong>自行烧录镜像，配置环境</strong> ：</p>
<p>下载之前要格式化SD卡或者U盘，具体操作见“jetson—主板—2.Jetson Nano B01基础教程”，然后烧录镜像文件：</p>
<p>亚博资料里的 “jetson—主板—附录—镜像” 包含**<code>已安装：</code>**</p>
<p><strong><code>CUDA10.2、CUDNNv8、tensorRT、opencv4.1.1、python2、python3、tensorflow2.3、jetpack4.6.1、yolov5、jetson- inference包（包括相关模型）、jetson-gpio库、安装pytorch1.8和torchvesion0.9、安装node v15.0.1、npm7.2.3，jupyter，已开启VNC服务，还有其他课程中所用到的模块。</code></strong></p>
<p>以及Swap空间配置，Jtop安装，只需要TF&#x2F;U盘扩容即可</p>
<p>减少自行配置的麻烦。</p>
<p>如果要从零开始自己配置，“jetson—主板—2.Jetson Nano B01基础教程” 和“4.系统基础设置教程”中包括了大部分操作，甚至包括空环境下载</p>
<h5 id="3-做好系统备份"><a href="#3-做好系统备份" class="headerlink" title="3.做好系统备份"></a>3.做好系统备份</h5><p>如果只是使用亚博官方提供的版本库，可以只用 “jetson—主板—附录—镜像”<br>中的镜像文件作为备份。如果自行配置了其他环境，建议备份系统，可在“jetson—主板—4.系统基础设置教程” 找到具体操作。</p>
<h2 id="一-vscode远程ssh操作"><a href="#一-vscode远程ssh操作" class="headerlink" title="一.vscode远程ssh操作"></a>一.vscode远程ssh操作</h2><h3 id="局域网连接"><a href="#局域网连接" class="headerlink" title="&lt;1&gt;局域网连接"></a>&lt;1&gt;局域网连接</h3><p>1.将jetson连接至路由器——电脑使用该路由wifi——打开VS Code——下载ssh-<br>remote插件——jetson上终端ifconfig查ip——vscode按格式输入：ssh<br>jetson@IP地址——输入密码登录（原始默认用户名为jetson，密码为yahboom）</p>
<p>2.crtl+o选择要打开的文件或侧栏资源管理器选择，文件可在主机写好直接拖入jetson；终端写入代码并操作</p>
<h3 id="电脑直连"><a href="#电脑直连" class="headerlink" title="&lt;2&gt;电脑直连"></a>&lt;2&gt;电脑直连</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15906550/5921556#:~:text=Jetson,Nano%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E6%9C%ACssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9CjetsonnanoSD%E5%8D%A1%E6%88%90%E5%8A%9F%E7%83%A7%E5%BD%95%E5%B9%B6%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B0%86Jetsonnano%E5%92%8C%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%BB%99%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8F%B3%E5%87%BBwlan%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E6%89%BE%E5%88%B0IP%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%89%93%E5%BC%80cmd%EF%BC%9Aarp-a%E8%BF%9E%E6%8E%A5ssh%E5%8D%B3%E5%8F%AF%E3%80%82" title="Jetson Nano——通过网线实现笔记本ssh远程连接">Jetson<br>Nano——通过网线实现笔记本ssh远程连接</a></p>
<h3 id="电脑直连-VNC远程桌面"><a href="#电脑直连-VNC远程桌面" class="headerlink" title="&lt;3&gt;电脑直连+VNC远程桌面"></a>&lt;3&gt;电脑直连+VNC远程桌面</h3><p>jetson nano上设置：[Jetson nano 通过 vnc<br>实现远程桌面控制（已在nano实现）](<a target="_blank" rel="noopener" href="https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171299147716800184169928&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171299147716800184169928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>top_positive~default-1-122121251-null-<br>null.142%5Ev100%5Epc_search_result_base9&amp;utm_term&#x3D;jetson%20nano%20vnc&amp;spm&#x3D;1018.2226.3001.4187<br>“Jetson nano 通过 vnc 实现远程桌面控制（已在nano实现）”)</p>
<p>下载VNC Viewer软件并连接（端口号参考&lt;2&gt;），效果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png"></p>
<p> 如果无法连接检查接口是否插好，如果成功会有一个不同于端口地址的地址：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/938609aaeb57355774c771bab4569295.png"></p>
<p>如果vnc server显示窗口过小，打开终端输入以下命令调整分辨率：</p>
<pre><code>xrandr --fb 1920x1080
</code></pre>
<h2 id="二-板载摄像头教程："><a href="#二-板载摄像头教程：" class="headerlink" title="二.板载摄像头教程："></a>二.板载摄像头教程：</h2><p><strong>获取摄像头相关参数：[linux查看摄像头分辨率参数](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20">https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20</a><br>–list-<br>devices%2F%2F%E9%80%9A%E8%BF%87v4l2%E6%9F%A5%E7%9C%8B%E6%91%84%E5%83%8F%E5%A4%B4%E8%AE%BE%E5%A4%87%20%2F%2F%E5%BD%93%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%91%84%E5%83%8F%E5%A4%B4%E6%97%B6%EF%BC%8C%E6%8C%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95,sudo%20rmmod%20uvcvideo%2F%2F%E7%A7%BB%E9%99%A4%E6%A8%A1%E5%9D%97%20sudo%20modprobe%20uvcvideo%20nodrop%3D1%20timeout%3D5000<br>“linux查看摄像头分辨率参数”)</strong></p>
<pre><code>Driver Info (not using libv4l2):
        Driver name   : tegra-video
        Card type     : vi-output, imx219 8-0010
        Bus info      : platform:54080000.vi:4
        Driver version: 4.9.255
        Capabilities  : 0x84200001
                Video Capture
                Streaming
                Extended Pix Format
                Device Capabilities
        Device Caps   : 0x04200001
                Video Capture
                Streaming
                Extended Pix Format
Priority: 2
Video input : 0 (Camera 4: ok)
Format Video Capture:
        Width/Height      : 3264/2464
        Pixel Format      : &#39;RG10&#39;
        Field             : None
        Bytes per Line    : 6528
        Size Image        : 16084992
        Colorspace        : sRGB
        Transfer Function : Default (maps to sRGB)
        YCbCr/HSV Encoding: Default (maps to ITU-R 601)
        Quantization      : Default (maps to Full Range)
        Flags             : 

Camera Controls

                     group_hold 0x009a2003 (bool)   : default=0 value=0 flags=execute-on-write
                    sensor_mode 0x009a2008 (int64)  : min=0 max=0 step=0 default=0 value=0 flags=slider
                           gain 0x009a2009 (int64)  : min=0 max=0 step=0 default=0 value=16 flags=slider
                       exposure 0x009a200a (int64)  : min=0 max=0 step=0 default=0 value=13 flags=slider
                     frame_rate 0x009a200b (int64)  : min=0 max=0 step=0 default=0 value=2000000 flags=slider
                    bypass_mode 0x009a2064 (intmenu): min=0 max=1 default=0 value=0
                override_enable 0x009a2065 (intmenu): min=0 max=1 default=0 value=0
                   height_align 0x009a2066 (int)    : min=1 max=16 step=1 default=1 value=1
                     size_align 0x009a2067 (intmenu): min=0 max=2 default=0 value=0
               write_isp_format 0x009a2068 (bool)   : default=0 value=0
       sensor_signal_properties 0x009a2069 (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
        sensor_image_properties 0x009a206a (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
      sensor_control_properties 0x009a206b (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
              sensor_dv_timings 0x009a206c (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
               low_latency_mode 0x009a206d (bool)   : default=0 value=0
               preferred_stride 0x009a206e (int)    : min=0 max=65535 step=1 default=0 value=0
                   sensor_modes 0x009a2082 (int)    : min=0 max=30 step=1 default=30 value=6 flags=read-only
</code></pre>
<p><strong>注意jetson nano要连接显示屏</strong></p>
<p>jetson@yahboom:&#x2F;home$ <strong>nvgstcapture-1.0  **                              **<br>&#x2F;&#x2F;打开摄像头命令</strong></p>
<p><strong>响应：</strong><br>Encoder null, cannot set bitrate!<br>Encoder Profile &#x3D; High<br>Supported resolutions in case of ARGUS Camera                      <strong>&#x2F;&#x2F;设置分辨率</strong><br>  (2) : 640x480<br>  (3) : 1280x720<br>  (4) : 1920x1080<br>  (5) : 2104x1560<br>  (6) : 2592x1944<br>  (7) : 2616x1472<br>  (8) : 3840x2160<br>  (9) : 3896x2192<br>  (10): 4208x3120<br>  (11): 5632x3168<br>  (12): 5632x4224</p>
<p>Runtime ARGUS Camera Commands:</p>
<p>  <strong>Help : ‘h’<br>  Quit : ‘q’</strong><br>  Set Capture Mode:<br>      mo:<val><br>          (1): image<br>          (2): video<br>  Get Capture Mode:<br>      gmo<br>  Set sensor orientation:<br>      so:<val><br>          (0): none<br>          (1): Rotate counter-clockwise 90 degrees<br>          (2): Rotate 180 degrees<br>          (3): Rotate clockwise 90 degrees<br>  Get sensor orientation:<br>      gso<br>  Set sensor mode:<br>      smo:<val> e.g., smo:1<br>  Get sensor mode:<br>      gsmo<br>  Set Whitebalance Mode:<br><strong>&#x2F;&#x2F;更改相机参数（曝光、饱和度等等）</strong><br>      wb:<val><br>          (0): off<br>          (1): auto<br>          (2): incandescent<br>          (3): fluorescent<br>          (4): warm-fluorescent<br>          (5): daylight<br>          (6): cloudy-daylight<br>          (7): twilight<br>          (8): shade<br>          (9): manual<br>  Get Whitebalance Mode:<br>      gwb<br>  Set Saturation (0 to 2):<br>      st:<val> e.g., st:1.25<br>  Get Saturation:<br>      gst<br>  Set Exposure Compensation (-2 to 2):<br>      ec:<val> e.g., ec:-2<br>  Get Exposure Compensation:<br>      gec<br>  Set Auto Whitebalance Lock:<br>      awbl:<val> e.g., awbl:0<br>  Get Auto Whitebalance Lock:<br>      awbl<br>  Set Auto Exposure Lock:<br>      ael:<val> e.g., ael:0<br>  Get Auto Exposure Lock:<br>      gael<br>  Set TNR Mode:<br>      tnrm:<val> e.g., tnrm:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get TNR Mode:<br>      gtnrm<br>  Set TNR Strength (-1 to 1):<br>      tnrs:<val> e.g., tnrs:0.5<br>  Get TNR Strength:<br>      gtnrs<br>  Set EE Mode:<br>      eem:<val> e.g., eem:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get EE Mode:<br>      geem<br>  Set EE Strength (-1 to 1):<br>      ees:<val> e.g., ees:0.5<br>  Get EE Strength:<br>      gees<br>  Set Auto Exposure Anti-Banding (0 to 3):<br>      aeab:<val> e.g., aeab:2<br>          (0): OFF<br>          (1): MODE AUTO<br>          (2): MODE 50HZ<br>          (3): MODE 60HZ<br>  Get Auto Exposure Anti-Banding:<br>      gaeab<br>  Set Gain Range:<br>      gr:<val><space><val> e.g., gr:1 16<br>  Get Gain Range:<br>      ggr<br>  Set Exposure Time Range:<br>      etr:<val><space><val> e.g., etr:34000 35000<br>  Get Exposure Time Range:<br>      getr<br>  Set ISP Digital Gain Range:<br>      dgr:<val><space><val> e.g., dgr:2 152<br>  Get ISP Digital Gain Range:<br>      gdgr<br>  <strong>Capture: enter ‘j’ OR<br>           followed by a timer (e.g., jx5000, capture after 5 seconds) OR<br>           followed by multishot count (e.g., j:6, capture 6 images)<br>           timer&#x2F;multihot values are optional, capture defaults to single shot with timer&#x3D;0s<br>  Start Recording : enter ‘1’<br>  Stop Recording  : enter ‘0’</strong><br>  Video <strong>snapshot</strong>  : enter ‘2’ (While recording video)<br>  Get Preview Resolution:<br>      gpcr<br>  Get Image Capture Resolution:<br>      gicr<br>  Get Video Capture Resolution:<br>      gvcr</p>
<p>Runtime encoder configuration options:</p>
<p>  Set Encoding Bit-rate(in bytes):<br>      br:<val> e.g., br:4000000<br>  Get Encoding Bit-rate(in bytes):<br>      gbr<br>  Set Encoding Profile(only for H.264):<br>      ep:<val> e.g., ep:1<br>          (0): Baseline<br>          (1): Main<br>          (2): High<br>  Get Encoding Profile(only for H.264):<br>      gep<br>  Force IDR Frame on video Encoder(only for H.264):<br>      Enter ‘f’ </p>
<p>bitrate &#x3D; 4000000<br>Encoder Profile &#x3D; High<br>Encoder control-rate &#x3D; 1<br>Encoder EnableTwopassCBR &#x3D; 0<br>Opening in BLOCKING MODE</p>
<p>摘自亚博教程：命令</p>
<ol>
<li>--prev_res 预览视屏的分辨率，高度和宽度，用的是CSI摄像头的话范围是 2 to 12 (5632x4224)</li>
</ol>
<p>e.g.,  nvgstcapture-1.0 –prev-res&#x3D;3</p>
<ol>
<li>--cus-prev-res 自定义预览分辨率，宽度和高度，仅支持CSI摄像头</li>
</ol>
<p>e.g., nvgstcapture-1.0 –cus-prev-res&#x3D;1920x1080</p>
<p>多个命令同时使用的话用！隔开</p>
<p>想关掉摄像头的额话，直接在终端输入q再按回车</p>
<p>想捕获图片的话，在终端输入j再按回车，图片将保存当前目录下</p>
<p><strong>关键参数的调整</strong> ：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h2 id="三-运行例程"><a href="#三-运行例程" class="headerlink" title="三.运行例程"></a>三.运行例程</h2><ul>
<li><p>MIPI CSI cameras (<code>csi://0</code>)</p>
</li>
<li><p>V4L2 cameras (<code>/dev/video0</code>)</p>
</li>
<li><p>RTP&#x2F;RTSP streams (<code>rtsp://username:password@ip:port</code>)</p>
<p>在&#x2F;home&#x2F;jetson&#x2F;jetson-inference&#x2F;build&#x2F;aarch64&#x2F;bin 中打开终端</p>
<p>输入示例(c++)(python 加.py即可)<br>.&#x2F;imagenet images&#x2F;orange_0.jpg images&#x2F;test&#x2F;output_0.jpg<br>.&#x2F;imagenet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;图像分类推理<br>.&#x2F;detectnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;目标检测推理<br>.&#x2F;segnet –network&#x3D;<model> csi:&#x2F;&#x2F;0           &#x2F;&#x2F;语义分割<br>.&#x2F;posenet &#x2F;dev&#x2F;video0                        &#x2F;&#x2F;姿态估计<br>.&#x2F;posenet –network&#x3D;resnet18-hand csi:&#x2F;&#x2F;0    &#x2F;&#x2F;手部姿态<br>.&#x2F;actionnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;动作识别<br>.&#x2F;backgroundnet csi:&#x2F;&#x2F;0                      &#x2F;&#x2F;背景去除<br>.&#x2F;depthnet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;单眼深度</p>
</li>
</ul>
<h2 id="四-GPIO使用"><a href="#四-GPIO使用" class="headerlink" title="四.GPIO使用"></a>四.GPIO使用</h2><p><strong>Python版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio" title="NVIDIA&#x2F;jetson-gpio: A
Python library that enables the use of Jetson&#39;s GPIOs">NVIDIA&#x2F;jetson-gpio: A Python library that enables the use of<br>Jetson’s GPIOs</a></p>
<p><strong>C++版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/pjueon/JetsonGPIO" title="pjueon&#x2F;JetsonGPIO: A C++
library that enables the use of Jetson&#39;s GPIOs">pjueon&#x2F;JetsonGPIO: A C++ library that enables the use of<br>Jetson’s GPIOs</a></p>
<h4 id="GPIO库的API用法"><a href="#GPIO库的API用法" class="headerlink" title="GPIO库的API用法"></a>GPIO库的API用法</h4><p>Jetson GPIO库提供了RPi.GPIO库提供的所有公共API。下面讨论每种API的用法：</p>
<h5 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h5><p>要导入Jetson.GPIO模块，请使用：</p>
<p>import Jetson.GPIO as GPIO</p>
<p>通过这种方式，您可以在应用程序的其余部分中将该模块称为GPIO。模块也可以使用RPi的名称导入。GPIO代替了Jetson。GPIO用于使用RPi库的现有代码。</p>
<h5 id="2-引脚编号"><a href="#2-引脚编号" class="headerlink" title="2.引脚编号"></a>2.引脚编号</h5><p>Jetson<br>GPIO库提供了四种给IO引脚编号的方法。前两个对应于RPi.GPIO库提供的模式，即BOARD和BCM，分别引用40引脚GPIO接头连接器的引脚号和Broadcom<br>SoC GPIO编号。其余两种模式CVM和TEGRA_SOC使用字符串代替数字，而数字分别对应于CVM CVB连接器和Tegra SoC上的信号名称。</p>
<p>要指定您正在使用哪种模式（强制性），请使用以下函数调用：</p>
<p>GPIO.setmode(GPIO.BOARD)# or</p>
<p>GPIO.setmode(GPIO.BCM)# or</p>
<p>GPIO.setmode(GPIO.CVM)# or</p>
<p>GPIO.setmode(GPIO.TEGRA_SOC)</p>
<p>要检查已设置的模式，可以调用：</p>
<p>mode &#x3D; GPIO.getmode()</p>
<p>该模式必须为GPIO.BOARD，GPIO.BCM，GPIO.CVM，GPIO.TEGRA_SOC或无。</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cynophile/article/details/99310678" title="Jetson Nano GPIO使用、四种模式以及串口解释">Jetson Nano<br>GPIO使用、四种模式以及串口解释</a></p>
<h5 id="3-警告"><a href="#3-警告" class="headerlink" title="3.警告"></a>3.警告</h5><p>您尝试使用的GPIO可能已在当前应用程序外部使用。在这种情况下，如果使用的GPIO配置为除默认方向（输入）以外的任何值，Jetson<br>GPIO库将向您发出警告。如果在设置模式和通道之前尝试清理，它也会警告您。要禁用警告，请使用：</p>
<p>GPIO.setwarnings(False)</p>
<h5 id="4-设置通道"><a href="#4-设置通道" class="headerlink" title="4.设置通道"></a>4.设置通道</h5><p>在用作输入或输出之前，必须先设置GPIO通道。要将通道配置为输入，请调用：</p>
<p>GPIO.setup(channel, GPIO.IN)</p>
<p>要将通道设置为输出，请调用：</p>
<p>GPIO.setup(channel, GPIO.OUT)</p>
<p>也可以为输出通道指定一个初始值：</p>
<p>GPIO.setup(channel, GPIO.OUT, initial&#x3D;GPIO.HIGH)</p>
<p>将一个通道设置为输出时，也可以一次设置多个通道：</p>
<p>channels &#x3D; [18, 12, 13]</p>
<p>GPIO.setup(channels, GPIO.OUT)</p>
<h5 id="5-输入"><a href="#5-输入" class="headerlink" title="5.输入"></a>5.输入</h5><p>要读取通道的值，请使用：</p>
<p>GPIO.input(channel)</p>
<p>这将返回GPIO.LOW或GPIO.HIGH。</p>
<h5 id="6-输出"><a href="#6-输出" class="headerlink" title="6.输出"></a>6.输出</h5><p>要设置配置为输出的引脚的值，请使用：</p>
<p>GPIO.output(channel, state)</p>
<p>状态可以是GPIO.LOW或GPIO.HIGH。</p>
<p>您还可以输出到频道列表或元组：</p>
<p>channels &#x3D; [18, 12, 13] # or use tuples</p>
<p>GPIO.output(channels, GPIO.HIGH) # or GPIO.LOW</p>
<h6 id="set-first-channel-to-HIGH-and-rest-to-LOW"><a href="#set-first-channel-to-HIGH-and-rest-to-LOW" class="headerlink" title="set first channel to HIGH and rest to LOW"></a>set first channel to HIGH and rest to LOW</h6><p>GPIO.output(channel, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH))</p>
<h5 id="7-清理"><a href="#7-清理" class="headerlink" title="7.清理"></a>7.清理</h5><p>在程序结束时，最好清理通道，以便将所有引脚设置为默认状态。要清理所有使用的通道，请使用：</p>
<p>GPIO.cleanup()</p>
<p>如果您不想清除所有通道，也可以清除单个通道或通道列表或元组：</p>
<p>GPIO.cleanup(chan1) # cleanup only chan1</p>
<p>GPIO.cleanup([chan1, chan2]) # cleanup only chan1 and chan2</p>
<p>GPIO.cleanup((chan1, chan2)) # does the same operation as previous statement</p>
<h5 id="8-jetson模块信息和库版本"><a href="#8-jetson模块信息和库版本" class="headerlink" title="8.jetson模块信息和库版本"></a>8.jetson模块信息和库版本</h5><p>要获取有关Jetson模块的信息，请使用&#x2F;阅读：</p>
<p>GPIO.JETSON_INFO</p>
<p>这为Python字典提供了以下键：P1_REVISION，RAM，REVISION，TYPE，MANUFACTURER和PROCESSOR。字典中的所有值都是字符串，但P1_REVISION是整数。</p>
<p>要获取有关库版本的信息，请使用&#x2F;阅读：</p>
<p>GPIO.VERSION</p>
<p>这提供了XYZ版本格式的字符串。</p>
<h5 id="9-中断"><a href="#9-中断" class="headerlink" title="9.中断"></a>9.中断</h5><p>除了繁忙的轮询外，该库还提供了三种监视输入事件的方法：</p>
<h6 id="wait-for-edge（）函数"><a href="#wait-for-edge（）函数" class="headerlink" title="wait_for_edge（）函数"></a>wait_for_edge（）函数</h6><p>该函数阻塞调用线程，直到检测到提供的边缘为止。该函数可以如下调用：</p>
<p>GPIO.wait_for_edge(channel, GPIO.RISING)</p>
<p>第二个参数指定要检测的边缘，可以是GPIO.RISING，GPIO.FALLING或GPIO.BOTH。如果只想将等待时间限制为指定的时间，则可以选择设置超时：</p>
<h6 id="timeout-is-in-milliseconds"><a href="#timeout-is-in-milliseconds" class="headerlink" title="timeout is in milliseconds"></a>timeout is in milliseconds</h6><p>GPIO.wait_for_edge(channel, GPIO.RISING, timeout&#x3D;500)</p>
<p>该函数返回检测到边缘的通道；如果发生超时，则返回无。</p>
<h6 id="event-detected（）函数"><a href="#event-detected（）函数" class="headerlink" title="event_detected（）函数"></a>event_detected（）函数</h6><p>此功能可用于定期检查自上次通话以来是否发生了事件。该函数可以如下设置和调用：</p>
<h6 id="set-rising-edge-detection-on-the-channel"><a href="#set-rising-edge-detection-on-the-channel" class="headerlink" title="set rising edge detection on the channel"></a>set rising edge detection on the channel</h6><p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>run_other_code()</p>
<p>if GPIO.event_detected(channel):</p>
<p>do_something()</p>
<p>和以前一样，您可以检测GPIO.RISING，GPIO.FALLING或GPIO.BOTH的事件。</p>
<h6 id="当检测到边缘时运行回调函数"><a href="#当检测到边缘时运行回调函数" class="headerlink" title="当检测到边缘时运行回调函数"></a>当检测到边缘时运行回调函数</h6><p>此功能可用于为回调函数运行第二个线程。因此，响应边缘，回调函数可以与主程序并发运行。可以按以下方式使用此功能：</p>
<h6 id="define-callback-function"><a href="#define-callback-function" class="headerlink" title="define callback function"></a>define callback function</h6><p>def callback_fn(channel):</p>
<p>print(“Callback called from channel %s” % channel)</p>
<h6 id="add-rising-edge-detection"><a href="#add-rising-edge-detection" class="headerlink" title="add rising edge detection"></a>add rising edge detection</h6><p>GPIO.add_event_detect(channel, GPIO.RISING, callback&#x3D;callback_fn)</p>
<p>如果需要，还可以添加多个回调：</p>
<p>def callback_one(channel):</p>
<p>print(“First Callback”)</p>
<p>def callback_two(channel):</p>
<p>print(“Second Callback”)</p>
<p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>GPIO.add_event_callback(channel, callback_one)</p>
<p>GPIO.add_event_callback(channel, callback_two)</p>
<p>在这种情况下，这两个回调是顺序运行的，而不是同时运行，因为只有线程运行所有回调函数。</p>
<p>为了通过将多个事件折叠为一个事件来防止多次调用回调函数，可以选择设置反跳时间：</p>
<h6 id="bouncetime-set-in-milliseconds"><a href="#bouncetime-set-in-milliseconds" class="headerlink" title="bouncetime set in milliseconds"></a>bouncetime set in milliseconds</h6><p>GPIO.add_event_detect(channel, GPIO.RISING,<br>callback&#x3D;callback_fn,bouncetime&#x3D;200)</p>
<p>如果不再需要边缘检测，可以按以下步骤将其删除：</p>
<p>GPIO.remove_event_detect(channel)</p>
<h5 id="10-检查GPIO通道的功能"><a href="#10-检查GPIO通道的功能" class="headerlink" title="10.检查GPIO通道的功能"></a>10.检查GPIO通道的功能</h5><p>此功能使您可以检查提供的GPIO通道的功能：</p>
<p>GPIO.gpio_function(channel)</p>
<p>该函数返回GPIO.IN或GPIO.OUT。</p>
<h5 id="11-PWM"><a href="#11-PWM" class="headerlink" title="11. PWM"></a>11. PWM</h5><p>请参阅samples&#x2F;simple_pwm.py有关如何使用PWM通道的详细信息。</p>
<p>Jetson.GPIO库仅在附带硬件PWM控制器的引脚上支持PWM。与RPi.GPIO库不同，Jetson.GPIO库不实现软件仿真的PWM。Jetson<br>Nano支持2个PWM通道，而Jetson AGX Xavier支持3个PWM通道。Jetson TX1和TX2不支持任何PWM通道。</p>
<p>系统引脚复用器必须配置为将硬件PWM控制器连接到相关引脚。如果未配置pinmux，则PWM信号将不会到达引脚！Jetson.GPIO库不会动态修改pinmux配置来实现此目的。阅读L4T文档以获取有关如何配置pinmux的详细信息</p>
<p>完整英文版说明见: <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio">https://github.com/NVIDIA/jetson-gpio</a></p>
<h2 id="五-串口通信"><a href="#五-串口通信" class="headerlink" title="五.串口通信"></a>五.串口通信</h2><h5 id="UART"><a href="#UART" class="headerlink" title="&lt;1&gt;UART"></a>&lt;1&gt;UART</h5><h6 id="1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code"><a href="#1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code" class="headerlink" title="1.python代码 ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code"></a><strong>1.python代码</strong> ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code</h6><p>(github.com)](<a target="_blank" rel="noopener" href="https://github.com/JetsonHacksNano/UARTDemo">https://github.com/JetsonHacksNano/UARTDemo</a><br>“JetsonHacksNano&#x2F;UARTDemo: UART Demo Code (github.com)“)</p>
<p>jetson nano的串口的TXD和RXD引脚分别对应物理引脚8,10</p>
<p>开启串口权限，注意这个权限关机后就也被关闭，下次需要重新开启</p>
<pre><code>sudo chmod 777 /dev/ttyTHS1
</code></pre>
<p>如果要永久打开，可参考：<a target="_blank" rel="noopener" href="https://codeleading.com/article/76115811693/" title="永久修改jetson
nano上电启动串口权限">永久修改jetson<br>nano上电启动串口权限</a></p>
<h5 id="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"><a href="#注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点" class="headerlink" title="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"></a>注意事项：<strong>如果使用USB转TTL模块电脑和nano进行通信注意一下几点</strong></h5><pre><code>    1.杜邦线不可太长，太长会乱码

    2.出现只能收不能发的情况是电压不足导致的，把usb转ttl模块的5V口和nano的5V进行连接

    3.如果线合理，但出现乱码，波特率、奇偶校验、停止位检查是否一致

    4.其它情况：[串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据](https://blog.csdn.net/lxj362343/article/details/89646731 &quot;串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据&quot;)
</code></pre>
<h6 id="2-C-代码：-Uart-c-class-for-Nvidia-Jetson"><a href="#2-C-代码：-Uart-c-class-for-Nvidia-Jetson" class="headerlink" title="2.C++代码：[Uart c++ class for Nvidia Jetson"></a>2.C++代码：[Uart c++ class for Nvidia Jetson</h6><p>Nano](<a target="_blank" rel="noopener" href="https://github.com/MathieuBahin/JetsonNanoUart/tree/master">https://github.com/MathieuBahin/JetsonNanoUart/tree/master</a> “Uart c++<br>class for Nvidia Jetson Nano”)</p>
<p>在四中的C++版GPIO库中并未包括uart相关内容，但是利用jetson nano设备中的</p>
<pre><code>/dev/ttyTHS1
</code></pre>
<p>进行系统调用，可实现串口通信。</p>
<p>但github上的C++ uart代码比较复杂，且只适用于特点场景，笔者修改了部分内容如下：</p>
<pre><code>//uart.h
#ifndef _UART_H
#define _UART_H


// Define Constants
const char *uart_target = &quot;/dev/ttyTHS1&quot;;
#define     NSERIAL_CHAR   256
#define     VMINX          1
#define     BAUDRATE       B115200


class Uart &#123;
private:
  /* data */
  int fid;
public:
  char serial_message[NSERIAL_CHAR];


  Uart ();
  void sendUart(char *msg);
  void readUart();
  void closeUart();

&#125;;
#endif



/************************************/
/* @auteur Mathieu Bahin            */
/* @date_création mars 2020         */
/* @version 1.0                     */
/* @email bahin.mathieu@gmail.com   */
/************************************/

#include &quot;uart.h&quot;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;       // Used for UART
#include &lt;sys/fcntl.h&gt;    // Used for UART
#include &lt;termios.h&gt;      // Used for UART
#include &lt;string.h&gt;

using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;

  // SETUP SERIAL WORLD

  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port


  //------------------------------------------------
  //  OPEN THE UART
  //------------------------------------------------
  // The flags (defined in fcntl.h):
  //	Access modes (use 1 of these):
  //		O_RDONLY - Open for reading only.
  //		O_RDWR   - Open for reading and writing.
  //		O_WRONLY - Open for writing only.
  //	    O_NDELAY / O_NONBLOCK (same function)
  //               - Enables nonblocking mode. When set read requests on the file can return immediately with a failure status
  //                 if there is no input immediately available (instead of blocking). Likewise, write requests can also return
  //				   immediately with a failure status if the output can&#39;t be written immediately.
  //                 Caution: VMIN and VTIME flags are ignored if O_NONBLOCK flag is set.
  //	    O_NOCTTY - When set and path identifies a terminal device, open() shall not cause the terminal device to become the controlling terminal for the process.fid = open(&quot;/dev/ttyTHS1&quot;, O_RDWR | O_NOCTTY | O_NDELAY);		//Open in non blocking read/write mode

  fid = open(uart_target, O_RDWR | O_NOCTTY );

  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);

  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;

  //------------------------------------------------
  // CONFIGURE THE UART
  //------------------------------------------------
  // flags defined in /usr/include/termios.h - see http://pubs.opengroup.org/onlinepubs/007908799/xsh/termios.h.html
  //	Baud rate:
  //         - B1200, B2400, B4800, B9600, B19200, B38400, B57600, B115200,
  //           B230400, B460800, B500000, B576000, B921600, B1000000, B1152000,
  //           B1500000, B2000000, B2500000, B3000000, B3500000, B4000000
  //	CSIZE: - CS5, CS6, CS7, CS8
  //	CLOCAL - Ignore modem status lines
  //	CREAD  - Enable receiver
  //	IGNPAR = Ignore characters with parity errors
  //	ICRNL  - Map CR to NL on input (Use for ASCII comms where you want to auto correct end of line characters - don&#39;t use for bianry comms!)
  //	PARENB - Parity enable
  //	PARODD - Odd parity (else even)

//*******************************begin::uart参数设置************************************
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

//********************************end::uart参数设置*************************************

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;

//*******************************begin::测试程序************************************
int main(int argc, char *argv[]) &#123;
  Uart u;
  int i;
  char m[256]=&quot;hello world!&quot;;
  u.sendUart(&quot;%s&quot;,&quot;hello world!\r\n&quot;);
  u.sendUart(m);
   
  while (1)
  &#123;
    u.readUart();
    if(strlen(u.serial_message)!=0)
    &#123;
      for(i=0;u.serial_message[i]!=&#39;$&#39;;i++)    //自定协议规定以$结尾
      &#123;
        printf(&quot;%c &quot;,u.serial_message[i]);
      &#125;
    &#125;
    printf(&quot;\n&quot;);    
  &#125;
  u.closeUart();

  return 0;
&#125;
//********************************end::测试程序*************************************
</code></pre>
<p><strong>其中删去了大部分不必要片段，并加入了Uart_Printf()函数，用法同printf()</strong></p>
<p>测试结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6af7567db40ef98ffaec08066206ca83.png"></p>
<p>&lt;2&gt;IIC</p>
<h2 id="六-在jetson-nano上使用OpenCV"><a href="#六-在jetson-nano上使用OpenCV" class="headerlink" title="六.在jetson nano上使用OpenCV"></a>六.在jetson nano上使用OpenCV</h2><p>&lt;1&gt;<strong>python打开摄像头：参考[通过OpenCV调用CSI和USB摄像头](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169070226116800188569163&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169070226116800188569163&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduend~default-2-123967404-null-<br>null.142%5Ev91%5Einsert_down28v1,239%5Ev12%5Econtrol2&amp;utm_term&#x3D;jetsonnano%E8%B0%83%E7%94%A8usb%E6%91%84%E5%83%8F%E5%A4%B4&amp;spm&#x3D;1018.2226.3001.4187<br>“通过OpenCV调用CSI和USB摄像头”)</strong></p>
<p><strong>C++打开，示例如下：</strong></p>
<pre><code>//适用于jetson nano上的模版
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/core.hpp&gt;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;opencv2/imgproc.hpp&gt;
#include &lt;opencv2/objdetect.hpp&gt;
#include &lt;opencv2/imgproc/types_c.h&gt;
#include &lt;opencv2/videoio.hpp&gt;

using namespace std;
using namespace cv;

string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
&#123;
    return &quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +
        to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +
        &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +
        to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;
&#125;

int main()
&#123;
    int capture_width = 1280;
    int capture_height = 720;
    int display_width = 1280;
    int display_height = 720;
    int framerate = 60;
    int flip_method = 0;

    //创建管道
    string pipeline = gstreamer_pipeline(capture_width,
        capture_height,
        display_width,
        display_height,
        framerate,
        flip_method);
    std::cout &lt;&lt; &quot;使用gstreamer管道: \n\t&quot; &lt;&lt; pipeline &lt;&lt; &quot;\n&quot;;

    //管道与视频流绑定
    VideoCapture cap(pipeline, CAP_GSTREAMER);

    //创建显示窗口
    namedWindow(&quot;CSI Camera&quot;, WINDOW_AUTOSIZE);
    Mat img;

    //逐帧显示
    while (true)
    &#123;
        cap.read(img);
        imshow(&quot;CSI Camera&quot;, img);

        if (waitKey(10) == 27)break;
    &#125;

    cap.release();
    destroyAllWindows();
&#125;
</code></pre>
<p>&lt;2&gt;使用官方自带的4.1.1版本OpenCV</p>
<p>自带的OpenCV文件夹在**&#x2F;usr&#x2F;share&#x2F;opencv4** 中，**~&#x2F;sample&#x2F;cpp  **内含众多示例代码</p>
<p>运行示例代码时使用g++编译，命令为：</p>
<pre><code>g++ name.cpp -o name `pkg-config --cflags --libs opencv4`
</code></pre>
<p>命令行输入如下命令即可运行：</p>
<pre><code>./name parameters
</code></pre>
<p>其中name为编写的程序名，parameters程序具体需要的参数</p>
<p>因为官方镜像所有的环境都是配好的，g++编译时加入<code>pkg-config --cflags --libs opencv4</code>就可运行。想要下载全新版本自己配置并了解其中的原理可以参考下面的资料</p>
<p>&lt;3&gt;自己配置其他版本OpenCV参考资料</p>
<p> 1.jetson nano上开发环境配置及使用QT(C++)或VsCode编写运行(Python)<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianbin3200896/article/details/103760640?spm=1001.2014.3001.5506#t6" title="Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）">Jetson Nano<br>从入门到实战（案例：Opencv配置、人脸检测、二维码检测）</a></p>
<p>2.使用CMake编译链接(C++)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43717839/article/details/128032486?spm=1001.2014.3001.5506" title="【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-CSDN博客">【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-<br>CSDN博客</a></p>
<p>3.使用g++命令(C++)</p>
<p>4.配置最新版或其他版本OpenCV：<a target="_blank" rel="noopener" href="https://blog.csdn.net/s15810751918/article/details/107705387?spm=1001.2014.3001.5506" title="linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-CSDN博客">linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47665864/article/details/128945476?spm=1001.2014.3001.5506" title="如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-CSDN博客">如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-<br>CSDN博客</a></p>
<h2 id="七-jetson-nano开机自启动程序"><a href="#七-jetson-nano开机自启动程序" class="headerlink" title="七.jetson nano开机自启动程序"></a>七.jetson nano开机自启动程序</h2><p>步骤：</p>
<p>1.打开文件：</p>
<pre><code>/usr/bin/yoyo.sh
</code></pre>
<p>2.写入命令（开机自动执行的命令），例如：</p>
<pre><code>cd /home/jetson/test/circle_control
./circle
</code></pre>
<p>注：终端路径转至&#x2F;home&#x2F;jetson&#x2F;test&#x2F;circle_control，执行.&#x2F;circle文件</p>
<p>3.终端执行:</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl enable start.service
sudo reboot
</code></pre>
<h2 id="八-实战程序"><a href="#八-实战程序" class="headerlink" title="八.实战程序"></a>八.实战程序</h2><h5 id="1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"><a href="#1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32" class="headerlink" title="1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"></a>1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</h5><pre><code>//*************circle.cpp**************
#include &quot;opencv2/opencv.hpp&quot;
#include &quot;opencv2/highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;

//begin::uart部分************************************************************************
#include &quot;uart.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;unistd.h&gt;       // Used for UART
#include &lt;sys/fcntl.h&gt;    // Used for UART
#include &lt;termios.h&gt;      // Used for UART
#include &lt;string.h&gt;

using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;
  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port
  fid = open(uart_target, O_RDWR | O_NOCTTY );
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

int Uart :: fputc(int ch, FILE *f)
&#123;
	write(fid, &amp;ch, 1);
	return ch;
&#125;

void Uart :: Uart_Printf(char *format, ...)
&#123;
	char String[256];
	va_list arg;
	va_start(arg, format);
	vsprintf(String, format, arg);
	va_end(arg);
	sendUart(String);
&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;
//end::uart部分**************************************************************************

const char* windowname=&quot;win&quot;;
int max_r=100;
int min_r=60;
int min_d=80;
int t_hold=25;
int param1=100;
int param2=20;
const int t_max=255;
const int r_max=1000;
const int d_max=100;
const int p1_max=200;
const int p2_max=200;


int main()
&#123;
  VideoCapture capture(0);
  Mat image;
	Mat matCanny;
  Mat BinImg;
  Mat matDst;
  Uart u;

  void on_Trackbar_1(int, void*);
  void on_Trackbar_2(int, void*);
  void on_Trackbar_3(int, void*);
  void on_Trackbar_4(int, void*);
  void on_Trackbar_5(int, void*);
  void on_Trackbar_6(int, void*);
  namedWindow(windowname,0);
  setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
  resizeWindow(windowname, 400, 300);
  moveWindow(windowname, 0, 0);
  createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);
  createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);
  createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);
  createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);
  createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);
  createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);

	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
    cvtColor(image, matDst, COLOR_BGR2GRAY);
		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV|THRESH_OTSU);
    Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
        
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

    printf(&quot;x:%d\ny:%d\n&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));
    u.Uart_Printf(&quot;#x%dy%d$&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));

    imshow(&quot;matCanny&quot;, matCanny);
    imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;

  u.closeUart();
  return 0;

&#125;

void on_Trackbar_1(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_2(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_3(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_4(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_5(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_6(int, void*)
&#123;
    ;
&#125;
</code></pre>
<p>使用说明：</p>
<p>使用前打开串口权限；程序使用usb摄像头；要将uart.h包含到该文件（circle.cpp）同目录下；</p>
<p>该目录下打开终端输入：<br>进行编译产生可执行文件</p>
<pre><code>g++ circle.cpp -o circle `pkg-config --cflags --libs opencv4`
</code></pre>
<p>该目录下打开终端输入：<br>即可运行</p>
<pre><code>./circle
</code></pre>
<p>注：霍夫圆检测不太稳定，会显示core出错，重启即可，也可以在启动时调节各个参数使稳定</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658">https://blog.csdn.net/qq_32971095/article/details/131511658</a>，如有侵权，请联系删除。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/None/" rel="tag"># None</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" rel="prev" title="图像识别小车（电源部分）——电赛学习笔记（1）">
      <i class="fa fa-chevron-left"></i> 图像识别小车（电源部分）——电赛学习笔记（1）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" rel="next" title="图像识别小车（电机部分）——电赛学习笔记（2）">
      图像识别小车（电机部分）——电赛学习笔记（2） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">零.前言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-jetson-nano%E8%B4%AD%E4%B9%B0%E5%95%86%E5%AE%B6%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">1.jetson nano购买商家及技术支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">2.相关环境配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">3.做好系统备份</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-vscode%E8%BF%9C%E7%A8%8Bssh%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">一.vscode远程ssh操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.1.</span> <span class="nav-text">&lt;1&gt;局域网连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E"><span class="nav-number">2.2.</span> <span class="nav-text">&lt;2&gt;电脑直连</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E-VNC%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">&lt;3&gt;电脑直连+VNC远程桌面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%9D%BF%E8%BD%BD%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%99%E7%A8%8B%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">二.板载摄像头教程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">三.运行例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-GPIO%E4%BD%BF%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">四.GPIO使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GPIO%E5%BA%93%E7%9A%84API%E7%94%A8%E6%B3%95"><span class="nav-number">5.0.1.</span> <span class="nav-text">GPIO库的API用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AF%BC%E5%85%A5%E5%BA%93"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">1.导入库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BC%95%E8%84%9A%E7%BC%96%E5%8F%B7"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">2.引脚编号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%AD%A6%E5%91%8A"><span class="nav-number">5.0.1.3.</span> <span class="nav-text">3.警告</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%AE%BE%E7%BD%AE%E9%80%9A%E9%81%93"><span class="nav-number">5.0.1.4.</span> <span class="nav-text">4.设置通道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%BE%93%E5%85%A5"><span class="nav-number">5.0.1.5.</span> <span class="nav-text">5.输入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%BE%93%E5%87%BA"><span class="nav-number">5.0.1.6.</span> <span class="nav-text">6.输出</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#set-first-channel-to-HIGH-and-rest-to-LOW"><span class="nav-number">5.0.1.6.1.</span> <span class="nav-text">set first channel to HIGH and rest to LOW</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%B8%85%E7%90%86"><span class="nav-number">5.0.1.7.</span> <span class="nav-text">7.清理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-jetson%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E5%92%8C%E5%BA%93%E7%89%88%E6%9C%AC"><span class="nav-number">5.0.1.8.</span> <span class="nav-text">8.jetson模块信息和库版本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E4%B8%AD%E6%96%AD"><span class="nav-number">5.0.1.9.</span> <span class="nav-text">9.中断</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait-for-edge%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.0.1.9.1.</span> <span class="nav-text">wait_for_edge（）函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#timeout-is-in-milliseconds"><span class="nav-number">5.0.1.9.2.</span> <span class="nav-text">timeout is in milliseconds</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#event-detected%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.0.1.9.3.</span> <span class="nav-text">event_detected（）函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#set-rising-edge-detection-on-the-channel"><span class="nav-number">5.0.1.9.4.</span> <span class="nav-text">set rising edge detection on the channel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E8%BE%B9%E7%BC%98%E6%97%B6%E8%BF%90%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">5.0.1.9.5.</span> <span class="nav-text">当检测到边缘时运行回调函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#define-callback-function"><span class="nav-number">5.0.1.9.6.</span> <span class="nav-text">define callback function</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#add-rising-edge-detection"><span class="nav-number">5.0.1.9.7.</span> <span class="nav-text">add rising edge detection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bouncetime-set-in-milliseconds"><span class="nav-number">5.0.1.9.8.</span> <span class="nav-text">bouncetime set in milliseconds</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-%E6%A3%80%E6%9F%A5GPIO%E9%80%9A%E9%81%93%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">5.0.1.10.</span> <span class="nav-text">10.检查GPIO通道的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-PWM"><span class="nav-number">5.0.1.11.</span> <span class="nav-text">11. PWM</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">五.串口通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#UART"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">&lt;1&gt;UART</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-python%E4%BB%A3%E7%A0%81-%EF%BC%9A-JetsonHacksNano-UARTDemo-UART-Demo-Code"><span class="nav-number">6.0.0.1.1.</span> <span class="nav-text">1.python代码 ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8USB%E8%BD%ACTTL%E6%A8%A1%E5%9D%97%E7%94%B5%E8%84%91%E5%92%8Cnano%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E6%B3%A8%E6%84%8F%E4%B8%80%E4%B8%8B%E5%87%A0%E7%82%B9"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-C-%E4%BB%A3%E7%A0%81%EF%BC%9A-Uart-c-class-for-Nvidia-Jetson"><span class="nav-number">6.0.0.2.1.</span> <span class="nav-text">2.C++代码：[Uart c++ class for Nvidia Jetson</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E5%9C%A8jetson-nano%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV"><span class="nav-number">7.</span> <span class="nav-text">六.在jetson nano上使用OpenCV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-jetson-nano%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">七.jetson nano开机自启动程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%9E%E6%88%98%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">八.实战程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-jetson-nano%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%B0%86%E5%9C%86%E5%BF%83%E5%9D%90%E6%A0%87%E9%80%9A%E8%BF%87uart%E4%BC%A0%E7%BB%99stm32"><span class="nav-number">9.0.0.1.</span> <span class="nav-text">1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">790k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
