<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Switch">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SWQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="Switch" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/22/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%94%EF%BC%88LCD%E6%B6%B2%E6%99%B6%E5%B1%8F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C6%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/22/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%94%EF%BC%88LCD%E6%B6%B2%E6%99%B6%E5%B1%8F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C6%EF%BC%9E/" class="post-title-link" itemprop="url">基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-22 16:14:34" itemprop="dateCreated datePublished" datetime="2023-09-22T16:14:34+08:00">2023-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.TFT_LCD%20%E6%B6%B2%E6%99%B6%E5%B1%8F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">一.TFT_LCD<br>液晶屏驱动设计</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89HV%20%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F">（1）HV<br>同步模式</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89DE%20%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F">（2）DE<br>同步模式</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（3）整体设计</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89TFT_LCD%20%E6%98%BE%E7%A4%BA%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">（4）TFT_LCD<br>显示时序控制模块</a></p>
<p><a href="about:blank#%3C2%3E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">&lt;2&gt;程序设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89tft_ctrl%20%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">（1）tft_ctrl<br>时序控制模块</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89tft_pic%C2%A0%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97">（2）tft_pic<br>图像数据生成模块</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">（3）顶层模块</a></p>
<p><a href="about:blank#%E4%BA%8C.TFT_LCD%20%E6%B6%B2%E6%99%B6%E5%B1%8F%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA">二.TFT_LCD<br>液晶屏字符显示</a></p>
<hr>
<p>前置学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132993678?spm=1001.2014.3001.5501" title="基础设计四——FPGA学习笔记＜5＞">基础设计四——FPGA学习笔记＜5＞</a></p>
<p>参考书目：《<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8E%E7%81%AB&spm=1001.2101.3001.7020" title="野火">野火</a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=FPGA&spm=1001.2101.3001.7020" title="FPGA">FPGA</a> Verilog 开发实战指南》</p>
<h2 id="一-TFT-LCD-液晶屏驱动设计"><a href="#一-TFT-LCD-液晶屏驱动设计" class="headerlink" title="一.TFT_LCD 液晶屏驱动设计"></a>一.TFT_LCD 液晶屏驱动设计</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><p>液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态， 但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会<br>改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率<br>的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/04aad9b1d62ffc8693a9159fb2d578e2.png"></p>
<p>​</p>
<pre><code>    ​常见的 LCD 按物理结构分为四种：扭曲向列型（TN－Twisted NemaTIc）、超扭曲向列型（ STN － Super TN ） 、 双层超扭曲向列型 （ DSTN － Dual Scan Tortuosity Nomograph）、薄膜晶体管型（TFT－Thin Film Transistor）。

    TN－LCD、STN－LCD 和 DSYN－LCD 的基本显示原理都相同，只是液 晶分子的扭曲角度不同而已。而 TFT－LCD 则采用与 TN 系列 LCD 截然不同的显示方式。 TFT-LCD 全称 Thin Film Transistor-Liquid Crystal Display，译为薄膜晶体管液晶显示器。其中 TFT 就是 Thin Film Transistor 的简称，指的是薄膜晶体管（矩阵），可以“主动 的”对屏幕上的各个独立的像素进行控制，这也就是所谓的主动矩阵 TFT（active matrix TFT）的来历。图像产生的基本原理很简单：**显示屏由许多可以发出任意颜色的光线的像素组成** ，只要控制各个像素显示相应的颜色就能达到目的了。在 TFT LCD 中一般采用背光 技术，为了能精确地控制每一个像素的颜色和亮度就需要**在每一个像素之后安装一个类似百叶窗的半导体开关** ，以此做到完全的单独的控制一个像素点，液晶材料被夹在 TFT 玻璃层和颜色过滤层之间，通过改变刺激液晶的电压值就可以控制最后出现的光线强度与色彩。

    RGB 接口 TFT-LCD 时序 对于 RGB 接口 TFT-LCD 显示屏，它的图像显示的同步模式有两种，分别为 HV 同步模式、DE 同步模式。不同的同步模式对应不同的时序。
</code></pre>
<h4 id="（1）HV-同步模式"><a href="#（1）HV-同步模式" class="headerlink" title="（1）HV 同步模式"></a>（1）HV 同步模式</h4><pre><code>    HV 同步模式下，图像的显示只需要行同步信号(hsync)和场同步信号(vsync)来确定显示时序。此时，RGB 接口的 TFT-LCD 液晶显示屏的显示时序和 VGA 时序标准类似。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ee839d4f5ecd6d1c464881b3eab8c9c8.png">​</p>
<pre><code>    如图 30-3 所示，图中 RGB 代表图像信息，HSync 表示行同步信号，HSync 自上一个上升沿起到下一个上升沿止为一个完整周期，我们称之为**行扫描周期** ，一个完整的行扫描周期，包含 4 部分：**同步、后沿、有效图像、前沿** ，**基本单位为 pixel** ，即一个像素时钟周期。 在一个完整的行扫描周期中，RGB 图像信息在 HSync 行同步信号的同步下**完成一行图像的显示** ，RGB 图像信息在有效图像阶段，图像信息有效，其他阶段图像信息无效； HSync 行同步信号在同步阶段，维持高电平，其他阶段均保持低电平，在下一个行扫描周期的同步阶段，HSync 行扫描信号拉高，其他阶段拉低，周而复始。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b65511792bc354ef74f41f3eab264275.png">​</p>
<pre><code>    如图 30-4 所示，图中 RGB 代表图像信息，VSync 表示场同步信号，VSync 自上一个上升沿起到下一个上升沿止为一个完整周期，我们称之为**场扫描周期** ，一个完整的行扫描周期，包含 4 部分：**同步、后沿、有效图像、前沿** ，基本单位为一个完整的**行扫描周期** 。 在一个完整的行扫描周期中，RGB 图像信息在 VSync 行同步信号的同步下**完成一帧图像的显示** ，RGB 图像信息在有效图像阶段，图像信息有效，其他阶段图像信息无效； VSync 行同步信号在同步阶段，维持高电平，其他阶段均保持低电平，在下一个行扫描周 期的同步阶段，VSync 行扫描信号拉高，其他阶段拉低，周而复始。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/85f0ba7e67fa5041c85a60eb8f1c4b9b.png">​</p>
<pre><code>    图中的红色区域表示在一个完整的行扫描周期中，RGB 图像信息只在此区域有效；黄 色区域表示在一个完整的场扫描周期中，RGB 图像信息只在此区域有效，两者相交的橙色区域，就是 RGB 接口 TFT-LCD 显示屏的图像显示区域。
</code></pre>
<h4 id="（2）DE-同步模式"><a href="#（2）DE-同步模式" class="headerlink" title="（2）DE 同步模式"></a>（2）DE 同步模式</h4><pre><code>    DE 同步模式下，图像的显示只需要数据使能信号确定显示时序，不需要行场同步信号。DE 同步模式下的 TFT 图像显示时序图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3bc25151b07fb4648b1983e0db34119.png"></p>
<pre><code>    由图可知，当数据使能信号为高电平时，表示 TFT 显示屏扫描到了有效显示区域，此时输入到 TFT 显示屏的图像信息能够显示出来；当数据使能信号为低电平时，表示 TFT 显 示屏未扫描到有效显示区域。         

    对于两种不同的同步模式， DE 同步模式一般使用在大尺寸屏幕，小尺寸屏幕多使用 HV 同步模式。HV 同步模式地出现早于 DE 同步模式，当今的大部分显示屏均支持 HV 和 DE 两种同步模式。

    RGB 接口 TFT-LCD 分辨率 不同的分辨率的 TFT-LCD 显示屏在时序上是相似的，只是存在一些参数上的差异，**下面列举了部分分辨率的时序参数** ，刷新频率均为 60Hz
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/579146b7878cc098a77520661a25946a.png">**<br>**</p>
<h4 id="（3）整体设计"><a href="#（3）整体设计" class="headerlink" title="（3）整体设计"></a>（3）整体设计</h4><pre><code>    设计编写 RGB 接口 TFT-LCD 液晶显示屏驱动，在 4.3 寸(480*272) TFT-LCD 显示屏上 横向依次显示等宽多色彩条，显示颜色自左向右依次为红、橙、黄、绿、青、蓝、紫、 黑、白、灰，图像像素格式为 RGB565，帧率为 60Hz。
</code></pre>
<p>注：本章节后文中涉及到的相关参数均与 <strong>4.3 寸(480*272)</strong> TFT-LCD 显示屏的的相关参数相对应，事先告知，后续不再声明。</p>
<p>升腾 mini 开发板 TFT_LCD 接口部分原理图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a9b704cd1bbef34a9ecc533fad44b6a.png"></p>
<p>注：在本实验工程中，输出信号中包含 <strong>HV 同步模式下需要的行、场同步信号 (hsync、vsync)和 DE 同步模式下的 tft_de 信号</strong><br>，各信号正确输出。读者<strong>若想要使用 HV 同 步模式进行图像显示，可在代码中注释掉 tft_de 信号；若想要使用 DE 同步模式进行图像<br>显示，可带代码中注释掉行、场同步信号。</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5df55d88953d7318baf258bb3c1bf1e1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1d9aa3aacb3968321f308fffdf71b364.png"></p>
<pre><code>    TFT 彩条显示工程的工作流程。
</code></pre>
<p>(1) 系统上电后，板卡传入系统时钟(sys_clk)和复位信号(sys_rst_n)到顶层模块；</p>
<p>(2) 系统时钟直接传入时钟生成模块(clk_gen)，分频产生 TFT 显示屏工作时钟 (clk_in)，作为图像数据生成模块(tft_pic)和 TFT<br>时序控制模块(tft_ctrl)的工作时 钟；</p>
<p>(3) 图像数据生成模块<strong>以 TFT<br>显示时序控制模块传入的像素点坐标(pix_x,pix_y)为约束条件，生成待显示彩条图像的色彩信息(pix_data)</strong> ；</p>
<p>(4) 图像数据生成模块生成的彩条图像色彩信息传入 TFT 时序控制模块，在模块内部使用使能信号滤除掉非图像显示有效区域的图像数据，产生 RGB 色彩信息<br>(rgb_tft)，在行、场同步信号(hsync、vsync)或数据使能信号(tft_de)的同步作用下，将 RGB 色彩信息扫描显示到 TFT<br>显示屏，显示出彩条图像。</p>
<h4 id="（4）TFT-LCD-显示时序控制模块"><a href="#（4）TFT-LCD-显示时序控制模块" class="headerlink" title="（4）TFT_LCD 显示时序控制模块"></a>（4）TFT_LCD 显示时序控制模块</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/645cd28fbf833e74cfc1158207c39f1d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd6c4b16e73cda79cdd0afbd07e55fab.png"></p>
<pre><code>    data_in 为彩条图像 像素点色彩信息，由图像数据生成模块产生并传入，在 TFT_LCD 显示器有效图像显示区域赋值给信号 RGB 图像色彩信息(rgb_tft_16b)。

    输出信号(pix_x,pix_y)为 TFT_LCD 有效显示区域像素点坐标，由 TFT_LCD 时序控制模块生并传入图像数据生成模块；hsync、vsync 为 TFT_LCD 行、场同步信号 ，通过 TFT_LCD 接口传输给 TFT_LCD 显示屏；rgb_tft_16b 为显示器要显示的图像色彩信息，传输给 TFT_LCD 显示器；tft_bl 为 TFT 显示屏背光信号；tft_clk 为 TFT 显示屏工作时钟； tft_de 为 TFT 显示使能信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/22580f39319a512293811631cfebc085.png"></p>
<p>**<br>第一部分**：行同步信号(hsync)、场同步信号(vsync)。由时序图可知，<strong>行同步信号为周期性信号，信号变化周期为完整的行扫描周期</strong><br>，信号在同步阶段保持高电平，在其他阶段保持低电平，那么如何实现行同步信号的周期性变化呢？ 我们想到了前文学过的计数器，因为一个完整行扫描周期为 <strong>525<br>个像素时钟周期 (480*272@60，见前表格)</strong> ，我们可以利用计数器以像素时钟周期进行计数，每一个像素时钟周期自加 1，计数范围为<br>0-524，共计数 525 次，与完整行扫描周期数相吻合。<strong>只要在行同步阶段(计数范围 0-40)赋值 hsync<br>信号为高电平，其他阶段为低电平，就可以实现符合时序要求的行同步信号 hsync</strong> 。根据此设计思路，声明并绘制行扫描周期计数器 cnt_h、行同步信号<br>hsync 信号波形如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e499e6c45177b382ec604cfeb1deb1b7.png"></p>
<pre><code>    同理，参考行同步信号波形的绘制思路，我们可以进行场同步信号波形的绘制。不过要注意的是，**场扫描周期单位不是像素时钟周期，而是完整的行扫描周期** ，所以要**添加场扫描周期计数器对行扫描周期进行计数（再525分频）** ，声明并绘制场扫描周期计数器 cnt_v、场同步信号 vsync 信号波形如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e57208bdc5c5038da15c114148fd918c.png"></p>
<pre><code>   **  第二部分**：图像显示有效信号(data_valid)波形绘制思路由上文可知，TFT 显示屏只有在有效的显示区域内送入图像数据，图像才会被正确显示。我们可以声明一个有效信号，在图像有效显示区域赋值高电平，在非图像有效显示区域赋值低电平，以此信号为约束条件，控制图像信号的正确输入，定义此信号为图像显示有效信号(rgb_valid)。 这里我们可以利用上一部分声明的 cnt_h、cnt_v 两个计数器，以其为约束条件，**当两个计数器计数到图像有效显示区域时，data_valid 赋值高电平** ，否则赋值低电平。绘制图像显示有效信号(data_valid)波形如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f64e56c6d4b2cd677cd62e5c1be2d54c.png"></p>
<p>**         第三部分**：图像信息请求信号(data_req)、TFT 显示屏有效显示区域像素点坐标<br>(pix_x,pix_y)波形绘制思路为了<strong>提高模块复用性</strong> ，我们将图像数据生成功能独立出来，设计为图像数据生成模块 <strong>tft_pic</strong><br>，虽然模块复用性提高，但这样就产生一个问题，怎样保证 data_in 传输的图像数据与 TFT 显示屏时序相吻合呢？</p>
<pre><code>    结合之前学习的知识，我们知道只有在 TFT 显示屏有效显示区域，data_in 传输的图像数据才会传输给 TFT 显示屏，那么我们可以**只在 TFT 显示屏有效显示区域对 data_in 进行赋值** ，如何实现这一想法呢？

    我们可以使用 cnt_h、cnt_v 信号来确定 TFT 显示屏有效显示区域，将有效显示区域使用坐标法表示，针对不同坐标点**对 data_in 进行赋值** ，所以我们声明 TFT 显示屏有效显示区域像素点坐标(pix_x,pix_y)。

    上面两个问题解决了，新的问题又来了，TFT 显示屏有效显示区域为 480*272，如何 使像素点坐标(pix_x,pix_y)实现(0,0) – (480,272)的坐标计数？ 读者可能会想到使用已经声明的图像显示有效信号(data_valid)，但在此处不能使用该信号。

    因为本次实验是 TFT 显示屏多色彩条的显示，**图像数据生成模块 tft_pic 需要以坐标 (pix_x,pix_y)为约束条件对 data_in 信号进行赋值，只能使用时序逻辑的赋值方式，那么 data_in 的赋值时刻会滞后条件满足时刻一个时钟周期，显示图像会出现问题** 。

    为了解决这一问题，我们需要声明新的图像数据请求信号 **data_req** ，该信号要**超前图像显示有效信号(data_valid)一个时钟周期，以抵消 data_in 时序逻辑赋值带来的问题** 。 综上所述，我们需要声明图像信息请求信号 data_req、TFT 显示屏有效显示区域像素点坐标(pix_x,pix_y)这三路信号来解决之前提到的若干问题。对于 data_req 信号的电平控制可参考 data_valid 信号的控制方式，以 cnt_h、cnt_v 信号为约束条件；坐标(pix_x,pix_y)则 以新声明的 data_req 信号为约束条件控制生成，三路信号绘制波形图如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2630498c7621e301628c2bc304db7555.png"></p>
<pre><code>    **第四部分** ：RGB 色彩信息(rgb_tft_16b)波形绘制思路这一部分就比较简单了，TFT 显示屏图像显示是在行、场同步信号的作用下，将图像色彩信息以扫描显示的方式显示出来，所以 RGB 色彩信息必不可少，只要在有效显示区域写入正确图像数据即可。信号 rgb_tft_16b 绘制波形如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fa324114eb35f5f9a972e8acd3dc394d.png"></p>
<pre><code>    **第五部分** ： TFT 显示数据使能信号(tft_de)波形绘制思路数据使能信号为 DE 同步模式下的图像显示同步信号，只在有效图像显示区域为高电平，其他时刻为低电平。tft_de 信号的波形变化和 data_valid 信号相同，所以 tft_de 信号可 由 data_valid 信号使用组合逻辑进行赋值。数据使能信号(tft_de)波形如下图。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/609d72183797781aa1c69af398211a21.png"></p>
<pre><code>    **第六部分** ： TFT 显示屏工作时钟(tft_clk)、TFT 显示屏背光信号(tft_bl)波形绘制思路 TFT 显示屏与 VGA 显示器不同，TFT 显示屏的正常工作离不开时钟信号，而且输入 TFT 显示屏的时钟信号，要与行场信号或数据使能信号的同步时钟相同，否者会出现图像显示的错误。 TFT 显示屏的背光信号作用是控制显示屏背光，为高电平时打开显示器背光，低电平时关闭背光，在本实验工程使用复位信号 sys_rst_n 信号为背光信号赋值。 上述两信号波形图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e2fbf4f6bc0fd18607c3d53df7d87f.png"></p>
<pre><code>    本设计思路只做参考，并非唯一方法，读者可利用所学知识，按照自己思路进行设计。 
</code></pre>
<h3 id="程序设计"><a href="#程序设计" class="headerlink" title="&lt;2&gt;程序设计"></a>&lt;2&gt;程序设计</h3><h4 id="（1）tft-ctrl-时序控制模块"><a href="#（1）tft-ctrl-时序控制模块" class="headerlink" title="（1）tft_ctrl 时序控制模块"></a>（1）tft_ctrl 时序控制模块</h4><pre><code>module  tft_ctrl
(
    input   wire            clk_in      ,   //输入时钟
    input   wire            sys_rst_n   ,   //系统复位,低电平有效
    input   wire    [15:0]  data_in     ,   //待显示数据

    output  wire            data_req    ,   //数据请求信号
    output  wire    [10:0]  pix_x       ,   //输出TFT有效显示区域像素点X轴坐标
    output  wire    [10:0]  pix_y       ,   //输出TFT有效显示区域像素点Y轴坐标
    output  wire    [15:0]  rgb_tft_16b ,   //TFT显示数据
    output  wire    [23:0]  rgb_tft_24b ,   //TFT显示数据
    output  wire            hsync       ,   //TFT行同步信号
    output  wire            vsync       ,   //TFT场同步信号
    output  wire            tft_clk     ,   //TFT像素时钟
    output  wire            tft_de      ,   //TFT数据使能
    output  wire            tft_bl          //TFT背光信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//parameter define  5寸、七寸屏
// parameter   H_SYNC      =   11&#39;d34  ,   //行同步
            // H_BACK      =   11&#39;d46  ,   //行时序后沿
            // H_LEFT      =   11&#39;d0   ,   //行时序左边框
            // H_VALID     =   11&#39;d800 ,   //行有效数据
            // H_RIGHT     =   11&#39;d0   ,   //行时序右边框
            // H_FRONT     =   11&#39;d210 ,   //行时序前沿
            // H_TOTAL     =   11&#39;d1090;   //行扫描周期
            
// parameter   V_SYNC      =   11&#39;d10  ,   //场同步
            // V_BACK      =   11&#39;d23  ,   //场时序后沿
            // V_TOP       =   11&#39;d0   ,   //场时序左边框
            // V_VALID     =   11&#39;d480 ,   //场有效数据
            // V_BOTTOM    =   11&#39;d0   ,   //场时序右边框
            // V_FRONT     =   11&#39;d22  ,   //场时序前沿
            // V_TOTAL     =   11&#39;d535 ;   //场扫描周期
//parameter define  4.3寸屏
parameter H_SYNC    =   10&#39;d41  ,   //行同步
          H_BACK    =   10&#39;d2   ,   //行时序后沿
          H_LEFT    =   11&#39;d0   ,   //行时序左边框
          H_VALID   =   10&#39;d480 ,   //行有效数据
          H_FRONT   =   10&#39;d2   ,   //行时序前沿
          H_RIGHT   =   11&#39;d0   ,   //行时序右边框
          H_TOTAL   =   10&#39;d525 ;   //行扫描周期
parameter V_SYNC    =   10&#39;d10  ,   //场同步
          V_BACK    =   10&#39;d2   ,   //场时序后沿
          V_TOP     =   11&#39;d0   ,   //场时序左边框
          V_VALID   =   10&#39;d272 ,   //场有效数据
          V_FRONT   =   10&#39;d2   ,   //场时序前沿
          V_BOTTOM  =   11&#39;d0   ,   //场时序右边框
          V_TOTAL   =   10&#39;d286 ;   //场扫描周期
                                                                                                                                            
parameter   H_PIXEL     =   11&#39;d480 ,   //水平方向有效图像像素个数
            V_PIXEL     =   11&#39;d272 ;   //垂直方向有效图像像素个数
parameter   H_BLACK     =   ((H_VALID - H_PIXEL) / 2),  //水平方向黑色边框宽度
            V_BLACK     =   ((V_VALID - V_PIXEL) / 2);  //垂直方向黑色边框宽度

//wire  define
wire            data_valid  ;   //有效显示区域标志
wire    [15:0]  data_out    ;   //输出有效图像数据
wire    [7:0]   rgb_r;
wire    [7:0]   rgb_g;
wire    [7:0]   rgb_b;

//reg   define
reg     [10:0]   cnt_h       ;   //行扫描计数器
reg     [10:0]   cnt_v       ;   //场扫描计数器

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//tft_clk,tft_de,tft_bl:TFT像素时钟、数据使能、背光信号
assign  tft_clk = clk_in    ;
assign  tft_de  = data_valid;
assign  tft_bl  = sys_rst_n ;

//cnt_h:行扫描计数器
always@(posedge clk_in or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_h   &lt;=  11&#39;d0;
    else    if(cnt_h == H_TOTAL - 1&#39;b1)
        cnt_h   &lt;=  11&#39;d0;
    else
        cnt_h   &lt;=  cnt_h + 10&#39;d1;

//cnt_v:场扫描计数器
always@(posedge clk_in or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_v   &lt;=  11&#39;d0;
    else    if(cnt_h == H_TOTAL - 1&#39;b1) 
    begin
        if(cnt_v == V_TOTAL - 1&#39;b1)
            cnt_v   &lt;=  11&#39;d0;
        else
            cnt_v   &lt;=  cnt_v + 10&#39;d1;
    end
    else 
        cnt_v   &lt;=  cnt_v;

//data_valid:有效显示区域标志
assign  data_valid = ((cnt_h &gt;= (H_SYNC + H_BACK + H_LEFT))
                    &amp;&amp; (cnt_h &lt; (H_SYNC + H_BACK + H_LEFT + H_VALID )))
                    &amp;&amp;((cnt_v &gt;= (V_SYNC + V_BACK + V_TOP))
                    &amp;&amp; (cnt_v &lt; (V_SYNC + V_BACK + V_TOP + V_VALID)));

//data_req:图像数据请求
assign  data_req = ((cnt_h &gt;= (H_SYNC + H_BACK + H_LEFT + H_BLACK - 1&#39;b1)) 
                    &amp;&amp; (cnt_h &lt; ((H_SYNC + H_BACK + H_LEFT + H_BLACK + H_PIXEL - 1&#39;b1))))
                    &amp;&amp;((cnt_v &gt;= ((V_SYNC + V_BACK + V_TOP + V_BLACK)))
                    &amp;&amp; (cnt_v &lt; ((V_SYNC + V_BACK + V_TOP + V_BLACK + V_PIXEL))));

assign  pix_x = (data_req == 1&#39;b1)
                ? (cnt_h - (H_SYNC + H_BACK + H_LEFT - 1&#39;b1)) : 11&#39;h3ff;
assign  pix_y = (data_req == 1&#39;b1)
                ? (cnt_v - (V_SYNC + V_BACK + V_TOP)) : 11&#39;h3ff;

//data_out:输出有效图像数据
assign  data_out = (data_req == 1&#39;b1) ? data_in : 16&#39;h0000;

//hsync,vsync,rgb_tft_16b:行、场同步信号、图像数据
assign  rgb_tft_16b = (data_valid == 1&#39;b0) ? 16&#39;hFFFF : data_out;
assign  hsync = (cnt_h  &lt;=  H_SYNC - 1&#39;d1) ? 1&#39;b1 : 1&#39;b0  ;
assign  vsync = (cnt_v  &lt;=  V_SYNC - 1&#39;d1) ? 1&#39;b1 : 1&#39;b0  ;

//rgb16 565转rgb24 888
assign rgb_r=&#123;rgb_tft_16b[15:11],3&#39;d0&#125;;
assign rgb_g=&#123;rgb_tft_16b[10:5],2&#39;d0&#125;;
assign rgb_b=&#123;rgb_tft_16b[4:0],3&#39;d0&#125;; 
assign rgb_tft_24b=&#123;rgb_r,rgb_g,rgb_b&#125;;

endmodule


    可以看出 **data_req 信号超前 data_valid 信号一个时钟周期** （这里H_BLACK=V_BLACK=0且 **data_req   多减了一个 1 **）；data_req 考虑了黑边框，**因为分辨率 480*272 对应行列有效周期 480 和 272 ，故黑边多少像素减去多少周期即可** ；另外 pix_x 和 pix_y 都已在此赋值。
</code></pre>
<h4 id="（2）tft-pic-图像数据生成模块"><a href="#（2）tft-pic-图像数据生成模块" class="headerlink" title="（2）tft_pic 图像数据生成模块"></a>（2）tft_pic 图像数据生成模块</h4><pre><code>    以 TFT 显示时序控制模块传入的图像有效显示区域像素点坐标(pix_x,pix_y)为约束条件，产生 TFT 彩条图像像素点色彩信息并回传给 TFT 显示时序控制模块。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6e497f9c789be6e30f8f2d095897aeef.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d168edbc88ab3e3d9e0d0242a1119154.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0997f4cd9124ba9a8c00f4b586e9d227.png"></p>
<pre><code>module  tft_pic
(
    input   wire            tft_clk_9m  ,   //输入工作时钟,频率9MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效
    input   wire    [9:0]   pix_x       ,   //输入TFT有效显示区域像素点X轴坐标
    input   wire    [9:0]   pix_y       ,   //输入TFT有效显示区域像素点Y轴坐标

    output  reg     [15:0]  pix_data        //输出像素点色彩信息

);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

parameter   H_VALID =   10&#39;d480 ,   //行有效数据
            V_VALID =   10&#39;d272 ;   //场有效数据

parameter   RED     =   16&#39;hF800,   //红色
            ORANGE  =   16&#39;hFC00,   //橙色
            YELLOW  =   16&#39;hFFE0,   //黄色
            GREEN   =   16&#39;h07E0,   //绿色
            CYAN    =   16&#39;h07FF,   //青色
            BLUE    =   16&#39;h001F,   //蓝色
            PURPPLE =   16&#39;hF81F,   //紫色
            BLACK   =   16&#39;h0000,   //黑色
            WHITE   =   16&#39;hFFFF,   //白色
            GRAY    =   16&#39;hD69A;   //灰色

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//pix_data:输出像素点色彩信息,根据当前像素点坐标指定当前像素点颜色数据
always@(posedge tft_clk_9m or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pix_data    &lt;= 16&#39;d0;
    else    if((pix_x &gt;= 0) &amp;&amp; (pix_x &lt; (H_VALID/10)*1))
        pix_data    &lt;=  RED;
    else    if((pix_x &gt;= (H_VALID/10)*1) &amp;&amp; (pix_x &lt; (H_VALID/10)*2))
        pix_data    &lt;=  ORANGE;
    else    if((pix_x &gt;= (H_VALID/10)*2) &amp;&amp; (pix_x &lt; (H_VALID/10)*3))
        pix_data    &lt;=  YELLOW;
    else    if((pix_x &gt;= (H_VALID/10)*3) &amp;&amp; (pix_x &lt; (H_VALID/10)*4))
        pix_data    &lt;=  GREEN;
    else    if((pix_x &gt;= (H_VALID/10)*4) &amp;&amp; (pix_x &lt; (H_VALID/10)*5))
        pix_data    &lt;=  CYAN;
    else    if((pix_x &gt;= (H_VALID/10)*5) &amp;&amp; (pix_x &lt; (H_VALID/10)*6))
        pix_data    &lt;=  BLUE;
    else    if((pix_x &gt;= (H_VALID/10)*6) &amp;&amp; (pix_x &lt; (H_VALID/10)*7))
        pix_data    &lt;=  PURPPLE;
    else    if((pix_x &gt;= (H_VALID/10)*7) &amp;&amp; (pix_x &lt; (H_VALID/10)*8))
        pix_data    &lt;=  BLACK;
    else    if((pix_x &gt;= (H_VALID/10)*8) &amp;&amp; (pix_x &lt; (H_VALID/10)*9))
        pix_data    &lt;=  WHITE;
    else    if((pix_x &gt;= (H_VALID/10)*9) &amp;&amp; (pix_x &lt; H_VALID))
        pix_data    &lt;=  GRAY;
    else
        pix_data    &lt;=  BLACK;

endmodule


    每个时钟周期 tft_clk_9m 对 pix_data 赋值即可；由于 pix_data 由 pix_x、pix_y 的值确定，易知 **pix_data 滞后 pix_x、pix_y 信号一个时钟周期** 。
</code></pre>
<h4 id="（3）顶层模块"><a href="#（3）顶层模块" class="headerlink" title="（3）顶层模块"></a>（3）顶层模块</h4><pre><code>module  tft_colorbar
(
    input   wire            sys_clk     ,   //输入工作时钟,频率50MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效

    output  wire    [15:0]  rgb_tft     ,   //输出像素信息
    output  wire            hsync       ,   //输出行同步信号
    output  wire            vsync       ,   //输出场同步信号
    output  wire            tft_clk     ,   //输出TFT时钟信号
    output  wire            tft_de      ,   //输出TFT使能信号
    output  wire            tft_bl          //输出背光信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//wire  define
wire            tft_clk_9m  ;   //TFT工作时钟,频率9MHz
wire            locked      ;   //PLL locked信号
wire            rst_n       ;   //TFT模块复位信号
wire    [9:0]   pix_x       ;   //TFT有效显示区域X轴坐标
wire    [9:0]   pix_y       ;   //TFT有效显示区域Y轴坐标
wire    [15:0]  pix_data    ;   //TFT像素点色彩信息

//rst_n:TFT模块复位信号
assign  rst_n = (sys_rst_n &amp; locked);

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

clk_wiz_0 clk_gen_inst
(
    .reset     (~sys_rst_n ),  //输入复位信号,高电平有效,1bit
    .clk_in1   (  sys_clk  ),  //输入50MHz晶振时钟,1bit
    .clk_out1  (tft_clk_9m ),  //输出TFT工作时钟,频率9Mhz,1bit

    .locked    (locked     )   //输出pll locked信号,1bit
);

//------------- tft_ctrl_inst -------------
tft_ctrl tft_ctrl_inst
(
    .clk_in     (tft_clk_9m ) ,   //输入时钟
    .sys_rst_n  (rst_n      ) ,   //系统复位,低电平有效
    .data_in    (pix_data   ) ,   //待显示数据
    .data_req   (           ) ,   //数据请求信号
    .pix_x      (pix_x      ) ,   //输出TFT有效显示区域像素点X轴坐标
    .pix_y      (pix_y      ) ,   //输出TFT有效显示区域像素点Y轴坐标
    .rgb_tft_16b(rgb_tft    ) ,   //TFT显示数据16bit
    .rgb_tft_24b(           ) ,   //TFT显示数据24bit
    .hsync      (hsync      ) ,   //TFT行同步信号
    .vsync      (vsync      ) ,   //TFT场同步信号
    .tft_clk    (tft_clk    ) ,   //TFT像素时钟
    .tft_de     (tft_de     ) ,   //TFT数据使能
    .tft_bl     (tft_bl     )     //TFT背光信号
);
//------------- tft_pic_inst -------------
tft_pic tft_pic_inst
(
    .tft_clk_9m  (tft_clk_9m),   //输入工作时钟,频率9MHz
    .sys_rst_n   (rst_n     ),   //输入复位信号,低电平有效
    .pix_x       (pix_x     ),   //输入TFT有效显示区域像素点X轴坐标
    .pix_y       (pix_y     ),   //输入TFT有效显示区域像素点Y轴坐标

    .pix_data    (pix_data  )    //输出像素点色彩信息

);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/657603b593b0d744497cd255c77a7f32.png"></p>
<h2 id="二-TFT-LCD-液晶屏字符显示"><a href="#二-TFT-LCD-液晶屏字符显示" class="headerlink" title="二.TFT_LCD 液晶屏字符显示"></a>二.TFT_LCD 液晶屏字符显示</h2><pre><code>    在 TFT 显示屏中心位置显示金色“野火科技”四个汉字，字符外的背景颜色为黑色。**每个汉字大小为 56*56，字模点阵为 64*64** ，TFT 显示屏显示模式为 480*270@60。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d58f5808c61fc77af64e60a14708137c.png"></p>
<p>**         第一部分**：字符点阵显示区域坐标信号的设计与实现在上面小节中，我们利用<strong>取模软件</strong> 生成了要显示字符的字模，字模点阵的大小为<br><strong>256<em>64（64</em>4*64）</strong> ，那么如何利用字模点阵进行字符显示呢？ 首先确定字符<strong>有效显示区域</strong><br>，区域大小与字符点阵大小相同，显示区域的像素点与字模点阵中数据项一一对应，<strong>当字模点阵中的数据项数值为“1”时，赋值字符颜色给对应像素点；当字模点阵中的数据项数值为“0”时，赋值点阵背景颜色给对应像素点</strong><br>。 所以为了确定字符点阵显示区域，我们声明两个变量 char_x、char_y，两变量组成字 符点阵显示区域坐标，在字符点阵有效显示区域内，<strong>char_x<br>信号 0-255 循环计数，char_y 信号 0-63 循环计数</strong><br>，根据坐标(char_x,char_y)寻找字符点阵对应的数据项，根据数据项的数值，赋予对应坐标像素点颜色信息。char_x、char_y<br>信号波形具体见图。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ff106cc7206516eb925a0af0c62929b.png"></p>
<pre><code>module  tft_pic
(
    input   wire            tft_clk_9m  ,   //输入工作时钟,频率9MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效
    input   wire    [9:0]   pix_x       ,   //输入TFT有效显示区域像素点X轴坐标
    input   wire    [9:0]   pix_y       ,   //输入TFT有效显示区域像素点Y轴坐标

    output  reg     [15:0]  pix_data        //输出像素点色彩信息

);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

parameter   H_VALID =   10&#39;d480 ,   //行有效数据
            V_VALID =   10&#39;d272 ;   //场有效数据

parameter   CHAR_B_H=   10&#39;d112 ,   //字符开始X轴坐标
            CHAR_B_V=   10&#39;d104 ;   //字符开始Y轴坐标

parameter   CHAR_W  =   10&#39;d256 ,   //字符宽度
            CHAR_H  =   10&#39;d64  ;   //字符高度

parameter   BLACK   =   16&#39;h0000,   //黑色
            GOLDEN  =   16&#39;hFEC0;   //金色

//wire  define
wire    [9:0]   char_x  ;   //字符显示X轴坐标
wire    [9:0]   char_y  ;   //字符显示Y轴坐标

//reg   define
reg     [255:0] char    [63:0]  ;   //字符数据

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//字符显示坐标
assign  char_x  =   (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))
                    &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))
                    ? (pix_x - CHAR_B_H) : 10&#39;h3FF;
assign  char_y  =   (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))
                    &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))
                    ? (pix_y - CHAR_B_V) : 10&#39;h3FF;

//char:字符数据
always@(posedge tft_clk_9m)
    begin
        char[0]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[1]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[2]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[3]     &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[4]     &lt;=  256&#39;h00000000003C0000000000000000000000000000000070000000000000000000;
        char[5]     &lt;=  256&#39;h0000000E003E00000000000000000000000000000000F0000000000000000000;
        char[6]     &lt;=  256&#39;h000000FF001F00000000000000000000000000000001F0000000000000400000;
        char[7]     &lt;=  256&#39;h000007FF000F00000000000000000000000010000001F8000000000000E00000;
        char[8]     &lt;=  256&#39;h00007FFE000F000000000000000000000003FE000001F8000000000000F00000;
        char[9]     &lt;=  256&#39;h0000FE7E003F00000000000000000000000FFF800001F80000003E0000F00000;
        char[10]    &lt;=  256&#39;h0000E07C01F8000000000000000000000007FF81F801FC0000003F0000F00000;
        char[11]    &lt;=  256&#39;h0000E0F80380000000000000000000000003FF80FE00780000003F0001E00000;
        char[12]    &lt;=  256&#39;h0000E0F80380000000000000000000000001FF80FF00780000003F0001E00000;
        char[13]    &lt;=  256&#39;h0780E1F003FC000000000000000000000000FF80FF80780000003E0001E00000;
        char[14]    &lt;=  256&#39;h07C0FFF003FE0000000000020000000000003F007F80780000003E0001E00000;
        char[15]    &lt;=  256&#39;h07E0FFE001FE0000000000070000000000000E007F00780000003C0001FF0000;
        char[16]    &lt;=  256&#39;h07F3FFE0000E00000000000700000000000000007E00F80000003C0001FF0000;
        char[17]    &lt;=  256&#39;h07F9FFC0000E00000000000F0000000000003E00CC01F80000007C0003FE0000;
        char[18]    &lt;=  256&#39;h03F9FFC0001C03E00000000F8000000000003F010001F80000007E0003F80000;
        char[19]    &lt;=  256&#39;h03F9FF8000781FF80000001F8000000000007F038001F8000000FF0007F00000;
        char[20]    &lt;=  256&#39;h03F9FF8001F07FF80000001F878000000000FE078001F8000000FF000FE00000;
        char[21]    &lt;=  256&#39;h03FDFF0007C3FFF00000003FFFC000000001FC07C001F8000001FF003FE00000;
        char[22]    &lt;=  256&#39;h03FDFF000F9F8FF00001C03FFFC000000007F807F001F8000007FE003FC00000;
        char[23]    &lt;=  256&#39;h03FFFE001FFF8FE00001E07FFFC00000001FF807FC01F800000FFC0003C00000;
        char[24]    &lt;=  256&#39;h01FFF0007FFF8FC00003E07FFC000000067FF007FE01FC00001FF80003800000;
        char[25]    &lt;=  256&#39;h01FFC000FFEF9F800003E0FE000000000FFFF003FC01FE00007FF00007800000;
        char[26]    &lt;=  256&#39;h01FF8001FF8F9F000007E0FE000000000FFFF041F803FC0000FFE00007800000;
        char[27]    &lt;=  256&#39;h01FF8007FC1F9E00001FE0FE000000000FFFF180F00FFC000001E00007000000;
        char[28]    &lt;=  256&#39;h00FF8007F01F3C00003FE1FC00000000007FF601E01FF8000001E000071C0000;
        char[29]    &lt;=  256&#39;h00FF8007C01FFC00003FE1FC00000000001FFC03C0FFF8000001E0000F3E0000;
        char[30]    &lt;=  256&#39;h00030002001FF800003FC3FC00000000003FF807C3FFF8000001E7800FFE0000;
        char[31]    &lt;=  256&#39;h00070000001FF000007FC3F800000000003FF80F9FFFF0000001FF000FFE0000;
        char[32]    &lt;=  256&#39;h0007F000001FE000007F83F800000000007FF01FFFC3F0000001FE000FFE0000;
        char[33]    &lt;=  256&#39;h001FF000001FC000003F83F00000000000FFF01FFE03F0000001FC001FFE0000;
        char[34]    &lt;=  256&#39;h007FE000001F8000003F07F00000000000FFE03FF003F0000003F8001F3E0000;
        char[35]    &lt;=  256&#39;h007FC000001F8000001807F00000000001FFE03F8003F0000003F0001F3C0000;
        char[36]    &lt;=  256&#39;h00078600001F000000000FF80000000003FFC07E0003F0000003F0001E3C0000;
        char[37]    &lt;=  256&#39;h000F1E00001F000000000FFC0000000007FFC0180003F0000007E003843C0000;
        char[38]    &lt;=  256&#39;h003FFC00001F800000001FDE0000000007FFC0000003F000000FF001E03C0000;
        char[39]    &lt;=  256&#39;h007FF800001F800000003FDF8000000007C7C0000003F00000FFF000F83C0000;
        char[40]    &lt;=  256&#39;h00FFF000001F800000007F9FF00000000787C0000003F00007FFF0007F3C0000;
        char[41]    &lt;=  256&#39;h01FFE000001F80000000FF0FFE0000000707C0000003F0001FF1F8003FFC0000;
        char[42]    &lt;=  256&#39;h03FF8000001F80000001FE0FFFE000000003C0000003F0003F81F8001FFC0000;
        char[43]    &lt;=  256&#39;h07FF0000003F80000003FC07FFFE0000000300000003F0003E01FC000FFE0000;
        char[44]    &lt;=  256&#39;h07FC0000003F80000007F803FFFFE000000000000003F0001F83FC0007FFF000;
        char[45]    &lt;=  256&#39;h07F80000003F8000000FF001FFFFFF80000000000003F0000FFFFC0003FFFF80;
        char[46]    &lt;=  256&#39;h03E00000007F8000001FC0007FFFFFC0000000000003F00003FFFE0007FFFFF0;
        char[47]    &lt;=  256&#39;h0000000000FF8000007F80001FFFFFE0000000000003F000007FFE003FBFFFF8;
        char[48]    &lt;=  256&#39;h0000000001FF800000FE000007FFFFE0000000000003E000000FFC03FE0FFFF8;
        char[49]    &lt;=  256&#39;h0000000007FF800001F8000001FFFFF0000000000003E0000000F8FFC003FFF8;
        char[50]    &lt;=  256&#39;h000000007FFF000003E00000001FFFC0000000000003C0000000000000007FF8;
        char[51]    &lt;=  256&#39;h00000007FFFE0000070000000001FFC0000000000003C0000000000000000FF0;
        char[52]    &lt;=  256&#39;h0000000200F800000000000000000F8000000000000300000000000000000060;
        char[53]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[54]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[55]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[56]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[57]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[58]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[59]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[60]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[61]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[62]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
        char[63]    &lt;=  256&#39;h0000000000000000000000000000000000000000000000000000000000000000;
    end

//pix_data:输出像素点色彩信息,根据当前像素点坐标指定当前像素点颜色数据
always@(posedge tft_clk_9m or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pix_data    &lt;= BLACK;
    else    if(((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W)))
                &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H))))
        begin
            if(char[char_y][10&#39;d255 - char_x] == 1&#39;b1)
                pix_data    &lt;=  GOLDEN;
            else
                pix_data    &lt;=  BLACK;
        end
    else
        pix_data    &lt;= BLACK;

endmodule
</code></pre>
<p>可知根据对应坐标的char二维数组值判定颜色。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133174030">https://blog.csdn.net/qq_32971095/article/details/133174030</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="post-title-link" itemprop="url">嵌入式学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-22 13:03:41" itemprop="dateCreated datePublished" datetime="2023-09-22T13:03:41+08:00">2023-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF">一.嵌入式学习路线</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5">二.学习实践</a></p>
<p><a href="about:blank#1.%E8%AF%BE%E5%86%85%E8%AF%BE%E7%A8%8B">1.课内课程</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p>
<p><a href="about:blank#2.51%E5%8D%95%E7%89%87%E6%9C%BA">2.51单片机</a></p>
<p><a href="about:blank#3.stm32">3.stm32</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p>
<p><a href="about:blank#4.FPGA">4.FPGA</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p>
<p><a href="about:blank#5.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">5.操作系统</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">三.其他学习资料</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%80%BB%E7%BB%93">四.总结</a></p>
<hr>
<h2 id="一-嵌入式学习路线"><a href="#一-嵌入式学习路线" class="headerlink" title="一.嵌入式学习路线"></a>一.嵌入式学习路线</h2><pre><code>   对于计算机科学与技术嵌入式方向的学生，要学好嵌入式括软件和硬件。 大一时搜集有关嵌入式方面的介绍，分享一篇对我颇有启发的作者——小智学长嵌入式（微信公众号）。

    截取文章[【干货】关于嵌入式开发的经验之谈](https://mp.weixin.qq.com/s/HFsuS9_teHIzbdc6dQ9-IA &quot;【干货】关于嵌入式开发的经验之谈&quot;)如下：
</code></pre>
<p>总结下来，需要掌握以下技能：</p>
<pre><code>    **算法层** ：需要根据处理器的特性，选择最适合在该处理上运行的算法。例如两个实现相同功能的算法，一个适合并行，一个不适合并行，则优先选取适合并行的算法。再比如有些算法的实现，存在一些过设计（如太多的迭代次数），需要能及时识别出来。算法层的优化必须先做，在这一层可能能带来事半功倍的效果。所以嵌入式工程师需要懂相关算法的原理，否则容易被算法工程师唬住（大家别笑，这种事情其实经常发生）。并行层：识别出代码中可以并行加速的部分，根据所用处理器的并行处理单元(NEON, DSP, GPU) ，使用vectorC/intrinsic C/CUDA/openCL编写并行加速代码，最大限度提高并行运算单元利用率。处理器层：如果编译器做得比较好，经过第二层，会得到优化效率很高的代码。但目前大部分编译器仍旧与人工节写的汇编有一定差距。所以针对热点代码，可以采用手写汇编的方式进行优化。但这一步，是优化到最后仍旧差一点点万不得已的办法，写汇编会耗费大量的时间精力，日后换处理器时还需要重写。处理器层除了汇编优化，还包括cache,DMA等memory相关的优化。memory的优化是经常被忽视的地方，通过提升内存的cache友好性是一件事半功倍的工作。
</code></pre>
<p>**<br>语言基础**:C&#x2F;C++操作系统：RTOS、Linux、Android硬件：10、12C、SPI、SDIO、USB、内外部中断、定时器编程技能：数据结构、IPC、进程、线程、内存、文件、socket项目相关:wifi<br>ble 摄像头 激光雷达<br>zigbee等，这个部分根据自己学校资源与身边资源去选择。但有一个点非常重要，比如说你做wifi相关的项目，不是去实现wifi的连接功能即可，而是针对实际的产品场景，去输出有价值的实现方案。举个例子，做智能家居的产品，部分同学都是把模块买回来，源码UI改下，连接到别人服务器，然后整个链路跑通就完了。但是如果你做了一个断网以及网络延时情况下方案的解决办法或者模块远程升级的方案，这部分的实现思想比起你跑通整个链路，其实是更有谈资的。</p>
<pre><code>    大学可以学习学习以下方面：C和汇编语言混合编程、c++-&gt;python-&gt;JAVA、MAKEFILE、Builtroot(Linux移植)、cpu架构 ARM DSP/GPU、操作系统、通信协议(驱动)、ros系统、协议栈。

    还有有关硬件基础的内容，由于大一当时看不懂，就未截取。现在看来还是非常全面的。

    大学的很多竞赛都可以打打，提升自己的技术，比如：数学竞赛、算法竞赛、嵌入式相关的一些比赛和项目、数学建模...

    如果想在将来创业或者职业规划最后走向管理岗，可以多多了解一些项目管理的知识。

 

    另外看到两段比较有感触的话：

    12、输出**个人价值：** 把自己对于项目、对于职场、对于专业技能的思考，转化为文字、语音或视频输出到互联网，能给你带来意想不到的收获。

    13、不要给自己设限。工作十年后，你可以成为技术专家、项目经理，也可以成为售前技术、方案架构、专利顾问，可以开淘宝店卖开发板教程、出书、做培训机构老师，也可以给自己上下游厂家卖技术方案、开外包公司、建立自己品牌，甚至在自已小区楼下开小卖铺，一个月一万多生活没问题的。
</code></pre>
<h2 id="二-学习实践"><a href="#二-学习实践" class="headerlink" title="二.学习实践"></a>二.学习实践</h2><h3 id="1-课内课程"><a href="#1-课内课程" class="headerlink" title="1.课内课程"></a>1.课内课程</h3><p>高等数学、离散数学、概率论、大学物理;</p>
<p>电路基础、数字电路、模拟电路、计算机通信与网络、信号与系统、数字信号处理;</p>
<p>计算机组织与体系结构、微机原理;</p>
<p>计算机导论与程序设计、程序设计、数据结构、操作系统、python、数据库系统</p>
<h4 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/129629331?spm=1001.2014.3001.5502" title="python爬虫学习笔记">python爬虫学习笔记<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;129629331?spm&#x3D;1001.2014.3001.5502</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124532108?spm=1001.2014.3001.5502" title="位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业">位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124532108?spm&#x3D;1001.2014.3001.5502</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124508883?spm=1001.2014.3001.5502" title="简单文件数据库-模拟图书馆管理系统-西安电子科技大学大一程序基础设计课程设计作业">简单文件数据库-模拟图书馆管理系统-<br>西安电子科技大学大一程序基础设计课程设计作业<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124508883?spm&#x3D;1001.2014.3001.5502</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124302787?spm=1001.2014.3001.5502" title="UVa232解答">UVa232解答<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;124302787?spm&#x3D;1001.2014.3001.5502</a><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88221772?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机大类大一下程序设计基础课程设计大作业资源">【免费】西安电子科技大学计算机大类大一下程序设计基础课程设计大作业资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221772?spm&#x3D;1001.2014.3001.5503</a><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88221707?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机大类大一上机代码及部分答案资源">【免费】西安电子科技大学计算机大类大一上机代码及部分答案资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221707?spm&#x3D;1001.2014.3001.5503</a><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88221767?spm=1001.2014.3001.5503" title="【免费】西安电子科技大学计算机科学与技术专业大二数据结构上机代码资源">【免费】西安电子科技大学计算机科学与技术专业大二数据结构上机代码资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221767?spm&#x3D;1001.2014.3001.5503</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133420554" title="边缘检测——Matlab实现计算机视觉＜1＞">边缘检测——Matlab实现计算机视觉＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133420554</a></p>
<h3 id="2-51单片机"><a href="#2-51单片机" class="headerlink" title="2.51单片机"></a>2.51单片机</h3><p>推荐学习（结合开发板）：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RB4y1i71i/?spm_id_from=333.999.0.0" title="【普中官方】51单片机手把手教学视频">【普中官方】51单片机手把手教学视频</a></p>
<p>学习收获：</p>
<p>对单片机、模块有相应概念，会通过寄存器操作的方式使用单片机；实现简单功能</p>
<h3 id="3-stm32"><a href="#3-stm32" class="headerlink" title="3.stm32"></a>3.stm32</h3><p>推荐学习（结合核心板和模块）：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.999.0.0" title="STM32入门教程-2023持续更新中">STM32入门教程-2023持续更新中</a></p>
<p>学习收获：</p>
<p>掌握单片机的库函数开发方式；熟悉模块互联通信；单片机系统程序设计；可制作稍复杂控制系统</p>
<h5 id="学习记录-1"><a href="#学习记录-1" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132150694?spm=1001.2014.3001.5502" title="2023年电赛E题完整设计暨电赛全记录——二.学习资料分享——&lt;1&gt;学习笔记">2023年电赛E题完整设计暨电赛全记录——二.学习资料分享——&lt;1&gt;学习笔记<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132150694?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88226743?spm=1001.2014.3001.5503" title="电赛备战：基于stm32的多功能巡线避障小车_stm32巡线小车原理详解资源">电赛备战：基于stm32的多功能巡线避障小车_stm32巡线小车原理详解资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88226743?spm&#x3D;1001.2014.3001.5503</a><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88221917" title="基于stm32的智能自行车尾灯_自行车尾灯资源">基于stm32的智能自行车尾灯_自行车尾灯资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221917</a><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88221914" title="【免费】stm32测试平台，包含oled显示和蓝牙通讯功能资源">【免费】stm32测试平台，包含oled显示和蓝牙通讯功能资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88221914</a></p>
<h3 id="4-FPGA"><a href="#4-FPGA" class="headerlink" title="4.FPGA"></a>4.FPGA</h3><p>推荐学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA系列Xilinx Artix7教学视频">FPGA系列Xilinx<br>Artix7教学视频</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1T84y1C7qy/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA-MPSoC">FPGA-<br>MPSoC</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hq4y1u7qH/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="ZYNQ之嵌入式SDK开发">ZYNQ之嵌入式SDK开发</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qz4y1d7pF/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="ZYNQ之Linux开发">ZYNQ之Linux开发</a></p>
<p>学习收获：</p>
<p>**     **    Zynq 的 PS 部分就像 stm32<br>一样，本质都是配置外设的寄存器，利用开发商或者其他提供的友好接口的库函数对寄存器进行配置开发。 stm32 使用<br>ARM公司提供的cortex-M3内核，通过下载器将机器码下载至存储器代码段。</p>
<pre><code>    此时再**回头看 stm32 的 SoC 架构和总线系统** 相比 Zynq 的也容易看了许多，之后再看stm32 的数据手册也多了一些理解。还有之后的 stm32 的学习，可以使用 keil5 的调试功能，检查各个寄存器的值和执行的汇编语言，从而更深层面了解微机原理和 CPU 的运作。
</code></pre>
<h5 id="学习记录-2"><a href="#学习记录-2" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132220627?spm=1001.2014.3001.5502" title="FPGA基本概念及资源整理——FPGA学习笔记＜0＞——零.前言——学习实践汇总">FPGA基本概念及资源整理——FPGA学习笔记＜0＞——零.前言——学习实践汇总<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132220627?spm&#x3D;1001.2014.3001.5502</a></p>
<h3 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5.操作系统"></a>5.操作系统</h3><p><strong>学习记录</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/130351060?spm=1001.2014.3001.5502" title="FreeRTOS学习笔记（一）">FreeRTOS学习笔记（一）<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;130351060?spm&#x3D;1001.2014.3001.5502</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133484963" title="Linux系统——OS学习笔记＜1＞">Linux系统——OS学习笔记＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133484963</a></p>
<h2 id="三-其他学习资料"><a href="#三-其他学习资料" class="headerlink" title="三.其他学习资料"></a>三.其他学习资料</h2><p>推荐学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yx411u7iX/?spm_id_from=333.788.videocard.6&vd_source=01cde8042a76495bf513aa4407a56cd6" title="【Advanced控制理论】">【Advanced控制理论】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16E411h7Cg/?spm_id_from=333.788.videocard.10" title="现代控制理论（清华大学）">现代控制理论（清华大学）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15t411G7AG/?p=22&vd_source=01cde8042a76495bf513aa4407a56cd6" title="东北大学-计算机控制系统（国家级精品课）">东北大学-<br>计算机控制系统（国家级精品课）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bf4y1t7oA/?p=1&vd_source=01cde8042a76495bf513aa4407a56cd6" title="现代数字信号处理">现代数字信号处理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1es411H7eJ/?p=1&vd_source=01cde8042a76495bf513aa4407a56cd6" title="数字信号处理（西安电子科技大学&#x2F;西电）">数字信号处理（西安电子科技大学&#x2F;西电）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cqfdcw/article/details/84939698" title="常见滤波器简要对比介绍及Matlab实现">常见滤波器简要对比介绍及Matlab实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18E411f7ZQ/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="数字信号分析理论与实践（基于matlab）">数字信号分析理论与实践（基于matlab）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qf4y1x7kB/" title="浙江大学-机器学习">浙江大学-机器学习</a></p>
<h5 id="学习记录-3"><a href="#学习记录-3" class="headerlink" title="学习记录"></a><strong>学习记录</strong></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132343604?spm=1001.2014.3001.5501" title="​​​​​项目管理概述">​​​​​项目管理概述<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132343604?spm&#x3D;1001.2014.3001.5501</a></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>总结来说就是借鉴，思考，改进，创新！</p>
<p>做好生涯规划，不要蹉跎岁月</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133165306">https://blog.csdn.net/qq_32971095/article/details/133165306</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/18/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E5%9B%9B%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E3%80%81%E5%8F%91%E7%94%9F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C5%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/18/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E5%9B%9B%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E3%80%81%E5%8F%91%E7%94%9F%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C5%EF%BC%9E/" class="post-title-link" itemprop="url">基础设计四（信号采集、发生）——FPGA学习笔记＜5＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-18 21:55:27" itemprop="dateCreated datePublished" datetime="2023-09-18T21:55:27+08:00">2023-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E7%AE%80%E6%98%93%E9%A2%91%E7%8E%87%E8%AE%A1">一.简易频率计</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A2%91%E7%8E%87%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97">（2）频率计算模块</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89freq_meter_calc%E6%A8%A1%E5%9D%97">（1）freq_meter_calc模块</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">（2）顶层模块</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">&lt;3&gt;仿真设计</a></p>
<p><a href="about:blank#%E4%BA%8C.%E7%AE%80%E6%98%93%20DDS%20%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8">二.简易 DDS<br>信号发生器</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89DDS%E9%83%A8%E5%88%86">（2）DDS部分</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F">&lt;3&gt;仿真</a></p>
<p><a href="about:blank#%E4%B8%89.%E7%AE%80%E6%98%93%E7%94%B5%E5%8E%8B%E8%A1%A8">三.简易电压表</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">&lt;2&gt;代码设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89ADC">（1）ADC</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E9%A1%B6%E5%B1%82">（2）顶层</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%BF%E7%9C%9F">&lt;3&gt;仿真</a></p>
<hr>
<p>前置学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132818565" title="基础设计三——FPGA学习笔记＜4＞">基础设计三——FPGA学习笔记＜4＞</a></p>
<p>参考书目：《<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8E%E7%81%AB&spm=1001.2101.3001.7020" title="野火">野火</a>FPGA Verilog 开发实战指南》</p>
<h2 id="一-简易频率计"><a href="#一-简易频率计" class="headerlink" title="一.简易频率计"></a>一.简易频率计</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><p><strong>频率测量法</strong> ：在时间 t 内对被测时钟信号的时钟周期 N 进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。</p>
<p><strong>周期测量法</strong> ：先测量出被测时钟信号的时钟周期 T，然后根据频率 f &#x3D; 1／T 求出被测时钟信号的频率。</p>
<pre><code>    但是上述两种方法都会**产生±1 个被测时钟周期的误差** ，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现**频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量** ，但二者都不能兼顾高低频率同样精度的测量要求。

    等精度测量法与前两种方式不同，其最大的特点是，测量的实际门控时间不是一个固定值，它与被测时钟信号相关，是被测时钟信号周期的整数倍。**在实际门控信号下，同时对标准时钟和被测时钟信号的时钟周期进行计数，再通过公式计算得到被测信号的时钟频率** 。**由于实际门控信号是被测时钟周期的整数倍，就消除了被测信号产生的±1 时钟周期的误差，但是会 产生对标准时钟信号±1 时钟周期的误差。**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29bf724d81198014910c13dc96eaac2d.png"></p>
<pre><code>    结合等精度测量原理和原理示意图可得：被测时钟信号的时钟频率 fx 的相对误差与被测时钟信号无关；**增大“软件闸门”的有效范围或者提高“标准时钟信号”的时钟频率 fs，可以减小误差，提高测量精度。**

    我们来说明一下被测时钟信号的计算方法。 首先我们先分别**对实际闸门下被测时钟信号和标准时钟信号的时钟周期进行计数** 。
</code></pre>
<p>实际闸门下被测时钟信号周期数为 X，设被测信号时钟周期为 Tfx，它的时钟频率 fx &#x3D; 1&#x2F;Tfx，由此可得等式：<strong>X * Tfx &#x3D; X &#x2F; fx &#x3D;<br>Tx(实际闸门)</strong> 。</p>
<p>实际闸门下标准时钟信号周期数为 Y，设被测信号时钟周期为 Tfs，它的时钟频率 fs &#x3D; 1&#x2F;Tfs，由此可得等式：<strong>Y * Tfs &#x3D; Y &#x2F; fs &#x3D;<br>Tx(实际闸门)</strong> 。</p>
<p>其次，将两等式结合得到只包含各自时钟周期计数和时钟频率的等式：X &#x2F; fx &#x3D; Y &#x2F; fs &#x3D;<br>Tx(实际闸门)，等式变换，得到被测时钟信号时钟频率计算公式：<strong>fx &#x3D; X * fs &#x2F; Y</strong> 。 最后，将已知量标准时钟信号时钟频率 fs 和测量量<br>X、Y 带入计算公式，得到被测时 钟信号时钟频率 fx。</p>
<h4 id="（1）整体设计"><a href="#（1）整体设计" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><pre><code>    设计一个基于等精度测量原理的简易频率计，对输入的未知时钟信号做频率测量，并将测量结果在数码管上显示。 要求：标准时钟信号频率为 100MHz，实际闸门时间大于或等于 1s，目的是减小误差，提高测量精度。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/978217a5799aeabeded01deee9551eac.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e94173082bc78bce0b67675ae8d59ee8.png"></p>
<pre><code>    注：由频率计算模块输出的测量结果的单位为 Hz，为提高频率计测量范围，将结果除以 1000 后，再传入数码管显示模块，同时数码管小数点左移三位，所以**数码管显示结果的单位为 MHz** ；被测时钟生成模块(clk_test_gen)负责产生待检测时钟信号，如有条件的读者可用信号发生器代替该模块，直接输入待检测时钟信号。
</code></pre>
<h4 id="（2）频率计算模块"><a href="#（2）频率计算模块" class="headerlink" title="（2）频率计算模块"></a>（2）频率计算模块</h4><p>波形绘制：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/02b9a4ea89adbb43d059dc540145cbb6.png"></p>
<p><strong>第一部分</strong> ：软件闸门 gate_s 及相关信号的设计与实现</p>
<pre><code>    软件闸门的生成我们需要声明计数器进行时间计数，计数时钟使用系统时钟 sys_clk。 声明软件闸门计数器 cnt_gate_s，计数时钟为 50MHz 系统时钟，时钟周期为 20ns，计数器 cnt_gate_s 初值为 0，在(0 – CNT_GATE_S_MAX)范围内循环计数。
</code></pre>
<p><strong>第二部分</strong> ：<strong>实际闸门 gate_a 的设计与实现生成软件闸门后，使用被测时钟对软件闸门进行同步生成实际闸门 gate_a，实际闸门<br>波形图如下。（结合代码分析逻辑）</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/23648a345380b8c3154eb7e6118f1e8e.png"></p>
<p><strong>第三部分</strong> ：实际闸门下，标准信号和被测信号时钟计数相关信号的波形设计与实现在实际闸门下，分别对标准信号和被测信号的时钟周期进行计数。声明计数器<br>cnt_clk_stand，在实际闸门下对标准时钟信号 clk_stand 进行时钟周期计数；声明计数器<br>cnt_clk_test，在实际闸门下对被测时钟信号 clk_test 进行时钟周期计数，两计数器波形如下。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5edf159cbdcee71c341f62c6e45080f0.png"></p>
<pre><code>    计数器 cnt_clk_stand、cnt_clk_test 在实际闸门下计数完成后，需要进行数据清零，方便下次计数。但是被测时钟频率的计算需要计数器的数据，所以在计数器数据清零之前我们需要**将计数器数据做一下寄存** ，对于数据寄存的时刻，我们选择**实际闸门的下降沿** 。 声明寄存器 cnt_clk_stand_reg；在标准时钟信号 clk_stand 同步下对实际闸门打一拍得 到 gate_a_s；使用实际闸门 gate_a 和 gate_a_s 得到标准时钟下的实际闸门下降沿标志信号 gate_a_fall_stand。当 gate_afall_stand 信号为高电平时，将计数器 cnt_clk_stand 数值赋值给寄存器 cnt_clk_stand_reg。 对 于 计 数 器 cnt_clk_test 的 数 值 寄 存 ， 我们使用相同的方法 ， 声明寄 存器 cnt_clk_test_reg；在被检测时钟信号 clk_test 同步下对实际闸门打一拍得到 gate_a_t；使用 实际闸门 gate_a 和 gate_a_t 得到被检测时钟下的实际闸门下降沿标志信号 gate_a_fall_test。 当 gate_a_fall_test 信号为高电平时，将计数器 cnt_clk_test 数值赋值给 cnt_clk_test_reg。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2bcf8e025972c05ca71aba1dc4dec4c.png"></p>
<p><strong>第四部分</strong> ：频率计算结果 freq 等相关信号波形的设计与实现实际闸门下的标准时钟和被测时钟的周期个数已经完成计数，且对结果进行了寄存，<br>标准时钟信号的时钟频率为已知量，得到这些参数，结合公式可以进行频率的求解。同时，新的问题出现，在哪一时刻进行数据求解。 我们可以利用最初声明的软件闸门计数器<br>cnt_gate_s，声明计算标志信号 calc_flag，在 计数器 cnt_gate_s 计数到最大值，将 calc_flag<br>拉高一个时钟周期的高电平作为计算标志， 计算被检测时钟信号时钟频率 freq_reg(注意变量位宽是否满足要求)；然后在系统时钟下将计算标志信号<br>calc_flag 打一拍，得到时钟频率输出标志信号 calc_flag_reg，当时钟频率输出标志信号 calc_flag_reg<br>为高电平时，将时钟频率计算结果 freq_reg 赋值给输出信号 freq。各信号波形图如下。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/680f95434816da76d89cec9336e84b6f.png"></p>
<h3 id="代码设计"><a href="#代码设计" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><p>参考书目参考代码：</p>
<h4 id="（1）freq-meter-calc模块"><a href="#（1）freq-meter-calc模块" class="headerlink" title="（1）freq_meter_calc模块"></a>（1）freq_meter_calc模块</h4><pre><code>module  freq_meter_calc
(
    input   wire            sys_clk     ,   //系统时钟,频率50MHz
    input   wire            sys_rst_n   ,   //复位信号,低电平有效
    input   wire            clk_test    ,   //待检测时钟

    output  reg     [33:0]  freq            //待检测时钟频率

);
//********************************************************************//
//****************** Parameter And Internal Signal *******************//
//********************************************************************//
//parameter define
parameter   CNT_GATE_S_MAX  =   28&#39;d37_499_999  ,   //软件闸门计数器计数最大值
            CNT_RISE_MAX    =   28&#39;d6_250_000   ;   //软件闸门拉高计数值
parameter   CLK_STAND_FREQ  =   28&#39;d100_000_000 ;   //标准时钟时钟频率
//wire  define
wire            clk_stand           ;   //标准时钟,频率100MHz
wire            gate_a_fall_s       ;   //实际闸门下降沿(标准时钟下)
wire            gate_a_fall_t       ;   //实际闸门下降沿(待检测时钟下)

//reg   define
reg     [27:0]  cnt_gate_s          ;   //软件闸门计数器
reg             gate_s              ;   //软件闸门
reg             gate_a              ;   //实际闸门
reg             gate_a_test         ;
reg             gate_a_stand        ;   //实际闸门打一拍(标准时钟下)
reg             gate_a_stand_reg    ;
reg             gate_a_test_reg     ;   //实际闸门打一拍(待检测时钟下)
reg     [47:0]  cnt_clk_stand       ;   //标准时钟周期计数器
reg     [47:0]  cnt_clk_stand_reg   ;   //实际闸门下标志时钟周期数
reg     [47:0]  cnt_clk_test        ;   //待检测时钟周期计数器
reg     [47:0]  cnt_clk_test_reg    ;   //实际闸门下待检测时钟周期数
reg             calc_flag           ;   //待检测时钟时钟频率计算标志信号

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//cnt_gate_s:软件闸门计数器
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_gate_s  &lt;=  28&#39;d0;
    else    if(cnt_gate_s == CNT_GATE_S_MAX)
        cnt_gate_s  &lt;=  28&#39;d0;
    else
        cnt_gate_s  &lt;=  cnt_gate_s + 1&#39;b1;

//gate_s:软件闸门
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_s  &lt;=  1&#39;b0;
    else    if((cnt_gate_s&gt;= CNT_RISE_MAX)
                &amp;&amp; (cnt_gate_s &lt;= (CNT_GATE_S_MAX - CNT_RISE_MAX)))
        gate_s  &lt;=  1&#39;b1;
    else
        gate_s  &lt;=  1&#39;b0;

//gate_a:实际闸门
always@(posedge clk_test or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_a  &lt;=  1&#39;b0;
    else
        gate_a  &lt;=  gate_s;

always@(posedge clk_test or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_a_test  &lt;=  1&#39;b0;
    else
        gate_a_test  &lt;=  gate_a;

//cnt_clk_stand:标准时钟周期计数器,计数实际闸门下标准时钟周期数
always@(posedge clk_stand or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_clk_stand   &lt;=  48&#39;d0;
    else    if(gate_a_stand == 1&#39;b0)
        cnt_clk_stand   &lt;=  48&#39;d0;
    else    if(gate_a_stand == 1&#39;b1)
        cnt_clk_stand   &lt;=  cnt_clk_stand + 1&#39;b1;

//cnt_clk_test:待检测时钟周期计数器,计数实际闸门下待检测时钟周期数
always@(posedge clk_test or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_clk_test    &lt;=  48&#39;d0;
    else    if(gate_a_test == 1&#39;b0)
        cnt_clk_test    &lt;=  48&#39;d0;
    else    if(gate_a_test == 1&#39;b1)
        cnt_clk_test    &lt;=  cnt_clk_test + 1&#39;b1;

//gate_a_stand:实际闸门打一拍(标准时钟下)
always@(posedge clk_stand or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_a_stand    &lt;=  1&#39;b0;
    else
        gate_a_stand    &lt;=  gate_a_test;

always@(posedge clk_stand or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_a_stand_reg    &lt;=  1&#39;b0;
    else
        gate_a_stand_reg    &lt;=  gate_a_stand;

//gate_a_fall_s:实际闸门下降沿(标准时钟下)
assign  gate_a_fall_s = ((gate_a_stand_reg == 1&#39;b1) &amp;&amp; (gate_a_stand == 1&#39;b0))
                        ? 1&#39;b1 : 1&#39;b0;

//cnt_clk_stand_reg:实际闸门下标志时钟周期数
always@(posedge clk_stand or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_clk_stand_reg   &lt;=  32&#39;d0;
    else    if(gate_a_fall_s == 1&#39;b1)
        cnt_clk_stand_reg   &lt;=  cnt_clk_stand;

//gate_a_test:实际闸门打一拍(待检测时钟下)
always@(posedge clk_test or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        gate_a_test_reg &lt;=  1&#39;b0;
    else
        gate_a_test_reg &lt;=  gate_a_test;

//gate_a_fall_t:实际闸门下降沿(待检测时钟下)
assign  gate_a_fall_t = ((gate_a_test_reg == 1&#39;b1) &amp;&amp; (gate_a_test == 1&#39;b0))
                        ? 1&#39;b1 : 1&#39;b0;

//cnt_clk_test_reg:实际闸门下待检测时钟周期数
always@(posedge clk_test or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_clk_test_reg   &lt;=  32&#39;d0;
    else    if(gate_a_fall_t == 1&#39;b1)
        cnt_clk_test_reg   &lt;=  cnt_clk_test;

//calc_flag:待检测时钟时钟频率计算标志信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        calc_flag   &lt;=  1&#39;b0;
    else    if(cnt_gate_s == (CNT_GATE_S_MAX - 1&#39;b1))
        calc_flag   &lt;=  1&#39;b1;
    else
        calc_flag   &lt;=  1&#39;b0;

//freq:待检测时钟信号时钟频率
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        freq    &lt;=  34&#39;d0;
    else    if(calc_flag == 1&#39;b1)
        freq    &lt;=  (CLK_STAND_FREQ / cnt_clk_stand_reg * cnt_clk_test_reg);

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//---------- clk_gen_inst ----------
clk_gen clk_gen_inst
(
    .reset    (~sys_rst_n ),
    .clk_in1  (sys_clk    ),
     
    .clk_out1 (clk_stand  )
);

endmodule
</code></pre>
<p>注：上述“打一拍”即经过一级寄存器，通过always时钟上升沿赋值即可实现</p>
<h4 id="（2）顶层模块"><a href="#（2）顶层模块" class="headerlink" title="（2）顶层模块"></a>（2）顶层模块</h4><pre><code>module  freq_meter
(
    input   wire            sys_clk     ,   //系统时钟,频率50MHz
    input   wire            sys_rst_n   ,   //复位信号,低电平有效
    input   wire            clk_test    ,   //待检测时钟

    output  wire            clk_out     ,   //生成的待检测时钟
    output  wire    [5:0]   sel         ,   //数码管位选信号
    output  wire    [7:0]   seg             //数码管段选信号

);

//wire  define
wire    [33:0]  freq    ;   //计算得到的待检测信号时钟频率

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//---------- clk_gen_test_inst ----------
clk_test_gen    clk_test_gen_inst
(
    .reset     (~sys_rst_n ),  //复位端口,高电平有效
    .clk_in1   (sys_clk    ),  //输入系统时钟

    .clk_out1  (clk_out    )   //输出生成的待检测时钟信号
);

//------------- freq_meter_calc_inst --------------
freq_meter_calc freq_meter_calc_inst
(
    .sys_clk    (sys_clk    ),   //模块时钟,频率50MHz
    .sys_rst_n  (sys_rst_n  ),   //复位信号,低电平有效
    .clk_test   (clk_test   ),   //待检测时钟

    .freq       (freq       )    //待检测时钟频率  
);

//------------- seg_595_dynamic_inst --------------
seg_dynamic     seg_dynamic_inst
(
    .sys_clk     (sys_clk    ), //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n  ), //复位信号，低有效
    .data        (freq/1000  ), //数码管要显示的值
    .point       (6&#39;b001000  ), //小数点显示,高电平有效
    .seg_en      (1&#39;b1       ), //数码管使能信号，高电平有效
    .sign        (1&#39;b0       ), //符号位，高电平显示负号

    .sel         (sel        ), //数码管位选信号
    .seg         (seg        )  //数码管段选信号

);

endmodule
</code></pre>
<p>这里还实例化了之前编写的动态数码管模块</p>
<h3 id="仿真设计"><a href="#仿真设计" class="headerlink" title="&lt;3&gt;仿真设计"></a>&lt;3&gt;仿真设计</h3><pre><code>module tb_freq_meter();

//********************************************************************//
//****************** Parameter And Internal Signal *******************//
//********************************************************************//
//wire  define
wire    [5:0]   sel         ;
wire    [7:0]   seg         ;

//reg   define
reg             sys_clk     ;
reg             sys_rst_n   ;
reg             clk_test    ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//时钟、复位、待检测时钟的生成
initial
    begin
        sys_clk     =   1&#39;b1;
        sys_rst_n   &lt;=  1&#39;b0;
        #200
        sys_rst_n  &lt;=  1&#39;b1;
        #500
        clk_test      =   1&#39;b1;
    end

always  #10     sys_clk =   ~sys_clk    ;   //50MHz系统时钟
always  #100    clk_test=   ~clk_test    ;   //5MHz待检测时钟

//重定义软件闸门计数时间,缩短仿真时间
defparam freq_meter_inst.freq_meter_calc_inst.CNT_GATE_S_MAX    = 240   ;
defparam freq_meter_inst.freq_meter_calc_inst.CNT_RISE_MAX      = 40    ;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------- freq_meter_inst -------------
freq_meter  freq_meter_inst
(
    .sys_clk     (sys_clk   ),   //系统时钟,频率50MHz
    .sys_rst_n   (sys_rst_n ),   //复位信号,低电平有效
    .clk_test    (clk_test  ),   //待检测时钟

    .clk_out     (clk_out   ),   //生成的待检测时钟
    .sel         (sel       ),   //串行数据输入
    .seg         (seg       )
);

endmodule
</code></pre>
<h2 id="二-简易-DDS-信号发生器"><a href="#二-简易-DDS-信号发生器" class="headerlink" title="二.简易 DDS 信号发生器"></a>二.简易 DDS 信号发生器</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    DDS 技术是一种全新的频率合成方法，其具有低成本、低功耗、高分辨率和快速转换时间等优点，对数字信号处理及其硬件实现有着很重要的作用。 DDS 的基本结构主要由**相位累加器、相位调制器、波形数据表 ROM、D/A 转换器** 等四大结构组成，其中较多设计还会在数模转换器之后增加一个**低通滤波器** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1c2608b13ba13fac858da44b3b45277.png"></p>
<pre><code>    系统时钟 CLK 为整个系统的工作时钟， 频率为 fCLK；**频率字输入 F_WORD** ，一般为整数，数值大小控制输出信号的频率大小，数值越大输出信号频率越高，反之，输出信号频率越低，后文中**用 K 表示** ；**相位字输入 P_WORD** ，为整数，数值大小控制输出信号的相位偏移，主要用于相位的信号调制，后文 用 P 表示；设输出信号为 CLK_OUT，频率为 fOUT。

    图中所展示的四大结构中，相位累加器是整个 DDS 的核心，在这里完成相位累加，生成相位码。相位累加器的输入为**频率字输入 K** ，表示相位增量，设其**位宽为 N** ，满足等式** K = (2^N) * fOUT / fCLK** 。其在输入相位累加器之前，在系统时钟同步下做数据寄存，数据改变时不会干扰相位累加器的正常工作。

    相位调制器接收相位累加器输出的相位码， 在这里加上一个相位偏移值 P，主要用于信号的相位调制，如应用于通信方面的相移键控等，不使用此部分时可以去掉，或者将其设为一个常数输入，同样相位字输入也要做寄存。

    **波形数据表 ROM 中存有一个完整周期的正弦波信号** 。假设波形数据 ROM 的**地址位宽为 12 位，存储数据位宽为 8 位** ，即 ROM 有 2^12 = 4096 个存储空间，每个存储空间可存储 1 字节数据。将一个周期的正弦波信号，**沿横轴等间隔采样 2^12 = 4096 次** ，每次采集的信号**幅度用 1 字节数据表示** ，最大值为 255，最小值为 0。将 4096 次采样结果按顺序写入 ROM 的 4096 个存储单元，一个完整周期正弦波的数字幅度信号写入了波形数据表 ROM 中。**波形数据表 ROM 以相位调制器传入的相位码为 ROM 读地址，将地址对应存储单元中的电压幅值数字量输出** 。 D/A 转换器将输入的电压幅值数字量转换为模拟量输出 ， 就得到输出信号 CLK_OUT。 输出信号 CLK_OUT 的信号频率 **fOUT = K * fCLK / 2^N。当 K = 1 时，可得 DDS 最小分辨率为：fOUT = fCLK / 2^N，此时输出信号频率最低。根据采样定理，K 的最大值应小于 (2 ^N) / 2。**
</code></pre>
<p><strong>相位累加器得到的相位码是如何实现 ROM 寻址的</strong> ？</p>
<p>对于 N 位的相位累加器，它对应的相位累加值为 2^N，如果正弦 <strong>ROM 中存储单元的个数</strong> 也是 2^N 的话，这个问题就很好解决，但是这对 ROM<br>的对存储容量的要求较高。<strong>在实际操作中，我们使用相位累加值的高几位对 ROM 进行寻址</strong> ，也就是说<strong>并不是每个系统时钟都对 ROM<br>进行数据读取，而是多个时钟读取一次</strong> ，因为这样能<strong>保证相位累加器溢出时， 从正弦 ROM 表中取出正好一个正弦周期的样点</strong> 。<br>因此，<strong>相位累加器每计数 2^N 次，对应一个正弦周期</strong> 。而相位累加器 1 秒钟计数 fCLK 次，<strong>在 k&#x3D;1 时，DDS<br>输出的时钟频率就是频率分辨率。 频率控制字 K 增加时，相位累加器溢出的频率增加，对应 DDS 输出信号 CLK_OUT 频率变为 K 倍的 DDS<br>频率分辨率。</strong></p>
<p>举个例子： 设：ROM 存储单元个数为 4096，每个存储数据用 8 位二进制表示。即，<strong>ROM 地址线 宽度为 12，数据线宽度为 8；相位累加器位宽<br>N &#x3D; 32</strong> 。 根据上述条件可以知道，相位调制器位宽 M &#x3D; 12，那么根据 DDS<br>原理。那么在相位调制器中与相位控制字进行累加时，应用相位累加器的高 12 位累加。而相位累加器的低 20 位只与频率控制字累加。 我们以<strong>频率控制字 K<br>&#x3D; 1</strong> 为例，相位累加器的低 20 位<strong>一直会加 1</strong> ，直到低 20 位溢出向 高 12 位进位，此时 ROM 为 0，也就是说，ROM 的 0<br>地址中的数据被读了 2^20次，继续下 去，ROM 中的 4096 个点，每个点都将会被读 2^ 20次，最终输出的波形频率应该是参考时钟频率的 1 &#x2F;<br>2^20，周期被扩大了 2^20 倍。同样当<strong>频率控制字 K&#x3D;  100 时</strong>，相位累加器的低 20 位 <strong>一直会加 100</strong><br>，那么，相位累加器的低 20 位溢出的时间比上面会快 100 倍，则 ROM 中的 每个点相比于上面会少读 100 次，所以最终输出频率是上述的 10 倍。</p>
<pre><code>    D/A 转换器即 数/模转换器，简称 DAC（Digital to Analog Conver），是指将数字信号转换为模拟信号的电子元件或电路。

    DAC 内部电路构造无太大差异，大多数 DAC 由**电阻阵列和 n 个电流开关(或电压开关)** 构成，按照输入的数字值进行**开关切换** ，输出对应电流或电压。因此，按照输出信号类型可分为电压型和电流型，也可以按照 DAC 能否做乘法运算进行分类。若将 DAC 分为电压型和电流型两大类，电压型 DAC 中又**有权电阻网络、T 形电阻网络、树形开关网络** 等分别；电流型 DAC 中又有**权电流型电阻网络和倒 T 形电阻网络** 等。

    电压输出型 DAC 一般采用**内置输出放大器以低阻抗输出** ，少部分**直接通过电阻阵列进行电压输出** 。直接输出电压的 DAC 仅用于高阻抗负载，由于**无输出放大器部分的延迟** ，故常作为**高速 DAC** 使用。

    电流输出型 DAC 很少直接利用电流输出，大多**外接电流 - 电压转换电路进行电压输出** 。实现电流 - 电压转换，方法有二：一是只在输出引脚上**接负载电阻而进行电流- 电压转换** ，**二是外接运算放大器** 。

    DAC 的主要技术指标包括**分辨率、线性度、转换精度和转换速度** 。

    分辨率指输出模拟电压的最小增量，即表明 DAC 输入一个最低有效位(LSB)而在输出端上模拟电压的变化量。

    线性度在理想情况下，DAC 的数字输入量作**等量增加时，其模拟输出电压也应作等量增加** ，但是实际输出往往有偏离。

    D/A 转换器的转换精度与 D/A 转换器的集成芯片的结构和接口电路配置有关。如果不考虑其他 D/A 转换误差时，D/A 的转换精度就是分辨率的大小，因此要获得高精度的 D/A 转换结果，首先要保证选择有足够分辨率的 D/A 转换器。同时 D/A 转换精度还与外接电路的配置有关，当外部电路器件或电源误差较大时，会造成较大的 D/A 转换误差，当这些误差超过一定程度时，D/A 转换就产生错误。

    转换速度一般由建立时间决定。建立时间是将一个数字量转换为稳定模拟信号所需的时间，也可以认为是转换时间。**DA 中常用建立时间来描述其速度，而不是 AD 中常用的转换速率** 。一般地，电流输出 DA 建立时间较短，电压输出 DA 则较长。
</code></pre>
<h3 id="代码设计-1"><a href="#代码设计-1" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><h4 id="（1）整体设计-1"><a href="#（1）整体设计-1" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><pre><code>    使用 FPGA 开发板和外部挂载的高速 AD/DA 板卡，设计并实现一个简易 DDS 信号发 生器，可通过按键控制实现正弦波、方波、三角波和锯齿波的波形输出，频率相位可调
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c80ea34aef420c3c4f07da0c3fcf0d2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5f9d3db772c9b21577ae3374dc4460f4.png"></p>
<p>详细介绍参考《野火FPGA Verilog开发实战指南》</p>
<pre><code>    其他 3 部分，相位累加器、相位调制器、波形数据表 ROM 由 FPGA 负责。所以我们要建立一个单独的模块对 DDS 部分进行处理；实验目标还提到要使用按键实现 4 种波形的切换，按键消抖模块必不可少；同时也要声明一个按键控制模块对 4 个输入按键进行控制，子功能模块已经足够了，最后再加一个顶层模块。

    顶层模块较为简单，内部例化了各子功能模块，连接各对应信号；外部有 3 路输入信号、2 路输出信号。输入有时钟、复位信号和控制信号波形切换的 4 路按键信号；输出 2 路信号中，信号 dac_data 为 DDS 模块输出的，自波形数据表 ROM 中读取的波形数据；信号 dac_clk 为输入至外载板卡的时钟信号，**DA 模块使用此时钟进行数据处理，该信号由系统时钟 sys_clk 取反得到** 。 波形数据表 ROM 的读时钟为系统时钟 sys_clk，在系统时钟上升沿时对 ROM 进行数据读取，而 DA 模块也使用时钟上升沿进行数据处理，**将系统时钟 sys_clk 取反得到 dac_clk，dac_clk 的上升沿刚好采集到波形数据 dac_data 的稳定数据** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/da377471871ba01b431909229db0e598.png"></p>
<pre><code>module  top_dds
(
    input   wire            sys_clk     ,   //系统时钟,50MHz
    input   wire            sys_rst_n   ,   //复位信号,低电平有效
    input   wire    [3:0]   key         ,   //输入4位按键

    output  wire            dac_clk     ,   //输入DAC模块时钟
    output  wire    [7:0]   dac_data        //输入DAC模块波形数据
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire    [3:0]   wave_select ;   //波形选择

//dac_clka:DAC模块时钟
assign  dac_clk  = ~sys_clk;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//-------------------------- dds_inst -----------------------------
dds     dds_inst
(
    .sys_clk        (sys_clk    ),   //系统时钟,50MHz
    .sys_rst_n      (sys_rst_n  ),   //复位信号,低电平有效
    .wave_select    (wave_select),   //输出波形选择

    .data_out       (dac_data   )    //波形输出
);

//----------------------- key_control_inst ------------------------
key_control key_control_inst
(
    .sys_clk        (sys_clk    ),   //系统时钟,50MHz
    .sys_rst_n      (sys_rst_n  ),   //复位信号,低电平有效
    .key            (key        ),   //输入4位按键

    .wave_select    (wave_select)    //输出波形选择
 );

endmodule
</code></pre>
<h4 id="（2）DDS部分"><a href="#（2）DDS部分" class="headerlink" title="（2）DDS部分"></a>（2）DDS部分</h4><pre><code>    dds 模块中实例化一个 ROM IP 核，按顺序存入了一个完整周期的正弦波、方波、三角波、锯齿波的信号波形， 根据输入波形选择信号对 rom 中对应信号波形进行读取，将读出波形的幅度数字值输出， 传入外部挂载的高速 AD/DA 板卡的 DA 端，板卡根据输入的数字信号生成对应波形的模拟信号。其中，输出信号的频率和相位的调节可在 dds 模块中通过修改参数实现。

    需要事先在波形数据表 ROM 中存入 4 种波形信号各自的完整周期波形数据。ROM 作为只读存储器，**在进行 IP 核设置时需要指定初始化文件，我们将波形数据作为初始化文件写入其中，文件格式为 COE 文件。**

    使用 MatLab 绘制 4 种信号波形，对波形进行等间隔采样，以采样次数作为 ROM 存储地址，将采集的波形幅值数据做为存储数据写入存储地址对应的存储空间。我们对 4 种信号波形进行分别采样，采样次数为 2^12 = 4096 次，采集的波形幅值数据位宽为 8bit，将采集数据保存为 MIF 文件。
</code></pre>
<p>MATLAB文件（以正弦信号为例）：</p>
<pre><code>clc;                    %清除命令行命令
clear all;              %清除工作区变量,释放内存空间
F1=1;                   %信号频率
Fs=2^12;                %采样频率
P1=0;                   %信号初始相位
N=2^12;                 %采样点数
t=[0:1/Fs:(N-1)/Fs];    %采样时刻
ADC=2^7 - 1;            %直流分量
A=2^7;                  %信号幅度
%生成正弦信号
s=A*sin(2*pi*F1*t + pi*P1/180) + ADC;
plot(s);                %绘制图形
%创建coe文件
fild = fopen(&#39;sin_wave_4096x8.coe&#39;,&#39;wt&#39;);
%写入coe文件头
fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_RADIX=10;&#39;); %10进制数
fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_VECTOR=&#39;); 
for i = 1:N
    s0(i) = round(s(i));    %对小数四舍五入以取整
    if s0(i) &lt;0             %负1强制置零
        s0(i) = 0
    end
    if i == N
            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入
            fprintf(fild, &#39;%s&#39;,&#39;;&#39;);        %最后一个数据使用分号
    else
            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入
            fprintf(fild, &#39;%s\n&#39;,&#39;,&#39;);      %逗号，换行
    end     
end
fclose(fild);
</code></pre>
<p>整体信号写入：</p>
<pre><code>clc;                    %清除命令行命令
clear all;              %清除工作区变量,释放内存空间
F1=1;                   %信号频率
Fs=2^12;                %采样频率
P1=0;                   %信号初始相位
N=2^12;                 %采样点数
t=[0:1/Fs:(N-1)/Fs];    %采样时刻
ADC=2^7 - 1;            %直流分量
A=2^7;                  %信号幅度
s1=A*sin(2*pi*F1*t + pi*P1/180) + ADC;          %正弦波信号
s2=A*square(2*pi*F1*t + pi*P1/180) + ADC;       %方波信号
s3=A*sawtooth(2*pi*F1*t + pi*P1/180,0.5) + ADC; %三角波信号
s4=A*sawtooth(2*pi*F1*t + pi*P1/180) + ADC;     %锯齿波信号
%创建coe文件
fild = fopen(&#39;wave_16384x8.coe&#39;,&#39;wt&#39;);
%写入coe文件头
fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_RADIX=10;&#39;); %10进制数
fprintf(fild, &#39;%s\n&#39;,&#39;MEMORY_INITIALIZATION_VECTOR=&#39;);
for j = 1:4
    for i = 1:N
        if j == 1       %打印正弦信号数据
            s0(i) = round(s1(i));    %对小数四舍五入以取整
        end

        if j == 2       %打印方波信号数据
            s0(i) = round(s2(i));    %对小数四舍五入以取整
        end

        if j == 3       %打印三角波信号数据
            s0(i) = round(s3(i));    %对小数四舍五入以取整
        end

        if j == 4       %打印锯齿波信号数据
            s0(i) = round(s4(i));    %对小数四舍五入以取整
        end

        if s0(i) &lt;0             %负1强制置零
            s0(i) = 0
        end
        
        if j == 4 &amp;&amp; i == N
            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入
            fprintf(fild, &#39;%s&#39;,&#39;;&#39;);        %最后一个数使用分号结束
        else
            fprintf(fild, &#39;%d&#39;,s0(i));      %数据写入
            fprintf(fild, &#39;%s\n&#39;,&#39;,&#39;);      %逗号，换行
        end
    end
end
fclose(fild);
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a87316586f399c84e19bb0b36947031f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0404863083748a6404247951d25cd7cb.png"></p>
<pre><code>    内部声明 3 个寄存器变量。其中 fre_add 表示相位累加器输出值，位宽为 32 位，系统上电后，**fre_add 信号一直执行自加操作，每个时钟周期自加参数 FREQ_CTRL** ，参数 FREQ_CTRL 就是在之前理论知识部分提到的频率字输入 K。

    寄存器变量 rom_addr_reg 表示相位调制器输出值，将相位累加器输出值的高 12 位与相位偏移量 PHASE_CTRL 相加，参数 PHASE_CTRL 就是我们之前提到过的相位字输入P。之所以使用高 12 位，与存储波形的 ROM 深度有关。按理论讲，将得到的变量 rom_addr_reg，可直接作为 ROM 读地址输入波形数据表进行数据读取，但是我们将 4 中波形存储在了同一 ROM 中，所以还需要对读数据地址做进一步计算。

    ROM 读地址 rom_addr 是输入波形数据表的 ROM 读地址，是在 rom_addr_reg 的基础上计算得到。我们之前将 4 种信号波形数据按照正弦波、方波、三角波、锯齿波的顺序写 入 ROM。若需要读取正弦波波形数据，rom_addr_reg 可直接赋值给 rom_addr；但是要进行方波波形数据的读取，rom_addr_reg 需要再加上正弦波存储单元个数才能赋值给 rom_addr；剩余两信号同理。

    本实验，我们希望输出一个频率为 500Hz，初相位为π/2 的正弦波信号。 计算参数 FREQ_CTRL，即频率输入字 K。

    **FREQ_CTRL = K = 2N * fOUT / fCLK** ，其中**N = 32(相位累加器输出值 fre_add 的位宽)** 、 fOUT = 500Hz，fCLK = 50MHz，带入公式，FREQ_CTRL = K = 42949.67296 ，取整数部分为 42949；         

    计算参数 PHASE_CTRL，即相位输入字 P。 **PHASE_CTRL = P = θ / (2π / 2M)** ，其中**M =12(输入 ROM 地址位宽)** 、θ = π / 2，带入 公式，PHASE_CTRL = P = 1024。


module  dds
(
    input   wire            sys_clk     ,   //系统时钟,50MHz
    input   wire            sys_rst_n   ,   //复位信号,低电平有效
    input   wire    [3:0]   wave_select ,   //输出波形选择

    output  wire    [7:0]   data_out        //波形输出
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//parameter define
parameter   sin_wave    =   4&#39;b0001     ,   //正弦波
            squ_wave    =   4&#39;b0010     ,   //方波
            tri_wave    =   4&#39;b0100     ,   //三角波
            saw_wave    =   4&#39;b1000     ;   //锯齿波
parameter   FREQ_CTRL   =   32&#39;d42949   ,   //相位累加器单次累加值
            PHASE_CTRL  =   12&#39;d1024    ;   //相位偏移量

//reg   define
reg     [31:0]  fre_add     ;   //相位累加器
reg     [11:0]  rom_addr_reg;   //相位调制后的相位码
reg     [13:0]  rom_addr    ;   //ROM读地址

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//fre_add:相位累加器
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        fre_add &lt;=  32&#39;d0;
    else
        fre_add &lt;=  fre_add + FREQ_CTRL;

//rom_addr:ROM读地址
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        begin
            rom_addr        &lt;=  14&#39;d0;
            rom_addr_reg    &lt;=  11&#39;d0;
        end
    else
    case(wave_select)
        sin_wave:
            begin
                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;
                rom_addr        &lt;=  rom_addr_reg;
            end     //正弦波
        squ_wave:
            begin
                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;
                rom_addr        &lt;=  rom_addr_reg + 14&#39;d4096;
            end     //方波
        tri_wave:
            begin
                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;
                rom_addr        &lt;=  rom_addr_reg + 14&#39;d8192;
            end     //三角波
        saw_wave:
        begin
                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;
                rom_addr        &lt;=  rom_addr_reg + 14&#39;d12288;
            end     //锯齿波
        default:
            begin
                rom_addr_reg    &lt;=  fre_add[31:20] + PHASE_CTRL;
                rom_addr        &lt;=  rom_addr_reg;
            end     //正弦波
    endcase

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------- rom_wave_inst ------------------------

rom_wave    rom_wave_inst
(
  .clka(sys_clk), // input clka
  .addra(rom_addr), // input [13 : 0] addra
  .douta(data_out) // output [7 : 0] douta
);

endmodule


    rom_wave 是 IP 核，可以看到改变初相位的办法就是初始值加上 PHASE_CTRL ；每个时钟周期先给 fre_add 赋值，接着是 rom_addr_reg 和 rom_addr，rom_addr 直接连接到 IP 核。
</code></pre>
<p>（3）按键消抖部分</p>
<pre><code>module  key_filter
#(
    parameter CNT_MAX = 20&#39;d999_999 //计数器计数最大值
)
(
    input   wire    sys_clk     ,   //系统时钟50Mhz
    input   wire    sys_rst_n   ,   //全局复位
    input   wire    key_in      ,   //按键输入信号

    output  reg     key_flag        //key_flag为1时表示消抖后检测到按键被按下
                                    //key_flag为0时表示没有检测到按键被按下
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//reg   define
reg     [19:0]  cnt_20ms    ;   //计数器

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//cnt_20ms:如果时钟的上升沿检测到外部按键输入的值为低电平时，计数器开始计数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_20ms &lt;= 20&#39;b0;
    else    if(key_in == 1&#39;b1)
        cnt_20ms &lt;= 20&#39;b0;
    else    if(cnt_20ms == CNT_MAX &amp;&amp; key_in == 1&#39;b0)
        cnt_20ms &lt;= cnt_20ms;
    else
        cnt_20ms &lt;= cnt_20ms + 1&#39;b1;

//key_flag:当计数满20ms后产生按键有效标志位
//且key_flag在999_999时拉高,维持一个时钟的高电平
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        key_flag &lt;= 1&#39;b0;
    else    if(cnt_20ms == CNT_MAX - 1&#39;b1)
        key_flag &lt;= 1&#39;b1;
    else
        key_flag &lt;= 1&#39;b0;

endmodule



module  key_control
(
    input   wire            sys_clk     ,   //系统时钟,50MHz
    input   wire            sys_rst_n   ,   //复位信号,低电平有效
    input   wire    [3:0]   key         ,   //输入4位按键

    output  reg     [3:0]   wave_select     //输出波形选择
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//parameter define
parameter   sin_wave    =   4&#39;b0001,    //正弦波
            squ_wave    =   4&#39;b0010,    //方波
            tri_wave    =   4&#39;b0100,    //三角波
            saw_wave    =   4&#39;b1000;    //锯齿波

parameter   CNT_MAX =   20&#39;d999_999;    //计数器计数最大值

//wire  define
wire            key3    ;   //按键3
wire            key2    ;   //按键2
wire            key1    ;   //按键1
wire            key0    ;   //按键0

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//wave:按键状态对应波形
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wave_select   &lt;=  4&#39;b0000;
    else    if(key0 == 1&#39;b1)
        wave_select   &lt;=  sin_wave;
    else    if(key1 == 1&#39;b1)
        wave_select   &lt;=  squ_wave;
    else    if(key2 == 1&#39;b1)
        wave_select   &lt;=  tri_wave;
    else    if(key3 == 1&#39;b1)
        wave_select   &lt;=  saw_wave;
    else
        wave_select   &lt;=  wave_select;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------- key_fifter_inst3 --------------
key_filter 
#(
    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值
)
key_filter_inst3
(
    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz
    .sys_rst_n    (sys_rst_n)   ,   //全局复位
    .key_in       (key[3]   )   ,   //按键输入信号

    .key_flag     (key3     )       //按键消抖后标志信号
);

//------------- key_fifter_inst2 --------------
key_filter 
#(
    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值
)
key_filter_inst2
(
    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz
    .sys_rst_n    (sys_rst_n)   ,   //全局复位
    .key_in       (key[2]   )   ,   //按键输入信号

    .key_flag     (key2     )       //按键消抖后标志信号
);

//------------- key_fifter_inst1 --------------
key_filter 
#(
    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值
)
key_filter_inst1
(
    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz
    .sys_rst_n    (sys_rst_n)   ,   //全局复位
    .key_in       (key[1]   )   ,   //按键输入信号

    .key_flag     (key1     )       //按键消抖后标志信号
);

//------------- key_fifter_inst0 --------------
key_filter 
#(
    .CNT_MAX      (CNT_MAX  )       //计数器计数最大值
)
key_filter_inst0
(
    .sys_clk      (sys_clk  )   ,   //系统时钟50Mhz
    .sys_rst_n    (sys_rst_n)   ,   //全局复位
    .key_in       (key[0]   )   ,   //按键输入信号

    .key_flag     (key0     )       //按键消抖后标志信号
);

endmodule
</code></pre>
<p>key_control模块实例化了四个按键消抖模块</p>
<h3 id="仿真"><a href="#仿真" class="headerlink" title="&lt;3&gt;仿真"></a>&lt;3&gt;仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a74cf028e7f344f5bbcede195c9bddaa.png"></p>
<pre><code>`timescale  1ns/1ns

// Author  : EmbedFire
// 实验平台: 野火FPGA系列开发板
// 公司    : http://www.embedfire.com
// 论坛    : http://www.firebbs.cn
// 淘宝    : https://fire-stm32.taobao.com


module  tb_top_dds();

//**************************************************************//
//*************** Parameter and Internal Signal ****************//
//**************************************************************//
parameter   CNT_1MS  = 20&#39;d19000   ,
            CNT_11MS = 21&#39;d69000   ,
            CNT_41MS = 22&#39;d149000  ,
            CNT_51MS = 22&#39;d199000  ,
            CNT_60MS = 22&#39;d249000  ;

//wire  define
wire            dac_clk     ;
wire    [7:0]   dac_data    ;

//reg   define
reg             sys_clk     ;
reg             sys_rst_n   ;
reg     [21:0]  tb_cnt      ;
reg             key_in      ;
reg     [1:0]   cnt_key     ;
reg     [3:0]   key         ;

//defparam  define
defparam    top_dds_inst.key_control_inst.CNT_MAX = 24;

//**************************************************************//
//************************** Main Code *************************//
//**************************************************************//
//sys_rst_n,sys_clk,key
initial
    begin
        sys_clk     =   1&#39;b0;
        sys_rst_n   &lt;=   1&#39;b0;
        key &lt;= 4&#39;b0000;
        #200;
        sys_rst_n   &lt;=   1&#39;b1;
    end

always #10 sys_clk = ~sys_clk;

//tb_cnt:按键过程计数器，通过该计数器的计数时间来模拟按键的抖动过程
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        tb_cnt &lt;= 22&#39;b0;
    else    if(tb_cnt == CNT_60MS)
        tb_cnt &lt;= 22&#39;b0;
    else    
        tb_cnt &lt;= tb_cnt + 1&#39;b1;

//key_in:产生输入随机数，模拟按键的输入情况
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        key_in &lt;= 1&#39;b1;
    else    if((tb_cnt &gt;= CNT_1MS &amp;&amp; tb_cnt &lt;= CNT_11MS)
                || (tb_cnt &gt;= CNT_41MS &amp;&amp; tb_cnt &lt;= CNT_51MS))
        key_in &lt;= &#123;$random&#125; % 2;
    else    if(tb_cnt &gt;= CNT_11MS &amp;&amp; tb_cnt &lt;= CNT_41MS)
        key_in &lt;= 1&#39;b0;
    else
        key_in &lt;= 1&#39;b1;

always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_key &lt;=  2&#39;d0;
    else    if(tb_cnt == CNT_60MS)
        cnt_key &lt;=  cnt_key + 1&#39;b1;
    else
        cnt_key &lt;=  cnt_key;

always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        key     &lt;=  4&#39;b1111;
    else
        case(cnt_key)
            0:      key &lt;=  &#123;3&#39;b111,key_in&#125;;
            1:      key &lt;=  &#123;2&#39;b11,key_in,1&#39;b1&#125;;
            2:      key &lt;=  &#123;1&#39;b1,key_in,2&#39;b11&#125;;
            3:      key &lt;=  &#123;key_in,3&#39;b111&#125;;
            default:key &lt;=  4&#39;b1111;
        endcase

//**************************************************************//
//************************ Instantiation ***********************//
//**************************************************************//
//------------- top_dds_inst -------------
top_dds top_dds_inst
(
    .sys_clk    (sys_clk    ),
    .sys_rst_n  (sys_rst_n  ),
    .key        (key        ),

    .dac_clk    (dac_clk    ),
    .dac_data   (dac_data   )
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1889590a090cc653ecbc28aa8be916d.png"></p>
<h2 id="三-简易电压表"><a href="#三-简易电压表" class="headerlink" title="三.简易电压表"></a>三.简易电压表</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    模/数转换器即 A/D 转换器，或简称 ADC（Analog to Digital Conver），模拟信号与数字信号的转换过程一般分为四个步骤：**采样、保持、量化、编码** 。前两个步骤在采样-保持电路中完成，后两步则在 ADC 芯片中完成。

    常用的 ADC 可分为**积分型、逐次逼近型、并行比较型/串并行型、Σ -Δ调制型、电容阵列逐次比较型以及压频变换型** 。

    积分型 ADC 工作原理是**将输入电压转换成时间或频率，然后由定时器/计数器获得数字值** 。其优点是使用简单电路就能获得高分辨率；缺点是由于转换精度依赖于积分时间， 因此**转换速率极低** 。双积分是一种常用的 AD 转换技术，具有精度高，抗干扰能力强等优点。但高精度的双积分 AD 芯片，价格昂贵，设计成本较高。

    逐次逼近型 ADC 由一个比较器和 DA 转换器通过逐次比较逻辑构成，从 MSB 开始， 顺序地对每一位**将输入电压与内置 DA 转换器输出进行比较，经 n 次比较而输出数字值** 。 其电路规模属于中等，优点是速度较高、功耗低，在低分辨率( &lt; 12 位)时价格便宜，但高精度( &gt; 12 位)价格昂贵。

    并行比较型 ADC **采用多个比较器** ，仅作一次比较而实行转换，又称 Flash 型。由于转换速率极高，**n 位的转换需要 2n - 1 个比较器** ，因此电路规模也极大，价格也高，**只适用于视频 AD 转换器等速度特别高的领域** 。

    Σ- Δ型 ADC 以**很低的采样分辨率( 1 位)和很高的采样速率** 将模拟信号数字化，通过使用**过采样、噪声整形和数字滤波等方法增加有效分辨率** ，然后对 ADC 输出进行采样抽取处理以降低有效采样速率。Σ-Δ型 ADC 的电路结构是由非常简单的模拟电路和十分复杂的数字信号处理电路构成。

    电容阵列逐次比较型 ADC 在**内置 DA 转换器中采用电容矩阵方式** ，也可称为电荷再分配型。一般的电阻阵列 DA 转换器中多数电阻的值必须一致，在单芯片上生成高精度的电阻并不容易。如果用电容阵列取代电阻阵列，可以用低廉成本制成高精度单片 AD 转换器。最近的逐次比较型 AD 转换器大多为电容阵列式的。

    压频变换型是通过间接转换方式实现模数转换的。其原理是首先**将输入的模拟信号转换成频率，然后用计数器将频率转换成数字量** 。从理论上讲这种 ADC 的分辨率几乎可以无限增加，**只要采样的时间能够满足输出频率分辨率要求的累积脉冲个数的宽度** 。其优点是分辨率高、功耗低、价格低，但是需要外部计数电路共同完成 AD 转换。

    ADC 的主要技术指标包括：**分辨率、转换速率、量化误差、满刻度误差、线性度** 。

    分辨率指输出数字量变化一个最低有效位(LSB)所需的输入模拟电压的变化量。 转换速率是指完成一次从模拟转换到数字的 AD 转换所需要的时间的倒数。**积分型 AD 的转换时间是毫秒级属低速 AD，逐次比较型 AD 是微秒级属中速 AD，全并行/串并行 型 AD 可达到纳秒级** 。采样时间则是另外一个概念，是指**两次转换的间隔** 。为了保证转换的正确完成，**采样速率（Sample Rate）必须小于或等于转换速率** 。因此有人习惯上将转换速率在数值上等同于采样速率也是可以接受的。 量化误差是由于 AD 的有限分辩率而引起的误差，即有限分辩率 AD 的阶梯状转移特性曲线与无限分辩率 AD（理想 AD）的转移特性曲线（直线）之间的最大偏差。通常是 1 个或半个最小数字量的模拟变化量，表示为 **1LSB、1/2LSB** 。 满刻度误差是满刻度输出时对应的输入信号与理想输入信号值之差。 线性度指实际转换器的转移函数与理想直线的最大偏移。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/02c1afc1e39c76f93bda212446d69078.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0285c7fd6f5b8e37bd4d93f9cdba82b.png"></p>
<pre><code>    实验主要把adc模块传回的数据变换为数值。本实验使用的 ADC 芯片位宽为 8 位，板卡模拟电压输入范围为-5v~+5v，即电压表测量范围，最大值和最小值压降为 10v，分辨率为 10/28。

    当 ADC 芯片采集后的电压数值 ad_data 位于 0 - 127 范围内，表示测量电压位于-5V ~ 0V 范围内，换算为电压值：Vin = - (10 / 28 * (127 - ad_data))；当 ADC 芯片采集后的电压数值 ad_data 位于 128 - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，换算为电压值：Vin = (10 / 28 * (ad_data - 127))。

    简易电压表实验可以参照这种思想来进行工程的设计与实现，但为了提高测量结果的精确性，我们使用**定义中值的测量方法** 。

    在电压表上电后未接入测量电压时，取 ADC 芯片采集的最初的若干测量值，取平均，作为测量中值 **data_median** ，与实际测量值 0V 对应。 使用定义中值的测量方法时，当 ADC 芯片采集后的电压数值 ad_data 位于 0 ~ data_median 范围内，表示测量电压位于-5V ~ 0V 范围内，**分辨率为 10/((data_median + 1) * 2)** ，换算为电压值：Vin = - ((10 /((data_median + 1) * 2)) * (data_median - ad_data))；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，分辨率为 10/((255 - data_median + 1) * 2)，换算为电压值：Vin = ((10 /((255 - data_median + 1) * 2)) * (ad_data - data_median))。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/70245ce26acea947146d29556fab06f5.png"></p>
<pre><code>    对于模块的输入信号不再说明，输出至外载板块的的时钟信号为 ad_clk，频率为 12.5MHz，使用系统时钟 4 分频得来，所以声明了分频计数器 cnt_sys_clk，初值为 0，在系 统时钟同步下，在 0、1 之间循环计数；声明时钟信号 clk_sample，在计数器 cnt_sys_clk 计数值为 1 时，对自身取反，就得到了时钟频率为 12.5MHz 的分频时钟信号 clk_sample，也 作为本模块工作时钟信号；因为外载板卡与本模块均使用时钟上升沿对数据采样，**为保证模块内工作时钟上升沿能够采集到板块传入的稳定数据，我们对 clk_sample 时钟信号取反 作为输入板卡的时钟信号 adc_clk，adc_clk 的上升沿刚好采集到数据的稳定状态** 。

    声明中值使能信号 median_en，方便计算中值，当 median_en 信号为低电平时，进行中值的计算；当 median_en 信号为高电平时，对 ADC 测量值进行累加求平均的计算。 对中值的计算我们也使用累加求平均的方法，**在无测量电压输入电压表时，对前 1024 个数据进行累加求平均** ，所以声明计数器 cnt_median 对累加值个数进行计数，计算范围 0- 1023，只在 median_en 为低电平时进行计数，median_en 为高电平时，保持计数最大值；同时，计数最大值作为条件，拉高 median_en 使能信号。1024 个测量值总和保存在变量 data_sum_m 中，**当 cnt_median 计数到最大值，将平均值赋值给变量 data_median** 。

    中值 data_median 确定后，开始测量电压的计算。 为保证运算后的电压值更准确，我们对计算出的分辨率进行放大。**当 ADC 芯片采集后的电压数值 ad_data 位于 0 - data_median 范围内，表示测量电压位于-5V ~ 0V 范围内， 声明分辨率为 data_n = (10 * 2^13 * 1000) / ((data_median + 1) * 2)；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压位于 0V ~ 5V 范围内，声明分辨率为 data_p = (10 * 2^13 * 1000) / ((255 - data_median + 1) * 2)。放大倍数为(2^13 * 1000) 倍** ，之所以使用这个放大倍数是为了方便电压值的计算与显示。（**小数除以大数精度损失，且无法恢复；左移变大，放大精度** ）

    确定了分辨率之后，结合 ADC 芯片传入的测量值，我们开始计算实际电压值。声明实际电压值为 volt_reg，当 ADC 芯片采集后的电压数值 ad_data 位于 0 - data_median 范围内，表示测量电压位于-5V ~ 0V 范围内，volt_reg = (data_n *(data_median - ad_data)) &gt;&gt; 13；当 ADC 芯片采集后的电压数值 ad_data 位于 data_median - 255 范围内，表示测量电压 位于 0V ~ 5V 范围内，**volt_reg = (data_p *(ad_data - data_median)) &gt;&gt; 13。使用 “&gt;&gt; 13”对 计算值进行右移 13 位，由于抵消分辨率放大的 2^13 倍，分辨率中放大的 1000 倍，可以通 过将数码管显示值小数点左移 3 位来抵消**；正负号通过 ad_data 与中值 data_median 的打消比较来确定，sign = (ad_data &lt; data_median) ? 1&#39;b1 : 1&#39;b0，sign 为高电平，代表测量结果为负向电压，反之为正向电压。
</code></pre>
<h3 id="代码设计-2"><a href="#代码设计-2" class="headerlink" title="&lt;2&gt;代码设计"></a>&lt;2&gt;代码设计</h3><h4 id="（1）ADC"><a href="#（1）ADC" class="headerlink" title="（1）ADC"></a>（1）ADC</h4><pre><code>module  adc
(
    input   wire            sys_clk         ,   //时钟
    input   wire            sys_rst_n       ,   //复位信号，低电平有效
    input   wire    [7:0]   ad_data         ,   //AD输入数据

    output  wire            ad_clk          ,   //AD驱动时钟,最大支持20Mhz时钟
    output  wire            sign            ,   //正负符号位
    output  wire    [15:0]  volt                //数据转换后的电压值
);
//********************************************************************//
//******************Parameter And Internal Signal ********************//
//********************************************************************//
//parameter define
parameter   CNT_DATA_MAX = 11&#39;d1024;    //数据累加次数

//wire  define
wire    [27:0]  data_p      ;   //根据中值计算出的正向电压AD分辨率
wire    [27:0]  data_n      ;   //根据中值计算出的负向电压AD分辨率

//reg define
reg             median_en   ;   //中值使能
reg     [10:0]  cnt_median  ;   //中值数据累加计数器
reg     [18:0]  data_sum_m  ;   //1024次中值数据累加总和
reg     [7:0]   data_median ;   //中值数据
reg     [1:0]   cnt_sys_clk ;   //时钟分频计数器
reg             clk_sample  ;   //采样数据时钟
reg     [27:0]  volt_reg    ;   //电压值寄存

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//数据ad_data是在ad_sys_clk的上升沿更新
//所以在ad_sys_clk的下降沿采集数据是数据稳定的时刻
//FPGA内部一般使用上升沿锁存数据,所以时钟取反
//这样ad_sys_clk的下降沿相当于sample_sys_clk的上升沿
assign  ad_clk = ~clk_sample;

//sign:正负符号位
assign  sign = (ad_data &lt; data_median) ? 1&#39;b1 : 1&#39;b0;

//时钟分频(4分频,时钟频率为12.5Mhz),产生采样AD数据时钟
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        begin
            cnt_sys_clk &lt;=  2&#39;d0;
            clk_sample  &lt;=  1&#39;b0;
        end
        else
        begin
            cnt_sys_clk &lt;=  cnt_sys_clk + 2&#39;d1;
        if(cnt_sys_clk == 2&#39;d1)
            begin
            cnt_sys_clk &lt;=  2&#39;d0;
            clk_sample  &lt;=  ~clk_sample;
            end
        end

//中值使能信号
always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        median_en   &lt;=  1&#39;b0;
    else    if(cnt_median == CNT_DATA_MAX)
        median_en   &lt;=  1&#39;b1;
    else
        median_en   &lt;=  median_en;

//cnt_median:中值数据累加计数器
always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_median    &lt;=  11&#39;d0;
    else    if(median_en == 1&#39;b0)
        cnt_median    &lt;=  cnt_median + 1&#39;b1;

//data_sum_m:1024次中值数据累加总和
always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_sum_m  &lt;=  19&#39;d0;
    else    if(cnt_median == CNT_DATA_MAX)
        data_sum_m    &lt;=  19&#39;d0;
    else
        data_sum_m    &lt;=  data_sum_m + ad_data;

//data_median:中值数据
always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_median    &lt;=  8&#39;d0;
    else    if(cnt_median == CNT_DATA_MAX)
        data_median    &lt;=  data_sum_m / CNT_DATA_MAX;
    else
        data_median    &lt;=  data_median;

//data_p:根据中值计算出的正向电压AD分辨率(放大2^13*1000倍)
//data_n:根据中值计算出的负向电压AD分辨率(放大2^13*1000倍)
assign  data_p = (median_en == 1&#39;b1) ? 8192_0000 / ((255 - data_median) * 2) : 0;
assign  data_n = (median_en == 1&#39;b1) ? 8192_0000 / ((data_median + 1) * 2) : 0;

//volt_reg:处理后的稳定数据
always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        volt_reg    &lt;= &#39;d0;
    else    if(median_en == 1&#39;b1)
        if((ad_data &gt; (data_median - 3))&amp;&amp;(ad_data &lt; (data_median + 3)))
            volt_reg    &lt;= &#39;d0;
        else    if(ad_data &lt; data_median)
            volt_reg &lt;= (data_n *(data_median - ad_data)) &gt;&gt; 13;
        else    if(ad_data &gt; data_median)
            volt_reg &lt;= (data_p *(ad_data - data_median)) &gt;&gt; 13;
    else
        volt_reg    &lt;= &#39;d0;

//volt:数据转换后的电压值
assign  volt    =   volt_reg;

endmodule
</code></pre>
<p>可以看到 volt_reg 数值在 da_data 接近 0 （ data_median ）时直接赋值 0<br>；同时注意到系统只能通过复位进行重新测量，median_en并没有自动拉低</p>
<h4 id="（2）顶层"><a href="#（2）顶层" class="headerlink" title="（2）顶层"></a>（2）顶层</h4><pre><code>module  dig_volt
(
    input   wire            sys_clk     ,   //系统时钟,50MHz
    input   wire            sys_rst_n   ,   //复位信号，低有效
    input   wire    [7:0]   ad_data     ,   //AD输入数据

    output  wire            ad_clk      ,   //AD驱动时钟,最大支持20Mhz时钟
    output  wire    [5:0]   sel         ,   //串行数据输入
    output  wire    [7:0]   seg             //使能信号
);
//********************************************************************//
//*********************** Internal Signal ****************************//
//********************************************************************//
//wire  define
wire    [15:0]  volt    ;   //数据转换后的电压值
wire            sign    ;   //正负符号位

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------- adc_inst -------------
adc     adc_inst
(
    .sys_clk    (sys_clk    ),  //时钟
    .sys_rst_n  (sys_rst_n  ),  //复位信号，低电平有效
    .ad_data    (ad_data    ),  //AD输入数据

    .ad_clk     (ad_clk     ),  //AD驱动时钟,最大支持20Mhz时钟
    .sign       (sign       ),  //正负符号位
    .volt       (volt       )   //数据转换后的电压值
);

//------------- seg_dynamic_inst --------------
seg_dynamic     seg_dynamic_inst
(
    .sys_clk    (sys_clk    ),  //系统时钟，频率50MHz
    .sys_rst_n  (sys_rst_n  ),  //复位信号，低有效
    .data       (&#123;4&#39;b0,volt&#125;),  //数码管要显示的值
    .point      (6&#39;b001000  ),  //小数点显示,高电平有效
    .seg_en     (1&#39;b1       ),  //数码管使能信号，高电平有效
    .sign       (sign       ),  //符号位，高电平显示负号

    .sel        (sel        ),  //串行数据输入
    .seg        (seg        )   //输出使能信号
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21ad66777b680d8d5fb99e1369c3fbe1.png"></p>
<h3 id="仿真-1"><a href="#仿真-1" class="headerlink" title="&lt;3&gt;仿真"></a>&lt;3&gt;仿真</h3><pre><code>module  tb_dig_volt();
//wire  define
wire            ad_clk  ;
wire      [5:0]      sel    ;
wire      [7:0]      seg    ;


//reg   define
reg             sys_clk     ;
reg             clk_sample  ;
reg             sys_rst_n   ;
reg             data_en     ;
reg     [7:0]   ad_data_reg ;
reg     [7:0]   ad_data     ;

//sys_rst_n,sys_clk,ad_data
initial
    begin
        sys_clk     =   1&#39;b1;
        clk_sample  =   1&#39;b1;
        sys_rst_n   =   1&#39;b0;
        #200;
        sys_rst_n   =   1&#39;b1;
        data_en     =   1&#39;b0;
        #499990;
        data_en     =   1&#39;b1; 
    end

always #10 sys_clk = ~sys_clk;
always #40 clk_sample = ~clk_sample;

always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        ad_data_reg &lt;=  8&#39;d0;
    else    if(data_en == 1&#39;b1)
        ad_data_reg &lt;=  ad_data_reg + 1&#39;b1;
    else
        ad_data_reg &lt;=  8&#39;d0;

always@(posedge clk_sample or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        ad_data &lt;=  8&#39;d0;
    else    if(data_en == 1&#39;b0)
        ad_data &lt;=  8&#39;d125;
    else    if(data_en == 1&#39;b1)
        ad_data &lt;=  ad_data_reg;
    else
        ad_data &lt;=  ad_data;

//------------- dig_volt_inst -------------
dig_volt    dig_volt_inst
(
    .sys_clk     (sys_clk   ),
    .sys_rst_n   (sys_rst_n ),
    .ad_data     (ad_data   ),

    .ad_clk      (ad_clk    ),
    .sel        (sel      ),
    .seg        (seg      )
);

endmodule
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132993678">https://blog.csdn.net/qq_32971095/article/details/132993678</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%89%EF%BC%88RS232%E3%80%81I2C%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C4%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%89%EF%BC%88RS232%E3%80%81I2C%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C4%EF%BC%9E/" class="post-title-link" itemprop="url">基础设计三（RS232、I2C）——FPGA学习笔记＜4＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-11 22:30:32" itemprop="dateCreated datePublished" datetime="2023-09-11T22:30:32+08:00">2023-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>57k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>52 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E4%B8%B2%E5%8F%A3%20RS232">一.串口 RS232</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%3C2%3E%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B">&lt;2&gt;物理模型</a></p>
<p><a href="about:blank#%3C3%3ERS232%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">&lt;3&gt;RS232通信协议</a></p>
<p><a href="about:blank#%3C4%3E%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">&lt;4&gt;设计实践</a></p>
<p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">1.硬件资源</a></p>
<p><a href="about:blank#2.%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">2.程序设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89uart_rx%E8%AE%BE%E8%AE%A1">（1）uart_rx设计</a></p>
<p><a href="about:blank#%E2%91%A0%E6%B3%A2%E5%BD%A2%E5%9B%BE%E5%88%86%E6%9E%90">①波形图分析</a></p>
<p><a href="about:blank#%E2%91%A1%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">②代码设计</a></p>
<p><a href="about:blank#%E2%91%A2%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">③仿真设计</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89uart_tx%E8%AE%BE%E8%AE%A1">（2）uart_tx设计</a></p>
<p><a href="about:blank#%E2%91%A0%E6%B3%A2%E5%BD%A2%E5%9B%BE%E5%88%86%E6%9E%90">①波形图分析</a></p>
<p><a href="about:blank#%E2%91%A1%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">②代码设计</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1">（3）顶层设计</a></p>
<p><a href="about:blank#%E2%91%A0%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">①代码设计</a></p>
<p><a href="about:blank#%E2%91%A1%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">②仿真设计</a></p>
<p><a href="about:blank#3.%E6%80%BB%E7%BB%93">3.总结</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%9F%BA%E4%BA%8E%20I2C%20%E5%8D%8F%E8%AE%AE%E7%9A%84%20EEPROM%20%E9%A9%B1%E5%8A%A8%E6%8E%A7%E5%88%B6">二.基于 I2C 协议的 EEPROM<br>驱动控制</a></p>
<p><a href="about:blank#%3C1%3E%E7%AE%80%E4%BB%8B">&lt;1&gt;简介</a></p>
<p><a href="about:blank#%3C2%3E%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C">&lt;2&gt;读写操作</a></p>
<p><a href="about:blank#%3C3%3E%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">&lt;3&gt;设计实践</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1">（1）整体设计</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89I2C%20%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97">（2）I2C<br>驱动模块</a></p>
<p><a href="about:blank#%E3%80%901%E3%80%91%E5%8D%95%E5%AD%97%E8%8A%82%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">【1】单字节写操作时序分析</a></p>
<p><a href="about:blank#%E3%80%902%E3%80%91%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">【2】随机读操作时序分析</a></p>
<p><a href="about:blank#%E3%80%903%E3%80%91%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">【3】代码设计</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%A8%A1%E5%9D%97">（3）数据收发模块</a></p>
<p><a href="about:blank#%E3%80%901%E3%80%91%E5%86%99%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86">【1】写数据操作部分</a></p>
<p><a href="about:blank#%E3%80%902%E3%80%91%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86">【2】读数据操作部分</a></p>
<p><a href="about:blank#%E3%80%903%E3%80%91%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">【3】代码设计</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1">（4）仿真设计</a></p>
<hr>
<p>前置学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132779996" title="基础设计二——FPGA学习笔记＜3＞">基础设计二——FPGA学习笔记＜3＞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p>
<p>参考书目：《野火FPGA Verilog 开发实战指南》</p>
<h2 id="一-串口-RS232"><a href="#一-串口-RS232" class="headerlink" title="一.串口 RS232"></a>一.串口 RS232</h2><h3 id="简介"><a href="#简介" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    **通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），通常称作 UART** 。UART 是一种**通用的数据通信协议** ，也是**异步串行通信口（串口）的总称** ，它在**发送数据时将并行数据转换成串行数据来传输** ，在**接收数据时将接收到的串行数据转换成并行数据** 。它包括了 RS232、RS499、RS423、RS422 和 RS485 等接口标准规范和总线标准规范。三大低速总线（UART、SPI、IIC）

    UART 和 SPI、IIC 不同的是，它是**异步通信接口** ，异步通信中的接收方并不知道数据什么时候会到达，所以双方收发端都要有各自的时钟，在数据传输过程中是不需要时钟的，发送方发送的时间间隔可以不均匀，接受方是在数据的**起始位和停止位** 的帮助下实现信息同步的。而**SPI、IIC 是同步通信接口** （后面的章节会做详细介绍），同步通信中双方使用频率一致的时钟，在数据传输过程中时钟伴随着数据一起传输，发送方和接收方使用的时钟都是由主机提供的。

     UART 通信只有两根信号线，一根是发送数据端口线叫 tx（Transmitter），一根是接收数据端口线叫 rx（Receiver），如图 26-1 所示，对于 PC 来说它的 tx 要和对于 FPGA 来 说的 rx 连接，同样 PC 的 rx 要和 FPGA 的 tx 连接，如果是两个 tx 或者两个 rx 连接那数据 就不能正常被发送出去和接收到，所以不要弄混，记住 rx 和 tx 都是相对自身主体来讲的。 UART 可以实现全双工，即可以同时进行发送数据和接收数据。        
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/41ba38e183929d6376ec40adbf1f8724.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad1a4ba482564893ff8359fd376ba7fc.png"></p>
<pre><code>    设计 FPGA 部分接收串口数据和发送串口数据的模块，最后把两个模块拼接起来，最后通过 loopback 测试（回环测试）来验证设计模块的正确性。所谓**loopback 测试** 就是发送端发送什么数据，接收端就接收什么数据。
</code></pre>
<p>串口 RS232 缺点：距离不远，传输速率相对较慢</p>
<p>串口 RS232优点：</p>
<p>1、很多传感器芯片或 CPU 都带有串口功能，目的是在使用一些传感器或 CPU 时可以通过串口进行调试，十分方便；</p>
<p>2、在较为复杂的<strong>高速数据接口和数据链路集合的系统</strong> 中往往<strong>联合调试比较困难</strong><br>，可以<strong>先使用串口将数据链路部分验证后，再把串口换成高速数据接口</strong><br>。如在做以太网相关的项目时，可以在调试时先使用串口把整个数据链路调通，然后再把串口换成以太网的接口；</p>
<p>3、串口的数据线一共就两根，也没有时钟线，节省了大量的管脚资源。</p>
<h3 id="物理模型"><a href="#物理模型" class="headerlink" title="&lt;2&gt;物理模型"></a>&lt;2&gt;物理模型</h3><p>设备被分为<strong>数据终端设备 DTE</strong>(计算机、路由)和 <strong>数据通讯设备 DCE</strong>(调制调解器)。我们以这种通讯模型讲解它们的信号线连接方式及各个<br>信号线的作用。</p>
<p>旧式台式计算机 RS-232 标准 COM 口(也称 DB9 接口)：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/efd543a7b07dc4ab460314ea28977952.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0b0c8afd598edcb653a10bd0c1f5ab4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/88c30e0af5325c41a66213c7d463ec71.png"></p>
<p>串口线中的 RTS、CTS、DSR、DTR 及 DCD 信号，使用逻辑 1 表示信号有效，逻辑 0 表示信号无效。例如，当计算机端控制 DTR<br>信号线表示为逻辑 1 时，它是为了告知远端的调制调解器，本机已准备好接收数据， 0 则表示还没准备就绪。</p>
<h3 id="RS232通信协议"><a href="#RS232通信协议" class="headerlink" title="&lt;3&gt;RS232通信协议"></a>&lt;3&gt;RS232通信协议</h3><p>1、RS232 是 UART 的一种，没有时钟线，只有两根数据线，分别是 rx 和 tx，这两根线都是<strong>1bit 位宽</strong> 的。其中 rx<br>是接收数据的线，tx 是发送数据的线。</p>
<p>2、rx 位宽为 1bit，PC 机通过串口调试助手往 FPGA 发 8bit 数据时，FPGA 通过串口线 rx<br>一位一位地接收，<strong>从最低位到最高位依次接收</strong> ，最后在 FPGA 里面位拼接成 8 比特数据。</p>
<p>3、tx 位宽为 1bit，FPGA 通过串口往 PC 机发 8bit 数据时，FPGA 把 8bit 数据通过 tx 线一位一位的传给 PC<br>机，从最低位到最高位依次发送，最后上位机通过串口助手按照 RS232 协议把这一位一位的数据位拼接成 8bit 数据。</p>
<p>4、串口数据的发送与接收是基于帧结构的，即一帧一帧的发送与接收数据。<strong>每一帧除 了中间包含 8bit<br>有效数据外，还在每一帧的开头都必须有一个起始位，且固定为 0</strong> ；<strong>在每 一帧的结束时也必须有一个停止位，且固定为 1</strong><br>，<strong>即最基本的帧结构（不包括校验等）有 10bit</strong> 。在不发送或者不接收数据的情况下，r<strong>x 和 tx 处于空闲状态，此时 rx 和 tx 线都保持<br>高电平</strong> ，如果有数据帧传输时，首先会有一个起始位，然后是 8bit 的数据位，接着有 1bit 的停止位，然后 rx 和 tx<br>继续进入空闲状态，然后等待下一次的数据传输。如图为一个最基本的 RS232 帧结构。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b8c4ca545f52dddf282fb029181733a.png"></p>
<p>5、波特率：在信息传输通道中，携带数据信息的信号单元叫码元（因为串口是 1bit 进<br>行传输的，所以其码元就是代表一个二进制数），每秒钟通过信号传输的码元数称为码元的传输速率，简称波特率，常用符号“Baud”表示，其单位为“波特每秒（Bps）”。串口常见的波特率有<br>4800、9600、115200 等，我们选用 9600 的波特率进行串口章节的讲解。</p>
<p>6、比特率：每秒钟通信信道传输的信息量称为位传输速率，简称比特率，其单位为 “每秒比特数（bps）”。比特率可由波特率计算得出，公式为：比特率&#x3D;波特率 *<br><strong>单个调制状态对应的二进制位数</strong> 。如果使用的是 9600 的波特率，其串口的比特率为：9600Bps * <strong>1bit</strong> &#x3D; 9600bps。</p>
<p>7、由计算得串口发送或者接收 1bit 数据的时间为一个波特，即 1&#x2F;9600 秒，如果用 50MHz（周期为<br>20ns）的系统时钟来计数，需要计数的个数为<strong>cnt &#x3D; (1s * 10^9)ns &#x2F; 9600bit)ns &#x2F; 20ns ≈ 5208<br>个系统时钟周期</strong> ，即每个 bit 数据之间的间隔要在 50MHz 的时钟频率下计数 <strong>5208 次</strong> 。</p>
<p>8、上位机通过串口发 8bit 数据时，会自动在发 8 位有效数据前发一个波特时间的起始位，也会自动在发完 8<br>位有效数据后发一个停止位。同理，串口助手接收上位机发送的数据前，必须检测到一个波特时间的起始位才能开始接收数据，接收完 8bit<br>的数据后，再接收一个波特时间的停止位。</p>
<h3 id="设计实践"><a href="#设计实践" class="headerlink" title="&lt;4&gt;设计实践"></a>&lt;4&gt;设计实践</h3><h4 id="1-硬件资源"><a href="#1-硬件资源" class="headerlink" title="1.硬件资源"></a>1.硬件资源</h4><p>Artix-7开发板上使用CH340芯片将Rx、Tx信号线转成USB，硬件电路图见参考图书。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/01160649df593bdc68380afe16a251a7.png"></p>
<p>在使用时需将 J9 口的 1、2 脚以及 3、4 脚用跳帽连接起来才能正常使 用。</p>
<h4 id="2-程序设计"><a href="#2-程序设计" class="headerlink" title="2.程序设计"></a>2.程序设计</h4><p>整体框图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ee97485a24245074b314660c134dafd.png"></p>
<h5 id="（1）uart-rx设计"><a href="#（1）uart-rx设计" class="headerlink" title="（1）uart_rx设计"></a>（1）uart_rx设计</h5><pre><code>    uart_rx按照规定波特率将接受到的1bit串行数据转成8bit并行数据po_data，并有效并行数据有效的标志信号 po_data_flag
</code></pre>
<h6 id="①波形图分析"><a href="#①波形图分析" class="headerlink" title="①波形图分析"></a>①波形图分析</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe6084b0edb9a5f4cd334a61d80e651c.png"></p>
<p><strong>波形设计思路详细解析：</strong></p>
<p><strong>第一部分</strong> ：</p>
<p>首先画出三个输入信号，时钟和复位，另一个是串行输入数据 rx， rx 串行数据一开始经过了 <strong>两级寄存器</strong> 。</p>
<p>理论上我们应该按照串口接收数据的时序要求找到 rx 的下降沿，然后开始接收起始位的数据，但为什么先将数据打了两拍呢？那就要先从跨时钟域会导致“<strong>亚稳态</strong><br>” 的问题上说起。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/facb669a93fa73b488a4709d2cadce6f.png"></p>
<pre><code>    把一个矩形脉冲的上升沿或下降沿放大后会发现其上升沿和下降沿并不是瞬间被拉高或拉低的，而是有一个**倾斜变化的过程** ，这在 运放中被称为“**压摆率** ”。

    如果 FPGA 的系统时钟刚好采集到 rx 信号上升沿或下降沿的中间位置附近（按照概率来讲，如果数据传输量足够大或传输速度足够快时一定会产生这种情况），即 FPGA 在接收 rx 数据时不满足**内部寄存器的建立时间 Tsu（指触发器的时钟信号上升沿到来以前，数据稳定不变的最小时间）和保持时间 Th（指触发器的时钟信号上升沿到来以后，数据稳定不变的最小时间）** ，此时 FPGA 的**第一级寄存器的输出端在时钟沿到来之后比较长的一段时间内都处于不确定的状态** ，在 0 和 1 之间处于**振荡状态** ，而不是 等于串口输入的确定的 rx 值。

    如图为产生亚稳态的波形示意图，rx 信号经过 FPGA 中的第一级寄存器后输出的 rx_reg1 信号在时钟上升沿 Tco 时间后会有**Tmet（决断时间）的振荡时段** ，当第一 个寄存器发生亚稳态后，经过 Tmet 的振荡稳定后，第二级寄存器就能采集到一个相对稳定的值。但由于** _振荡时间 Tmet 是受到很多因素影响的，所以 Tmet 时间有长有短_** 。如图所示，当 **Tmet1 时间长到大于一个采样周期后，那第二级寄存器就会采集到亚稳态** ，但是从第二级寄存器输出的信号就是相对稳定的了。当然会人会问到第二级寄存器的 Tmet2 的持续时间会不会继续延长到大于一个采样周期？这种情况虽然会存在，但是其概率是极小的，寄存器本身就有减小 Tmet 时间让数据快速稳定的作用。 由于在 PC 机中**波特率和 rx 信号是同步的，而 rx 信号和 FPGA 的系统时钟 sys_clk 是异步** 的关系，我们此时要做的是**将慢速时钟域（PC 机中的波特率）系统中的 rx 信号同步到快速时钟域（FPGA 中的 sys_clk）系统** 中，所使用的方法叫电平同步，俗称**“打两拍法”** 。所以 rx 信号进入 FPGA 后会首先经过一级寄存器，出现如图 26-13 所示的亚稳态现 象，导致 rx_reg1 信号的状态不确定是 0 还是 1，就会受其影响使其他相关信号做出不同的判断，有的判断到“0”有的判断到“1”，有的也进入了亚稳态并产生连锁反应，导致后 级相关逻辑电路混乱。为了避免这种情况，rx 信号进来后首先进行打一拍的处理，打一拍后产生 rx_reg1 信号。但 rx_reg1 可能还存在低概率的亚稳态现象，为了进一步降低出现亚稳态的概率，我们将从 rx_reg1 信号再打一拍后产生 rx_reg2 信号，使之能够较大概率保证 rx_reg2 信号是 0 或者 1 中的一种确定情况，这样 rx_reg2 所影响的后级电路就都是相对稳定的了。但一定要注意：**打两拍后虽然能让信号稳定到 0 或者 1 中确定的值，但究竟是 0 还是 1 却是随机的，与打拍之前输入信号的值没有必然的关系** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d8f07d8ac3ff30bf88e42bedf2ad6151.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/89cd57b8bd71f41c5fe4616c0cb4bc03.png"></p>
<p>注：单比特信号从慢速时钟域同步到快速时钟域需要使用打两拍的方式消除亚稳态。<strong>第一级寄存器产生亚稳态并经过自身后可以稳定输出的概率为<br>70%~80%左右，第二级寄存器可以稳定输出的概率为 99%左右</strong> ，<strong>后面再多加寄存器的级数改善效果就不明显了</strong> ，所以<br>数据进来后一般选择打两拍即可。 另外<strong>单比特信号从<br>快速时钟域同步到慢速时钟域还仅仅使用打两拍的方式会漏采数据，所以往往使用脉冲同步法或的握手信号法</strong>；而<strong>多比特信号跨时钟域需要进行格雷码编码</strong><br>（<strong>多比特顺序数</strong> 才可以）后才能进行打两拍的处理，或者通过使用 FIFO、RAM 来处理数据与时钟同步的问题。 亚稳态振荡时间 Tmet<br>关系到后级寄存器的采集稳定问题，Tmet<br>影响因素包括：器件的生产工艺、温度、环境以及寄存器采集到亚稳态里稳定态的时刻等。甚至某些特定条件，如干扰、辐射等都会造成 Tmet 增长。</p>
<p><strong>第二部分：</strong></p>
<pre><code>  打两拍后的 rx_reg2 信号就是我们可以在后级逻辑电路中使用的相对稳定的信号，只 比 rx 信号延后两。下一步我们就可以根据串口接收数据的时序要求找到串口帧起始开始的标志——下降沿，然后按顺序接收数据。由第一部分的分析得 rx_reg1 信号可能是不稳定的， 而 rx_reg2 信号是相对稳定的，所以不能直接用 rx_reg1 信号和 rx_reg2 信号来产生下降沿标志信号，因为 **rx_reg1 信号的不稳定性可能会导致由它产生的下降沿标志信号也不稳定** 。所以如图所示，我们将 rx_reg2 信号再打一拍，得到 rx_reg3 信号，用 rx_reg2 信 号和 rx_reg3 信号产生 staet_nedge 作为下降沿标志信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e38f5d9d318853e610d55253e535ed8d.png"></p>
<p><strong>第三部分：</strong></p>
<pre><code>    我们检测到了第一个下降沿，后面的信号将以下降沿标志信号 start_nedge 为条件开始接收一帧 10bit 的数据。但新的问题又出现了，我们的 rx 信号本身就是 1bit 的，如 果在判断第一个下降沿后，后面帧中的数据还可能会有下降沿出现，那我们会又产生一个start_nedge 标志信号。我们知道在 Verilog 代码中**标志信号（flag）和使能信号（en）** 都是非常有用的，标志信号只有一拍，非常适合我们产生像下降沿标志这种信号，而使能信号就特别适合在此处使用，即**对一段时间区域进行控制锁定** 。如图所示，当下降沿标志信号 start_nedge 为高电平时拉高工作使能信号 work_en（什么时候拉低在后面讲解），在 work_en 信号为高的时间区域内虽然也会有下降沿 start_nedge 标志信号产生，但是我们可 以根据 work_en 信号就可以判断出此时出现的 start_nedge 标志信号并不是我们想要的串口帧起始下降沿，从而将其过滤除掉。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1bb92fefa5e8f242a1c746b4cd59c1d.png"></p>
<pre><code>    开始接收一帧数据。我们使用的是 9600bps 的波特率 和 PC 机进行串口通信，PC 机的串口调试助手要将发送数据波特率调整为 9600bps。而 FPGA 内部使用的系统时钟是 50MHz，前面也进行过计算，得出 1bit 需要的时间约为 5208 个（因为一帧只有 10bit，**细微的近似计数差别不会产生数据错误** ，但是如果计数值差的过大，则会产生接收数据的错误）系统时钟周期，那么我们就需要产生一个能计 5208 个数的计数器来依次接收 10 个比特的数据，计数器每计 5208 个数就接收一个新比特的数据。如 图 26-17 所示，计数器名为 baud_cnt，当 **work_en 信号为高电平的时候就让计数器计数** ， **当计数器计 5208 个数（从 0 到 5207）或 work_en 信号为低电平时计数器清零。**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae18e4581af78dc5e42749840658916c.png"></p>
<p><strong>第四部分：</strong></p>
<pre><code>    现在我们可以根据波特率计数器一个一个接收数据了，我们发现 baud_cnt 计数 器在计数值为 0 到 5207 期间都是数据有效的时刻，那我们该什么时候取数据呢？理论上讲，在数据变化的地方取数是不稳定的，所以我们**选择当 baud_cnt 计数器计数到 2603，即中间位置时取数最稳定** （其实只要 baud_cnt 计数器在计数值不是在 0 和 5207 这两个最不稳定的时刻取数都可以，**更为准确的是多次取值取概率最大的情况** ）。所以如图所示，在 baud_cnt 计数器**计数到中点时产生一个时钟周期的 bit_flag 的取数标志信号** ，用于 指示该时刻的数据可以被取走。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6933ce910fc5d709216700158924677.png"></p>
<pre><code>    也就是说我们需要准确的知道此时此刻接收的是第几比特，当接收够 10bit 数据后，我们就停止继续接收数据，等 rx 信号被拉高待恢复到空闲状态后再等待接收下一帧的数据。所以我们还需要 产生一个用于计数该时刻接收的数据是第几个比特的 **bit_cnt 计数器** 。如图所示，刚好可以利用我们已经产生的 bit_flag 取数标志信号，对该信号进行计数既可以知道此时我们接收的数据是第几个比特了。这里我们只让 bit_cnt 计数器的计数值为 8 时再清零，虽然 bit_cnt 计数器的计数值从 0 计数到 8 只有 9 个 bit，但这 9 个 bit 中已经包含的我们所需要 的 8bit 有用的数据，最后的 1bit 停止位没有用，可以不用再进行计数了，但如果非要将 bit_cnt 计数器的计数值计数到 9 后再清零也是可以的。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/01fac4f9c508d4dd87006a8b89346c90.png"></p>
<p><strong>第五部分：</strong></p>
<pre><code>    我们接收到的 rx 信号是串行的，后面的系统要使用的是完整的 8bit 并行数据。 也就是说我们还需要将 1bit 串行数据转换为 8bit 并行数据的串并转换的工作，这也是我们在接口设计中常遇到的一种操作。**串并转换就需要做移位** ，我们要考虑清楚什么时候开始移位，不能提前也不能推后，否则会将无用的数据也移位进来，所以我们需要卡准时间。 如图所示 PC 机的串口调试助手发送的数据是先发送的低位后发送的高位，所以我们接收的 rx 信号也是先接收的低位后接收的高位，我们采用边接收边移位的操作。移位操作的方法我们已经在前面的流水灯章节中讲过，这里不再重复。接下来我们需要确定移位开始和结束的时间。如图所示，当 bit_cnt 计数器的计数值为 1 时说明第一个有用数据已经接收到了，刚好剔除了起始位，就可以进行移位了。注意移位的条件， _**要在 bit_cnt 计 数器的计数值为 1 到 8 区间内且 bit_flag 取数标志信号同时为高时才能移位**_ ，也就是移动 7 次即可，接收最后 1bit 有用数据时就不需要再进行移位了。当移位 7 次后 1bit 的串行数据 已经变为 8bit 的并行数据了，此时产生一个移位完成标志信号 rx_flag。
</code></pre>
<p><strong>第六部分：</strong></p>
<pre><code>    最后一 点，rx_data 信号是参与移位的数据，在移位的过程中数据是变动的，不可以被后级模块所使用，而可以肯定的是**在移位完成标志信号 rx_flag 为高时，rx_data 信号一定是移位完成的 稳定的 8bit 有用数据** 。如图所示，此时我们当移位完成标志信号 **rx_flag 为高时让 rx_data 信号赋值给专门用于输出 稳定 8bit 有用数据的 po_data 信号**就可以了，但 **rx_flag 信号又不能作为 po_data 信号有效的标志信号，所以需要将 rx_flag 信号 再打一拍**。最后输出的有用 8bit 数据为 po_data 信号和伴随 po_data 信号有效的标志信号 po_flag 信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6128969d4060f737d0dd13fb53fcc866.png"></p>
<pre><code>    到此为止我们 uart_rx 模块的波形就全部设计好了，此时再看时序图就能理解各个设计。为了获得数据到来标志start_nedge设置了三级寄存器；work_en确定了接收状态，对start_nedge进行管控，不再变化，并开启计数器baud_cnt ；在计数中央采集数据并记录数据个数bit_cnt ；结束置标志位rx_flag，但为稳定，滞后一拍得最终结果和标志位
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe6084b0edb9a5f4cd334a61d80e651c.png"></p>
<h6 id="②代码设计"><a href="#②代码设计" class="headerlink" title="②代码设计"></a>②代码设计</h6><pre><code>module  uart_rx
#(
    parameter   UART_BPS    =   &#39;d9600,         //串口波特率
    parameter   CLK_FREQ    =   &#39;d50_000_000    //时钟频率
)
(
    input   wire            sys_clk     ,   //系统时钟50MHz
    input   wire            sys_rst_n   ,   //全局复位
    input   wire            rx          ,   //串口接收数据

    output  reg     [7:0]   po_data     ,   //串转并后的8bit数据
    output  reg             po_flag         //串转并后的数据有效标志信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//localparam    define
localparam  BAUD_CNT_MAX    =   CLK_FREQ/UART_BPS   ;

//reg   define
reg         rx_reg1     ;
reg         rx_reg2     ;
reg         rx_reg3     ;
reg         start_nedge ;
reg         work_en     ;
reg [12:0]  baud_cnt    ;
reg         bit_flag    ;
reg [3:0]   bit_cnt     ;
reg [7:0]   rx_data     ;
reg         rx_flag     ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//插入两级寄存器进行数据同步，用来消除亚稳态
//rx_reg1:第一级寄存器，寄存器空闲状态复位为1
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rx_reg1 &lt;= 1&#39;b1;
    else
        rx_reg1 &lt;= rx;

//rx_reg2:第二级寄存器，寄存器空闲状态复位为1
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rx_reg2 &lt;= 1&#39;b1;
    else
        rx_reg2 &lt;= rx_reg1;

//rx_reg3:第三级寄存器和第二级寄存器共同构成下降沿检测
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rx_reg3 &lt;= 1&#39;b1;
    else
        rx_reg3 &lt;= rx_reg2;

//start_nedge:检测到下降沿时start_nedge产生一个时钟的高电平
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        start_nedge &lt;= 1&#39;b0;
    else    if((~rx_reg2) &amp;&amp; (rx_reg3))
        start_nedge &lt;= 1&#39;b1;
    else
        start_nedge &lt;= 1&#39;b0;

//work_en:接收数据工作使能信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        work_en &lt;= 1&#39;b0;
    else    if(start_nedge == 1&#39;b1)
        work_en &lt;= 1&#39;b1;
    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))
        work_en &lt;= 1&#39;b0;

//baud_cnt:波特率计数器计数，从0计数到BAUD_CNT_MAX - 1
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        baud_cnt &lt;= 13&#39;b0;
    else    if((baud_cnt == BAUD_CNT_MAX - 1) || (work_en == 1&#39;b0))
        baud_cnt &lt;= 13&#39;b0;
    else    if(work_en == 1&#39;b1)
        baud_cnt &lt;= baud_cnt + 1&#39;b1;

//bit_flag:当baud_cnt计数器计数到中间数时采样的数据最稳定，
//此时拉高一个标志信号表示数据可以被取走
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        bit_flag &lt;= 1&#39;b0;
    else    if(baud_cnt == BAUD_CNT_MAX/2 - 1)
        bit_flag &lt;= 1&#39;b1;
    else
        bit_flag &lt;= 1&#39;b0;

//bit_cnt:有效数据个数计数器，当8个有效数据（不含起始位和停止位）
//都接收完成后计数器清零
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        bit_cnt &lt;= 4&#39;b0;
    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))
        bit_cnt &lt;= 4&#39;b0;
     else    if(bit_flag ==1&#39;b1)
         bit_cnt &lt;= bit_cnt + 1&#39;b1;

//rx_data:输入数据进行移位
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rx_data &lt;= 8&#39;b0;
    else    if((bit_cnt &gt;= 4&#39;d1)&amp;&amp;(bit_cnt &lt;= 4&#39;d8)&amp;&amp;(bit_flag == 1&#39;b1))
        rx_data &lt;= &#123;rx_reg3, rx_data[7:1]&#125;;

//rx_flag:输入数据移位完成时rx_flag拉高一个时钟的高电平
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rx_flag &lt;= 1&#39;b0;
    else    if((bit_cnt == 4&#39;d8) &amp;&amp; (bit_flag == 1&#39;b1))
        rx_flag &lt;= 1&#39;b1;
    else
        rx_flag &lt;= 1&#39;b0;

//po_data:输出完整的8位有效数据
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        po_data &lt;= 8&#39;b0;
    else    if(rx_flag == 1&#39;b1)
        po_data &lt;= rx_data;

//po_flag:输出数据有效标志（比rx_flag延后一个时钟周期，为了和po_data同步）
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        po_flag &lt;= 1&#39;b0;
    else
        po_flag &lt;= rx_flag;

endmodule


    可以看到，在2-5行声明参数方便修改；7-13行声明输入输出接口；20行定义局部变量；23-32行声明内部寄存器；40-58行rx数据经过三级寄存器赋值；start_nedge是判断(~rx_reg2) &amp;&amp; (rx_reg3)进行赋值，对应波形图上的关系；在112行进行了移位赋值，rx_data &lt;= &#123;rx_reg3, rx_data[7:1]&#125;，使得低位在右；后面要注意start_nedge和work_en的关系，后面一大部分实际上是以baud_cnt为基石，所以在baud_cnt的赋值中引入work_en的限制即可（另一种不同思路是start_nedge的赋值引入work_en作为判断【&amp;&amp;~work_en】，然后baud_cnt引入start_nedge）。
</code></pre>
<h6 id="③仿真设计"><a href="#③仿真设计" class="headerlink" title="③仿真设计"></a>③仿真设计</h6><pre><code>module  tb_uart_rx();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//reg   define
reg             sys_clk;
reg             sys_rst_n;
reg             rx;

//wire  define
wire    [7:0]   po_data;
wire            po_flag;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化系统时钟、全局复位和输入信号
initial begin
        sys_clk    = 1&#39;b1;
        sys_rst_n &lt;= 1&#39;b0;
        rx        &lt;= 1&#39;b1;
        #20;
        sys_rst_n &lt;= 1&#39;b1;
end

//模拟发送8次数据，分别为0~7
initial begin
        #200
        rx_bit(8&#39;d0);  //任务的调用，任务名+括号中要传递进任务的参数
        rx_bit(8&#39;d1);
        rx_bit(8&#39;d2);
        rx_bit(8&#39;d3);
        rx_bit(8&#39;d4);
        rx_bit(8&#39;d5);
        rx_bit(8&#39;d6);
        rx_bit(8&#39;d7);
end

//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号
always #10 sys_clk = ~sys_clk;

//定义一个名为rx_bit的任务，每次发送的数据有10位
//data的值分别为0~7由j的值传递进来
//任务以task开头，后面紧跟着的是任务名，调用时使用
task rx_bit(
    //传递到任务中的参数，调用任务的时候从外部传进来一个8位的值
        input   [7:0]   data
);
        integer i;      //定义一个常量
//用for循环产生一帧数据，for括号中最后执行的内容只能写i=i+1
//不可以写成C语言i=i++的形式
        for(i=0; i&lt;10; i=i+1) begin
            case(i)
                0: rx &lt;= 1&#39;b0;
                1: rx &lt;= data[0];
                2: rx &lt;= data[1];
                3: rx &lt;= data[2];
                4: rx &lt;= data[3];
                5: rx &lt;= data[4];
                6: rx &lt;= data[5];
                7: rx &lt;= data[6];
                8: rx &lt;= data[7];
                9: rx &lt;= 1&#39;b1;
            endcase
            #(5208*20); //每发送1位数据延时5208个时钟周期
        end
endtask         //任务以endtask结束

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------uart_rx_inst------------------------
uart_rx uart_rx_inst(
        .sys_clk    (sys_clk    ),  //input           sys_clk
        .sys_rst_n  (sys_rst_n  ),  //input           sys_rst_n
        .rx         (rx         ),  //input           rx
                
        .po_data    (po_data    ),  //output  [7:0]   po_data
        .po_flag    (po_flag    )   //output          po_flag
);

endmodule



    8-9行因要对输入信号赋值使用reg变量；21-27初始化系统时钟、全局复位和输入信号；29-40模拟拟发送 8 次数据；43行对时钟进行规定；77-86行进行实例化，实例名为代码设计中的模块名，实例化名可以是实例名加_inst；最关键的是48-70行对发送任务的定义，类似c语言中的函数，单独分析：


//定义一个名为rx_bit的任务，每次发送的数据有10位
//data的值分别为0~7由j的值传递进来
//任务以task开头，后面紧跟着的是任务名，调用时使用
task rx_bit(
    //传递到任务中的参数，调用任务的时候从外部传进来一个8位的值
        input   [7:0]   data
);
        integer i;      //定义一个常量
//用for循环产生一帧数据，for括号中最后执行的内容只能写i=i+1
//不可以写成C语言i=i++的形式
        for(i=0; i&lt;10; i=i+1) begin
            case(i)
                0: rx &lt;= 1&#39;b0;
                1: rx &lt;= data[0];
                2: rx &lt;= data[1];
                3: rx &lt;= data[2];
                4: rx &lt;= data[3];
                5: rx &lt;= data[4];
                6: rx &lt;= data[5];
                7: rx &lt;= data[6];
                8: rx &lt;= data[7];
                9: rx &lt;= 1&#39;b1;
            endcase
            #(5208*20); //每发送1位数据延时5208个时钟周期
        end
endtask         //任务以endtask结束

    注意这是第一次for循环的使用，for 括号中最后执行的内容只能写 i=i+1；任务以 task 开头，后面紧跟着的是任务名，调用时使用，以 endtask 结束；任务名紧接着是传入参数的定义，i是内部参数定义在括号外（类比c语言函数定义）
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c596d3b31134c232a5b00ae3aa4e8e48.png"></p>
<pre><code>    第一、第二、第三部分仿真波形如图所示，我们可以清晰的看到将 rx 信号打三拍的操作，并产生了串口帧起始的下降沿标志信号，以及 work_en 信号在串口帧起始的下降沿标志信号为高时拉高，baud_cnt 计数器在 work_en 信号为高时开始计数。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a4836417c6b50f8cf813a88f9361063.png"></p>
<p>……</p>
<h5 id="（2）uart-tx设计"><a href="#（2）uart-tx设计" class="headerlink" title="（2）uart_tx设计"></a>（2）uart_tx设计</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed4132b9525222bdeaa4e73667653c35.png"></p>
<h6 id="①波形图分析-1"><a href="#①波形图分析-1" class="headerlink" title="①波形图分析"></a>①波形图分析</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df689b6329ed5b9a83b12ebab4268f37.png"></p>
<pre><code>    前6个信号通过uart_rx的设计可以知道其用途

    下面我们就可以按照 5208 个系统时钟周期的波特率间隔来发送 1bit 数据了。理论上我们在第一个 5208 系统时钟周期内 的任意一个位置发送数据都可以，这和接收数据时要在中间位置不同，所以我们直接让当 **baud_cnt** 计数器的计数值为 1（选择其他的值也可以，但是尽量不要选择 baud_cnt 计数器的计数值为 0 或 5207 这种端点，因为容易出问题）的时候作为发送数据的点，产生 **bit_flag** 信号，并使 **bit_cnt** 计数值加一，而下一个 baud_cnt 计数器的计数值为 1 的时候和上一个正好相差 5208 个系统时钟周期，是完全可以满足要求的。发送完一帧数据后要将 work_en 信号拉低。

    bit_cnt清零和work_en拉低的条件：**让 bit_cnt 计数器计数到 9** ，停止位和空闲情况下都为高电平，所以最有一个停止位就没有必要再单独计数了，所以 bit_cnt 计数器计数到 9 清零是完全可以 的，当然让 bit_cnt 计数器计数到 10 更是可以的。 最后再来说说 work_en 信号拉低的条件，work_en 存在的原因就是为了方便 baud_cnt 计数器计数的，当我们不需要 baud_cnt 计数器计数的时候也就可以让 work_en 信号拉低 了。当 bit_cnt 计数器计数到 9 且 bit_flag 信号有效时停止位就可以被发送出去了，此时就不再需要 baud_cnt 计数器计数了，就可以把 work_en 信号拉低了，但同时还要将 baud_cnt 计数器清零，等待下一次发送数据时再从 0 开始计数。
</code></pre>
<h6 id="②代码设计-1"><a href="#②代码设计-1" class="headerlink" title="②代码设计"></a>②代码设计</h6><pre><code>module  uart_tx
#(
    parameter   UART_BPS    =   &#39;d9600,         //串口波特率
    parameter   CLK_FREQ    =   &#39;d50_000_000    //时钟频率
)
(
     input   wire            sys_clk     ,   //系统时钟50MHz
     input   wire            sys_rst_n   ,   //全局复位
     input   wire    [7:0]   pi_data     ,   //模块输入的8bit数据
     input   wire            pi_flag     ,   //并行数据有效标志信号
 
     output  reg             tx              //串转并后的1bit数据
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//localparam    define
localparam  BAUD_CNT_MAX    =   CLK_FREQ/UART_BPS   ;

//reg   define
reg [12:0]  baud_cnt;
reg         bit_flag;
reg [3:0]   bit_cnt ;
reg         work_en ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//work_en:接收数据工作使能信号
always@(posedge sys_clk or negedge sys_rst_n)
        if(sys_rst_n == 1&#39;b0)
            work_en &lt;= 1&#39;b0;
        else    if(pi_flag == 1&#39;b1)
            work_en &lt;= 1&#39;b1;
        else    if((bit_flag == 1&#39;b1) &amp;&amp; (bit_cnt == 4&#39;d9))
            work_en &lt;= 1&#39;b0;

//baud_cnt:波特率计数器计数，从0计数到BAUD_CNT_MAX - 1
always@(posedge sys_clk or negedge sys_rst_n)
        if(sys_rst_n == 1&#39;b0)
            baud_cnt &lt;= 13&#39;b0;
        else    if((baud_cnt == BAUD_CNT_MAX - 1) || (work_en == 1&#39;b0))
            baud_cnt &lt;= 13&#39;b0;
        else    if(work_en == 1&#39;b1)
            baud_cnt &lt;= baud_cnt + 1&#39;b1;

//bit_flag:当baud_cnt计数器计数到1时让bit_flag拉高一个时钟的高电平
always@(posedge sys_clk or negedge sys_rst_n)
        if(sys_rst_n == 1&#39;b0)
            bit_flag &lt;= 1&#39;b0;
        else    if(baud_cnt == 13&#39;d1)
            bit_flag &lt;= 1&#39;b1;
        else
            bit_flag &lt;= 1&#39;b0;

//bit_cnt:数据位数个数计数，10个有效数据（含起始位和停止位）到来后计数器清零
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        bit_cnt &lt;= 4&#39;b0;
    else    if((bit_flag == 1&#39;b1) &amp;&amp; (bit_cnt == 4&#39;d9))
        bit_cnt &lt;= 4&#39;b0;
    else    if((bit_flag == 1&#39;b1) &amp;&amp; (work_en == 1&#39;b1))
        bit_cnt &lt;= bit_cnt + 1&#39;b1;

//tx:输出数据在满足rs232协议（起始位为0，停止位为1）的情况下一位一位输出
always@(posedge sys_clk or negedge sys_rst_n)
        if(sys_rst_n == 1&#39;b0)
            tx &lt;= 1&#39;b1; //空闲状态时为高电平
        else    if(bit_flag == 1&#39;b1)
            case(bit_cnt)
                0       : tx &lt;= 1&#39;b0;
                1       : tx &lt;= pi_data[0];
                2       : tx &lt;= pi_data[1];
                3       : tx &lt;= pi_data[2];
                4       : tx &lt;= pi_data[3];
                5       : tx &lt;= pi_data[4];
                6       : tx &lt;= pi_data[5];
                7       : tx &lt;= pi_data[6];
                8       : tx &lt;= pi_data[7];
                9       : tx &lt;= 1&#39;b1;
                default : tx &lt;= 1&#39;b1;
            endcase

endmodule
</code></pre>
<p>③仿真设计</p>
<pre><code>module  tb_uart_tx();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//reg   define
reg         sys_clk;
reg         sys_rst_n;
reg [7:0]   pi_data;
reg         pi_flag;

//wire  define
wire        tx;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化系统时钟、全局复位
initial begin
        sys_clk    = 1&#39;b1;
        sys_rst_n &lt;= 1&#39;b0;
        #20;
        sys_rst_n &lt;= 1&#39;b1;
end

//模拟发送7次数据，分别为0~7
initial begin
        pi_data &lt;= 8&#39;b0;
        pi_flag &lt;= 1&#39;b0;
        #200
        //发送数据0
        pi_data &lt;= 8&#39;d0;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
//每发送1bit数据需要5208个时钟周期，一帧数据为10bit
//所以需要数据延时(5208*20*10)后再产生下一个数据
        #(5208*20*10);
        //发送数据1
        pi_data &lt;= 8&#39;d1;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据2
        pi_data &lt;= 8&#39;d2;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据3
        pi_data &lt;= 8&#39;d3;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据4
        pi_data &lt;= 8&#39;d4;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据5
        pi_data &lt;= 8&#39;d5;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据6
        pi_data &lt;= 8&#39;d6;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
        #(5208*20*10);
        //发送数据7
        pi_data &lt;= 8&#39;d7;
        pi_flag &lt;= 1&#39;b1;
        #20
        pi_flag &lt;= 1&#39;b0;
end

//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号
always #10 sys_clk = ~sys_clk;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------uart_rx_inst------------------------
uart_tx uart_tx_inst(
        .sys_clk    (sys_clk    ),  //input           sys_clk
        .sys_rst_n  (sys_rst_n  ),  //input           sys_rst_n
        .pi_data    (pi_data    ),  //output  [7:0]   pi_data
        .pi_flag    (pi_flag    ),  //output          pi_flag

        .tx         (tx         )   //input           tx
);

endmodule
</code></pre>
<p>仿真这里测试了发送数据0~7</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/27adf568c1d8464861d39e0417d4b893.png"></p>
<pre><code>    第三部分仿真波形如图所示，**我们可以清晰地看到最后一个 bit_flag 信号为高的时刻，且 bit_cnt 计数器也计数到 9，将停止位发送出去，同时 work_en 信号拉低， baud_cnt 计数器检测到 work_en 信号为低电平后立刻清零并停止计数，等待下一次发送数据时再工作。**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bff01cc72bba6840bbb1317293b334c8.png"></p>
<h5 id="（3）顶层设计"><a href="#（3）顶层设计" class="headerlink" title="（3）顶层设计"></a>（3）顶层设计</h5><h6 id="①代码设计"><a href="#①代码设计" class="headerlink" title="①代码设计"></a>①代码设计</h6><pre><code>`timescale  1ns/1ns

module  rs232
(
    input   wire    sys_clk     ,   //系统时钟50MHz
    input   wire    sys_rst_n   ,   //全局复位
    input   wire    rx          ,   //串口接收数据

    output  wire    tx              //串口发送数据
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//parameter define
parameter   UART_BPS    =   20&#39;d9600        ,   //比特率
            CLK_FREQ    =   26&#39;d50_000_000  ;   //时钟频率

//wire  define
wire    [7:0]   po_data;
wire            po_flag;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------ uart_rx_inst ------------------------
uart_rx
#(
    .UART_BPS    (UART_BPS  ),  //串口波特率
    .CLK_FREQ    (CLK_FREQ  )   //时钟频率
)
uart_rx_inst
(
    .sys_clk    (sys_clk    ),  //input             sys_clk
    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n
    .rx         (rx         ),  //input             rx
            
    .po_data    (po_data    ),  //output    [7:0]   po_data
    .po_flag    (po_flag    )   //output            po_flag
);

//------------------------ uart_tx_inst ------------------------
uart_tx
#(
    .UART_BPS    (UART_BPS  ),  //串口波特率
    .CLK_FREQ    (CLK_FREQ  )   //时钟频率
)
uart_tx_inst
(
    .sys_clk    (sys_clk    ),  //input             sys_clk
    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n
    .pi_data    (po_data    ),  //input     [7:0]   pi_data
    .pi_flag    (po_flag    ),  //input             pi_flag
                
    .tx         (tx         )   //output            tx
);

endmodule


    可以看到，顶层模块先定义好顶层输入输出线in/output wire，需要用到的参数parameter和内部模块的连线wire型变量；然后实例化设计好的模块，按照模块代码实例化参数，格式与模块定义时一致，**·+参数名**** _引出模块内部参数_** ，**括号内是顶层模块的变量** ，起连接作用。
</code></pre>
<h6 id="②仿真设计"><a href="#②仿真设计" class="headerlink" title="②仿真设计"></a>②仿真设计</h6><pre><code>module  tb_rs232();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire    tx          ;

//reg   define
reg     sys_clk     ;
reg     sys_rst_n   ;
reg     rx          ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化系统时钟、全局复位和输入信号
initial begin
    sys_clk    = 1&#39;b1;
    sys_rst_n &lt;= 1&#39;b0;
    rx        &lt;= 1&#39;b1;
    #20;
    sys_rst_n &lt;= 1&#39;b1;
end

//调用任务rx_byte
initial begin
    #200
    rx_byte();
end

//sys_clk:每10ns电平翻转一次，产生一个50MHz的时钟信号
always #10 sys_clk = ~sys_clk;

//创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7
task    rx_byte();  //因为不需要外部传递参数，所以括号中没有输入
    integer	j;
    for(j=0; j&lt;8; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化7
        rx_bit(j);
endtask

//创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来
task    rx_bit(
    input   [7:0]   data
);
    integer i;
    for(i=0; i&lt;10; i=i+1)   begin
        case(i)
            0: rx &lt;= 1&#39;b0;
            1: rx &lt;= data[0];
            2: rx &lt;= data[1];
            3: rx &lt;= data[2];
            4: rx &lt;= data[3];
            5: rx &lt;= data[4];
            6: rx &lt;= data[5];
            7: rx &lt;= data[6];
            8: rx &lt;= data[7];
            9: rx &lt;= 1&#39;b1;
        endcase
        #(5208*20); //每发送1位数据延时5208个时钟周期
    end
endtask

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------ rs232_inst ------------------------
rs232   rs232_inst
(
    .sys_clk    (sys_clk    ),  //input         sys_clk
    .sys_rst_n  (sys_rst_n  ),  //input         sys_rst_n
    .rx         (rx         ),  //input         rx

    .tx         (tx         )   //output        tx
);

endmodule




    这里的仿真使用了**task的嵌套** ，再实例化了顶层设计模块；**从此对模块设计 .V 文件中的参数及实例化理解加深，类似于顶层模块的综合，仿真模块开始时定义的变量时为了后面的实例化所服务的，要么起连线作用（wire），要么起赋值仿真作用（reg），在实例化的括号里连接。**
</code></pre>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><pre><code>    “在本章的 Testbench 的设计中我们第一次使用到了 task 任务以及 for 循环语句，这两个语法都在仿真中使用的较多，虽然都是可以综合的但还是推荐初学者尽量**不要在 RTL 代码中使用** ，尤其是对它们理解不深刻的情况下。而我们**在 Testbench 中使用就不用担心这么多** ，且可以大大简化我们的代码，提高效率，是十分好用的，也推荐大家以后再 Testbench 中多尝试使用。”

    以及更深入了解Verilog HDL代码的编写，深刻理解了参数、变量、实例化。
</code></pre>
<p>知识点总结：</p>
<p>1. 理解亚稳态产生的原理，掌握单比特数据从<strong>慢速时钟域到快速时钟域</strong> 处理亚稳态的方法。</p>
<p>2. 学会使用边沿检测，并记住代码的格式，理解原理。（<strong>第三级寄存器和第二级寄存器共同构成下降沿检测(~rx_reg2) &amp;&amp; (rx_reg3)）</strong></p>
<p>3. 串并转换是接口中很常用的一种方法，用到了移位，要熟练掌握。</p>
<p>4. 掌握 loopback 测试的方法，以后用于我们模块中代码的调试。</p>
<h2 id="二-基于-I2C-协议的-EEPROM-驱动控制"><a href="#二-基于-I2C-协议的-EEPROM-驱动控制" class="headerlink" title="二.基于 I2C 协议的 EEPROM 驱动控制"></a>二.基于 I2C 协议的 EEPROM 驱动控制</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="&lt;1&gt;简介"></a>&lt;1&gt;简介</h3><pre><code>    I2C 通讯协议(Inter－Integrated Circuit)是由 Philips 公司开发的一种简单、**双向二线制同步串行总线** ，只需要两根线即可在连接于总线上的器件之间传送信息。 I2C 通讯协议和通信接口在很多工程中有广泛的应用，如数据采集领域的串行 AD，图像处理领域的摄像头配置，工业控制领域的 X 射线管配置等等。除此之外，由于 I2C 协议占用引脚特别少，硬件实现简单，可扩展型强，现在被广泛地使用在系统内多个**集成电路 (IC)间的通讯** 。

    下面我们分别对 I2C 协议的**物理层** 及**协议层** 进行讲解。

    它的**物理层** 有如下特点：        

    (1) 它是一个支持多设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯 总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。

    (2) 一个 I2C 总线只使用两条总线线路，**一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)** 。数据线即用来表示数据，时钟线用于数据收发同步。

    (3) 每个连接到总线的设备都有**一个独立的地址** ，主机可以利用这个地址进行不同设备之间的访问。

    (4) 总线通过上拉电阻接到电源。**当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平** 。

    (5) 多个主机同时使用总线时，为了防止数据冲突，会利用**仲裁** 方式决定由哪个设备占用总线。

    (6) 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。

    (7) 连接到相同总线的 IC 数量受到**总线的最大电容 400pF 限制** 。

    它的**协议层** 有如下特点：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/752abc66eb1c6660c1e6af853f3feb85.png"></p>
<pre><code>    由图可知，I2C 协议整体时序图分为 4 个部分，图中标注的①②③④表示 I2C 协议的 4 个状态，分别为“总线空闲状态”、“起始信号”、“数据读/写状态”和“停止信号”， 针对这 4 个状态，我们来做一下详细介绍。

    (1) 图中标注①表示“总线空闲状态”，在此状态下串口时钟信号 SCL 和串行数据信 号 SDA 均保持高电平，此时无 I2C 设备工作。

    (2) 图中标注②表示“起始信号”，在 I2C 总线处于“空闲状态”时，SCL 依旧保持高电平时， SDA 出现由高电平转为低电平的**下降沿，产生一个起始信号** ，此时与总线相连的所有 I2C 设备在检测到起始信号后，均跳出空闲状态，**等待控制字节的输入** 。

    (3) 图中标注③表示“数据读/写状态”，“数据读/写状态”时序图具体见图：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c934c50ba6ee94b62f9e40b9f133fcf7.png"></p>
<pre><code>    I2C 通讯设备的通讯模式是**主从通讯模式** ，通讯双方有主从之分。 当主机向从机进行指令或数据的写入时，串行数据线 SDA 上的数据**在串行时钟 SCL 为高电平时写入从机设备** ，每次只写入一位数据；串行数据线 SDA 中的数据**在串行时钟 SCL 为低电平时进行数据更新** ，以保证在 SCL 为高电平时采集到 SDA 数据的稳定状态。 当一个完整字节的指令或数据传输完成，从机设备正确接收到指令或数据后，会通过**拉低 SDA 为低电平，向主机设备发送单比特的应答信号** ，表示数据或指令写入成功。若从机正确应答，可以结束或开始下一字节数据或指令的传输，否则表明数据或指令写入失败，主机就可以决定是否放弃写入或者重新发起写入。

    (4) 图中标注④表示“停止信号”，完成数据读写后，串口时钟 SCL 保持高电平，当 串口数据信号 SDA 产生一个由低电平转为高电平的上升沿时，产生一个停止信号，I2C 总线跳转回“总线空闲状态”。

    **I2C 设备器件地址与存储地址** 有如下特点：

    每个 I2C 设备在出厂前都被设置了器件地址，用户不可自主更改；器件地址一般位宽为 7 位，有的 I2C 设备的器件地址**设置了全部位宽** ，例如后面章节要讲解的 OV7725、 OV5640 摄像头；有的 I2C 设备的器件地址**设置了部分位宽** ，例如本章节要使用的 EEPROM 存储芯片，它的器件地址只设置了高 4 位，**剩下的低 3 位由用户在设计硬件时自主设置** 。 FPGA 开发板使用的是 ATMEL 公司生产的 AT24C 系列中的型号为 AT24C64 的 EEPROM 存储芯片。AT24C64 存储容量为**64Kbit，内部分成 256 页，每页 32 字节** ， 共有 8192 个字节，且其读写操作都是以字节为基本单位。 AT24C64 EEPROM 存储芯片的器件地址包括厂商设置的高 4 位 1010 和用户需自主设置的低 3 位 A0、A1、A2 。**在硬件设计时，通过将芯片的 A0、A1、A2 这 3 个引脚分别连接到 VCC 或 GND 来实现器件地址低 3 位的设置** ，若 3 个引脚均连接到 VCC，则设置后的器件地址为 1010_111；若 3 个引脚均连接到 GND，则设置后的器件地址为 1010_000。由于 A0、A1、A2 这 3 位只能组合出 8 种 情况，所以一个主机最多只能连接 8 个 AT24C64 存储芯片。 在 I2C 主从设备通讯时，主机在发送了起始信号后，接着会向从机发送控制命令。控制命令长度为 1 个字节，它的**高 7 位为上文讲解的 I2C 设备的器件地址，最低位为读写控制位** 。读写控制位为 0 时，表示主机要对从机进行数据写入操作；读写控制位为 1 时，表 示主机要对从机进行数据读出操作。         EEPROM 储存芯片控制命令格式示意图，具体见图：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6b29ef23df2793e6dee03a09ab8981.png"></p>
<pre><code>    **I2C 设备存储地址相关** ： 

    每一个支持 I2C 通讯协议的设备器件，内部都会**包含一些可进行读/写操作的寄存器或存储器** 。例如后面章节将会讲到的 OV7725、OV5640 摄像头(它们使用的是与 I2C 协议极 为相似的 SCCB 协议，后面章节会进行讲解)，他们内部包含一些需要进行读/写配置的寄存器，只有**向对应寄存器写入正确参数** ，摄像头才能被正确使用；同样，本章节要使用的 EEPROM 存储芯片内部则包含许多存储单元，需要**存储的数据按照地址被写入对应存储单元** 。 由于 I2C 设备要配置寄存器的多少或**存储容量的大小的不同，存储地址根据 位宽分为单字节和 2 字节**两种。例如后文要提到的 OV7725、OV5640 摄像头，两者的寄存器数量不 同，OV7725 摄像头需要配置寄存器较少，单个字节能够实现所有寄存器的寻址，所以他的存储地址位宽为 8 位；而 OV5640 摄像头需要配置寄存器较多，单个字节不能够实现所有寄存器的寻址，所以他的存储地址位宽为 16 位，2 个字节。 以 EEPROM 存储芯片为例，在 ATMEL 公司生产的 AT24C 系列 EEPROM 存储芯片中选取两款存储芯片 AT24C04 和 AT24C64。AT24C04 的存储容量为 1Kbit(128byte)，7 位存储地址即可满足所有存储单元的寻址，存储地址为单字节即可；而 AT24C64 的存储空间为 64 Kbit(8Kbyte)，需要 13 位存储地址才可满足所有存储单元的寻址，存储地址为 2 字节。
</code></pre>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="&lt;2&gt;读写操作"></a>&lt;2&gt;读写操作</h3><pre><code>    I2C 读/写操作对传入从机的控制命令最低位读写控制位写入不同数据值，主机可实现对从机的读/写 操作，读写控制位为 0 时，表示主机要对从机进行数据写入操作；读写控制位为 1 时，表 示主机要对从机进行数据读出操作。
</code></pre>
<p><strong>I2C 单字节写操作：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4b199374ee410594861d4b291846da6.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/416c880b3f8aca3ecaa6fcfbeba575bf.png"></p>
<p><strong>注：MSB（最高有效位，Most Significant Bit）；LSB（最低有效位，Last Significant Bit）</strong></p>
<p>参照时序图，列出单字节写操作流程如下：</p>
<pre><code>    (1) **主机** 产生并**发送起始信号** 到从机，将控制命令写入从机设备，读写控制位设置为低电平，表示对从机进行数据写操作，控制命令的写入高位在前低位在后；

    (2) **从机** 接收到控制指令后，**回传应答信号** ，主机接收到应答信号后开始存储地址的写入。若为 2 字节地址，顺序执行操作；若为单字节地址跳转到步骤(5)；

    (3) **先** 向从机写入**高 8 位地址** ，且**高位在前低位在后** ；

    (4) 待接收到从机回传的应答信号，**再写入低 8 位地址** ，且高位在前低位在后，若为 2 字节地址，跳转到步骤(6)；

    (5) 按高位在前低位在后的顺序写入单字节存储地址；

    (6) 地址写入完成，主机接收到从机**回传的应答信号** 后，开始单字节**数据的写入** ；

    (7) 单字节数据写入完成，主机接收到应答信号后，向从机**发送停止信号** ，数据写入完成。
</code></pre>
<p><strong>I2C 页写操作：</strong></p>
<pre><code>    单字节写操作中，主机一次向从机中写入单字节数据；页写操作中，主机一次可向从机写入**多字节数据** 。连续写时序图，具体见图：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f2fe112d1778081fc5d2cce74354fc.png"></p>
<pre><code>    所有 I2C 设备均支持单字节数据写入操作，但只有**部分 I2C 设备支持页写操作** ； 且支持页写操作的设备，一次页写操作写入的字节数**不能超过设备 单页包含的存储单元数**。本章节使用的 AT24CXX 系列的 EEPROM 存储芯片，单页存储单元个数为 32 个，**一 次页写操作只能写入 32 字节数据。**
</code></pre>
<p><strong>I2C 随机读操作：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/435e1a69a14a95b0356304920bc062df.png"></p>
<p>参照时序图，列出页写时序操作流程如下：</p>
<pre><code>    (1) 主机产生并发送起始信号到从机，将控制命令写入从机设备，读写控制位设置为**低电平** ，表示对从机进行**数据写操作** ，控制命令的写入高位在前低位在后；

    (2) 从机接收到控制指令后，回传应答信号，主机接收到应答信号后**开始存储地址的写入** 。若为 2 字节地址，顺序执行操作；若为单字节地址跳转到步骤(5)；         

    (3) 先向从机写入高 8 位地址，且高位在前低位在后；         

    (4) 待接收到从机回传的应答信号，再写入低 8 位地址，且高位在前低位在后，若为 2 字节地址，跳转到步骤(6)；

    (5) 按高位在前低位在后的顺序写入单字节存储地址；

    (6) **地址写入完成** ，主机接收到从机回传的应答信号后，主机**再次向从机发送一个起始信号** ；

    (7) 主机向从机发送控制命令，读写控制位设置为**高电平** ，表示对从机进行**数据读操作** ；

    (8) 主机接收到从机回传的应答信号后，开始**接收从机传回的第一个单字节数据** ；

    (9) 数据接收完成后，**主机产生应答信号回传给从机** ，**从机接收到应答信号开始下一字节数据的传输** ，若数据接收完成，执行下一操作步骤；若数据接收未完成，在此执行步骤(9)；

    (10) 主机产生**一个时钟的高电平 无应答信号**；

    (11) 主机向从机发送**停止信号** ，顺序读操作完成。
</code></pre>
<p>注：可以看到，主机进行了<strong>两次控制命令发送（读写操作，地址+w&#x2F;r）</strong> ；在写操作中写入地址，然后在读操作读取数据。</p>
<h3 id="设计实践-1"><a href="#设计实践-1" class="headerlink" title="&lt;3&gt;设计实践"></a>&lt;3&gt;设计实践</h3><pre><code>    运用所学理论知识设计一个使用 I2C 通讯协议的 EEPROM 读写控制器，使用按键控制数据写入或读出 EEPROM。使用写控制按键向 EEPROM 中写入数据 1-10 共 10 字节数据， 使用读控制按键读出之前写入到 EEPROM 的数据，并将读出的数据在数码管上显示出来。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/12435cc99834822d4e7d56554f5cd25b.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/25c752bd6943503f200153f7dce4a032.png"></p>
<pre><code>    由原理图可知，升腾 Mini 板载 EEPROM 地址位 A0、A1 接高电平，A2 接地； EEPROM 地址为 7’b1010_011。
</code></pre>
<h4 id="（1）整体设计"><a href="#（1）整体设计" class="headerlink" title="（1）整体设计"></a>（1）整体设计</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad709b86b2f585ed9b7e32572f475fa0.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5046f4605c4667e12c78374ab7af14f9.png"></p>
<pre><code>    按下数据写操作按键，写触发信号传入按键消抖模块(key_filter)，经消抖处理后的写触发信号传入数据收发模块(i2c_rw_data)，模块接收到有效的**写触发信号** 后，生成写**使能信号、待写入数据、数据地址** 传入 I2C 驱动模块(i2c_ctrl)，I2C 驱动模块按照 I2C 协议将数据写入 EEPROM 存储芯片； 数据写入完成后，按下数据读操作按键，读触发信号传入按键消抖模块(key_filter)， 经消抖处理后的读触发信号传入数据收发模块(i2c_rw_data)，模块接收到有效的**读触发信号** 后，生成**读使能信号、数据地址** 传入 I2C 驱动模块(i2c_ctrl)，I2C 驱动模块自 EEPROM 存储芯片读取数据，将读取到的数据回传给数据收发模块(i2c_rw_data)，**数据收发模块将数据暂存** ，待所有数据均读取完成后，将数据传至数码管动态显示模块(seg_dynamic)，自 EEPROM 中读取的数据在数码管显示出来。


module  eeprom_byte_rd_wr
(
    input   wire            sys_clk     ,   //输入工作时钟,频率50MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效
    input   wire            key_wr      ,   //按键写
    input   wire            key_rd      ,   //按键读

    inout   wire            sda         ,   //串行数据
    output  wire            scl         ,   //串行时钟
    output  wire    [5:0]   sel         ,   //数码管位选信号
    output  wire    [7:0]   seg             //数码管段选信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire            read        ;
wire            write       ;
wire    [7:0]   po_data     ;
wire    [7:0]   rd_data     ;
wire            wr_en       ;
wire            rd_en       ;
wire            i2c_end     ;
wire            i2c_start   ;
wire    [7:0]   wr_data     ;
wire    [15:0]  byte_addr   ;
wire            i2c_clk     ;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------- key_wr_inst -------------
key_filter  key_wr_inst
(
    .sys_clk    (sys_clk    ),  //系统时钟50Mhz
    .sys_rst_n  (sys_rst_n  ),  //全局复位
    .key_in     (key_wr     ),  //按键输入信号

    .key_flag   (write      )   //key_flag为1时表示按键有效，0表示按键无效
);

//------------- key_rd_inst -------------
key_filter  key_rd_inst
(
    .sys_clk    (sys_clk    ),  //系统时钟50Mhz
    .sys_rst_n  (sys_rst_n  ),  //全局复位
    .key_in     (key_rd     ),  //按键输入信号

    .key_flag   (read       )   //key_flag为1时表示按键有效，0表示按键无效
);

//------------- i2c_rw_data_inst -------------
i2c_rw_data i2c_rw_data_inst
(
    .sys_clk     (sys_clk   ),  //输入系统时钟,频率50MHz
    .i2c_clk     (i2c_clk   ),  //输入i2c驱动时钟,频率1MHz
    .sys_rst_n   (sys_rst_n ),  //输入复位信号,低有效
    .write       (write     ),  //输入写触发信号
    .read        (read      ),  //输入读触发信号
    .i2c_end     (i2c_end   ),  //一次i2c读/写结束信号
    .rd_data     (rd_data   ),  //输入自i2c设备读出的数据

    .wr_en       (wr_en     ),  //输出写使能信号
    .rd_en       (rd_en     ),  //输出读使能信号
    .i2c_start   (i2c_start ),  //输出i2c读/写触发信号
    .byte_addr   (byte_addr ),  //输出i2c设备读/写地址
    .wr_data     (wr_data   ),  //输出写入i2c设备的数据
    .fifo_rd_data(po_data   )   //输出自fifo中读出的数据

);

//------------- i2c_ctrl_inst -------------
i2c_ctrl
#(
    .DEVICE_ADDR    (7&#39;b1010_011     ), //i2c设备器件地址
    .SYS_CLK_FREQ   (26&#39;d50_000_000  ), //i2c_ctrl模块系统时钟频率
    .SCL_FREQ       (18&#39;d250_000     )  //i2c的SCL时钟频率
)
i2c_ctrl_inst
(
    .sys_clk     (sys_clk   ),   //输入系统时钟,50MHz
    .sys_rst_n   (sys_rst_n ),   //输入复位信号,低电平有效
    .wr_en       (wr_en     ),   //输入写使能信号
    .rd_en       (rd_en     ),   //输入读使能信号
    .i2c_start   (i2c_start ),   //输入i2c触发信号
    .addr_num    (1&#39;b1      ),   //输入i2c字节地址字节数
    .byte_addr   (byte_addr ),   //输入i2c字节地址
    .wr_data     (wr_data   ),   //输入i2c设备数据

    .rd_data     (rd_data   ),   //输出i2c设备读取数据
    .i2c_end     (i2c_end   ),   //i2c一次读/写操作完成
    .i2c_clk     (i2c_clk   ),   //i2c驱动时钟
    .i2c_scl     (scl       ),   //输出至i2c设备的串行时钟信号scl
    .i2c_sda     (sda       )    //输出至i2c设备的串行数据信号sda
);

//------------- seg_dynamic_inst -------------
seg_dynamic seg_dynamic_inst
(
    .sys_clk     (sys_clk   ), //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n ), //复位信号，低有效
    .data        (po_data   ), //数码管要显示的值
    .point       (          ), //小数点显示,高电平有效
    .seg_en      (1&#39;b1      ), //数码管使能信号，高电平有效
    .sign        (          ), //符号位，高电平显示负号

    .sel         (sel       ), //数码管位选信号
    .seg         (seg       )  //数码管段选信号
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d5635fe91ddb5bd3e38a3c10b537fc9f.png"></p>
<h4 id="（2）I2C-驱动模块"><a href="#（2）I2C-驱动模块" class="headerlink" title="（2）I2C 驱动模块"></a>（2）I2C 驱动模块</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb7cecb706c44404eb242fcfc064d9aa.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c4f74a5010a210f39adf6fbdc8ec967.png"></p>
<pre><code>    由图表可知，I2C 驱动模块包括 13 路输入输出信号，其中输入信号 8 路、输出信号 5 路。输入信号中，sys_clk、sys_rst_n 是必不可少的系统时钟和复位信号；wr_en、rd_en 为写使能信号，由数据收发模块生成并传入，高电平有效；**i2c_start 信号为单字节数据读/写 开始信号；与 i2c_start 信号同时传入的还有数据存储地址 byte_addr 和待写入字节数据 wr_data** ；当写使能 wr_en 和 i2c_start 信号同时有效，模块执行单字节数据写操作，按照数据存储地址 byte_addr，向 EEPROM 对应地址写入数据 wr_data；当读使能信号 rd_en 和 i2c_start 信号同时有效，模块执行单字节数据读操作，按照数据存储地址 byte_addr 读取 EEPROM 对应地址中的数据；前文中我们提到， I2C 设备存储地址有单字节和 2 字节两种，为了应对这一情况，我们向模块输入**addr_num** 信号**，当信号为低电平时，** 表示 I2C 设备存储地址为单字节，在进行数据读写操作时只写入数据存储地址**byte_addr 的低 8 位** ；**当信号为高电平时，** 表示 I2C 设备存储地址为 2 字节，在进行数据读写操作时要写入数据存储地址 **byte_addr 的全部 16 位。**

    输出信号中，**i2c_clk** 是本模块的工作时钟，由系统时钟 sys_clk 分频而来，它的时钟频率为串行时钟 **i2c_scl 频率的 4 倍** ，时钟信号 i2c_clk 要传入数据收发模块(i2c_rw_data)作为模块的工作时钟；输出给数据收发模块(i2c_rw_data)的单字节数据读/写结束信号 i2c_end，高电平有效，表示一次单字节数据读/写操作完成；rd_data 信号表示自 EEPROM 读出的单字节单字节数据，输出至数据收发模块(i2c_rw_data)；i2c_scl、i2c_sda 分别是串行时钟信号和串行数据信号，由模块产生传入 EEPROM 存储芯片。

    注：对 EERPROM 的数据读写操作均使用单字节读/写操作，即**每次操作只读/写单字节数据** ；若想要实现数据的连续读/写，可**持续拉高读/写使能 rd_en/wr_en** ，并输入有效的单字节数据读/写开始信号 i2c_start 即可。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/981cf57f7293a8b151ecefba24bcc8ab.png"></p>
<pre><code>    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)；FPGA 向 EEPROM 存储芯片发送起始信号；随后状态机跳转到 SEND_D_ADDR(发送器件地址状态)，在此状态下向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表 示执行写操作；控制指令写入完毕后，状态机跳转到 ACK_1(应答状态)。 在 ACK_1(应答状态)状态下，要根据存储地址字节数进行不同状态的跳转。当 FPGA 接收到 EEPROM 回传的应答信号且存储地址字节为 2 字节 ， 状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，将存储地址的高 8 位写入 EEPROM，写入完成后，状态机跳转到 ACK_2(应答状态)；FPGA 接收到应答信号后，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态)；当 FPGA 接收到 EEPROM 回传的应答信号且存储地址字节为单字节，状态机状态机直接跳转到 SEND_B_ADDR_L(发送低字节地址状 态)；在此状态低 8 位存储地址或单字节存储地址写入完成后，状态机跳转到 ACK_3(应答状态)。 在 ACK_3(应答状态)状态下，要根据读/写使能信号做不同的状态跳转。当 FPGA 接收到应答信号且写使能信号有效，状态机跳转到 WR_DATA(写数据状态)；在写数据状态， 向 EEPROM 写入单字节数据后，状态机跳转到 ACK_4(应答状态)；待 FPGA 接收到有效应答信号后，状态机跳转到**STOP(停止状态)** ；当 FPGA 接收到应答信号且读使能信号有效， 状态机跳转到 START_2(起始状态)；再次向 EEPROM 写入起始信号，状态跳转到 SEND_RD_ADDR(发送读控制状态)；再次向 EEPROM 写入控制字节，高 7 位器件地址不变，读写控制位写入“1”，表示进行读操作，控制字节写入完毕后，状态机跳转到 ACK_5(应答状态)；待 FPGA 接收到有效应答信号后，状态机跳转到 RD_DATA(读数据状态)；在 RD_DATA(读数据状态)状态，EEPROM 向 FPGA 发送存储地址对应存储单元下的单字节数据，待数据读取完成户，状态机跳转到 **N_ACK(无应答状态)** ，在此状态下向 EEPROM 写入一个时钟的高电平，表示数据读取完成，随后状态机跳转到 STOP(停止状态)。 在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次单字节数据读/写操作完成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a22e72a1f9818b6e8dd52d4e6e556113.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2c607f0961eaa4707998a179c81932b4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dbbae5dafe0c9d75fea0a0c8f4c0b8b0.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f163cf331443f13ea529491e0964a4d1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6ddc3bdf972cfc6b409df0357a7b299.png"></p>
<p>注：参考复习状态机设计<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5501" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞</a></p>
<h5 id="【1】单字节写操作时序分析"><a href="#【1】单字节写操作时序分析" class="headerlink" title="【1】单字节写操作时序分析"></a><strong>【1】单字节写操作时序分析</strong></h5><pre><code>    **第一部分** ：输入信号说明

    本模块的输入信号有 8 路，其中 7 路信号与单字节写操作有关。系统时钟信号 sys_clk 和复位信号 sys_rst_n 不必多说，这是模块正常工作必不可少的；写使能信号 wr_en、 单 字节数据读/写开始信号 i2c_start，只有在两信号同时有效时，模块才会执行单字节数据写操作，若 wr_en 有效时，i2c_start 信号 n 次有效输入，可以实现 **n 个字节的连续写操作** ； addr_num 信号为存储地址字节数标志信号，赋值为 0 时，表示 I2C 设备存储地址为单字节，赋值为 1 时，表示 I2C 设备存储地址为 2 字节，本实验使用的 EEPROM 存储芯片的存 储地址位 2 字节，此信号**恒为高电平** ；信号 byte_addr 为存储地址；wr_data 表示要写入该地址的单字节数据。

    **第二部分** ：时钟信号计数器 cnt_clk 和输出信号 i2c_clk 的设计与实现

    本实验对 EEPROM 读写操作的串行时钟**scl 的频率为 250KHz** ，且只在数据读写操作时时钟信号才有效，其他时刻 scl 始终保持高电平。若直接使用系统时钟生成串行时钟 scl，计数器要设置**较大的位宽** ，较为麻烦，我们这里先**将系统时钟分频为频率较小的时钟，在使用新分频的时钟来生成串行时钟 scl** 。

    所以，在这里声明一个新的计数器 **cnt_clk** 对系统时钟 sys_clk 进行计数，利用计数器 cnt_clk 生成新的时钟 **i2c_clk** 。

    串行时钟 scl 的时钟频率为 250KHz，我们要生成的新时钟 i2c_clk 的频率要是 scl 的 4 倍，之所以这样是为了后面更好的生成 scl 和 sda，所以 i2c_clk 的时钟频率为 1MHz。经计 算，cnt_clk 要在 0-24 （25次）内循环计数，每个系统时钟周期自加 1；cnt_clk **每计完一个周期， i2c_clk 进行一次取反（50分频）** ，最后得到 i2c_clk 为频率 1MHz 的时钟，本模块中其他信号的生成都以此信号为同步时钟。两信号波形图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21691eb71a39d5bf950a025e94f0dda7.png"></p>
<pre><code>    注：由于系统时钟 sys_clk 与时钟 i2c_clk 时钟频率相差较大，sys_clk 信号用虚线表示。

    **第三部分** ：输出至 EEPROM 的串行时钟 scl 与串行数据 sda 只有在进行数据读写操作时有效，其他时刻始终保持高电平。由前文状态机相关讲解可知，除 IDLE(初始 状态)状态之外的其他状态均属于数据读写操作的有效部分，所以声明一个使能信号 **cnt_i2c_clk_en** ，在除 IDLE(初始状态)状态之外的其他状态保持有效高电平，作为 I2C 数据读写操作使能信号。

    我们使用 50MHz 系统时钟生成了 1MHz 时钟 i2c_clk，但输出至 EEPROM 的串行时钟 scl 的时钟频率为 250KHz，我们声明时钟信号计数器 **cnt_i2c_clk** ，作为分频计数器，对时钟 i2c_clk 时钟信号进行计数，初值为 0，计数范围为 0-3，计数时钟为 i2c_clk 时钟，每个 时钟周期自加 1，实现时钟 i2c_clk 信号的 4 分频，生成串行时钟 **scl** 。同时计数器 cnt_i2c_clk 也可作为生成串行数据 sda 的约束条件，以及状态机跳转条件。

    计数器 cnt_i2c_clk 循环计数一个周期，对应串行时钟 scl 的 1 个时钟周期以及串行数据 **sda 的 1 位数据保持时间** ，进行数据读写操作时，传输的指令、地址以及数据，位宽为固定的 8 位数据，我们声明一个比特计数器 cnt_bit，对计数器 cnt_i2c_clk 的计数周期进行计数，可以辅助串行数据 sda 的生成，同时作为状态机状态跳转的约束条件。

    输出的串行数据 sda 作为一个双向端口，主机通过它向从机发送控制指令、地址以及数据，接收从机回传的应答信号和读取数据。回传给主机的**应答信号是实现状态机跳转的条件之一** 。**声明信号 sda_in 作为串行数据 sda 缓存** ，声明 ack 信号作为应答信号，ack 信号只在状态机处于各应答状态时由 sda_in 信号赋值，此时为从机回传的应答信号，其他状态时钟保持高电平。

    状态机状态跳转的各约束条件均已介绍完毕，声明**状态变量 state** ， 单字节写操作状态机跳转流程如下：

    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)，同时使能信号 **cnt_i2c_clk_en 拉高** 、计数器 **cnt_i2c_clk、cnt_bit 开始计数** ，开始数据读写操作；

    在 START_1(起始状态)状态保持一个串行时钟周期，期间 FPGA 向 EEPROM 存储芯 片发送起始信号，一个时钟周期过后，计数器 cnt_i2c_clk 完成一个周期计数，计数到最大值 3，状态机跳转到 SEND_D_ADDR(发送器件地址状态)；

    计数器 cnt_i2c_clk、cnt_bit 同时归 0，重新计数，计数器 cnt_i2c_clk 每计完一个周期，cnt_bit 自加 1，当计数器 cnt_i2c_clk 完成 8 个计数周期后，cnt_bit 计数到 7，实现 8 个比特计数，器件 FPGA 按照时序向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表示执行写操作。当计数器 cnt_ i2c_clk 计数到最大值 3、cnt_bit 计数到 7，两计数器同时归 0，**状态机跳转到转到 ACK_1(应答状态)** ；

    在 ACK_1(应答状态)状态下，计数器 cnt_i2c_clk、cnt_bit 重新计数，当计数器 cnt_ i2c_clk 计数到最大值 3 ， 且应答信号 ack 为有效的低电平 ， 状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，两计数器清 0；

    此状态下，FPGA 将存储地址的高 8 位按时序写入 EEPROM，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，状态机跳转到 ACK_2(应答状态)， 两计数器清 0；

    ACK_2 状态下，当计数器 cnt_ i2c_clk 计数到 3，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态) ，两计数器清 0；

    在此状态下，低 8 位存储地址按时序写入 EEPROM，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_3(应答状态)；

    在 ACK_3(应答状态)状态下，当 **cnt_ i2c_clk 计数 3、应答信号 ack 有效，且写使能信号 wr_en 有效，状态机跳转到 WR_DATA(写数据状态)** ；

    在写数据状态，按时序向 EEPROM 写入单字节数据，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_4(应答状态)；

    在 ACK_4(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，状态机跳转到 STOP(停止状态)状态；

    在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次单字节数据读/写操作完成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。

    可以看到主要决定状态机状态**跳转的判断条件** 是**cnt_ i2c_clk 计数到 3、应答信号 ack 有效、cnt_bit 计数到 7**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a970f3612ef8aafc029a265ccdf27ec.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ec68fc6685298d54ce1f1f76d69b368c.png"></p>
<pre><code>    **第四部分** ：输出串行时钟 i2c_scl、串行数据信号 i2c_sda 及相关信号的波形设计与实现

    串口数据 sda 端口作为一个双向端口，在单字节读取操作中，**主机只在除应答状态之外的其他状态拥有它的控制权，在应答状态下主机只能接收由从机通过 sda 传入的应答信号** 。声明使能信号 sda_en，只在除应答状态之外的其他状态赋值为有效的高电平，**sda_en 有效时，主机拥有对 sda 的控制权。**

    声明 **i2c_sda_reg** 作为输出 i2c_sda 信号的**数据缓存** ，**在 sda_en 有效时，将 i2c_sda_reg 的值赋值给输出串口数据 i2c_sda，sda_en 无效时，输出串口数据 i2c_sda 为高阻态，主机放弃其控制权，接收其传入的应答信号。**

    i2c_sda_reg 在使能信号 sda_en 无效时始终保持高电平，在使能 sda_en 有效时，在状态机对应状态下，以计数器 cnt_ i2c_clk、cnt_bit 为约束条件，对应写入起始信号、控制指令、存储地址、写入数据、停止信号。

    对于输出的串行时钟 i2c_clk，由 I2C 通讯协议可知，I2C 设备只在串行时钟为高电平时进行数据采集，在串行时钟低电平时实现串行数据更新。我们使用计数器 cnt_ i2c_clk、 cnt_bit 以及状态变量 state 为约束条件，结合 I2C 通讯协议，生成满足时序要求的输出串行 时钟 i2c_clk。

    输出串行时钟 i2c_scl、串行数据信号 i2c_sda 及相关信号的波形图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b50b1bf58d51104cf8dcdb6ec165a14.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f84ba56575b04cae5fd6ae73bea6d80.png"></p>
<h5 id="【2】随机读操作时序分析"><a href="#【2】随机读操作时序分析" class="headerlink" title="【2】随机读操作时序分析"></a>【2】随机读操作时序分析</h5><pre><code>    单字节写操作和随机读操作所涉及的各信号大体相同，在随机读操作，我们只讲解差别较大之处，两操作相同或相似之处不再说明，读者可回顾单字节写操作部分的介 绍。 

    **第一部分** ：输入信号说明 本模块的输入信号有 8 路，其中 6 路信号与随机读操作有关。系统时钟信号 sys_clk 和 复位信号 sys_rst_n 不必多说，这是模块正常工作必不可少的；读使能信号 rd_en、 单字节数据读/写开始信号 i2c_start，只有在两信号同时有效时，模块才会执行随机读操作，若 rd_en 有效时，i2c_start 信号 n 次有效输入，可以实现 n 个字节的连续读操作；addr_num 信 号为存储地址字节数标志信号，赋值为 0 时，表示 I2C 设备存储地址为单字节，赋值为 1 时，表示 2C 设备存储地址为 2 字节，本实验使用的 EEPROM 存储芯片的存储地址位 2 字节，此信号恒为高电平；信号 byte_addr 为存储地址。

    **第二部分** ：状态机相关信号波形的设计与实现

    状态机状态跳转的各约束条件，读者可回顾单字节写操作部分介绍。声明状态变量 state，结合各约束信号，单字节写操作状态机跳转流程如下：

    系统上电后，状态机处于 IDLE(初始状态)，接收到有效的单字节数据读/写开始信号 i2c_start 后，状态机跳转到 START_1(起始状态)，同时使能信号 cnt_i2c_clk_en 拉高、计数器 cnt_i2c_clk、cnt_bit 开始计数，开始数据读写操作；

    在 START_1(起始状态)状态保持一个串行时钟周期，期间 FPGA 向 EEPROM 存储芯 片发送起始信号，一个时钟周期过后，计数器 cnt_ i2c_clk 完成一个周期计数，计数器 cnt_ i2c_clk 计数到最大值 3，状态机跳转到 SEND_D_ADDR(发送器件地址状态)；

    计数器 cnt_i2c_clk、cnt_bit 同时归 0，重新计数，计数器 cnt_i2c_clk 每计完一个周期，cnt_bit 自加 1，当计数器 cnt_i2c_clk 完成 8 个计数周期后，cnt_bit 计数到 7，实现 8 个比特计数，器件 FPGA 按照时序向 EEPROM 存储芯片写入控制指令，控制指令高 7 位为器件地址，最低位为读写控制字，写入“0”，表示执行写操作。当计数器 cnt_ i2c_clk 计数到最大值 3、cnt_bit 计数到 7，两计数器同时归 0，状态机跳转到转到 ACK_1(应答状态)；

    在 ACK_1(应答状态)状态下，计数器 cnt_i2c_clk、cnt_bit 重新计数，当计数器 cnt_ i2c_clk 计数到最大值 3 ，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_H(发送高字节地址状态)，两计数器清 0；

    此状态下，FPGA 将存储地址的高 8 位按时序写入 EEPROM，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，状态机跳转到 ACK_2(应答状态)， 两计数器清 0；

    ACK_2 状态下，当计数器 cnt_ i2c_clk 计数到 3，且应答信号 ack 为有效的低电平，状态机跳转到 SEND_B_ADDR_L(发送低字节地址状态) ，两计数器清 0； 在此状态下，低 8 位存储地址按时序写入 EEPROM，计数器 cnt_ i2c_clk 计数到 3、 cnt_bit 计数到 7，状态机跳转到 ACK_3(应答状态)；

    在 ACK_3(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，且读使能信号 rd_en 有效，状态机跳转到 START_2(起始状态)；

    在 START_2(起始状态)状态保持一个串行时钟周期，期间 FPGA 再次向 EEPROM 存 储芯片发送起始信号，一个时钟周期过后，计数器 cnt_ i2c_clk 完成一个周期计数，计数器 cnt_ i2c_clk 计数到 3，状态机跳转到 SEND_RD_ADDR(发送读控制状态)；

    在此状态下，按时序向 EEPROM 写入控制指令，控制指令高 7 位为器件地址，最低位 为读写控制字，写入“1”，表示执行读操作。当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计 数到 7，两计数器同时归 0，状态机跳转到 ACK_5(应答状态)；

    在 ACK_5(应答状态)状态下，当 cnt_ i2c_clk 计数 3、应答信号 ack 有效，状态机跳转 到 RD_DATA(读数据状态)；读数据状态下，主机读取从机发送的单字节数据，当计数器 cnt_ i2c_clk 计数到 3、cnt_bit 计数到 7，数据读取完成，计数器清 0，状态机跳转到 N_ACK(非应答状态)；在非应答状态下，向 EEPROM 写入一个时钟的高电平，当 cnt_ i2c_clk 计数 3，状态机跳转到 STOP(停止状态)。

    在 STOP(停止状态)状态，FPGA 向 EEPROM 发送停止信号，一次随机数据读操作完 成，随后状态机跳回 IDLE(初始状态)，等待下一次单字节数据读/写开始信号 i2c_start。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c844ac970c4e331bb4259a5372a63cb7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3502bc1d7fd38855b0b7f7a688156c7a.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a9f2151c7bafded4a203e9e302ce02b.png"></p>
<p>可以看到主要决定状态机状态<strong>跳转的判断条件</strong> 是<strong>cnt_ i2c_clk 计数到 3、应答信号 ack 有效、cnt_bit 计数到 7</strong></p>
<pre><code>    **第三部分** ：输出串行时钟 i2c_scl、串行数据信号 i2c_sda、读出数据 rd_data 及相关信号的波形设计与实现串口数据 sda 端口作为一个双向端口，在随机读操作中，主机只在除应答状态、读数据状态之外的其他状态拥有它的控制权，在应答状态下主机接收由从机通过 sda 传入的应答信号，在读数据状态下主机接收由从机传入的单字节数据。声明使能信号 sda_en，只在除应答状态、读数据状态之外的其他状态赋值为有效的高电平，sda_en 有效时，主机拥有 对 sda 的控制权。

    声明 i2c_sda_reg 作为输出 i2c_sda 信号的数据缓存；声明 rd_data_reg 作为 EEPROM 读 出数据缓存。

    i2c_sda_reg 在使能信号 sda_en 无效时始终保持高电平，在使能 sda_en 有效时，在状态机对应状态下，以计数器 cnt_ i2c_clk、cnt_bit 为约束条件，对应写入起始信号、控制指令、存储地址、写入数据、停止信号；在状态机处于读数据状态时，变量 rd_data_reg 由输入信号 sda_in 赋值，暂存 EEPROM 读取数据。

    当 sda_en 有效时，将 i2c_sda_reg 赋值给 i2c_sda；当 sda_en 无效时，**i2c_sda 保持高阻 态。主机放弃对 sda 端口的控制；在状态机处于读数据状态时，变量 rd_data_reg 暂存 EEPROM 读取数据，读数据状态结束后，将暂存数据赋值给输出信号 rd_data** 。

    对于输出的串行时钟 i2c_clk，由 I2C 通讯协议可知，I2C 设备只在串行时钟为高电平时进行数据采集，在串行时钟低电平时实现串行数据更新。我们使用计数器 cnt_ i2c_clk、 cnt_bit 以及状态变量 state 为约束条件，结合 I2C 通讯协议，生成满足时序要求的输出串行 时钟 i2c_clk。

    输出串行时钟 i2c_scl、串行数据信号 i2c_sda、读出数据 rd_data 及相关信号波形图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5807cf4689a02cb0d3cc686a4d8d115e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/724069bcb981b658644f954820b36b02.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/31e7abe3c09fafe03c928c4066ed76e5.png"></p>
<h5 id="【3】代码设计"><a href="#【3】代码设计" class="headerlink" title="【3】代码设计"></a>【3】代码设计</h5><pre><code>module  i2c_ctrl
#(
    parameter   DEVICE_ADDR     =   7&#39;b1010_000     ,   //i2c设备地址
    parameter   SYS_CLK_FREQ    =   26&#39;d50_000_000  ,   //输入系统时钟频率
    parameter   SCL_FREQ        =   18&#39;d250_000         //i2c设备scl时钟频率
)
(
    input   wire            sys_clk     ,   //输入系统时钟,50MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低电平有效
    input   wire            wr_en       ,   //输入写使能信号
    input   wire            rd_en       ,   //输入读使能信号
    input   wire            i2c_start   ,   //输入i2c触发信号
    input   wire            addr_num    ,   //输入i2c字节地址字节数
    input   wire    [15:0]  byte_addr   ,   //输入i2c字节地址
    input   wire    [7:0]   wr_data     ,   //输入i2c设备数据

    output  reg             i2c_clk     ,   //i2c驱动时钟
    output  reg             i2c_end     ,   //i2c一次读/写操作完成
    output  reg     [7:0]   rd_data     ,   //输出i2c设备读取数据
    output  reg             i2c_scl     ,   //输出至i2c设备的串行时钟信号scl
    inout   wire            i2c_sda         //输出至i2c设备的串行数据信号sda
);

//************************************************************************//
//******************** Parameter and Internal Signal *********************//
//************************************************************************//
// parameter define
parameter   CNT_CLK_MAX     =   (SYS_CLK_FREQ/SCL_FREQ) &gt;&gt; 2&#39;d3   ;   //cnt_clk计数器计数最大值

parameter   CNT_START_MAX   =   8&#39;d100; //cnt_start计数器计数最大值

parameter   IDLE            =   4&#39;d00,  //初始状态
            START_1         =   4&#39;d01,  //开始状态1
            SEND_D_ADDR     =   4&#39;d02,  //设备地址写入状态 + 控制写
            ACK_1           =   4&#39;d03,  //应答状态1
            SEND_B_ADDR_H   =   4&#39;d04,  //字节地址高八位写入状态
            ACK_2           =   4&#39;d05,  //应答状态2
            SEND_B_ADDR_L   =   4&#39;d06,  //字节地址低八位写入状态
            ACK_3           =   4&#39;d07,  //应答状态3
            WR_DATA         =   4&#39;d08,  //写数据状态
            ACK_4           =   4&#39;d09,  //应答状态4
            START_2         =   4&#39;d10,  //开始状态2
            SEND_RD_ADDR    =   4&#39;d11,  //设备地址写入状态 + 控制读
            ACK_5           =   4&#39;d12,  //应答状态5
            RD_DATA         =   4&#39;d13,  //读数据状态
            N_ACK           =   4&#39;d14,  //非应答状态
            STOP            =   4&#39;d15;  //结束状态

// wire  define
wire            sda_in          ;   //sda输入数据寄存
wire            sda_en          ;   //sda数据写入使能信号

// reg   define
reg     [7:0]   cnt_clk         ;   //系统时钟计数器,控制生成clk_i2c时钟信号
reg     [3:0]   state           ;   //状态机状态
reg             cnt_i2c_clk_en  ;   //cnt_i2c_clk计数器使能信号
reg     [1:0]   cnt_i2c_clk     ;   //clk_i2c时钟计数器,控制生成cnt_bit信号
reg     [2:0]   cnt_bit         ;   //sda比特计数器
reg             ack             ;   //应答信号
reg             i2c_sda_reg     ;   //sda数据缓存
reg     [7:0]   rd_data_reg     ;   //自i2c设备读出数据

//************************************************************************//
//******************************* Main Code ******************************//
//************************************************************************//
// cnt_clk:系统时钟计数器,控制生成clk_i2c时钟信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_clk &lt;=  8&#39;d0;
    else    if(cnt_clk == CNT_CLK_MAX - 1&#39;b1)
        cnt_clk &lt;=  8&#39;d0;
    else
        cnt_clk &lt;=  cnt_clk + 1&#39;b1;

// i2c_clk:i2c驱动时钟
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        i2c_clk &lt;=  1&#39;b1;
    else    if(cnt_clk == CNT_CLK_MAX - 1&#39;b1)
        i2c_clk &lt;=  ~i2c_clk;

// cnt_i2c_clk_en:cnt_i2c_clk计数器使能信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_i2c_clk_en  &lt;=  1&#39;b0;
    else    if((state == STOP) &amp;&amp; (cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))
        cnt_i2c_clk_en  &lt;=  1&#39;b0;
    else    if(i2c_start == 1&#39;b1)
        cnt_i2c_clk_en  &lt;=  1&#39;b1;

// cnt_i2c_clk:i2c_clk时钟计数器,控制生成cnt_bit信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_i2c_clk &lt;=  2&#39;d0;
    else    if(cnt_i2c_clk_en == 1&#39;b1)
        cnt_i2c_clk &lt;=  cnt_i2c_clk + 1&#39;b1;

// cnt_bit:sda比特计数器
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_bit &lt;=  3&#39;d0;
    else    if((state == IDLE) || (state == START_1) || (state == START_2)
                || (state == ACK_1) || (state == ACK_2) || (state == ACK_3)
                || (state == ACK_4) || (state == ACK_5) || (state == N_ACK))
        cnt_bit &lt;=  3&#39;d0;
    else    if((cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 2&#39;d3))
        cnt_bit &lt;=  3&#39;d0;
    else    if((cnt_i2c_clk == 2&#39;d3) &amp;&amp; (state != IDLE))
        cnt_bit &lt;=  cnt_bit + 1&#39;b1;

// state:状态机状态跳转
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        state   &lt;=  IDLE;
    else    case(state)
        IDLE:
            if(i2c_start == 1&#39;b1)
                state   &lt;=  START_1;
            else
                state   &lt;=  state;
        START_1:
            if(cnt_i2c_clk == 3)
                state   &lt;=  SEND_D_ADDR;
            else
                state   &lt;=  state;
        SEND_D_ADDR:
            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  ACK_1;
            else
                state   &lt;=  state;
        ACK_1:
            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))
                begin
                    if(addr_num == 1&#39;b1)
                        state   &lt;=  SEND_B_ADDR_H;
                    else
                        state   &lt;=  SEND_B_ADDR_L;
                end
             else
                state   &lt;=  state;
        SEND_B_ADDR_H:
            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  ACK_2;
            else
                state   &lt;=  state;
        ACK_2:
            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))
                state   &lt;=  SEND_B_ADDR_L;
            else
                state   &lt;=  state;
        SEND_B_ADDR_L:
            if((cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 3))
                state   &lt;=  ACK_3;
            else
                state   &lt;=  state;
        ACK_3:
            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))
                begin
                    if(wr_en == 1&#39;b1)
                        state   &lt;=  WR_DATA;
                    else    if(rd_en == 1&#39;b1)
                        state   &lt;=  START_2;
                    else
                        state   &lt;=  state;
                end
             else
                state   &lt;=  state;
        WR_DATA:
            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  ACK_4;
            else
                state   &lt;=  state;
        ACK_4:
            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))
                state   &lt;=  STOP;
            else
                state   &lt;=  state;
        START_2:
            if(cnt_i2c_clk == 3)
                state   &lt;=  SEND_RD_ADDR;
            else
                state   &lt;=  state;
        SEND_RD_ADDR:
            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  ACK_5;
            else
                state   &lt;=  state;
        ACK_5:
            if((cnt_i2c_clk == 3) &amp;&amp; (ack == 1&#39;b0))
                state   &lt;=  RD_DATA;
            else
                state   &lt;=  state;
        RD_DATA:
            if((cnt_bit == 3&#39;d7) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  N_ACK;
            else
                state   &lt;=  state;
        N_ACK:
            if(cnt_i2c_clk == 3)
                state   &lt;=  STOP;
            else
                state   &lt;=  state;
        STOP:
            if((cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))
                state   &lt;=  IDLE;
            else
                state   &lt;=  state;
        default:    state   &lt;=  IDLE;
    endcase

// ack:应答信号
always@(*)
    case    (state)
        IDLE,START_1,SEND_D_ADDR,SEND_B_ADDR_H,SEND_B_ADDR_L,
        WR_DATA,START_2,SEND_RD_ADDR,RD_DATA,N_ACK:
            ack &lt;=  1&#39;b1;
        ACK_1,ACK_2,ACK_3,ACK_4,ACK_5:
            if(cnt_i2c_clk == 2&#39;d0)
                ack &lt;=   sda_in /* 1&#39;b0 */;
            else
                ack &lt;=  ack;
        default:    ack &lt;=  1&#39;b1;
    endcase

// i2c_scl:输出至i2c设备的串行时钟信号scl
always@(*)
    case    (state)
        IDLE:
            i2c_scl &lt;=  1&#39;b1;
        START_1:
            if(cnt_i2c_clk == 2&#39;d3)
                i2c_scl &lt;=  1&#39;b0;
            else
                i2c_scl &lt;=  1&#39;b1;
        SEND_D_ADDR,ACK_1,SEND_B_ADDR_H,ACK_2,SEND_B_ADDR_L,
        ACK_3,WR_DATA,ACK_4,START_2,SEND_RD_ADDR,ACK_5,RD_DATA,N_ACK:
            if((cnt_i2c_clk == 2&#39;d1) || (cnt_i2c_clk == 2&#39;d2))
                i2c_scl &lt;=  1&#39;b1;
            else
                i2c_scl &lt;=  1&#39;b0;
        STOP:
            if((cnt_bit == 3&#39;d0) &amp;&amp;(cnt_i2c_clk == 2&#39;d0))
                i2c_scl &lt;=  1&#39;b0;
            else
                i2c_scl &lt;=  1&#39;b1;
        default:    i2c_scl &lt;=  1&#39;b1;
    endcase

// i2c_sda_reg:sda数据缓存
always@(*)
    case    (state)
        IDLE:
            begin
                i2c_sda_reg &lt;=  1&#39;b1;
                rd_data_reg &lt;=  8&#39;d0;
            end
        START_1:
            if(cnt_i2c_clk &lt;= 2&#39;d0)
                i2c_sda_reg &lt;=  1&#39;b1;
            else
                i2c_sda_reg &lt;=  1&#39;b0;
        SEND_D_ADDR:
            if(cnt_bit &lt;= 3&#39;d6)
                i2c_sda_reg &lt;=  DEVICE_ADDR[6 - cnt_bit];
            else
                i2c_sda_reg &lt;=  1&#39;b0;
        ACK_1:
            i2c_sda_reg &lt;=  1&#39;b1;
        SEND_B_ADDR_H:
            i2c_sda_reg &lt;=  byte_addr[15 - cnt_bit];
        ACK_2:
            i2c_sda_reg &lt;=  1&#39;b1;
        SEND_B_ADDR_L:
            i2c_sda_reg &lt;=  byte_addr[7 - cnt_bit];
        ACK_3:
            i2c_sda_reg &lt;=  1&#39;b1;
        WR_DATA:
            i2c_sda_reg &lt;=  wr_data[7 - cnt_bit];
        ACK_4:
            i2c_sda_reg &lt;=  1&#39;b1;
        START_2:
            if(cnt_i2c_clk &lt;= 2&#39;d1)
                i2c_sda_reg &lt;=  1&#39;b1;
            else
                i2c_sda_reg &lt;=  1&#39;b0;
        SEND_RD_ADDR:
            if(cnt_bit &lt;= 3&#39;d6)
                i2c_sda_reg &lt;=  DEVICE_ADDR[6 - cnt_bit];
            else
                i2c_sda_reg &lt;=  1&#39;b1;
        ACK_5:
            i2c_sda_reg &lt;=  1&#39;b1;
        RD_DATA:
            if(cnt_i2c_clk  == 2&#39;d2)
                rd_data_reg[7 - cnt_bit]    &lt;=  sda_in;
            else
                rd_data_reg &lt;=  rd_data_reg;
        N_ACK:
            i2c_sda_reg &lt;=  1&#39;b1;
        STOP:
            if((cnt_bit == 3&#39;d0) &amp;&amp; (cnt_i2c_clk &lt; 2&#39;d3))
                i2c_sda_reg &lt;=  1&#39;b0;
            else
                i2c_sda_reg &lt;=  1&#39;b1;
        default:
            begin
                i2c_sda_reg &lt;=  1&#39;b1;
                rd_data_reg &lt;=  rd_data_reg;
            end
    endcase

// rd_data:自i2c设备读出数据
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_data &lt;=  8&#39;d0;
    else    if((state == RD_DATA) &amp;&amp; (cnt_bit == 3&#39;d7) &amp;&amp; (cnt_i2c_clk == 2&#39;d3))
        rd_data &lt;=  rd_data_reg;

// i2c_end:一次读/写结束信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        i2c_end &lt;=  1&#39;b0;
    else    if((state == STOP) &amp;&amp; (cnt_bit == 3&#39;d3) &amp;&amp;(cnt_i2c_clk == 3))
        i2c_end &lt;=  1&#39;b1;
    else
        i2c_end &lt;=  1&#39;b0;

// sda_in:sda输入数据寄存
assign  sda_in = i2c_sda;
// sda_en:sda数据写入使能信号
assign  sda_en = ((state == RD_DATA) || (state == ACK_1) || (state == ACK_2)
                    || (state == ACK_3) || (state == ACK_4) || (state == ACK_5))
                    ? 1&#39;b0 : 1&#39;b1;
// i2c_sda:输出至i2c设备的串行数据信号sda
assign  i2c_sda = (sda_en == 1&#39;b1) ? i2c_sda_reg : 1&#39;bz;

endmodule


    代码中有一处，读者要注意，经计算，生成 i2c_clk 时钟信号的计数器 cnt_clk 一个循环周期计数 25 次满足要求，但此处计数器 cnt_clk 计数最大值 CNT_CLK_MAX 并未直接赋值，而是使用公式赋值。


parameter CNT_CLK_MAX = (SYS_CLK_FREQ/SCL_FREQ) &gt;&gt; 2&#39;d3 ; 

    这是为了提高 I2C 驱动模块的复用性，参数 **SYS_CLK_FREQ** 表示系统时钟 sys_clk 时钟频率，参数 **SCL_FREQ** 表示输出串行时钟 i2c_scl 时钟频率；两参数做除法运算，结果右移一位结表示除 2，得到的结果用于**分频计数器计数最大值** ，可直接由系统时钟分频产生串行时钟 i2c_scl 时钟信号；结果继续右移两位表示除 4，作为分频计数器计数最大值， 可产生时钟信号 **i2c_clk** ，时钟频率为串行时钟 **i2c_scl 时钟频率的 4 倍** 。 这样一来，只要设置好系统时钟与串行时钟的时钟频率，本模块即可在多种时钟频率下使用，复用性大大提高。 
</code></pre>
<h4 id="（3）数据收发模块"><a href="#（3）数据收发模块" class="headerlink" title="（3）数据收发模块"></a>（3）数据收发模块</h4><pre><code>    数据收发模块的主要功能是：为 I2C 驱动模块**提供读/写数据存储地址** 、**待写入数据** 以及作为 **EEPROM 读出数据缓存** ，待数据读取完成后将读出数据**发送给数码管** 显示模块进行数据示。        
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1eabdb473fb9d49eb26921b67ba45288.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e9d9b2f0b9d41c7067ec9a6cd74b3c2b.png"></p>
<pre><code>    由图表可知，I2C 驱动模块包括 13 路输入输出信号，其中输入信号 7 路、输出信号 6 路。

    输入信号中，有 2 路时钟信号和 1 路复位信号，sys_clk 为系统时钟信号，在数据收发模块中用于采集读/写触发信号 read 和 write，2 路触发信号均由外部按键输出，经消抖处理后传入本模块，消抖模块使用的时钟信号为与 sys_clk 相同的系统时钟，所以读/写触发信号的采集要使用系统时钟；i2c_clk 为模块工作时钟，由 I2C 驱动模块生成并传入，是存储地址、读/写数据以及使能信号的同步时钟，因为 I2C 模块的工作时钟为 i2c_clk 时钟信号，两模块工作时钟相同，不会出现时钟不同引起时序问题；复位信号 sys_rst_n，低电平有效，不必多说；i2c_end 为单字节数据读/写接数信号，由 I2C 驱动模块产生并传入，告 知数据生成模块单字节数据读/写操作完成。若连续读/写多字节数据，此信号可作为存储地址、写数据的更新标志；rd_data 为 I2C 驱动模块传入的数据信号，表示由 EEPROM 读出的字节数据。

    输出信号中，**rd_en、wr_en 分别为读写使能信号** ，生成后传入 I2C 驱动模块，作为 I2C 驱动模块读/写操作的判断标志；i2c_start 是单字节数据读/写开始信号，作为 I2C 驱动模块单字节读/写操作开始的标志信号；byte_addr 为读写数据存储地址；wr_data 为待写入 EEPROM 的字节数据；**fifo_rd_data 为自 EEPROM 读出的字节数据，要发送到数码换显示模块在数码管显示出来** 。

    注：数据收发模块内部**实例化一个 FIFO** ，将读出 EEPROM 的字节数据做**暂存** ，待**所有数据读取完成后，开始向数码管发送数据** 。例如本实验向 EEPROM 连续写入 10 个字节数据，随后将写入数据读出并在数码管显示，数据收发模块只有接收到读出的 10 个字节数据后，才会开始向数码管显示模块发送数据。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/50887563f603498a62193a654156c9c0.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0209b025d932bf0f3184f96236101d7e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c37479538b21c177100541d00510745f.png"></p>
<h5 id="【1】写数据操作部分"><a href="#【1】写数据操作部分" class="headerlink" title="【1】写数据操作部分"></a>【1】写数据操作部分</h5><pre><code>    **第一部分** ：输出写使能信号 wr_en 及其相关信号波形的设计与实现

    外部按键传入的写触发信号经消抖处理后传入本模块，该信号只保持一个有效时钟， 且同步时钟为系统时钟 sys_clk，模块工作时钟 i2c_clk 很难采集到该触发信号。我们需要**延长该写使能触发信号的有效时间** ，使模块工作时钟 i2c_clk 可以采集到该触发信号。

    声明计数器 cnt_wr 和写有效信号 wr_valid 两信号的同步时钟均为系统时钟 sys_clk，当外部传入有效的写触发信号 write，写有效信号 wr_valid 拉高，计数器 cnt_wr 来时计数，计数器计数到设定值(200)后归 0，写有效信号拉低。计数器 cnt_wr 计数设定值可自主设定，只要能使 **wr_valid 信号保持一个工作时钟周期高电平即可** 。计数器 cnt_wr 和写有效信号 wr_valid 波形图如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/231d2a6b838d3c39c536be23ca2454f6.png"></p>
<pre><code>    写有效信号 wr_valid 拉高后，工作时钟 i2c_clk 上升沿采集到 wr_valid 高电平，拉高写使能信号 wr_en，告知 I2C 驱动模块接下来要进行数据写操作。在此次实验我们要连续写入 10 字节数据，所以写使能信号 wr_en 要保持 10 次数据写操作的有效时间，在这一时间段我们要**输出 10 次有效的 i2c_start 信号** ，在接收到第 10 次 i2c_end 信号后，表示 10 字节 数据均已写入完成，将**写使能信号 rw_en 拉低** ，完成 10 字节数据的连续写入。 要实现这一操作我们需要声明 2 个变量，声明**字节计数器 wr_i2c_data_num** 对已写入 字节进行计数；由数据手册可知，两次相邻的读/写操作之间需要一定的**时间间隔，以保证 上一次读/写操作完成** ，所以声明计数器 **cnt_start** ，对相邻读/写操作**时间间隔进行计数** 。 采集到写有效信号 wr_valid 为高电平，拉高写使能信号 wr_en，计数器 **cnt_wait** 、 wr_i2c_data_num 均由 0 开始计数，每一个工作时钟周期 cnt_wait 自加 1，计数到最大值 1499，i2c_start 保持一个工作时钟的高电平，同时 cnt_wait 归 0，重新开始计数；I2C 驱动模块接收到有效的 i2c_start 信号后，向 EEPROM 写入单字节数据，传回 i2c_end 信号，表示一次单字节写操作完毕，计数器 wr_i2c_data_num 加 1；计数器 cnt_start 完成 10 次循环 计数，i2c_start 拉高 10 次，在接收到第 10 次有效的 i2c_end 信号后，表示连续 10 字节数 据写入完毕，将写使能信号 wr_en 拉低，写操作完毕。相关信号波形如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b26cbb5556b0e75db6eae9f5e4854b8d.png"></p>
<pre><code>    **第二部分** ：输出存储地址 byte_addr、写数据 wr_data 信号波形的设计与实现

    既然是对 EEPROM 中写数据操作，存储地址和写数据必不可少，在本从实验中，向 EEPROM 中 10 个连续存储存储单元写入 10 字节数据。对输出存储地址 byte_addr，赋值**初始存储地址** ，当 i2c_end 信号有效时，地址加 1，待 10 字节数据均写入完毕，再次赋值初始从从地址；对于写数据 wr_data 处理方式相同，先赋值写数据初值，当 i2c_end 信号有效时，写数据加1，待 10 字节数据均写入完毕，在此赋值写数据初值。两输出信号波形如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7aefb6d791d0e5b2ee40791a003868d2.png"></p>
<h5 id="【2】读数据操作部分"><a href="#【2】读数据操作部分" class="headerlink" title="【2】读数据操作部分"></a>【2】读数据操作部分</h5><pre><code>   延长该读使能触发信号的有效时间，使模块工作时钟 i2c_clk 可以采集到该触发信号。声明计数器 cnt_rd 和读有效信号 rd_valid 两信号，延长读触发信号 read 有效时间，使 i2c_clk 时钟能采集到该读触发信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/807dba7ae4cedc9edcfd57af4d0a16da.png"></p>
<pre><code>    对于读使能信号的处理方式也与写操作方式相同，工作时钟 i2c_clk 上升沿采集到有效 rd_valid 信号，拉高读使能信号 **rd_en** ，告知 I2C 驱动模块接下来要进行数据读操作。

    声明字节计数器 rd_i2c_data_num 对已读出字节进行计数；使用之前声明的计数器 **cnt_start** ，对相邻读/写操作**时间间隔进行计数** 。

    采集到读有效信号 rd_valid 为高电平，拉高 rd_en，计数器 cnt_wait、 rd_i2c_data_num 均由 0 开始计数，每一个工作时钟周期 cnt_wait 自加 1，计数到最大值 1499，i2c_start 保持一个工作时钟的高电平，同时 cnt_wait 归 0，重新开始计数；I2C 驱动模块接收到有效的 i2c_start 信号后，自 EEPROM 读出单字节数据，传回 i2c_end 信号，表 示一次单字节写操作完毕，计数器 rd_i2c_data_num 加 1；计数器 cnt_start 完成 10 次循环计 数，i2c_start 拉高 10 次，在接收到第 10 次有效的 i2c_end 信号后，表示连续 10 字节数据 写入完毕，将读使能信号 rd_en 拉低，读操作完毕。相关信号波形如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e2a77dfc171149e04c16efba72151793.png"></p>
<pre><code>    既然是数据读操作，自然有读出数据传入本模块，一次读操作连续读出 10 字节数据， 先将读取的 10 字节数据暂存到内部例化的 FIFO 中，以传回的 i2c_end 结束信号为写使能，在 i2c_clk 时钟同步下将读出数据写入 FIFO 中。同时我们将 FIFO 的数据计数器引出，方便后续数据发送阶段的操作。相关信号波形图如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/48ccb6e9de9b9a2775173b221db5bbf9.png"></p>
<pre><code>    对于存储地址信号 byte_addr 的讲解，读者参阅写操作部分相关介绍，此处不再赘述， 接下来开始数据发送部分各信号波形的讲解。

    等到读取的 10 字节均写入 FIFO 中，FIFO 数据计数器 data_num 显示为 10，表示 FIFO 中存有 10 字节读出数据。此时拉高 FIFO 读有效信号 fifo_rd_valid，只有信号 fifo_rd_valid 为有效高电平，对 FIFO 的读操作才有效；fifo_rd_valid 有效时，计数器 cnt_wait 开始循环计数，声明此计数器的目的是计数字节数据读出时间间隔，间隔越长，每字节数据在数码 管显示时间越长，方面现象观察；当计数器 cnt_wait 计数到最大值时，归 0 重新计数， FIFO 读使能信号信号 fifo_rd_en 拉高一个时钟周期，自 FIFO 读出一个字节数据，由 fifo_rd_data 将数据传出给数码管显示模块，读出字节计数器 rd_data_num 加 1；等到 10 字 节数据均读取并传出后，fifo_rd_valid 信号拉低，数据发送操作完成。相关信号波形如下。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a252e7dbc6797d1f315a8c7a7f10f427.png"></p>
<h5 id="【3】代码设计-1"><a href="#【3】代码设计-1" class="headerlink" title="【3】代码设计"></a>【3】代码设计</h5><pre><code>module  i2c_rw_data
(
    input   wire            sys_clk     ,   //输入系统时钟,频率50MHz
    input   wire            i2c_clk     ,   //输入i2c驱动时钟,频率1MHz
    input   wire            sys_rst_n   ,   //输入复位信号,低有效
    input   wire            write       ,   //输入写触发信号
    input   wire            read        ,   //输入读触发信号
    input   wire            i2c_end     ,   //一次i2c读/写结束信号
    input   wire    [7:0]   rd_data     ,   //输入自i2c设备读出的数据

    output  reg             wr_en       ,   //输出写使能信号
    output  reg             rd_en       ,   //输出读使能信号
    output  reg             i2c_start   ,   //输出i2c读/写触发信号
    output  reg     [15:0]  byte_addr   ,   //输出i2c设备读/写地址
    output  reg     [7:0]   wr_data     ,   //输出写入i2c设备的数据
    output  wire    [7:0]   fifo_rd_data    //输出自fifo中读出的数据
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
// parameter  define
parameter   DATA_NUM        =   8&#39;d10       ,   //读/写操作读出或写入的数据个数
            CNT_START_MAX   =   16&#39;d4000    ,   //cnt_start计数器计数最大值
            CNT_WR_RD_MAX   =   8&#39;d200      ,   //cnt_wr/cnt_rd计数器计数最大值
            CNT_WAIT_MAX    =   28&#39;d500_000 ;   //cnt_wait计数器计数最大值
// wire  define
wire    [7:0]   data_num    ;   //fifo中数据个数

// reg   define
reg     [7:0]   cnt_wr          ;   //写触发有效信号保持时间计数器
reg             write_valid     ;   //写触发有效信号
reg     [7:0]   cnt_rd          ;   //读触发有效信号保持时间计数器
reg             read_valid      ;   //读触发有效信号
reg     [15:0]  cnt_start       ;   //单字节数据读/写时间间隔计数
reg     [7:0]   wr_i2c_data_num ;   //写入i2c设备的数据个数
reg     [7:0]   rd_i2c_data_num ;   //读出i2c设备的数据个数
reg             fifo_rd_valid   ;   //fifo读有效信号
reg     [27:0]  cnt_wait        ;   //fifo读使能信号间时间间隔计数
reg             fifo_rd_en      ;   //fifo读使能信号
reg     [7:0]   rd_data_num     ;   //读出fifo数据个数

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//cnt_wr:写触发有效信号保持时间计数器,计数写触发有效信号保持时钟周期数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_wr    &lt;=  8&#39;d0;
    else    if(write_valid == 1&#39;b0)
        cnt_wr    &lt;=  8&#39;d0;
    else    if(write_valid == 1&#39;b1)
        cnt_wr    &lt;=  cnt_wr + 1&#39;b1;

//write_valid:写触发有效信号
//由于写触发信号保持时间为一个系统时钟周期(20ns),
//不能被i2c驱动时钟i2c_scl正确采集,延长写触发信号生成写触发有效信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        write_valid    &lt;=  1&#39;b0;
    else    if(cnt_wr == (CNT_WR_RD_MAX - 1&#39;b1))
        write_valid    &lt;=  1&#39;b0;
    else    if(write == 1&#39;b1)
        write_valid    &lt;=  1&#39;b1;

//cnt_rd:读触发有效信号保持时间计数器,计数读触发有效信号保持时钟周期数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_rd    &lt;=  8&#39;d0;
    else    if(read_valid == 1&#39;b0)
        cnt_rd    &lt;=  8&#39;d0;
    else    if(read_valid == 1&#39;b1)
        cnt_rd    &lt;=  cnt_rd + 1&#39;b1;

//read_valid:读触发有效信号
//由于读触发信号保持时间为一个系统时钟周期(20ns),
//不能被i2c驱动时钟i2c_scl正确采集,延长读触发信号生成读触发有效信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        read_valid    &lt;=  1&#39;b0;
    else    if(cnt_rd == (CNT_WR_RD_MAX - 1&#39;b1))
        read_valid    &lt;=  1&#39;b0;
    else    if(read == 1&#39;b1)
        read_valid    &lt;=  1&#39;b1;

//cnt_start:单字节数据读/写操作时间间隔计数
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_start   &lt;=  16&#39;d0;
    else    if((wr_en == 1&#39;b0) &amp;&amp; (rd_en == 1&#39;b0))
        cnt_start   &lt;=  16&#39;d0;
    else    if(cnt_start == (CNT_START_MAX - 1&#39;b1))
        cnt_start   &lt;=  16&#39;d0;
    else    if((wr_en == 1&#39;b1) || (rd_en == 1&#39;b1))
        cnt_start   &lt;=  cnt_start + 1&#39;b1;

//i2c_start:i2c读/写触发信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        i2c_start   &lt;=  1&#39;b0;
    else    if((cnt_start == (CNT_START_MAX - 1&#39;b1)))
        i2c_start   &lt;=  1&#39;b1;
    else
        i2c_start   &lt;=  1&#39;b0;

//wr_en:输出写使能信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wr_en   &lt;=  1&#39;b0;
    else    if((wr_i2c_data_num == DATA_NUM - 1) 
                &amp;&amp; (i2c_end == 1&#39;b1) &amp;&amp; (wr_en == 1&#39;b1))
        wr_en   &lt;=  1&#39;b0;
    else    if(write_valid == 1&#39;b1)
        wr_en   &lt;=  1&#39;b1;

//wr_i2c_data_num:写入i2c设备的数据个数
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wr_i2c_data_num &lt;=  8&#39;d0;
    else    if(wr_en == 1&#39;b0)
        wr_i2c_data_num &lt;=  8&#39;d0;
    else    if((wr_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))
        wr_i2c_data_num &lt;=  wr_i2c_data_num + 1&#39;b1;

//rd_en:输出读使能信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_en   &lt;=  1&#39;b0;
    else    if((rd_i2c_data_num == DATA_NUM - 1) 
                &amp;&amp; (i2c_end == 1&#39;b1) &amp;&amp; (rd_en == 1&#39;b1))
        rd_en   &lt;=  1&#39;b0;
    else    if(read_valid == 1&#39;b1)
        rd_en   &lt;=  1&#39;b1;

//rd_i2c_data_num:写入i2c设备的数据个数
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_i2c_data_num &lt;=  8&#39;d0;
    else    if(rd_en == 1&#39;b0)
        rd_i2c_data_num &lt;=  8&#39;d0;
    else    if((rd_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))
        rd_i2c_data_num &lt;=  rd_i2c_data_num + 1&#39;b1;

//byte_addr:输出读/写地址
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        byte_addr   &lt;=  16&#39;h00_5A;
    else    if((wr_en == 1&#39;b0) &amp;&amp; (rd_en == 1&#39;b0))
        byte_addr   &lt;=  16&#39;h00_5A;
    else    if(((wr_en == 1&#39;b1) || (rd_en == 1&#39;b1)) &amp;&amp; (i2c_end == 1&#39;b1))
        byte_addr   &lt;=  byte_addr + 1&#39;b1;

//wr_data:输出待写入i2c设备数据
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wr_data &lt;=  8&#39;h01;
    else    if(wr_en == 1&#39;b0)
        wr_data &lt;=  8&#39;h01;
    else    if((wr_en == 1&#39;b1) &amp;&amp; (i2c_end == 1&#39;b1))
        wr_data &lt;=  wr_data + 1&#39;b1;

//fifo_rd_valid:fifo读有效信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        fifo_rd_valid  &lt;=  1&#39;b0;
    else    if((rd_data_num == DATA_NUM)
                &amp;&amp; (cnt_wait == (CNT_WAIT_MAX - 1&#39;b1)))
        fifo_rd_valid  &lt;=  1&#39;b0;
    else    if(data_num == DATA_NUM)
        fifo_rd_valid  &lt;=  1&#39;b1;

//cnt_wait:fifo读使能信号间时间间隔计数,计数两fifo读使能间的时间间隔
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_wait    &lt;=  28&#39;d0;
    else    if(fifo_rd_valid == 1&#39;b0)
        cnt_wait    &lt;=  28&#39;d0;
    else    if(cnt_wait == (CNT_WAIT_MAX - 1&#39;b1))
        cnt_wait    &lt;=  28&#39;d0;
    else    if(fifo_rd_valid == 1&#39;b1)
        cnt_wait    &lt;=  cnt_wait + 1&#39;b1;

//fifo_rd_en:fifo读使能信号
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        fifo_rd_en &lt;=  1&#39;b0;
    else    if((cnt_wait == (CNT_WAIT_MAX - 1&#39;b1))
                &amp;&amp; (rd_data_num &lt; DATA_NUM))
        fifo_rd_en &lt;=  1&#39;b1;
    else
        fifo_rd_en &lt;=  1&#39;b0;

//rd_data_num:自fifo中读出数据个数计数
always@(posedge i2c_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_data_num &lt;=  8&#39;d0;
    else    if(fifo_rd_valid == 1&#39;b0)
        rd_data_num &lt;=  8&#39;d0;
    else    if(fifo_rd_en == 1&#39;b1)
        rd_data_num &lt;=  rd_data_num + 1&#39;b1;

//****************************************************************//
//************************* Instantiation ************************//
//****************************************************************//
//------------- fifo_read_inst -------------
fifo_read   fifo_read_inst
(
    .clk        (i2c_clk            ),  //输入时钟信号,频率1MHz,1bit
    .din        (rd_data            ),  //输入写入数据,1bit
    .rd_en      (fifo_rd_en         ),  //输入数据读请求,1bit
    .wr_en      (i2c_end &amp;&amp; rd_en   ),  //输入数据写请求,1bit

    .dout       (fifo_rd_data       ),  //输出读出数据,1bit
    .data_count (data_num           )   //输出fifo内数据个数,1bit
);

endmodule
</code></pre>
<h4 id="（4）仿真设计"><a href="#（4）仿真设计" class="headerlink" title="（4）仿真设计"></a>（4）仿真设计</h4><pre><code>module  tb_eeprom_byte_rd_wr();
//wire define
wire            scl ;
wire            sda ;
wire    [5:0]   sel ;
wire    [7:0]   seg ;

//reg define
reg           clk   ;
reg           rst_n ;
reg           key_wr;
reg           key_rd;

//时钟、复位信号
initial
  begin
    clk     =   1&#39;b1  ;
    rst_n   &lt;=  1&#39;b0  ;
    key_wr  &lt;=  1&#39;b1  ;
    key_rd  &lt;=  1&#39;b1  ;
    #200
    rst_n   &lt;=  1&#39;b1  ;
    #1000
    key_wr  &lt;=  1&#39;b0  ;
    key_rd  &lt;=  1&#39;b1  ;
    #400
    key_wr  &lt;=  1&#39;b1  ;
    key_rd  &lt;=  1&#39;b1  ;
    #20000000
    key_wr  &lt;=  1&#39;b1  ;
    key_rd  &lt;=  1&#39;b0  ;
    #400
    key_wr  &lt;=  1&#39;b1  ;
    key_rd  &lt;=  1&#39;b1  ;
    #40000000
    $stop;
  end

always  #10 clk = ~clk;

defparam eeprom_byte_rd_wr_inst.key_wr_inst.CNT_MAX = 5;
defparam eeprom_byte_rd_wr_inst.key_rd_inst.CNT_MAX = 5;
defparam eeprom_byte_rd_wr_inst.i2c_rw_data_inst.CNT_WAIT_MAX = 1000;

//-------------eeprom_byte_rd_wr_inst-------------
eeprom_byte_rd_wr   eeprom_byte_rd_wr_inst
(
    .sys_clk        (clk    ),    //输入工作时钟,频率50MHz
    .sys_rst_n      (rst_n  ),    //输入复位信号,低电平有效
    .key_wr         (key_wr ),    //按键写
    .key_rd         (key_rd ),    //按键读

    .sda            (sda    ),    //串行数据
    .scl            (scl    ),    //串行时钟
    .seg            (seg    ),    //数码管段选信号
    .sel            (sel    )     //数码管位选信号
);

//-------------eeprom_inst-------------
M24LC64  M24lc64_inst
(
    .A0     (1&#39;b0       ),  //器件地址
    .A1     (1&#39;b0       ),  //器件地址
    .A2     (1&#39;b0       ),  //器件地址
    .WP     (1&#39;b0       ),  //写保护信号,高电平有效
    .RESET  (~rst_n     ),  //复位信号,高电平有效

    .SDA    (sda        ),  //串行数据
    .SCL    (scl        )   //串行时钟
);

endmodule


    拓展训练：将串口 RS232 与 EEPROM 读写工程结合起来，使用 PC 机通过串口发送指令和和数据实现 EEPROM 数据读写操作。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132818565">https://blog.csdn.net/qq_32971095/article/details/132818565</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%8C%EF%BC%88IP%E6%A0%B8%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C3%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/11/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%BA%8C%EF%BC%88IP%E6%A0%B8%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C3%EF%BC%9E/" class="post-title-link" itemprop="url">基础设计二（IP核）——FPGA学习笔记＜3＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-11 21:42:56" itemprop="dateCreated datePublished" datetime="2023-09-11T21:42:56+08:00">2023-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8">一.IP核的使用</a></p>
<p><a href="about:blank#1.PLL%20IP%E6%A0%B8">1.PLL IP核</a></p>
<p><a href="about:blank#%3C1%3EPLL%E7%AE%80%E4%BB%8B">&lt;1&gt;PLL简介</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;2&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p>
<p><a href="about:blank#2.ROM%20IP%E6%A0%B8">2.ROM IP核</a></p>
<p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#%E2%91%B4%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6.coe%E6%96%87%E4%BB%B6">⑴创建初始化文件.coe文件</a></p>
<p><a href="about:blank#%E2%91%B5%E5%8D%95%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑵单端口 ROM<br>的配置</a></p>
<p><a href="about:blank#%E2%91%B6%E5%8F%8C%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑶双端口 ROM<br>的配置</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p>
<p><a href="about:blank#3.RAM%20IP%E6%A0%B8">3.RAM IP核</a></p>
<p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#%E2%91%B4%E5%8D%95%E7%AB%AF%E5%8F%A3%20ROM%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑴单端口 ROM<br>的配置</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;2&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#4.FIFO%20IP%E6%A0%B8">4.FIFO IP核</a></p>
<p><a href="about:blank#%E2%91%B4SCFIFO%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑴SCFIFO 的配置</a></p>
<p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p>
<p><a href="about:blank#%E2%91%B5DCFIFO%20%E7%9A%84%E9%85%8D%E7%BD%AE">⑵DCFIFO 的配置</a></p>
<p><a href="about:blank#%3C1%3Exilinx%20vivado%20IP%E6%A0%B8%E9%85%8D%E7%BD%AE">&lt;1&gt;xilinx vivado<br>IP核配置</a></p>
<p><a href="about:blank#%3C2%3Exilinx%20vivado%20IP%E6%A0%B8%E8%B0%83%E7%94%A8">&lt;2&gt;xilinx vivado<br>IP核调用</a></p>
<p><a href="about:blank#%E2%91%B6%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98">⑶注意问题</a></p>
<hr>
<p>前置学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="设计流程——FPGA学习笔记＜2＞">设计流程——FPGA学习笔记＜2＞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p>
<p>参考书目：《野火FPGA Verilog 开发实战指南》</p>
<h2 id="一-IP核的使用"><a href="#一-IP核的使用" class="headerlink" title="一.IP核的使用"></a>一.IP核的使用</h2><pre><code>    IP 核有三种不同的存在形式：HDL 语言形式，网表形式、版图形式。分别对应我们常说的三类 IP 内核：软核、固核和硬核。

    软核是用硬件描述语言的形式功能块的行为，并不涉及用什么电路和电路元件实现这 些行为，软 IP 通常是**以硬件描述语言 HDL 源文件** 的形式出现，应用开发过程与普通的 HDL 设计也十分相似，大多数应用于 FPGA 的 IP 内核均为软核，软核有助于用户调节参 数并增强可复用性。软核**通常以加密形式提供** ，这样实际的 RTL 对用户是不可见的，但布局和布线灵活。在这些加密的软核中，**如果对内核进行了参数化，那么用户就可通过头文件或图形用户接口（GUI）方便地对参数进行操作** 。软 IP 的设计周期短，设计投入少。由 于不涉及物理实现，为后续设计留有很大的发挥空间，增大了 IP 的灵活性和适应性。其主 要缺点是在一定程度上使后续工序无法适应整体设计，从而需要一定程度的软 IP 修正，在性能上也不可能获得全面的优化。由于软核是以源代码的形式提供，尽管源代码可以采用加密方法，但其知识产权保护问题不容忽视。

    固核则是软核和硬核的折衷。固核是完成了综合的功能块，有较大的设计深度，以网表的形式交给客户使用。对于那些对时序要求严格的内核（如 PCIE 接口内核），可预布线特定信号或分配特定的布线资源，以满足时序要求。这些内核可归类为固核，由于内核 是预先设计的代码模块，因此这有可能影响包含该内核的整体设计。由于内核的建立时 间、保持时间和握手信号都可能是固定的，因此其它电路的设计时都必须考虑与该内核进 行正确地接口。如果内核具有固定布局或部分固定的布局，那么这还将影响其它电路的布局。

    硬核是完成提供设计的最终阶段产品——掩膜（Mask），以经过完全的布局布线的网 表形式提供，这种硬核既具有可预见性，同时还可以针对特定工艺或购买商进行功耗和尺寸上的优化。尽管硬核由于缺乏灵活性而可移植性差，但由于无须提供寄存器转移级 （RTL）文件，因而更易于实现 IP 保护。比如一些 FPGA 芯片内置的 ARM 核就是硬核。
</code></pre>
<p>IP 核在拥有以上众多好处的同时也有他的巨大缺点：  </p>
<p> 1、在<strong>跨平台时，IP 核往往不通用</strong> ，需要重新设计。IP 核都是不全透明的，是每个 FPGA 开发厂商根据自己芯片适配的定制<br>IP，所以如果你之前用的 Altera 的芯片，用了一 个 PLL，但是因为某些原因需要将代码移植到 Xilinx 平台上，那就必须要将 PLL 给重新替<br>换掉，着增加了代码移植的复杂性。</p>
<p>2、IP 核就是个黑匣子，是<strong>不透明</strong> 的，我们往往看不到其核心代码。IP 核都是各大 FPGA 厂商专门设计的，都会进行<strong>加密</strong><br>，内核代码都看不到，如果你使用的这个 IP<br>核万一出现了问题或者需要知道其内部结构针对具体的应用进行定制优化时，你是无法进行修改的。以上两个问题就很棘手，所以<strong>有些公司坚持所有的可综合设计都不使用<br>IP 核，就是为了是所有的模块都能够掌控在在自己手里。</strong></p>
<p>3、有些定制的 IP 核由于是不通用的，往往会有较高的收费，这也是一笔巨大的开 销。所以 IP<br>核在能够加快我们开发周期的情况下也存在以上三种常见的问题，这就是需要 我们权衡利弊，针对具体的需求来做具体的选择。</p>
<p>IP 核生成工具提供的 IP 核主要有以下几类：</p>
<p>1、数学运算模块，包括累加器、乘加器、乘累加器、计数器、加&#x2F;减法器、实&#x2F;复数乘 法器、除法器、CORDIC 算法器、DSP48 宏和浮点数操作器。</p>
<p>2、存储器构造模块，包括块存储器和分布式存储器、先入先出存储器（FIFO）和移位寄存器。 3、DSP<br>功能，包括直接数字频率合成（DDS）编译器、数字上变频&#x2F;下变频 （DUC&#x2F;DDC）编译器、有限冲激响应（FIR）滤波器、级联积分梳状（CIC）滤波器、离<br>散傅里叶变换（DFT）和快速傅里叶变换（FFT）。</p>
<p>4、信道纠错码，包括 RS 码编码器和译码器、卷积码编码器、Viterbi 译码器、Turbo 码编&#x2F;译码器和低密度奇偶校验码（LDPC）编码器等。</p>
<p>5、网络应用，包括媒体访问控制器（MAC）、以太网物理编码子层&#x2F;物理介质连接<br>（PCS&#x2F;PMA）、网络负载统计、以太网拓展连接单元接口（XAUI）、减少引脚使用的 XAUI（RXAUI）、MAC 封装包和音&#x2F;视频桥接（AVB）端点。</p>
<p>6、FPGA 结构属性，包括时钟向导、高速串行收发器（GTX&#x2F;GTP）和系统监视向导。</p>
<p>7、连接器，包括标准总线接口（如 PCI&#x2F;PCI-X、PCI Express、CAN）和数据接口（如 以太网、RapidIO 等）。</p>
<p>8、调试和验证，包括逻辑调试内核（集成控制器核（ICON）、集成逻辑分析核 （ILA）、虚拟输入&#x2F;输出核（VIO）、Agilent<br>跟踪核（ATC2）、误比特率测试核 （IBERT）和集成总线分析核（IBA）。</p>
<p>9、针对不同设计方法的特殊IP核，包括用工程导航工具进行逻辑设计的IP核、用<br>Xilinx系统生成工具进行DSP算法设计的IP核，以及用Xilinx平台开发环境（XPS）或 PlanAhead进行嵌入式设计的IP核。</p>
<h3 id="1-PLL-IP核"><a href="#1-PLL-IP核" class="headerlink" title="1.PLL IP核"></a>1.PLL IP核</h3><h4 id="PLL简介"><a href="#PLL简介" class="headerlink" title="&lt;1&gt;PLL简介"></a>&lt;1&gt;PLL简介</h4><pre><code>    PLL（Phase Locked Loop，即锁相环）是最常用的 IP 核之一，其性能强大，可以对输入到 FPGA 的时钟信号进行任意**分频、倍频、相位调整、占空比调整** ，从而输出一个期望时钟，实际上，即使不想改变输入到 FPGA 时钟的任何参数，也常常会使用 PLL，因为经 过 PLL 后的时钟在抖动（Jitter）方面的性能更好一些。Xilinx 中的 PLL 是模拟锁相环，和数字锁相环不同的是**模拟锁相环** 的优点是**输出的稳定度高、相位连续可调、延时连续可调** ；缺点是当**温度过高或者电磁辐射过强时会失锁** （普通环境下不考虑该问题）。
</code></pre>
<p><strong>工作原理</strong> ：</p>
<pre><code>    1、首先需要参考时钟（ref_clk）通过**鉴频（FD）鉴相器（PD）** 和需要比较的时钟频率进行比较，我们以频率调整为例，如果参考时钟频率等于需要比较的时钟频率则鉴频鉴相器输出为 0，如果参考时钟频率大于需要比较的时钟频率则鉴频鉴相器输出一个变大的成正比的值，如果参考时钟频率小于需要比较的时钟频率则鉴频鉴相器输出一个变小的正比的值。

    2、鉴频鉴相器的输出连接到** _环路_ 滤波器（LF）**上，用于控制噪声的带宽，**滤掉高频噪声** ，使之稳定在一个值，起到将带有噪声的波形变平滑的作用。如果鉴频鉴相器之前的波形抖动比较大，经过环路滤波器后抖动就会变小，**趋近于信号的平均值** 。

    3、经过环路滤波器的输出连接到** _压控_ 振荡器（VCO）**上，环路滤波器输出的电压可以控制 VCO 输出频率的大小，环路滤波器输出的电压越大 VCO 输出的频率越高，然后将这个频率信号连接到鉴频鉴相器作为需要比较的频率。 如果 ref_clk 参考时钟输入的频率和需要比较的时钟频率不相等，该系统最终实现的就是让它们**逐渐相等并稳定下来** 。如果 ref_clk 参考时钟的频率是 50MHz，经过整个闭环反馈系统后，锁相环对外输出的时钟频率 pll_out 也是 50MHz。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/274a1b99ce88f7fabcba88e6ee3f1a26.png"></p>
<pre><code>    **倍频实现** ：倍频是在 **VCO 后直接加一级分频器** ，我们知道 ref_clk 参考时钟输入的频率和需要比较的时钟频率经过闭环反馈系统后最终会保持频率相等，而在需要比较的时钟之前加入分频器，就会使进入分频器之前的信号频率为需要比较的时钟频率的倍数，VCO 后输出的 pll_out 信号频率就是 ref_clk 参考时钟倍频后的结果。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a0b93e3ee21781dd2ef71e93e013b7f.png"></p>
<pre><code>    **分频实现** ：分频是在 **ref_clk 参考时钟后加一级分频器** ，这样需要比较的时钟频率就始终和 ref_clk 参考时钟分频后的频率相等，在 VCO 后输 出的 pll_out 信号就是 ref_clk 参考时钟分频后的结果。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f036569d6714c19ca076417fac7171cc.png"></p>
<h4 id="xilinx-vivado-IP核配置"><a href="#xilinx-vivado-IP核配置" class="headerlink" title="&lt;2&gt;xilinx vivado IP核配置"></a>&lt;2&gt;xilinx vivado IP核配置</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a60f7c9a83f3e41601ca6bafa50a4d7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d786b3bd2e5b1c4223912ded98e6dd3f.png"></p>
<p>②框选项区别在于左上Resoursce栏使用资源的不同</p>
<p>Clocking Features选择功能，左上Switch To Defaults恢复默认</p>
<p>Documentation可打开官方手册</p>
<p>IP Location选择核存放位置</p>
<p>接下来配置输出：这里输出四路信号，注意各个参数（<strong>期望和实际输出、相位&#x2F;占空比调整</strong> ）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cc03fe6e0a562e0631c4fdd0bb30ec9a.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9bca276789b7c6f78709a555880eb0dd.png"></p>
<p>生成之后可以在工程中看到我们生成的 IP 核，双击 IP 核可进入配置界面，对 IP 核的相关参数进行更改。</p>
<h4 id="xilinx-vivado-IP核调用"><a href="#xilinx-vivado-IP核调用" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h4><p> （拷贝调用： 要求同版本开发IDE。直接复制IP核文件夹，位置在source里的ip文件夹）新工程添加设计文件，点击后缀为xci的文件。</p>
<p>通过实例化对IP核进行调用，可从多个文件中选择复制。如下是一种办法：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/074776a8f290ace02f39615b2d040dc6.png"></p>
<p>或者找到IP核下的.veo文件，其中也包含实例化模版</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9136cc140a3a9a316d989e8dfca6e10b.png"></p>
<p>再编写一个顶层设计文件来例化这个 PLL IP 核：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1824668d82cca9e65be6ebe3bf79987d.png"></p>
<p>仿真：</p>
<pre><code>`timescale  1ns/1ns

module tb_pll();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg     sys_clk     ;
//wire  define
wire    clk_mul_2   ;
wire    clk_div_2   ;
wire    clk_phase_90;
wire    clk_ducle_20;
wire    locked      ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//初始化系统时钟
initial sys_clk = 1&#39;b1;


//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz
always #10 sys_clk = ~sys_clk;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//------------------------pll_inst------------------------
pll pll_inst
(
    .sys_clk        (sys_clk        ),  //input     sys_clk

    .clk_mul_2      (clk_mul_2      ),  //output    clk_mul_2
    .clk_div_2      (clk_div_2      ),  //output    clk_div_2
    .clk_phase_90   (clk_phase_90   ),  //output    clk_phase_90
    .clk_ducle_20   (clk_ducle_20   ),  //output    clk_ducle_20
    .locked         (locked         )   //output    locked
);

endmodule
</code></pre>
<h3 id="2-ROM-IP核"><a href="#2-ROM-IP核" class="headerlink" title="2.ROM IP核"></a>2.ROM IP核</h3><pre><code>    ROM 是**只读存储器（Read-Only Memory）** 的简称，是一种只能读出事先所存数据的固态半导体存储器。 其特性是一旦储存资料就无法再将之改变或删除，**且资料不会因为电源关闭而消失** 。而事实上在 FPGA 中通过 IP 核生成的 ROM 或 RAM（RAM 将在下一节为大家讲解）调用的**都是 FPGA 内部的 RAM 资源** ，**掉电内容都会丢失** （这也很容易解释，FPGA 芯片内部本来 就没有掉电非易失存储器单元）。用 IP 核生成的 ROM 模块只是**提前添加了数据文件 （.coe 格式）** （Quartus II中是mif/nex文件），**在 FPGA 运行时通过数据文件给 ROM 模块初始化** ，才使得 ROM 模块像个 “真正”的掉电非易失存储器；也正是这个原因，ROM 模块的内容必须提前在数据文件中 写死，无法在电路中修改。         Xilinx 推出的 ROM IP 核分为两种类型：**单端口 ROM（Single-Port Rom）和双端口 ROM（Dual-Port ROM）** 。对于单端口 ROM 提供一个读地址端口和一个读数据端口，只能进行读操作；双端口 ROM 与单端口 ROM 类似，区别是其提供两个读地址端口和两个读数 据端口，基本上**可以看做两个单口 ROM 拼接而成** 。下面是 ROM 不同配置模式存储器的接口信号图
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ec5a640e49917f4840c4ca3c15742b60.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/39d6daa7b05762402544c85107019209.png"></p>
<h4 id="xilinx-vivado-IP核配置-1"><a href="#xilinx-vivado-IP核配置-1" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h4><h5 id="⑴创建初始化文件-coe文件"><a href="#⑴创建初始化文件-coe文件" class="headerlink" title="⑴创建初始化文件.coe文件"></a>⑴创建初始化文件.coe文件</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ccd8980974bd3fa8b4fdce24cd3f8fe8.png"><br>        该文件的格式较为简单，第一行是定义数据的格式，其中 16 表示 数据格式为 16 进制，也可将数据格式定义为二进制和八进制，只需将 16 改为 2 或 8 即 可。其中第 3 到第 18 行是 16*8bit 大小 ROM 的初始化数据。</p>
<h5 id="⑵单端口-ROM-的配置"><a href="#⑵单端口-ROM-的配置" class="headerlink" title="⑵单端口 ROM 的配置"></a>⑵单端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8085df36a1e00f03bf8ec852afc0f5e2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2e78260a857973e7e77d95b658b3b5d8.png"></p>
<pre><code>    给该 IP 核取名为rom_256x8（rom 是我们调用的 IP 核，**256 是调用的 IP 核容量，8 是调用的 IP 核数据位宽** 。这里这样命名是为了方便识别我们创建的 IP 核类型及资源量）。

    3 框中选择存储器类型，可供选择的类型有：Single Port RAM（单端口 RAM）、 Simple Dual Port RAM（简单双口 RAM）、True Dual Port RAM（真双口 RAM）、Singl Port ROM（单端口 ROM）、Doul Port ROM（双端口 ROM）。这里我们选择“Single Port Rom”单端口 ROM。

    4 框在 Algorithm 一栏中可选择用于实现内存的算法，其中 Minimum Area 为最小面积 算法；Low Power 为低功耗算法；Fixed Primitives 为固定单元算法。这里我们按默认选择 Minimum Area 即可。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/790b6532330c243f14b65c359514812d.png"></p>
<pre><code>    1 框中是设置存储数据的位宽，这里我们设置为 8 位；

    2 框中是设置数据深度，所谓深度其实就是个数的选择，即设置的 ROM 可以存储多 少个 8 位宽的数据，这里我们设置为 256；这样我们设置的 ROM 和最大能存储的数据即为 256 x 8bit。（注意：设置的容量需大于我们需要写入的数据文件的数据量）

    3 框中选择是否创建端口使能信号，这里我们不创建，选择“Always Enabled”始终 使能。

    4 框是选择是否创建输出端口寄存器，** _若创建了择输出数据则会延后一个时钟输出_** ， 这里我们不创建。

    5 框是选择是否生产复位信号，这里我们不创建。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/14d99e61cee29c3ecc71c15ca55c8275.png"></p>
<p>添加初始化coe文件</p>
<h5 id="⑶双端口-ROM-的配置"><a href="#⑶双端口-ROM-的配置" class="headerlink" title="⑶双端口 ROM 的配置"></a>⑶双端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7538ac4b37f9a0e1ab940d76c1c9a54.png"></p>
<pre><code>    对端口 A 的设置跟单端口 ROM 的设置一样即可。对端口 B 的设置，这里我们只需对 B 端口的数据位宽设置即可，数据深度会根据端口 A 的位宽自动设置。例如我们端口 A 设置的数据位宽为 8bit，深度为 256；而我们 B 端 口设置的数据位宽为 16bit，则其深度即为 128，其数据总量是一样的。其余设置与端口 A 设置一样即可。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/59a531959f333f68e956985587bcc348.png"></p>
<p>剩余操作与单端口 ROM 相同</p>
<h5 id="xilinx-vivado-IP核调用-1"><a href="#xilinx-vivado-IP核调用-1" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>`timescale  1ns/1ns

module  rom
(
    input   wire            sys_clk ,   //系统时钟，频率50MHz
    input   wire    [7:0]   addra   ,   //输入rom地址

    output  wire    [7:0]   douta       //输出rom数据

);

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//----------------rom_256x8_inst---------------
rom_256x8 rom_256x8_inst
(
    .clka   (sys_clk    ), // input clka
    .addra  (addra      ), // input  [7 : 0] addra
    .douta  (douta      )  // output [7 : 0] douta
);

endmodule
</code></pre>
<p>仿真：</p>
<pre><code>`timescale  1ns/1ns

module  tb_rom();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg         sys_clk     ;
reg         sys_rst_n   ;
reg [7:0]   addra       ;

//wire  define
wire    [7:0]   douta   ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//对sys_clk,sys_rst赋初值，并模拟按键抖动
initial
    begin
            sys_clk     =   1&#39;b1 ;
            sys_rst_n   &lt;=  1&#39;b0 ;
    #200    sys_rst_n   &lt;=  1&#39;b1 ;
    end
    
//sys_clk:模拟系统时钟，每10ns电平取反一次，周期为20ns，频率为50Mhz
always  #10 sys_clk =   ~sys_clk;

//让地址从0~255循环
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        addra   &lt;=  8&#39;d0;
    else    if(addra == 8&#39;d255)
        addra   &lt;=  8&#39;d0;
    else
        addra   &lt;=  addra   +   1&#39;b1;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//---------------rom_inst--------------
rom rom_inst
(
    .sys_clk     (sys_clk   ),   //系统时钟，频率50MHz
    .addra       (addra     ),   //输入rom地址

    .douta       (douta     )    //输出rom数据

);

endmodule
</code></pre>
<p>通过reg变量进行手动赋值仿真，wire变量引出输出结果</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc49853964c20fc15b53b0176631ac29.png"></p>
<h3 id="3-RAM-IP核"><a href="#3-RAM-IP核" class="headerlink" title="3.RAM IP核"></a>3.RAM IP核</h3><pre><code>    RAM 是**随机 存取存储器（Random Access Memory）**的简称，是一个易失性存储器。 RAM 工作时可以**随时从任何一个指定的地址写入或读出数据** ，同时我们还能修改其存储的数据，即写入新的数据，这是 ROM 所并不具备的功能。在 FPGA 中这也是其与 ROM 的最大区别。**ROM 是只读存储器，而 RAM 是可写可读存储器** ，在我们 FPGA 中使用这两个存储器主要也是要区分这一点，因为这**两个存储器使用的都是我们 FPGA 内部的 RAM 资源，不同的是 ROM 是只用到了 RAM 资源的读数据端口** 。 Xilinx 推出的 RAM IP 核分为两种类型：单端口 RAM 和双端口 RAM。其中双端口 RAM 又分为简单双端口 RAM 和真正双端口 RAM。对于单端口 RAM， _**读写操作共用一组地址线，读写操作不能同时进行；对于简单双端口 RAM，读操作和写操作有专用地址端口 （一个读端口和一个写端口），即写端口只能写不能读，而读端口只能读不能写；对于真正双端口 RAM，有两个地址端口用于读写操作（两个读/写端口），即两个端口都可以进行读写。**_
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c138921d867b29ade86307accec8a2bd.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7676d6bbc9ea22f2b9315547c234d66.png"></p>
<h5 id="xilinx-vivado-IP核配置-2"><a href="#xilinx-vivado-IP核配置-2" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h5><h5 id="⑴单端口-ROM-的配置"><a href="#⑴单端口-ROM-的配置" class="headerlink" title="⑴单端口 ROM 的配置"></a>⑴单端口 ROM 的配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b07438a39423a20b261db7f1f923058.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9aede4ded03495c40d4069e1d2d36603.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/28198190f61b0884d06f953d2688a724.png"></p>
<pre><code>    2 框中是操作模式的选择。RAM 读写操作模式共分为三种，非别是 Write First（写优 先模式）、Read First（读优先模式）和 No Change（不变模式）。

    Write First（写优先模式）：若我们在在同一个时钟沿下对同一个地址进行读写，则**读出的数据为写入的数据** 。

    Read First（读优先模式）：若我们在在同一个时钟沿下对同一个地址进行读写，则**读出的数据为该地址写入数据前存储的数据** 。

    No Change（不变模式）：在该模式下**不能同时进行读写操作** ，输出数据为同时读写操作前输出的数据。 

    加载数据文件时，同 ROM 一样，RAM 也可以加载初始 化文件，但是 RAM 是可以写入数据的，所以这里可以选择不加，该页面按默认设置即可。
</code></pre>
<p>注：（真）双端口 ROM 的配置类似</p>
<h4 id="xilinx-vivado-IP核配置-3"><a href="#xilinx-vivado-IP核配置-3" class="headerlink" title="&lt;2&gt;xilinx vivado IP核配置"></a>&lt;2&gt;xilinx vivado IP核配置</h4><pre><code>    RTL 顶层的输入信号有：50MHz 的系统时钟 sys_clk、输入 256 个 8bit 地址 addra（值 为十进制 0~256）、输入 256 个 8bit 的数据 dina（值为十进制 0~255）和伴随该输入数据的 写使能信号 wea。这些输入信号需要在 Testbench 中产生激励。

    RTL 顶层的输出信号有：从 RAM 中读取的数据 douta。
</code></pre>
<p>RTL 顶层代码如下所示：</p>
<pre><code>`timescale  1ns/1ns

module  ram
(
    input   wire            sys_clk     ,   //系统时钟，频率50MHz
    input   wire    [7:0]   addra       ,   //输入ram读写地址
    input   wire    [7:0]   dina        ,   //输入ram写入数据
    input   wire            wea         ,   //输入ram写使能
    
    output  wire    [7:0]   douta           //输出读ram数据

);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//---------------ram_256x8_inst--------------
ram_256x8   ram_256x8_inst 
(
    .clka       (sys_clk    ),  //使用系统时钟作为读写时钟
    .addra      (addra      ),  //读写地址线
    .dina       (dina       ),  //输入写入RAM的数据
    .wea        (wea        ),  //写RAM使能
    .douta      (douta      )   //输出读RAM数据
);

endmodule
</code></pre>
<p>仿真代码：</p>
<pre><code>`timescale  1ns/1ns

module  tb_ram();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg         sys_clk     ;
reg         sys_rst_n   ;
reg [7:0]   addra       ;
reg         wea         ;
reg         wr_flag     ;

//wire  define
wire    [7:0]   dina    ;
wire    [7:0]   douta   ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//对sys_clk,sys_rst赋初值，并模拟按键抖动
initial
    begin
            sys_clk     =   1&#39;b1 ;
            sys_rst_n   &lt;=  1&#39;b0 ;
    #200    sys_rst_n   &lt;=  1&#39;b1 ;
    end
    
//sys_clk:模拟系统时钟，每10ns电平取反一次，周期为20ns，频率为50Mhz
always  #10 sys_clk =   ~sys_clk;

//写完成标志信号
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wr_flag &lt;=  1&#39;b0;
    else    if(addra == 8&#39;d255)
        wr_flag &lt;=  1&#39;b1;
    else
        wr_flag &lt;=  wr_flag;

//wea:产生写RAM使能信号
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        wea   &lt;=  1&#39;b0;
    else    if(wr_flag == 1&#39;b1)
        wea  &lt;=  1&#39;b0;
    else
        wea  &lt;=  1&#39;b1;

//addra：读写地址（0~255循环）
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        addra    &lt;=  8&#39;d0;
    else    if(addra == 8&#39;d255)
        addra    &lt;=  8&#39;d0;
    else
        addra    &lt;=  addra + 1&#39;b1;

//写使能为高时产生写数据0~255
assign  dina =   (wea == 1&#39;b1) ? addra : 8&#39;d0;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//---------------ram_inst--------------
ram ram_inst
(
    .sys_clk    (sys_clk    ),   //系统时钟，频率50MHz
    .addra      (addra      ),   //输入ram读写地址
    .dina       (dina       ),   //输入ram写入数据
    .wea        (wea        ),   //输入ram写使能
    
    .douta      (douta      )    //输出读ram数据

);

endmodule 


    这里我们截取了前面我们讲到的 Write First 模式以及 No Change 模式下的仿真波形图；**从 Write First 模式仿真图看一看到，当我们往 RAM 里写数据时，就有数据读出了；而从 No Change 模式下的波形图可以看到，当我们往 RAM 里写数据时，是不同同时进行数据读取的，读数据端口会输出读写操作前的输出数据，这里为 0。**
</code></pre>
<h3 id="4-FIFO-IP核"><a href="#4-FIFO-IP核" class="headerlink" title="4.FIFO IP核"></a>4.FIFO IP核</h3><pre><code>    FIFO（First In First Out，即先入先出），是一种**数据缓冲器** ，用来实现数据先入先出的读写方式。与 ROM 或 RAM 的按地址读写方式不同，FIFO 的读写遵循“先进先出”的原则，即数据按顺序写入 FIFO，先被写入的数据同样在读取的时候先被读出，所以 **FIFO 存储器没有地址线** 。FIFO 有**一个写端口和一个读端口** 外部无需使用者控制地址，使用方便。 FIFO 存储器主要是作为缓存，应用在同步时钟系统和异步时钟系统中，在很多的设计中都会使用，后面实例中如： _多比特数据做跨时钟域的转换、前后带宽不同步等都用到了 FIFO_ 。FIFO 根据读写时钟是否相同，分为**SCFIFO（同步 FIFO）和 DCFIFO（异步 FIFO）** ，SCFIFO 的读写为同一时钟，应用在同步时钟系统中；DCFIFO 的读写时钟不同，应用在异步时钟系统中。
</code></pre>
<p>可参考：<a target="_blank" rel="noopener" href="https://reborn.blog.csdn.net/article/details/108553930" title="FPGA设计心得（11）关于FIFO IP核使用的一点注意事项">FPGA设计心得（11）关于FIFO<br>IP核使用的一点注意事项</a></p>
<h4 id="⑴SCFIFO-的配置"><a href="#⑴SCFIFO-的配置" class="headerlink" title="⑴SCFIFO 的配置"></a><strong>⑴SCFIFO 的配置</strong></h4><h5 id="xilinx-vivado-IP核配置-4"><a href="#xilinx-vivado-IP核配置-4" class="headerlink" title="&lt;1&gt;xilinx vivado IP核配置"></a>&lt;1&gt;xilinx vivado IP核配置</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c106fa7567b9a84b4d3cb8480483a57a.png">​</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a853439259bb2a5f665df76c626314e1.png">​</p>
<pre><code>    3 框是选中 FIFO 的类型，以及使用什么资源来实现。这里我们选择“Common Clock Block RAM”使用块 RAM 来实现同步 FIFO；其中 Common Clock 表示是同步 FIFO， Block RAM 表示的是块 RAM 资源。可以从界面中的表格查看各类型区别
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1bcb36c171301bf55732cb8a0fd259a7.png">​</p>
<pre><code>    1 框中是对模式的选择，这里我们选择标准 FIFO（Standard FIF0）即可。

    若3框下选项选择异步复位（Asynchronous Reset），还会多出安全电路使能选项

    若3框上选项选中输出端口寄存器，可选择相应寄存器
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2678aece1ef8c870530c111406c36f6d.png">​</p>
<pre><code>    1 框中可勾选生成 FIFO 几乎满（Almost Full Flag），几乎空（Almost Empty Flag）输 出信号；也就是说若勾选了这两个信号，当 FIFO 存储数据快满或者快空的时候，该信号 就有效。这里大家可根据自己的实际需求进行勾选，这里我们选择都不勾选。

    2 框中可勾选生成写确认标志信号，用于报告写操作成功。若勾选后可以配置为高电 平有效或低电平有效，这里我们选择不勾选。

    3 框中可勾选生成溢出标志信号；该标志信号可以指示 FIFO 内存储数据是否溢出， 可以指示上一次写操作何时失败。若勾选后可以配置为高电平有效或低电平有效，这里我 们选择不勾选。

    4 框中可勾选生成指示输出总线上数据何时有效的有效标志信号。若勾选后可以配置 为高电平有效或低电平有，这里我们选择不勾选。

    5 框中可勾选生成下溢标志信号；该标志信号可以指示 FIFO 内存储数据空了，可以 指示上一次的读请求何时失败。若勾选后可以配置为高电平有效或低电平有效，这里我们 选择不勾选。 这些选项可以根据自己的设计需求进行勾选，这里我们按默认都不勾选，直接切换到 “Data Counts”页面。
</code></pre>
<h5 id="xilinx-vivado-IP核调用-2"><a href="#xilinx-vivado-IP核调用-2" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>    RTL 代码顶层的输入信号有：50MHz 的系统时钟 sys_clk、输入 256 个 8bit 的数据 pi_data（值为十进制 0~255）和伴随该输入数据有效的标志信号 pi_flag、FIFO 的写请求信 号 rd_en。这些输入信号需要在 Testbench 中产生激励。

    RTL 代码顶层的输出信号有：从 FIFO 中读取的数据 po_data、FIFO 空标志信号 empty、FIFO 满标志信号 full、指示 FIFO 中存在数据个数的信号 data_count。这些信号也是我们需要通过仿真 SCFIFO IP 核主要观察的信号，这些信号通过 Testbench 中给输入信号激励后产生输出。


`timescale  1ns/1ns

module fifo
(
    input   wire            sys_clk     ,   //系统时钟50Mhz
    input   wire            sys_rst_n   ,   //复位信号
    input   wire    [7:0]   pi_data     ,   //输入顶层模块的数据
                                            //要写入到FIFO中的数据
    input   wire            pi_flag     ,   //输入数据有效标志信号
                                            //也作为FIFO的写请求信号
    input   wire            rd_en       ,   //FIFO读请求信号

    output  wire    [7:0]   po_data     ,   //FIFO读出的数据
    output  wire            empty       ,   //FIFO空标志信号，高有效
    output  wire            full        ,   //FIFO满标志信号，高有效
    output  wire    [7:0]   data_count      //FIFO中存在的数据个数
);

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

scfifo_256x8 scfifo_256x8_inst
(
    .clk       (sys_clk   ),    // input clk
    .srst      (~sys_rst_n),    // input srst
    .din       (pi_data   ),    // input [7 : 0] din
    .wr_en     (pi_flag   ),    // input wr_en
    .rd_en     (rd_en     ),    // input rd_en

    .dout      (po_data   ),    // output [7 : 0] dout
    .full      (full      ),    // output full
    .empty     (empty     ),    // output empty
    .data_count(data_count)     // output [7 : 0] data_count
    
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/803786cc93ca0a0583f559f08f092a06.png"></p>
<p>仿真：</p>
<pre><code>    下面是 Testbench 仿真测试文件，和 SCFIFO 的仿真一样，我们也需要给输入信号测试激励，pi_flag 每 4 个时钟周期且没有读请求时产生一个数据有效标志信号也作为 FIFO 的写请求信号，因为需要 pi_data 伴随着 pi_flag 一起产生，所以每当 pi_data 检测到 pi_flag 标 志信号有效时就自加 1，其值从 0~255 循环变化，这样我们就可以在 pi_flag 标志信号有效时将 pi_data 写入到 FIFO 中。而 FIFO 的读请求信号 rd_en 当 FIFO 的满标志信号 full 有效时拉高，当 FIFO 的空标志信号 empty 有效时拉低。


`timescale  1ns/1ns

module tb_fifo();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg         sys_clk     ;
reg [7:0]   pi_data     ;
reg         pi_flag     ;
reg         rd_en       ;
reg         sys_rst_n   ;
reg [1:0]   cnt_baud    ;

//wire  define
wire    [7:0]   po_data     ;
wire            empty       ;
wire            full        ;
wire    [7:0]   data_count  ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//初始化系统时钟、复位
initial begin
    sys_clk    = 1&#39;b1;
    sys_rst_n &lt;= 1&#39;b0;
    #200;
    sys_rst_n &lt;= 1&#39;b1;
end

//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz
always #10 sys_clk = ~sys_clk;

//cnt_baud:计数从0到3的计数器，用于产生输入数据间的间隔
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_baud &lt;= 2&#39;b0;
    else    if(&amp;cnt_baud == 1&#39;b1)
        cnt_baud &lt;= 2&#39;b0;
    else
        cnt_baud &lt;= cnt_baud + 1&#39;b1;

//pi_flag:输入数据有效标志信号，也作为FIFO的写请求信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_flag &lt;= 1&#39;b0;
    //每4个时钟周期且没有读请求时产生一个数据有效标志信号
    else    if((cnt_baud == 2&#39;d0) &amp;&amp; (rd_en == 1&#39;b0))
        pi_flag &lt;= 1&#39;b1;
    else
        pi_flag &lt;= 1&#39;b0;

//pi_data:输入顶层模块的数据，要写入到FIFO中的数据
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_data &lt;= 8&#39;b0;
    //pi_data的值为0~255依次循环
    else    if((pi_data == 8&#39;d255) &amp;&amp; (pi_flag == 1&#39;b1))
        pi_data &lt;= 8&#39;b0;
    else    if(pi_flag  == 1&#39;b1)    //每当pi_flag有效时产生一个数据
        pi_data &lt;= pi_data + 1&#39;b1;

//rd_en:FIFO读请求信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_en &lt;= 1&#39;b0;
    else    if(full == 1&#39;b1)  //当FIFO中的数据存满时，开始读取FIFO中的数据
        rd_en &lt;= 1&#39;b1;
    else    if(empty == 1&#39;b1) //当FIFO中的数据被读空时停止读取FIFO中的数据
        rd_en &lt;= 1&#39;b0;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//------------------------fifo_inst------------------------
fifo fifo_inst
(
    .sys_clk    (sys_clk    ),  //input             sys_clk
    .sys_rst_n  (sys_rst_n  ),  //input             sys_rst_n
    .pi_data    (pi_data    ),  //input     [7:0]   pi_data
    .pi_flag    (pi_flag    ),  //input             pi_flag
    .rd_en      (rd_en      ),  //input             rd_en

    .po_data    (po_data    ),  //output    [7:0]   po_data
    .full       (full       ),  //output            full
    .empty      (empty      ),  //output            empty
    .data_count (data_count )   //output    [7:0]   data_count
);

endmodule


    可以看到 pi_data 和 po_data 交替出现并一直循环下去，pi_flag 数据有效标志信号伴随着 pi_data 一一对应，po_data 在读请求信号 rd_en 为高时输出。其中 我们也可以看到 empty 和 full 在不同的位置均有拉高的脉冲，接下来我们将图中位置 1 和 位置 2 分别放大观察。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/00d7409a0130be8cc12feeb8788375d2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eca70840bd1db754c3bc3d701b1818ad.png"></p>
<p>如图所示为位置 1 放大后的波形，有几个点需要我们重点观察：</p>
<pre><code>    1、full、data_count 信号的状态：我们可以看到当 pi_flag 为高且 pi_data 为 255 的同时 full 满标志信号拉高了，说明 FIFO 的存储空间已经满了，而 data_count 信号也从 255 变成 了 0，因为产生的 SCFIFO IP 核中 data_count 的位宽是 8bit 的，**而十进制 256 需要 9bit 才能 完全显示，这样最高位就无法显示出来，所以 data_count 的值显示为** 0。

    2、FIFO 读出的数据与 FIFO 读请求的关系：因为我们这里是对普通同步 FIFO 模式进行的仿真，所以可以看到当检测到 full 满标志信号有效，rd_en 读请求信号开始拉高，FIFO 开始读数据，FIFO 读出的第一个数据为 0，可以看到数据为 0 的时间有两个时钟周期，**所以第一个 0 为潜伏期导致的，第二个 0 才是我们真正读出来的数据** ，FIFO 中随着数据的读 出，FIFO 中的数据减少，full 满标志信号也拉低了，data_count 信号的值也随着减小。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f14c8432a6eb9fd004287a706d316a2.png"><br>如图所示为位置 2 放大后的波形，这里我们重点观察一下 empty 空标志信号。 因为我们使用的是标准<br>fifo，所以读出的数据要比读使能延后一拍，所以当读出十进制数 据 254 后 empty 空标志信号拉高，表示 FIFO 中的数据已经被读空。</p>
<h4 id="⑵DCFIFO-的配置"><a href="#⑵DCFIFO-的配置" class="headerlink" title="⑵DCFIFO 的配置"></a><strong>⑵DCFIFO 的配置</strong></h4><h5 id="1-xilinx-vivado-IP核配置"><a href="#1-xilinx-vivado-IP核配置" class="headerlink" title="**&lt; 1&gt;**xilinx vivado IP核配置"></a>**&lt; 1&gt;**xilinx vivado IP核配置</h5><p>与SCFIFO配置不同：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0fea968cb4005828177c4488c948c9c.png"></p>
<pre><code>    2 框中是选中 FIFO 的类型，以及使用什么资源来实现。这里我们选择“Independent Clock Block RAM”使用块 RAM 来实现异步 FIFO；其中 Independent Clock 表示是异步 FIFO，Block RAM 表示的是块 RAM 资源。 
</code></pre>
<p>如图所示，可勾选“Write Data Count”和“Read Data Count”生成 FIFO<br>内剩余个数输出信号，一个是基于读时钟，一个是基于写时钟。该输出信号可根据自己设计是否需要进行生成，默认是不生成，这里我们都勾选进行生成。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0314ab41426a1bfe5a18823d095c43d4.png"></p>
<h5 id="xilinx-vivado-IP核调用-3"><a href="#xilinx-vivado-IP核调用-3" class="headerlink" title="&lt;2&gt;xilinx vivado IP核调用"></a>&lt;2&gt;xilinx vivado IP核调用</h5><pre><code>    RTL 代码顶层的输入信号有：50MHz 的写时钟 wr_clk、输入 256 个 8bit 的数据 pi_data （值为十进制 0~255）和伴随该输入数据有效的标志信号 pi_flag、25MHz 的读时钟 rd_clk、FIFO 的写请求信号 rd_en。这些输入信号需要在 Testbench 中产生激励。

    RTL 代码顶层的输出信号有：FIFO 空标志信号 empty、FIFO 满标志信号 full、同步于 wr_clk 指示 FIFO 中存在数据个数的信号 wr_data_count、从 FIFO 中读取的数据 po_data、 同步于 rd_clk 指示 FIFO 中存在数据个数的信号 rd_data_count。这些信号也是我们需要通过仿真 DCFIFO IP 核主要观察的信号，这些信号通过 Testbench 中给输入信号激励后产生输出。


`timescale  1ns/1ns

module fifo
(
    input   wire         wr_clk    ,   //同步于FIFO写数据的时钟50MHz
    input   wire  [7:0]  pi_data   ,   //输入顶层模块的数据，要写入到FIFO中
                                       //的数据同步于wrclk时钟
    input   wire         pi_flag   ,   //输入数据有效标志信号，也作为FIFO的
                                       //写请求信号，同步于wrclk时钟
    input   wire         rd_clk    ,   //同步于FIFO读数据的时钟25MHz
    input   wire         rd_en     ,   //FIFO读请求信号，同步于rdclk时钟

    output  wire  [15:0] po_data   ,   //FIFO读出的数据，同步于rdclk时钟
    output  wire         empty     ,   //空标志信号，高有效，
    output  wire         full      ,   //满标志信号，高有效，
    output  wire  [6:0]  rd_data_count,//FIFO读端口中存在的数据个数，
                                       //同步于rdclk时钟
    output  wire  [7:0]  wr_data_count //FIFO写端口中存在的数据个数，
                                       //同步于wrclk时钟
);

//----------------------dcfifo_256x8to128x16_inst-----------------------
dcfifo_256x8to128x16    dcfifo_256x8to128x16_inst
(
    .din            (pi_data),  //input   [7:0]   din
    .rd_clk         (rd_clk ),  //input           rd_clk
    .rd_en          (rd_en  ),  //input           rd_en
    .wr_clk         (wr_clk ),  //input           wr_clk
    .wr_en          (pi_flag),  //input           wr_en

    .dout           (po_data),  //output   [15:0] dout
    .empty          (empty  ),  //output          empty
    .full           (full   ),  //output          full
    .rd_data_count  (rd_data_count),//output   [6:0]  rd_data_count
    .wr_data_count  (wr_data_count) //output   [7:0]  wr_data_count
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/58847d86d5164408b79f24c556aaf70e.png"></p>
<p>仿真：</p>
<pre><code>`timescale  1ns/1ns

module tb_fifo();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg          wr_clk         ;
reg  [7:0]   pi_data        ;
reg          pi_flag        ;
reg          rd_clk         ;
reg          rd_en          ;
reg          sys_rst_n      ;
reg  [1:0]   cnt_baud       ;
reg          full_reg0      ;
reg          full_reg1      ;

//wire  define
wire            empty           ;
wire            full            ;
wire    [7:0]   wr_data_count   ;
wire    [15:0]  po_data         ;
wire    [6:0]   rd_data_count   ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//初始化时钟、复位
initial begin
    wr_clk     = 1&#39;b1;
    rd_clk     = 1&#39;b1;
    sys_rst_n &lt;= 1&#39;b0;
    #100;
    sys_rst_n &lt;= 1&#39;b1;
    #100000
    sys_rst_n &lt;= 1&#39;b0;
end

//wr_clk:模拟FIFO的写时钟，每10ns电平翻转一次，周期为20ns，频率为50MHz
always #10 wr_clk = ~wr_clk;

//rd_clk:模拟FIFO的读时钟，每20ns电平翻转一次，周期为40ns，频率为25MHz
always #20 rd_clk = ~rd_clk;

//cnt_baud:计数从0到3的计数器，用于产生输入数据间的间隔
always@(posedge wr_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_baud &lt;= 2&#39;b0;
    else    if(&amp;cnt_baud == 1&#39;b1)
        cnt_baud &lt;= 2&#39;b0;
    else
        cnt_baud &lt;= cnt_baud + 1&#39;b1;

//pi_flag:输入数据有效标志信号，也作为FIFO的写请求信号
always@(posedge wr_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_flag &lt;= 1&#39;b0;
    //每4个时钟周期且没有读请求时产生一个数据有效标志信号
    else    if((cnt_baud == 2&#39;d0) &amp;&amp; (rd_en == 1&#39;b0))
        pi_flag &lt;= 1&#39;b1;
    else
        pi_flag &lt;= 1&#39;b0;

//pi_data:输入顶层模块的数据，要写入到FIFO中的数据
always@(posedge wr_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_data &lt;= 8&#39;b0;
    pi_data的值为0~255依次循环
    else    if((pi_data == 8&#39;d255) &amp;&amp; (pi_flag == 1&#39;b1))
        pi_data &lt;= 8&#39;b0;
    else    if(pi_flag  == 1&#39;b1)    //每当pi_flag有效时产生一个数据
        pi_data &lt;= pi_data + 1&#39;b1;

//将同步于rd_clk时钟的写满标志信号full在rd_clk时钟下打两拍
always@(posedge rd_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)   
        begin
            full_reg0 &lt;= 1&#39;b0;
            full_reg1 &lt;= 1&#39;b0;
        end
    else
        begin
            full_reg0 &lt;= full;
            full_reg1 &lt;= full_reg0;
        end

//rd_en:FIFO读请求信号同步于rd_clk时钟
always@(posedge rd_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        rd_en &lt;= 1&#39;b0;
//如果full信号有效就立刻读，则不会看到full信号拉高，
//所以此处使用full在rd_clk时钟下打两拍后的信号
    else    if(full_reg1 == 1&#39;b1)
        rd_en &lt;= 1&#39;b1;
    else    if(empty == 1&#39;b1)//当FIFO中的数据被读空时停止读取FIFO中的数据
        rd_en &lt;= 1&#39;b0;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//------------------------fifo_inst------------------------
fifo    fifo_inst
(
    .wr_clk  (wr_clk    ),  //input             wr_clk
    .pi_data (pi_data   ),  //input     [7:0]   pi_data
    .pi_flag (pi_flag   ),  //input             pi_flag
    .rd_clk  (rd_clk    ),  //input             rd_clk
    .rd_en   (rd_en     ),  //input             rd_en

    .po_data (po_data   ),  //output    [15:0]  po_data
    .empty   (empty     ),  //output            empty
    .full    (full      ),  //output            full
    .rd_data_count(rd_data_count),//output  [6:0]  rd_data_count
    .wr_data_count(wr_data_count) //output  [7:0]   wr_data_count
);

endmodule
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cd8a48624086dad5e90938923f91948.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/023c8533627e2e6d569a0488456e668a.png"></p>
<pre><code>    如图所示为位置 1 放大后的波形，因为我们设置的是普通模式 FIFO，所以和 SCFIFO 的普通模式一样读出的数据存在**一个时钟周期的潜伏期** ，另外还有几个点需要我们重点观察：

    1、full 满标志信号的状态：我们可以看到当 pi_flag 为高且 pi_data 为 254 的 full 满标 志信号先拉高了，虽然我们是往里面写入数据 0~255，但是我们在配置 fifo 核时知道**fifo 的实际深度只有 255，所以这里到数据写到 254 个时，full 满信号就被拉高了** 。

    2、wr_data_count、rd_data_count 信号的状态：我们可以看到 wr_data_count 信号计数到 255，而 rd_data_count 信号则计数到 127，这是因为**输入时 8btit 的，输出是 16bit 的** ，刚好总数据量相等。同样 wr_data_count 信号也从 255 变成了 0、rd_data_count 信号从 127 变 成 0 的原因和 SCFIFO 中的情况一样，都是因为数据存储满了，FIFO 内部的计数器溢出所导致的。我们还可以发现读出的 16bit 数据，是输入的 8bit 数据低位在后高位在前的顺序， 如果记错了顺序在使用数据的时候会产生错误。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cea9670fb75213b148fa33d32c8fc165.png"></p>
<pre><code>    如图所示为位置 2 放大后的波形，我们发现，最后一个读取的数据为 16’hfcfd （实际深度为 127），同时 empty 空信号标志信号也拉高，表示 16bit 的读 FIFO 数据已空。
</code></pre>
<h4 id="⑶注意问题"><a href="#⑶注意问题" class="headerlink" title="⑶注意问题"></a>⑶注意问题</h4><p>1、在单位时间内，写数据的总带宽一定要等于读数据的总带宽，否则会存在写满或读空的现象；</p>
<p>2、控制好、利用好 FIFO 的关键信号，如读写时钟、读写使能、空满标志信号；</p>
<p>3、根据实际的项目需求还要考虑需要多大的 FIFO，大了会浪费资源，小了则达不到需求。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132779996">https://blog.csdn.net/qq_32971095/article/details/132779996</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/17/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/17/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">项目管理概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-17 17:41:22" itemprop="dateCreated datePublished" datetime="2023-08-17T17:41:22+08:00">2023-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6">一.项目管理框架</a></p>
<p><a href="about:blank#1.%E4%B8%80%E4%BA%9B%E6%B5%81%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF">1.一些流行的时间管理工具和技术</a></p>
<p><a href="about:blank#2.%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B">2.项目章程</a></p>
<p><a href="about:blank#3.%E8%8C%83%E5%9B%B4%E8%AF%B4%E6%98%8E%E4%B9%A6">3.范围说明书</a></p>
<p><a href="about:blank#4.%E5%B7%A5%E4%BD%9C%E5%88%86%E8%A7%A3%E7%BB%93%E6%9E%84">4.工作分解结构</a></p>
<p><a href="about:blank#5.%E4%B8%80%E4%BA%9B%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%A2%AB%E5%8F%91%E7%8E%B0%E5%8F%AF%E4%BB%A5%E4%BF%83%E8%BF%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%B1%95%E7%9A%84%E9%87%8D%E8%A6%81%E5%B7%A5%E5%85%B7">5.一些广泛使用，被发现可以促进项目开展的重要工具</a></p>
<p><a href="about:blank#6.%E9%A1%B9%E7%9B%AE%E4%BA%A4%E4%BB%98%E8%83%BD%E5%8A%9B%E5%87%BA%E8%89%B2%E7%9A%84%E5%85%AC%E5%8F%B8%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%A6%81%E7%B4%A0">6.项目交付能力出色的公司的四个重要的实践要素</a></p>
<p><a href="about:blank#7.%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86">7.项目经理所需知识</a></p>
<p><a href="about:blank#8.%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F%E7%BB%8F%E7%90%86%E9%98%B6%E6%AE%B5">8.项目团队经理阶段</a></p>
<p><a href="about:blank#%E4%BA%8C.%E9%A1%B9%E7%9B%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E7%BB%84">二.项目生命周期和管理过程组</a></p>
<p><a href="about:blank#1.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%A7%82%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%90%83%E6%A8%A1%E5%9E%8B">1.项目管理的系统观以及系统管理的三球模型</a></p>
<p><a href="about:blank#2.%E9%A2%84%E6%B5%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B">2.预测生命周期和自适应软件开发生命周期模型</a></p>
<p><a href="about:blank#3.IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%80%E6%96%B0%E8%B6%8B%E5%8A%BF%EF%BC%9A">3.IT项目管理最新趋势：</a></p>
<p><a href="about:blank#4.%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">4.敏捷项目管理</a></p>
<p><a href="about:blank#5.%E9%A1%B9%E7%9B%AE%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E5%92%8C%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B">5.项目业务过程和管理过程</a></p>
<p><a href="about:blank#%3C1%3E%E8%B5%B7%E8%8D%89%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0">&lt;1&gt;起草项目章程​编辑
</a></p>
<p><a href="about:blank#%3C2%3E%E5%BC%80%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E4%BC%9A%E8%AE%AE%C2%A0">&lt;2&gt;开项目启动会议
</a></p>
<p><a href="about:blank#%3C3%3E%E5%85%B6%E4%BB%96">&lt;3&gt;其他</a></p>
<p><a href="about:blank#%E4%B8%89.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5">三.项目实践</a></p>
<p><a href="about:blank#%C2%A0%E4%B8%89.%E5%85%B6%E4%BB%96">四.其他</a></p>
<hr>
<h2 id="一-项目管理框架"><a href="#一-项目管理框架" class="headerlink" title="一.项目管理框架"></a>一.项目管理框架</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6561e507e27384e79a36ac6d5a8acb.png"></p>
<h3 id="1-一些流行的时间管理工具和技术"><a href="#1-一些流行的时间管理工具和技术" class="headerlink" title="1.一些流行的时间管理工具和技术"></a><strong>1.一些流行的时间管理工具和技术</strong></h3><p>◦ 项目章程, 范围说明书, 以及工作分解结构 (范围)</p>
<p>◦ 甘特图, 项目网络图, 关键路径分析, 关键链排程 (时间)</p>
<p>◦ 成本估算和挣值管理 (成本)</p>
<h3 id="2-项目章程"><a href="#2-项目章程" class="headerlink" title="2.项目章程"></a><strong>2.项目章程</strong></h3><p>◦ 编写一份<strong><strong>正式批准项目</strong></strong> 并授权项目经理在项目活动中使用组织资源的文件的过程。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b6e40deeb4c39947d46f1e5e21e22db7.png"></p>
<h3 id="3-范围说明书"><a href="#3-范围说明书" class="headerlink" title="3.范围说明书"></a><strong>3.范围说明书</strong></h3><h3 id="4-工作分解结构"><a href="#4-工作分解结构" class="headerlink" title="4.工作分解结构"></a><strong>4.工作分解结构</strong></h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb3053d170916cfedd694bb9272efd5d.png"></p>
<h3 id="5-一些广泛使用，被发现可以促进项目开展的重要工具"><a href="#5-一些广泛使用，被发现可以促进项目开展的重要工具" class="headerlink" title="5.一些广泛使用，被发现可以促进项目开展的重要工具"></a>5.<strong>一些广泛使用，被发现可以促进项目开展的重要工具</strong></h3><p>◦ 进程报告</p>
<p>◦ 开工会议</p>
<p>◦ 甘特图</p>
<p>◦ 变更请求</p>
<h3 id="6-项目交付能力出色的公司的四个重要的实践要素"><a href="#6-项目交付能力出色的公司的四个重要的实践要素" class="headerlink" title="6.项目交付能力出色的公司的四个重要的实践要素"></a>6.<strong>项目交付能力出色的公司的四个重要的实践要素</strong></h3><p>◦ 使用集成工具箱 (使用标准&#x2F;高级项目管理工具， 大量的模板)</p>
<p>◦ 培养项目领导人, 尤其是商业技巧和软件技术</p>
<p>◦ 开发一个流线型的项目交付过程</p>
<p>◦ 对项目的健康度进行量化（例如，客户满意度和投 资回报等）</p>
<h3 id="7-项目经理所需知识"><a href="#7-项目经理所需知识" class="headerlink" title="7.项目经理所需知识"></a>7.项目经理所需知识</h3><p>} 项目管理知识体系</p>
<p>} 应用领域的知识、标准和规则</p>
<p>} 项目环境知识</p>
<p>} 通用管理知识和技能</p>
<p>} 软技能或人际关系能力</p>
<pre><code>    1\. 人际关系技能

    2\. 领导能力

    3\. 倾听能力

    4\. 正直、行为道德、坚定

    5\. 善于建立信任关系

    6\. 口头沟通

    7\. 善于创建团队

    8\. 解决冲突、冲突管理

    9\. 批判式思考、解决问题

    10\. 理解、权衡优先
</code></pre>
<p>不同种类项目所需能力：</p>
<p>} 大型项目：领导力、相关经历、计划、人际关系技能、 口头沟通和团队建设技能是最重要的。</p>
<p>} 高不确定性项目: 风险管理、期望管理、领导力、人 际关系技能和计划能力是最重要的。</p>
<p>} 非常新颖项目：领导力、人际关系技能、有远见和目 标、自信、期望管理和倾听技能是最重要的</p>
<h3 id="8-项目团队经理阶段"><a href="#8-项目团队经理阶段" class="headerlink" title="8.项目团队经理阶段"></a><strong>8.项目团队经理阶段</strong></h3><p>组建期、激荡期、规范期、执行期和休整期</p>
<p>PMI 提供项目管理师 (PMP)认证</p>
<h2 id="二-项目生命周期和管理过程组"><a href="#二-项目生命周期和管理过程组" class="headerlink" title="二.项目生命周期和管理过程组"></a><strong><strong>二.项目生命周期和管理过程组</strong></strong></h2><h3 id="1-项目管理的系统观以及系统管理的三球模型"><a href="#1-项目管理的系统观以及系统管理的三球模型" class="headerlink" title="1.项目管理的系统观以及系统管理的三球模型"></a>1.项目管理的系统观以及系统管理的三球模型</h3><p>} 不能孤立地执行项目</p>
<p>} 必须在广阔的组织环境中运作</p>
<p>} 项目经理也不能孤立地领导项目，需要使用系统 思维、整体的观点，理解项目的组织环境</p>
<p>◦ 在组织情境内采用整体观点来实施项目</p>
<p>◦ 高级管理人员必须确保项目持续支持当前的业务需求</p>
<h3 id="2-预测生命周期和自适应软件开发生命周期模型"><a href="#2-预测生命周期和自适应软件开发生命周期模型" class="headerlink" title="2.预测生命周期和自适应软件开发生命周期模型"></a>2.预测生命周期和自适应软件开发生命周期模型</h3><p>◦ 项目阶段 ：传统项目管理存在一些基本阶段：概念、开发、实施和收 尾阶段。</p>
<p>◦ 这些阶段不能与今后提到的项目管理过程组的启动、计划、 执行、监控、收尾相混淆。</p>
<p>} 项目生命周期 是一系列项目阶段的集合</p>
<p>◦ 在每个阶段中要进行的工作</p>
<p>◦ 什么时候给出什么样的可交付成果</p>
<p>◦ 每个阶段涉及的人员和时间</p>
<p>◦ 管理层将如何控制和验证每个阶段产生的工作</p>
<p>} 一个 可交付成果 是作为项目的一部分生产或提供 的产品或服务。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e6a54b386d3f4b133d946789a016a0d.png"></p>
<p> } 瀑布式生命周期模型: 定义了良好的线性系统分析、 设计、编码、测试和维护的阶段。</p>
<p>} 原型生命周期模型: 用于开发软件原型来阐明用户 操作软件的需求。</p>
<p>} 渐增式构建生命周期模型: 提供了对操作软件累进 的开发。</p>
<p>} 螺旋式生命周期模型: 显示了多数软件是使用迭代 或者螺旋方法而不是线性方法开发出来的。 } 快速应用开发(RAD)生命周期模型: 用于在不牺牲<br>质量的前提下快速开发项目。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8df9890e84386a023ed31d1c7949d1f4.png"></p>
<h3 id="3-IT项目管理最新趋势："><a href="#3-IT项目管理最新趋势：" class="headerlink" title="3.IT项目管理最新趋势："></a>3.IT项目管理最新趋势：</h3><p><strong>全球化</strong></p>
<p>◦ 问题——沟通、信任、工作方式、工具</p>
<p>◦ 建议——项目规范、全球化与本地化、合作、新技术等</p>
<p><strong>外包</strong> ：从外部寻找来源以获得需要的产品和服务。</p>
<p>虚拟团队: 运用通信技术实现跨时间和跨地域工 作的个人组成的团队。</p>
<h3 id="4-敏捷项目管理"><a href="#4-敏捷项目管理" class="headerlink" title="4.敏捷项目管理"></a>4.敏捷项目管理</h3><p>敏捷宣言：</p>
<p>◦ 个体和交互 重于 过程和工具</p>
<p>◦ 可运行的软件 重于 面面俱到的文档</p>
<p>◦ 客户合作 重于 合同谈判</p>
<p>◦ 响应变化 重于 遵循计划</p>
<h3 id="5-项目业务过程和管理过程"><a href="#5-项目业务过程和管理过程" class="headerlink" title="5.项目业务过程和管理过程"></a>5.项目业务过程和管理过程</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a293d6846a5fc6174773cfe4d2d21824.png"></p>
<h4 id><a href="#" class="headerlink" title></a></h4><p>&lt;1&gt;起草项目章程<img src="https://i-blog.csdnimg.cn/blog_migrate/23428b81336d7764ceef3d263a46b820.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9a191e6eb24a199568ffd4c1c83bf5c.png"></p>
<h4 id="开项目启动会议"><a href="#开项目启动会议" class="headerlink" title="&lt;2&gt;开项目启动会议"></a>&lt;2&gt;开项目启动会议</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/44f91820f373f7b555aa503d8bfd6232.png"></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="&lt;3&gt;其他"></a>&lt;3&gt;其他</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5081537ca94bfe3852addd9a2661845.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/156f32c4a921fc7addcce0b3e179376e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c1d2a14497ac2dddb0faa40d2bf4c4d.png"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/090816d0caa2f7c0ea69492a9e497bc7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/66c4ba44817c651e2cb865aabd3dcfd3.png"></p>
<h2 id="三-项目实践"><a href="#三-项目实践" class="headerlink" title="三.项目实践"></a>三.项目实践</h2><p>见资源绑定部分，作者描述了曾经的一个项目进行规范化后的流程。</p>
<h2 id="四-其他"><a href="#四-其他" class="headerlink" title="四.其他"></a>四.其他</h2><p>项目总监—项目经理—— 项目主管—项目助理<br>产品总监—产品经理—产品助理—产品实习生<br>技术总监—技术经理—研发经理—技术主管—架构师</p>
<p>PDCA（plan ，do，check，action）<br>愿景-&gt;甲方（利益相关方、领导、客户）-&gt;产品经理-——（理解需求，记录）——&gt;开发团队<br>沟通：快速、高效、记录</p>
<p>产品负责人-&gt;做什么<br>开发团队-&gt;怎么做<br>项目经理（敏捷教练）-&gt;怎么快速交付</p>
<p>敏捷监控-&gt;判断敏捷项目状态（VT图【功能-时间图，最乐观、悲观两条直线，项目在这两条直线之间】）-&gt;提供方案</p>
<p><strong>相关资料及了解：</strong></p>
<p><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88226711" title="西安电子科技大学工程概论相关资料资源">西安电子科技大学工程概论相关资料资源<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://download.csdn.net/download/qq_32971095&#x2F;88226711</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wypblog/article/details/108701343?spm=1001.2014.3001.5506&ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTcxMDk1P3R5cGU9Y29sbGVjdA==" title="互联网大厂的薪资和职级一览">互联网大厂的薪资和职级一览<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/wypblog/article/details/108701343?spm=1001.2014.3001.5506&amp;ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTcxMDk1P3R5cGU9Y29sbGVjdA%3D%3D</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Albert_weiku/article/details/123089529?spm=1001.2014.3001.5506" title="一个大厂的项目组织架构学习">一个大厂的项目组织架构学习<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/Albert_weiku&#x2F;article&#x2F;details&#x2F;123089529?spm&#x3D;1001.2014.3001.5506</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xhtchina/article/details/112859450?spm=1001.2014.3001.5506" title="大厂人才结构">大厂人才结构<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/xhtchina/article/details/112859450?spm=1001.2014.3001.5506</a></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132343604">https://blog.csdn.net/qq_32971095/article/details/132343604</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/16/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C2%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/16/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C2%EF%BC%9E/" class="post-title-link" itemprop="url">基础设计一——FPGA学习笔记＜2＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-16 22:51:36" itemprop="dateCreated datePublished" datetime="2023-08-16T22:51:36+08:00">2023-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B">零.设计流程</a></p>
<p><a href="about:blank#%E4%B8%80.%E6%8C%89%E9%94%AE%E7%82%B9%E4%BA%AELED%E7%81%AF">一.按键点亮LED灯</a></p>
<p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">1.硬件资源</a></p>
<p><a href="about:blank#%C2%A02.%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1"> 2.项目设计</a></p>
<p><a href="about:blank#%C2%A03.%E6%B3%A2%E5%BD%A2%E8%AE%BE%E8%AE%A1"> 3.波形设计</a></p>
<p><a href="about:blank#%C2%A04.%E5%88%9B%E5%BB%BAVivado%E5%B7%A5%E7%A8%8B%E2%80%8B%E7%BC%96%E8%BE%91"><br>4.创建Vivado工程​编辑</a></p>
<p><a href="about:blank#%3C1%3E%E6%B7%BB%E5%8A%A0%E8%AE%BE%E8%AE%A1%E6%96%87%E4%BB%B6">&lt;1&gt;添加设计文件</a></p>
<p><a href="about:blank#%3C2%3E%E6%B7%BB%E5%8A%A0%E4%BB%BF%E7%9C%9F%E6%96%87%E4%BB%B6">&lt;2&gt;添加仿真文件</a></p>
<p><a href="about:blank#5.%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F">5.引脚约束</a></p>
<p><a href="about:blank#6.%E7%94%9F%E6%88%90%E6%AF%94%E7%89%B9%E6%B5%81%E6%96%87%E4%BB%B6">6.生成比特流文件</a></p>
<p><a href="about:blank#7.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">7.下载验证</a></p>
<p><a href="about:blank#8.%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96">8.程序固化</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8">二.多路选择器</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p>
<p>[&lt;1&gt;always 中 if-else 实现方法](about:blank#%3C1%3Ealways%20%E4%B8%AD%20if-<br>else%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95)</p>
<p><a href="about:blank#%C2%A0%3C2%3Ealways%20%E4%B8%AD%20case%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E2%80%8B%E7%BC%96%E8%BE%91"> &lt;2&gt;always 中 case<br>实现方法​编辑</a></p>
<p><a href="about:blank#%C2%A0%3C3%3Eassign%20%E4%B8%AD%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"> &lt;3&gt;assign<br>中条件运算符（三元运算符）实现方法</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E4%B8%89.%E8%AF%91%E7%A0%81%E5%99%A8">三.译码器</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E5%9B%9B.%E5%8D%8A%E5%8A%A0%E5%99%A8">四.半加器</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%B1%82%E6%AC%A1%E5%8C%96%E8%AE%BE%E8%AE%A1">五.层次化设计</a></p>
<p><a href="about:blank#1.%E5%85%A8%E5%8A%A0%E5%99%A8">1.全加器</a></p>
<p><a href="about:blank#%E5%85%AD.%E9%81%BF%E5%85%8DLatch%E7%9A%84%E4%BA%A7%E7%94%9F">六.避免Latch的产生</a></p>
<p><a href="about:blank#%E4%B8%83.%E5%AF%84%E5%AD%98%E5%99%A8">七.寄存器</a></p>
<p><a href="about:blank#1.%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%C2%A0D%20%E8%A7%A6%E5%8F%91%E5%99%A8">1.同步复位 D 触发器和异步复位 D<br>触发器</a></p>
<p><a href="about:blank#%3C1%3E%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8">&lt;1&gt;同步复位 D<br>触发器</a></p>
<p><a href="about:blank#%3C2%3E%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%20D%20%E8%A7%A6%E5%8F%91%E5%99%A8">&lt;2&gt;异步复位 D<br>触发器</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E5%85%AB.%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC">八.阻塞赋值与非阻塞赋值</a></p>
<p><a href="about:blank#%E4%B9%9D.%E8%AE%A1%E6%95%B0%E5%99%A8">九.计数器</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.实现方法</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E5%8D%81.%E5%88%86%E9%A2%91%E5%99%A8">十.分频器</a></p>
<p><a href="about:blank#1.%E5%81%B6%E5%88%86%E9%A2%91">1.偶分频</a></p>
<p><a href="about:blank#2.%E5%A5%87%E5%88%86%E9%A2%91">2.奇分频</a></p>
<p><a href="about:blank#%E5%8D%81%E4%B8%80.%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96">十一.按键消抖</a></p>
<p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E6%B6%88%E6%8A%96">1.硬件消抖</a></p>
<p><a href="about:blank#2.%E8%BD%AF%E4%BB%B6%E6%B6%88%E6%8A%96">2.软件消抖</a></p>
<p><a href="about:blank#%E5%8D%81%E4%BA%8C.%E6%B5%81%E6%B0%B4%E7%81%AF">十二.流水灯</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<p><a href="about:blank#%E5%8D%81%E4%B8%89.%E7%8A%B6%E6%80%81%E6%9C%BA">十三.状态机</a></p>
<p><a href="about:blank#1.%E7%AE%80%E6%98%93%E5%8F%AF%E4%B9%90%E6%9C%BA">1.简易可乐机</a></p>
<p><a href="about:blank#2.%E5%A4%8D%E6%9D%82%E5%8F%AF%E4%B9%90%E6%9C%BA">2.复杂可乐机</a></p>
<p><a href="about:blank#%E5%8D%81%E5%9B%9B.%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8">十四.无源蜂鸣器</a></p>
<p><a href="about:blank#%E5%8D%81%E4%BA%94.%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA">十五.动态数码管显示</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E7%8E%B0">1.实现</a></p>
<p><a href="about:blank#%3C1%3Edata_gen">&lt;1&gt;data_gen</a></p>
<p><a href="about:blank#%C2%A0%3C2%3Ebcd_8421"> &lt;2&gt;bcd_8421</a></p>
<p><a href="about:blank#%3C3%3E%C2%A0seg_dynamic">&lt;3&gt; seg_dynamic</a></p>
<p><a href="about:blank#%C2%A0%3C4%3Etop_seg_dynamic"> &lt;4&gt;top_seg_dynamic</a></p>
<p><a href="about:blank#2.%E4%BB%BF%E7%9C%9F">2.仿真</a></p>
<hr>
<p>前置学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5501" title="verilog语法——FPGA学习笔记＜1＞">verilog语法——FPGA学习笔记＜1＞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132220627?spm=1001.2014.3001.5501" title="FPGA基本概念及资源整理——FPGA学习笔记＜0＞">FPGA基本概念及资源整理——FPGA学习笔记＜0＞</a></p>
<p> 参考书目：《野火FPGA Verilog 开发实战指南》</p>
<h2 id="零-设计流程"><a href="#零-设计流程" class="headerlink" title="零.设计流程"></a>零.设计流程</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2efe3610ba66737b9104ad2f0d80a3c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f92d1d6e686a5d2205375e96b85fff6b.png"></p>
<p><strong>熟悉Vivado界面参考：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/L20902/article/details/86542768" title="4.1 Vivado使用技巧（1）：了解主界面"> 4.1 Vivado使用技巧（1）：了解主界面<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/L20902/article/details/86542768</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/152589392" title="[走近FPGA]之工具篇（上）-Vivado">[走近FPGA]之工具篇（上）-Vivado<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://zhuanlan.zhihu.com/p/152589392</a></p>
<h2 id="一-按键点亮LED灯"><a href="#一-按键点亮LED灯" class="headerlink" title="一.按键点亮LED灯"></a>一.按键点亮LED灯</h2><h3 id="1-硬件资源"><a href="#1-硬件资源" class="headerlink" title="1.硬件资源"></a>1.硬件资源</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2667696a820c85797d4d6df1cd43b3c2.png"></p>
<h3 id="2-项目设计"><a href="#2-项目设计" class="headerlink" title="2.项目设计"></a>2.项目设计</h3><p>①项目分解成模块；②模块设计：模块、输入信号、输出信号</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a547736864f1e460e82164c0dbd31028.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b7294591ac560a6ea16c433bad7f58b.png"></p>
<h3 id="3-波形设计"><a href="#3-波形设计" class="headerlink" title="3.波形设计"></a>3.波形设计</h3><p>信号之间的逻辑或时序上关系，众多信号使用波形图表达（注意信号间规范区分，比如绿色输入信号，黄色之间变量，红色输出变量等等）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9529f923229460a5c7d62e2813b2a149.png"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>4.创建Vivado工程<img src="https://i-blog.csdnimg.cn/blog_migrate/5c2a7cc9868e417cc2454b198ef7c77c.png"></p>
<h4 id="添加设计文件"><a href="#添加设计文件" class="headerlink" title="&lt;1&gt;添加设计文件"></a>&lt;1&gt;添加设计文件</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/af3dc861458df3b6b3b0b48ef0d48397.png"></p>
<p> 文件会复制到xxx.srcs文件夹内；创建文件路径也在此文件夹中；复制选项上面的选项指复制搜寻并复制子模块RTL文件</p>
<p>示例RTL代码：</p>
<pre><code>`timescale  1ns/1ns
//
// Company: 
// Engineer: 
// 
// Create Date: 2023/08/16 22:03:43
// Design Name: 
// Module Name: led_creat
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//

module  led
(
    input   wire    key_in  ,   //输入按键

    output  wire    led_out     //输出控制led
);

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//led_out:led灯输出的结果为key_in按键取反的输入
assign  led_out  =  ~key_in;

endmodule
</code></pre>
<h4 id="添加仿真文件"><a href="#添加仿真文件" class="headerlink" title="&lt;2&gt;添加仿真文件"></a>&lt;2&gt;添加仿真文件</h4><p>逻辑仿真时使用的Testbench脚本也是用HDL语言写的，其原理如下：</p>
<p>第一步创建Testbench脚本，名字通常为被测试模块前加tb_</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1dd6f2041ad2af10e07bce42ef0ed57.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8a5b95f6c18a4f91ac7113d884df5d06.png"></p>
<p>代码示例：</p>
<pre><code>`timescale  1ns/1ns

module  tb_led();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire    led_out ;

//reg   define
reg     key_in  ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化输入信号
initial key_in &lt;= 1&#39;b0;

//key_in:产生输入随机数，模拟按键的输入情况
always #10 key_in &lt;= &#123;$random&#125; % 2; /*取模求余数，产生非负随机数0、1
                                      每隔10ns产生一次随机数*/

//********************************************************************//
//**************************** Instantiate ***************************//
//********************************************************************//
//------------- led_inst -------------
led led_inst
(
    .key_in (key_in ),  //input     key_in

    .led_out(led_out)   //output    led_out
);

endmodule


    _**这里定义的变量类型如果要手动赋值仿真，使用reg变量；如果是输出则用使用wire变量引出**_ ，理解变量的含义即可。
</code></pre>
<p>然后运行仿真即可，可选择Vivado仿真或Modelsim联合仿真。仿真过程类似Quartus II</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/195ecfe4afdbb59d8a2c2871b179f4b4.png"></p>
<p>此处可设定仿真参数</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b47bce4a0d597ad6c2f825c93fddea3c.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/5f7462237ec90db44d753643fd1175f8.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b47c2afa869d2985439cd6a764acec2.png"></p>
<h3 id="5-引脚约束"><a href="#5-引脚约束" class="headerlink" title="5.引脚约束"></a>5.引脚约束</h3><p><strong>&lt; 1&gt;方式一——RTL ANALYSIS</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/08347777a3520b80c7389d37b9a8f174.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7022f97c6a64984110ce0190374f40ee.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07d2cc78f9f45c76abd50199a1765abb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db93f9f8c2c93c51f9cebe41a5343324.png"></p>
<p><strong>注：相关文件信息及更改在中间框中如下</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c87e94d3d00825f28e055fc0409abf65.png"></p>
<p>**  &lt;2&gt;方式二——直接编写并添加.xdc连接文件**</p>
<p><strong>注：.xdc文件使用#注释</strong></p>
<h3 id="6-生成比特流文件"><a href="#6-生成比特流文件" class="headerlink" title="6.生成比特流文件"></a>6.生成比特流文件</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/357b240f0acec1fdd18ae18c48ac40e6.png"></p>
<h3 id="7-下载验证"><a href="#7-下载验证" class="headerlink" title="7.下载验证"></a>7.下载验证</h3><p>**  注意事项**</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/45e3ec6b37e6730e9b3cb619c63e3506.png"></p>
<p><strong>即先将JTAG连接至FPGA，然后打开FPGA电源，然后JTAG链接电脑</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0cb4b6be1ea1d93446498b0a58ccf824.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/702c1dbfa022a48d2038ebc95a365143.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3f5cb3dcb64fe6c9a9fb78114e65ab90.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0552faa2eab0dffee4a70c5accc31b5b.png"></p>
<p>可以看到生成的bit文件保存在.runs文件夹中</p>
<h3 id="8-程序固化"><a href="#8-程序固化" class="headerlink" title="8.程序固化"></a>8.程序固化</h3><p><strong>首先在.xdc连接文件添加以下代码，目的是使用spi4加速（如果不添加后续只能使用spi1）</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/140e2313fb9fd6db965f491478b676bd.png"></p>
<pre><code>set_property CFGBVS VCCO [current_design]
set_property CONFIG_VOLTAGE 3.3 [current_design]
set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]
set_property CONFIG_MODE SPIx4 [current_design]
set_property BITSTREAM.CONFIG.CONFIGRATE 50 [current_design]
</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42741023/article/details/110523933" title="XILINX 7系列配置4线SPI_spi_setconfig">XILINX<br>7系列配置4线SPI_spi_setconfig</a></p>
<p>MSC文件是xilinx的二进制文件</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0dc2ae66a16b4d70850a1f4ae1018297.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9cce811c897aaa8d84456affe85324ee.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a4bbc39dcadb1a386cb97f00b0ed60ca.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87d997a95dc950fcd7f972d92fa4b0a5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad5f6ceceaaa31907048acf97b94a072.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6d545db03b98d36c3b125aa76fba5f7.png"></p>
<p> 进程两步操作：擦除FLASH芯片、写入FLASH芯片；</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a08207a83f751091bd3135d3a6b23cf.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9cfdde4d3a4b725549baa2d34cf355c.png"></p>
<p>生成bin文件之后，右键之前生成的存储器配置文件，更改“programme file”为生成的bin文件如下</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b7b0ba72cbd40812bb052723628d968f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e538294c904a9336b2a9984f3527a2bf.png"></p>
<p> 之后便可以在这里进行程序烧录</p>
<p><strong>最终简化流程为“Generate BItstrean”- &gt;“Program Configuration Memory Device”</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9be6c6007e107c284be2d883a67a383.png"></p>
<h2 id="二-多路选择器"><a href="#二-多路选择器" class="headerlink" title="二.多路选择器"></a>二.多路选择器</h2><h3 id="1-实现方法"><a href="#1-实现方法" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><h4 id="always-中-if-else-实现方法"><a href="#always-中-if-else-实现方法" class="headerlink" title="&lt;1&gt;always 中 if-else 实现方法"></a>&lt;1&gt;always 中 if-else 实现方法</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/93bb9d23989a1f4147bf1e7de4c66084.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/937dd3128d1f5cdf77c8fccd00816ed4.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/4cbcc3ca593a40beb56c37d744b6a0b5.png"></p>
<h4 id="always-中-case"><a href="#always-中-case" class="headerlink" title="&lt;2&gt;always 中 case"></a>&lt;2&gt;always 中 case</h4><p>实现方法<img src="https://i-blog.csdnimg.cn/blog_migrate/d8e7264f035f94a2d4c35f795bc2e70e.png"></p>
<h4 id="assign-中条件运算符（三元运算符）实现方法"><a href="#assign-中条件运算符（三元运算符）实现方法" class="headerlink" title="&lt;3&gt;assign 中条件运算符（三元运算符）实现方法"></a>&lt;3&gt;assign 中条件运算符（三元运算符）实现方法</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/56dcc057c914e8a882f7fcaae1c8522c.png"></p>
<p>注：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wordwarwordwar/article/details/101114439" title="assign和always@(*)区别">assign和always@(*)区别</a></p>
<h3 id="2-仿真"><a href="#2-仿真" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d640913a44f0ee53ed095a299dea32bf.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f03c006da178aee72d96d6e2a4269007.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/64bba58e601e6b56807646b7f5dedf3e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c59d2b0cbc40709126a80bb867ab976a.png"></p>
<h2 id="三-译码器"><a href="#三-译码器" class="headerlink" title="三.译码器"></a>三.译码器</h2><h3 id="1-实现方法-1"><a href="#1-实现方法-1" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d07f66848d920d0322d81f64d5e9bfa5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/94b02aeeb99d1401d4105fccbf6f30cb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1268b6615fce43b3f1c4286c6f1b6908.png"></p>
<h3 id="2-仿真-1"><a href="#2-仿真-1" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c327b5d96c1e35949a45b32ae231a9e5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/72d0265f36c516cd1237289542749cae.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9907890950a3eb61c446e3525534c57.png"></p>
<h2 id="四-半加器"><a href="#四-半加器" class="headerlink" title="四.半加器"></a>四.半加器</h2><h3 id="1-实现"><a href="#1-实现" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ec6283f38702f38a3f6b123c9d7d8cb.png"></p>
<h3 id="2-仿真-2"><a href="#2-仿真-2" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/005205dcc527510028d73ea92813072b.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/04a58b1443519b04e6ba1b564905ca29.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/53534ff8355e13c45c4c60f415bed274.png"></p>
<h2 id="五-层次化设计"><a href="#五-层次化设计" class="headerlink" title="五.层次化设计"></a>五.层次化设计</h2><p>**         <em>自上而下设计</em>** ：自上而下的设计是<strong>从系统级开始</strong> ，<strong>把系统分为基本单元</strong> ，然后再把每个单元划分为<strong>下<br>一层次的基本单元</strong> ，一直这样做下去，<strong>直到直接可以用 EDA 元件库中的原件来实现为止。</strong> 在自顶向下设计方法中，我们首<br>先定义顶层功能块，进而分析需要哪些构成顶层模块的必 要子模块；然后进一步对各个子模块进行分解，直到到达无法进一步分解的底层功能块。</p>
<p>**         <em>自下而上设计</em>** ：自底向上的设计是一种传统的设计方法，对设计进行逐次划分的过程是<strong>从存在的基本单元出发的</strong><br>，设计树最末枝上的单元要么是<strong>已经构造出的单元</strong> ，要么是<strong>其他 项目开发好的单元</strong><br>或者是可外购得到的单元。在自底向上建模方法中，我们首先对现有的功能块进行分 析，然后使用这些模块来搭建规模大一些的功能块，如此继续<strong>直至顶层模块</strong> 。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7538cc8f96cd3ed8557ff715e102cc35.png"></p>
<h3 id="1-全加器"><a href="#1-全加器" class="headerlink" title="1.全加器"></a>1.全加器</h3><p>&lt;1&gt;实现</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/098c9d43dc2c588dda513c7f86aef146.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0550049229a1c71c2bf226988dc5403d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b63e0103ecc4b574df8128798cca2804.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5d7fc4a027154627993d5a2ea410858.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c81af6a8d1452ff19cb2584c664cb05e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9212a0f54789e4279e0deb46892893a0.png"></p>
<h2 id="六-避免Latch的产生"><a href="#六-避免Latch的产生" class="headerlink" title="六.避免Latch的产生"></a>六.避免Latch的产生</h2><pre><code>    Latch 其实就是**锁存器** ，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。

    在同步电路中 Latch 会产生不好的效果，**如对毛刺敏感** ；不能异步复位，**上电后处于不定态** ；还会让静态时序分析变得十分复杂；在 FPGA 的资源中，大部分器件没有锁存器 这个东西，所以需要用使用寄存器来组成锁存器所以会**占用更多逻辑资源** ；在 ASIC 设计 中，锁存器也会带来**额外的延时和 DFT** ，并不利于提高系统的工作频率，所以要避免产 生。在这里我们把会产生组合逻辑的几种情况列举出来，希望大家以后能够避免出现类似 的问题。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0c366aa57dc96fc107f7a98134ea541e.png"></p>
<h2 id="七-寄存器"><a href="#七-寄存器" class="headerlink" title="七.寄存器"></a>七.寄存器</h2><pre><code>    时序逻辑最基本的单元就是寄存器， 寄存器具有存储功能，一般是由 **D 触发器构成** ，由时钟脉冲控制，每个 D 触发器（**D Flip Flop ，DFF** ）能够存储一位二进制码。

    我们先给模块取一个名字叫 **flip_flop** ，接下来是分析端口信号：D 触发器能够正常工 作一定有时钟，每当**时钟** 的“沿（上升沿或下降沿）”来到时我们采集到稳定有效的数 据；其次还需要的就是**复位信号** ，用于让触发器的回到初始状态把数据清零；因为是用按 键控制 led 灯的亮灭，所以输入端我们还需要一个按键控制信号；输出就只有一个控制 led 灯的信号，这里我们的输入输出信号都是 1bit 的。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7cfd9794934a24ebb4c1604bc93ddff.png"></p>
<h3 id="1-同步复位-D-触发器和异步复位-D-触发器"><a href="#1-同步复位-D-触发器和异步复位-D-触发器" class="headerlink" title="1.同步复位 D 触发器和异步复位 D 触发器"></a>1.同步复位 D 触发器和异步复位 D 触发器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb4bca81cfe11f1a319e9269c00fc728.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a587c62737e05e53796c075785335997.png"></p>
<pre><code>    因为时 序电路只有在沿到来时才检测信号是否有效，所以在两个上升沿之间的毛刺都会被自然的 过滤掉，可以大大减少毛刺现象产生的干扰，提高了电路中数据的可靠性。

    时序电路还有一个特点，就是“**延一拍** ”的效果。上面两个图最左边的一组红色竖线所表达的就是这个现象。key_in 在复位后的第一个时钟的上升沿来到时拉高，我们可以发 现此时 led_out 并**没有在同一时刻也跟着拉高** ，而在之前的组合逻辑中输出是在输入变化的 同一时刻立刻变化的

    因为我们所画的波形图都是基于前仿真的，没有加入**门延时** 的信息，所以很多时候数 据的变化都是和时钟直接对齐的。当表达**时序逻辑时如果时钟和数据是对齐的，则默认当 前时钟沿采集到的数据为在该时钟上升沿前一时刻的值** ；当表达组合逻辑时如果时钟和数据是对齐的，则默认当前时钟沿采集到的数据为在该时钟上升沿同一时刻的值。而仿真工 具在进行 RTL 代码的仿真时也遵循这个规则，我们也可以理解为仿真寄存器是按照**建立时间 Tsu（指触发器的时钟信号上升沿到来以前，数据稳定不变的最小时间）最大（一个时 钟周期），保持时间 Th（指触发器的时钟信号上升沿到来以后，数据稳定不变的最小时 间）最小（为 0）的理想环境下进行的** ；而在仿真组合逻辑时因为没有时钟也就**没有建立时间和保持时间的概念** ，所以数据只要有变化就立刻有效。这里我们在 _**画波形图的时候一 定要记住这个“延一拍”的效果**_ ，否则我们绘制的波形图就会和最后的仿真结果不符，也 可能会导致最后的逻辑混乱。
</code></pre>
<h4 id="同步复位-D-触发器"><a href="#同步复位-D-触发器" class="headerlink" title="&lt;1&gt;同步复位 D 触发器"></a>&lt;1&gt;同步复位 D 触发器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f0dd282c6d098d42d7ccbd5dcc6a8060.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9a0ef5616d5f85f5cd9134eba3f8b4af.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/19ead2babd57ed1bfbd253080790a2e8.png"></p>
<h4 id="异步复位-D-触发器"><a href="#异步复位-D-触发器" class="headerlink" title="&lt;2&gt;异步复位 D 触发器"></a>&lt;2&gt;异步复位 D 触发器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8046c5befbf38e5f3597ba0ee3ed4d54.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9b531d4379ea89303cbfd9c4322c8649.png"></p>
<h3 id="2-仿真-3"><a href="#2-仿真-3" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce8ccc7525ce5b5d56a6159fc5739653.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bde02cf87bc7d8048af7109c8740f6fb.png"></p>
<pre><code>    begin...end 是一个串行块在 Testbench 中被使用时其内部的语句是**顺序执行** 的，在本例中，我们多次进行延时，其时间是在之前基础上**叠加** 的，而不是从 0 时 刻开始计算时间。
</code></pre>
<h2 id="八-阻塞赋值与非阻塞赋值"><a href="#八-阻塞赋值与非阻塞赋值" class="headerlink" title="八.阻塞赋值与非阻塞赋值"></a>八.阻塞赋值与非阻塞赋值</h2><pre><code>    阻塞赋值的赋值号用“=”表示。对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关系。阻塞赋值的操作可以认为 是只有一个步骤的操作，即计算赋值号右边的语句并更新赋值号左边的语句，此时不允许 有来自任何其他 Verilog 语句的干扰，直到现行的赋值完成时刻，即把当前赋值号右边的值 赋值给左边的时刻完成后，它才允许下一条的赋值语句的执行。串行块（begin-end）中的各条阻塞型过程赋值语句将以它们在**顺序块后的排列次序依次执行** 。阻塞型过程赋值语句的执行过程是：首先计算赋值号右边的值，然后立即将计算结果赋值给左边，赋值语句结束，变量值立即发生改变。阻塞的概念是指在同一个 always 块中，其后面的赋值语句从概念上是在前一句赋值语句结束后再开始下面的赋值。

   非阻塞赋值的赋值号用“&lt;=”表示。对应的电路结构往往与触发沿有关系，只有在触发沿的时刻才能进行非阻塞赋值。非阻塞操作开始时计算非阻塞赋值符的赋值号右边的语句，赋值操作结束时刻才更新赋值号左 边的语句，可以认为是两个步骤（赋值开始时刻和结束时刻）来完成非阻塞赋值。在计算 非阻塞语句赋值号右边的语句和更新赋值号左边的语句期间，其他的 Verilog 语句包括其他 的 Verilog 非阻塞赋值语句都能同时计算赋值号右边的语句和更新赋值号左边的语句，**允许 其他的 Verilog 语句同时进行操作** 。非阻塞赋值的操作可以看作为两个步骤的过程：在赋值开始时刻，计算赋值号右边的语句。在赋值结束时刻，更新赋值号左边的语句。注意：非阻塞操作只能用于对寄存器类型变量进行赋值，**因此只能用于“initial”和“always”块 中，不允许用于连续赋值“assign”** 。

    **在描述逻辑电路时使用阻塞赋值，在描述时序逻辑电路时要用非阻塞赋值** ，这也 是官方的推荐写法。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/709bad310d63a8fb4530b7384ede5919.png"></p>
<h2 id="九-计数器"><a href="#九-计数器" class="headerlink" title="九.计数器"></a>九.计数器</h2><h3 id="1-实现方法-2"><a href="#1-实现方法-2" class="headerlink" title="1.实现方法"></a>1.实现方法</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1b3d9a5fc4da47dfa2eeb409d54cb4a.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a48c6951f6329e22e97c67b20b033e15.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc1c3738464e52a3b09c540e65703e3e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/13d4617698f497ba37ed751532fd025b.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/193aa0a1d5a6cc8beda043590a0a82e7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b48d646be58e4074fd5758995c1b194.png"></p>
<pre><code>    原理图可以看出由触发器组成的状态机，累加器，选择器等

    通过对比我们可以发现第一种实现方式用了 2 个 always 块，其 RTL 视图分别对应两组 触发器，而第二种实现方式用了 3 个 always 块，其 RTL 视图分别对应了 3 组触发器
</code></pre>
<h3 id="2-仿真-4"><a href="#2-仿真-4" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b64737d4cf0b4fb0e5a5ef634392b4e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cccccf928ca614d15bdc36b46caf2b3.png"></p>
<h2 id="十-分频器"><a href="#十-分频器" class="headerlink" title="十.分频器"></a>十.分频器</h2><pre><code>    无论分频和倍频，我们都有两种方式可以选择，一种是器件厂商提供的锁相环（PLL，后面章节会讲解），另一种是自己动手来用 Verilog 代码描述。用 Verilog 代码描述的往往是分频电路，即分频器。
</code></pre>
<h3 id="1-偶分频"><a href="#1-偶分频" class="headerlink" title="1.偶分频"></a>1.偶分频</h3><p><strong>方法 1 实现：仅实现分频功能</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f441c1d4aef20817a3875e82ada804c9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b6e5825667316f9e53a7c78b93238025.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb3cb18907d7b8039a8cab21a18b9a46.png"></p>
<p><strong>方法 2 实现： 实用的降频方法</strong></p>
<p>方法一中的 clk_out 输出信号是我们想要的分频后的信号，然后很多同学就直接把这个<br>信号当作新的低频时钟来使用，并实现了自己想要的功能。大家肯定会觉得能够实现功能 就一切 OK 了，而往往忽略了一些隐患的存在，如果你对 FPGA<br>的了解多一些就会理解其 实这是不严谨的做法，这种做法所衍生的潜在问题在低速系统中不易察觉，而在高速系统<br>中就很容易出现问题。因为我们通过这种方式分频得到的时钟虽然表面上是对系统时钟进<br>行了分频产生了一个新的低频时钟，但实际上和真正的时钟信号还是有很大区别的。因为在 FPGA<br>中凡是时钟信号都要连接到全局时钟网络上，<strong>全局时钟网络也称为全局时钟树， 是 FPGA<br>厂商专为时钟路径而特殊设计的，它能够使时钟信号到达每个寄存器的时间都尽 可能相同，以保证更低的时钟偏斜（Skew）和抖动（Jitter）</strong><br>。而我们用这种分频的方式产 生的 clk_out 信号并没有<strong>连接到全局时钟网络</strong> 上，但 sys_clk 则是由外部晶振直接通过管脚 连接到了<br>FPGA 的专用时钟管脚上，自然就会连接到全局时钟网络上，所以在 <strong>sys_clk 时钟 工作下的信号要比在 clk_out<br>时钟工作下的信号更容易在高速系统中保持稳定</strong> ，既然发现了 问题那我们该怎么办呢？这时可不要忘记了上一章中刚学到的 flag 标志信号，这里我们就<br>可以用上了，我们可以产生一个用于标记 6 分频的 clk_flag 标志信号，这样每两 clk_flag 脉 冲之间的频率就是对 sys_clk 时钟信号的<br>6 分频，但是计数器计数的个数我们需增加一些， 如图 17-4 所示需要从 0~5 共 6 个数，否则不能实现 6 分频的功能。和方法 1 对比可以发<br>现，相当于<strong>把 clk_out 的上升沿信号变成了 clk_flag 的脉冲电平信号</strong> （和上一章方法 2 中的 cnt_flag<br>是一样的道理），为后级模块实现相同的降频效果。虽然这样会多使用一些寄存器资源，不过不用担心我们的系统是完全可以承担的起的，而得到的好处却远远大于这点资源的使用，能让系统更加稳定。<img src="https://i-blog.csdnimg.cn/blog_migrate/a4604d25ce110aa5d7fcf14ae08cc6b7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/de1332e424bc46b895e1e0d63443eacf.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad6b10f466b0b610deb1f226a1481d6d.png"></p>
<h3 id="2-奇分频"><a href="#2-奇分频" class="headerlink" title="2.奇分频"></a>2.奇分频</h3><p>&lt;1&gt;方法一：分频（两结果或运算）</p>
<p>这里 clk1 和 clk2 都是低电平 2 个时钟周期，高电平 3 个时钟周期，clk1 和 clk2 相与的结果就是 clk_out 的波形。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6b290cd161a83a533df103f57c759bc.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c4c0e4274d427c529f6abec8fe8c648b.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/499a0fa7af357d8d9cca522a16524e9c.png"></p>
<p>&lt;2&gt;方法二：降频（同前）</p>
<p>&lt;3&gt;后面的 IP 核章节还会讲解到通过 PLL（Phase Locked Loop，即锁相环）的方法来实现对时钟的任意分频、倍频、相位 移动。</p>
<h2 id="十一-按键消抖"><a href="#十一-按键消抖" class="headerlink" title="十一.按键消抖"></a>十一.按键消抖</h2><h3 id="1-硬件消抖"><a href="#1-硬件消抖" class="headerlink" title="1.硬件消抖"></a>1.硬件消抖</h3><pre><code>    图中两个与非门构成一个 RS 触发器。当按键未按下时，输出为 0；当键按下时， 输出为 1。此时即使用按键的机械性能，使按键因弹性抖动而产生瞬时断开(抖动跳开 B)， 只要按键不返回原始状态 A，双稳态电路的状态不改变，输出保持为 0，不会产生抖动的波形。也就是说，即使 B 点的电压波形是抖动的，但经双稳态电路之后，其输出为正规的矩形波。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6893b44caf7ec63ddc68714a118b9b4.png"></p>
<h3 id="2-软件消抖"><a href="#2-软件消抖" class="headerlink" title="2.软件消抖"></a>2.软件消抖</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16ddf72ebb4d584e925a8b26d958cfaa.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8b274eaefe8b17e020a89b2ddfd461a9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5599919d9d77d3ca30d278b89288156.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a266ef72d4b7f265101a20d9fed74c1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/056d9b2536446b3eb89583eccfe55204.png"></p>
<h2 id="十二-流水灯"><a href="#十二-流水灯" class="headerlink" title="十二.流水灯"></a>十二.流水灯</h2><h3 id="1-实现-1"><a href="#1-实现-1" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/be646017aad2b634afd574b313146586.png"></p>
<p>三个计数器、cnt_en使led由暗到亮再由亮到暗</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b1bd720cad58a07bb520c880f0b80ac.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae562916815db1311874ac2adf109bfb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dab5caf57215a249ba38d858e47fb211.png"></p>
<p>可用异或简化判断语句</p>
<h3 id="2-仿真-5"><a href="#2-仿真-5" class="headerlink" title="2.仿真"></a>2.仿真</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/68e8473cbba3135dd5d8fc77423e4351.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/093258a351514dd05e83d3cf3d4e8bde.png"></p>
<p>减小三个MAX的值方便仿真观察</p>
<h2 id="十三-状态机"><a href="#十三-状态机" class="headerlink" title="十三.状态机"></a>十三.状态机</h2><pre><code>    **状态机（FSM，Finite State Machine）** ，若最后的输出只和当前状态有关而与输入无关则称为 Moore 型状态机； 若最后的输出不仅和当前状态有关还和输入有关则称为 Mealy 型状态机。

    最原始的状态我们称之为**IDLE** 状态
</code></pre>
<h3 id="1-简易可乐机"><a href="#1-简易可乐机" class="headerlink" title="1.简易可乐机"></a>1.简易可乐机</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff4a4f1a879daad7f8bfe49f24fe63b2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f705ff295f1ea2ea1e088ef15013368c.png"></p>
<pre><code>    上面是一个用 Verilog 描述的简单状态机，我们可以发现它是按照我们总结好的一套格 式来编写的，我们按照这种格式再结合状态转移图可以编写出更复杂的状态机代码，所以 我们总结一下我们套用的格式有哪些主要部分构成：
</code></pre>
<p>其中 01-09 行是端口列表部分；</p>
<p>17-19 行是状态编码部；</p>
<p>22 行是定义的状态变量；</p>
<p>29-49 行是第一段状态机部分；</p>
<p>52-58 是第二段 状态机部分。</p>
<pre><code>    一共有五部分，我们写状态机代码的时候根据这 5 部分对照着状态机依次编写，非常容易的就可以实现。 第一部分：第一部分是端口列表，和之前的设计一样没有什么特殊之处。 第二部分、第三部分：第二部分是状态编码，第三部分是状态变量，这两个是有联系 的，所以放到一起讲解。17-19 行是状态编码，状态转移图中有多少个状态数就需要有多少 个状态编码，这里一共有 3 个状态数，所以就需要 3 个状态编码。22 行是状态变量，这里 为什么状态变量的位宽是 3 呢？因为我们采用了独热码的编码方式，每个状态数只有 1 比 特为 1，其余比特都为 0，所以 3 个状态就要用 3 位宽的变量，如果是 4 个状态那就要用 4 位宽的变量，也就是一共有几个状态数就需要几位宽的状态变量。那么除了用独热码的方 式对状态进行编码，还有其他的方法吗？当然有，我们还可以采用二进制码或格雷码的方式对状态进行编码，上面的例子中如果我们用二进制码编码 3 个状态则为：2’b00， 2’b01，2’b10；而用格雷码编码 3 个状态则为：2’b00，2’b01，2’b11，都只需要 2 位宽的状态变量即可，即便是有 4 个状态数，我们使用 2 位宽的状态变量依然可以解决问题，要比独热码更节省状态变量的位宽个数。

    为什么例子中我们使用的是独热码而非二进制码或格雷码呢？那就要从每种编码的特性上说起了，首先独热码因为每个状态只有 1bit 是不同的，所以在执行到 55 行时的（state == TWO）这条语句时，综合器会识别出这是一个比较器，而因为只有 1 比特为 1，所以综**合器会进行智能优化为（state[2] == 1’b1）** ，这就相当于把之前 3 比特的比较器变为了 **1 比特的比较器** ，大大**节省了组合逻辑资源** ，但是付出的代价就是状态变量的位宽需要的比较多，而我们 FPGA 中组合逻辑资源相对较少，所以比较宝贵，而**寄存器资源较多** ，所以很完美。而二进制编码的情况和独热码刚好相反，他因为使用了较少的状态变量，使之在减 少了寄存器状态的同时无法进行比较器部分的优化，所以使用的寄存器资源较少，而使用 的组合逻辑资源较多，我们还知道 **CPLD 就是一个组合逻辑资源多而寄存器逻辑资源少的器件** ，因为这里我们使用的是 FPGA 器件，所以使用独热码进行编码。就因为这个比较部分的优化，还使得使用**独热码编码的状态机可以在高速系统上运行，其原因是多比特的比 较器每个比特到达比较器的时间可能会因为布局布线的走线长短而导致路径延时的不同， 这样在高速系统下，就会导致采集到不稳定的状态，导致比较后的结果产生一个时钟的毛刺，使输出不稳定，而单比特的比较器就不用考虑这种问题。** 下面是示意图解析。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b075f02dfe393c49623598e5ca2c5a23.png"></p>
<pre><code>    用独热码编码虽然好处多多，但是如果状态数非常多的话即使是 FPGA 也吃不消独热码对寄存器的消耗，所以当**状态数特别多的时候可以使用格雷码对状态进行编码** 。格雷码虽然也是和二进制编码一样使用的寄存器资源少，组合逻辑资源多，但是其相邻状态转换 时**只有一个状态发生翻转，这样不仅能消除状态转换时由多条信号线的传输延迟所造成的毛刺，又可以降低功耗** ，所以要优于二进制码的方式，相当于是独热码和二进制编码的折中。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/992fdf3e38def6dea07b66383225d3c4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21e5c11ef610a33d93b404ef205251e3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/277af51439649f5fd8edd3bea324ba42.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/669f0463e404b28fe73cf0b254d242bd.png"></p>
<pre><code>    第 40 行重新定义了一个 2bit 名为 state 的变量，然后通过在 Testbench 模块中实例化 RTL 模块的名字与“.”定位到 RTL 模块中的信号，如果要引入到 Testbench 模块中的信号是 RTL 模块多层实例化中最底层的信号则需要从顶层的实例化 RTL 模块的名字与“.”依次传递，直到最后定位到内部的信号。这样我们就把**RTL 模块中的内部信号引入到 Testbench 模块中** 了。之所以这样做是因为我们要在 ModelSim 的 “Transcript”界面中打印 RTL 模块中内部信号的信息以方便观察验证，直接实例化 RTL 模块的方式只能够将 **RTL 模块中的端口信号** 引入到 Testbench 模块中，而不能将 RTL 模块 的内部信号引入到 Testbench 模块中，所以无法在 ModelSim 的“Transcript”界面中观察打印的信息。
</code></pre>
<h3 id="2-复杂可乐机"><a href="#2-复杂可乐机" class="headerlink" title="2.复杂可乐机"></a>2.复杂可乐机</h3><pre><code>    输入信号除了可以投 1 元外，还可以投 0.5 元，一次只投一个币；可乐机的输出除了可乐还可能会有找零（找零的结果只有一种即找回 0.5 元），我们将可乐机输出购买可乐的信号取名为 po_cola，找零的信号取名为 po_money。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5300ccd1c590907cd2eef1605876a964.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8759c5a5b929f36c23f74d72c739fdb.png"></p>
<pre><code>    大家在画状态转移图时容易出现状态跳转情况遗漏的问题，这里我们给大家总结一个 小技巧：我们可以观察到，输入有多少种情况（上一节是两种输入情况，本节是三种输入 情况），每个状态的跳转就有多少种情况（上一节每个状态都有两种跳转情况。这样根据输入来确定状态的跳转就能够保证我们不漏掉任何一 种状态跳转。


`timescale  1ns/1ns

module  complex_fsm
(
    input   wire    sys_clk         ,   //系统时钟50MHz
    input   wire    sys_rst_n       ,   //全局复位
    input   wire    pi_money_one    ,   //投币1元
    input   wire    pi_money_half   ,   //投币0.5元
                    
    output  reg     po_money        ,   //po_money为1时表示找零
                                        //po_money为0时表示不找零
    output  reg     po_cola             //po_cola为1时出可乐
                                        //po_cola为0时不出可乐
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//parameter define
//只有五种状态，使用独热码
parameter   IDLE     = 5&#39;b00001;
parameter   HALF     = 5&#39;b00010;
parameter   ONE      = 5&#39;b00100;
parameter   ONE_HALF = 5&#39;b01000;
parameter   TWO      = 5&#39;b10000;

//reg   define
reg     [4:0]   state;

//wire  define
wire    [1:0]   pi_money;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//pi_money:为了减少变量的个数，我们用位拼接把输入的两个1bit信号拼接成1个2bit信号
//投币方式可以为：不投币（00）、投0.5元（01）、投1元（10），每次只投一个币
assign pi_money = &#123;pi_money_one, pi_money_half&#125;;

//第一段状态机，描述当前状态state如何根据输入跳转到下一状态
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        state &lt;= IDLE;  //任何情况下只要按复位就回到初始状态
    else	case(state)
                IDLE    : if(pi_money == 2&#39;b01)   //判断一种输入情况
                              state &lt;= HALF;
                          else    if(pi_money == 2&#39;b10)//判断另一种输入情况
                              state &lt;= ONE;
                          else
                              state &lt;= IDLE;
    
                HALF    : if(pi_money == 2&#39;b01)
                              state &lt;= ONE;
                          else    if(pi_money == 2&#39;b10)
                              state &lt;= ONE_HALF;
                          else
                              state &lt;= HALF;
    
                ONE     : if(pi_money == 2&#39;b01)
                              state &lt;= ONE_HALF;
                          else    if(pi_money == 2&#39;b10)
                              state &lt;= TWO;
                          else
                              state &lt;= ONE;
    
                ONE_HALF: if(pi_money == 2&#39;b01)
                              state &lt;= TWO;
                          else    if(pi_money == 2&#39;b10)
                              state &lt;= IDLE;
                          else
                              state &lt;= ONE_HALF;
    
                TWO     : if((pi_money == 2&#39;b01) || (pi_money == 2&#39;b10))
                              state &lt;= IDLE;
                          else
                              state &lt;= TWO;
        //如果状态机跳转到编码的状态之外也回到初始状态
                default :       state &lt;= IDLE;
            endcase

//第二段状态机，描述当前状态state和输入pi_money如何影响po_cola输出
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        po_cola &lt;= 1&#39;b0;
    else    if((state == TWO &amp;&amp; pi_money == 2&#39;b01) || (state == TWO &amp;&amp; 
          pi_money == 2&#39;b10) || (state == ONE_HALF &amp;&amp; pi_money == 2&#39;b10))
        po_cola &lt;= 1&#39;b1;
    else
        po_cola &lt;= 1&#39;b0;

//第二段状态机，描述当前状态state和输入pi_money如何影响po_money输出
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n ==	1&#39;b0)
        po_money &lt;= 1&#39;b0;
    else if((state == TWO) &amp;&amp; (pi_money == 2&#39;b10))
        po_money &lt;= 1&#39;b1;
    else
        po_money &lt;= 1&#39;b0;

endmodule



`timescale  1ns/1ns

module  tb_complex_fsm();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg         sys_clk;
reg         sys_rst_n;
reg         pi_money_one;
reg         pi_money_half;
reg         random_data_gen;

//wire  define
wire        po_cola;
wire        po_money;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//初始化系统时钟、全局复位
initial begin
    sys_clk    = 1&#39;b1;
    sys_rst_n &lt;= 1&#39;b0;
    #20
    sys_rst_n &lt;= 1&#39;b1;
end

//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50MHz
always  #10 sys_clk = ~sys_clk;

//random_data_gen:产生非负随机数0、1
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        random_data_gen &lt;= 1&#39;b0;
    else
        random_data_gen &lt;= &#123;$random&#125; % 2;

//pi_money_one:模拟投入1元的情况
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_money_one &lt;= 1&#39;b0;
    else
        pi_money_one &lt;= random_data_gen;

//pi_money_half:模拟投入0.5元的情况
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        pi_money_half &lt;= 1&#39;b0;
    else
    //取反是因为一次只能投一个币，即pi_money_one和pi_money_half不能同时为1
        pi_money_half &lt;= ~random_data_gen;

//------------------------------------------------------------
//将RTL模块中的内部信号引入到Testbench模块中进行观察
wire    [4:0]   state    = complex_fsm_inst.state;
wire    [1:0]   pi_money = complex_fsm_inst.pi_money;

initial begin
    $timeformat(-9, 0, &quot;ns&quot;, 6);
    $monitor(&quot;@time %t: pi_money_one=%b pi_money_half=%b pi_money=%b state=%b po_cola=%b po_money=%b&quot;, $time, pi_money_one, pi_money_half, pi_money, state, po_cola, po_money);
end
//------------------------------------------------------------

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//------------------------complex_fsm_inst------------------------
complex_fsm complex_fsm_inst(
    .sys_clk        (sys_clk        ),  //input     sys_clk
    .sys_rst_n      (sys_rst_n      ),  //input     sys_rst_n
    .pi_money_one   (pi_money_one   ),  //input     pi_money_one
    .pi_money_half  (pi_money_half  ),  //input     pi_money_half
                    
    .po_cola        (po_cola        ),  //output    po_money
    .po_money       (po_money       )   //output    po_cola
);  

endmodule
</code></pre>
<h2 id="十四-无源蜂鸣器"><a href="#十四-无源蜂鸣器" class="headerlink" title="十四.无源蜂鸣器"></a>十四.无源蜂鸣器</h2><pre><code>    蜂鸣器按其是否带有震荡源又分为有源蜂鸣器和无源蜂鸣器。有源蜂鸣器的内部装有 集成电路，不需要音频驱动电路，只需要接通直流电源就能直接发出声响。而无源蜂鸣器 只有外加音频驱动信号才能发出声响。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9739916bd01d5da854f10529de7bf04c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff8f350fea1cf05ea913f0a2cc20aed0.png"></p>
<pre><code>    这里占空比我们保持为 50%。cnt_500ms：该信号我们定义为蜂鸣器的鸣叫状态计数。由于我们需鸣叫七个音调，所 以我们需要计 7 个数（0~6），而每个音调的鸣叫时间即计数值的持续时间。所以这里我们 需要用一个鸣叫持续时间计数器去控制蜂鸣器各音调的鸣叫持续时间。 cnt：蜂鸣器各音调鸣叫持续时间计数器。在“计数器”章节我们详细的介绍了该如何 用计数器进行时间计数，这里就不详细的介绍了。本次实验我们设计让每个音调持续鸣叫 0.5s，故这里我们计数到 24999999（0.5s）时让鸣叫状态计数器加 1。当最后一个音调 （cnt_500ms = 3’d6）鸣叫了 0.5s 时，我们让状态计数器跳转回第一个音调鸣叫状态 （cnt_500ms = 3’d0），以此循环，我们就能实现蜂鸣器七个基本音调的循环鸣叫了。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5620fa45183aaca2fc841d87809c8010.png"></p>
<pre><code>    首先是音调的频率我们该如何产生？我们先计算该频率单个方波的时间：1 / 262 ≈ 0.003816794s=3816794ns；而我们单个系统时钟（50MHz）的时间为：1 / 50000000 =0.00000002s = 20ns；所以我们需用：3816794 / 20 ≈ 190840 个系统时钟去产生一个 PWM 波，该 PWM 波形的频率即为 262。故我们需先对 190840 个系统时钟进行计数，这里我们 声明 freq_cnt 信号进行计数。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/efc4721fe989ceadb077cfa024b628d1.png"></p>
<pre><code>`timescale  1ns/1ns

module  beep
#(
    parameter   TIME_500MS =   25&#39;d24999999,   //0.5s计数值
    parameter   DO  =   18&#39;d190839 ,   //&quot;哆&quot;音调分频计数值（频率262）
    parameter   RE  =   18&#39;d170067 ,   //&quot;来&quot;音调分频计数值（频率294）
    parameter   MI  =   18&#39;d151514 ,   //&quot;咪&quot;音调分频计数值（频率330）
    parameter   FA  =   18&#39;d143265 ,   //&quot;发&quot;音调分频计数值（频率349）
    parameter   SO  =   18&#39;d127550 ,   //&quot;梭&quot;音调分频计数值（频率392）
    parameter   LA  =   18&#39;d113635 ,   //&quot;拉&quot;音调分频计数值（频率440）
    parameter   XI  =   18&#39;d101214     //&quot;西&quot;音调分频计数值（频率494）
)
(
    input   wire        sys_clk     ,   //系统时钟,频率50MHz
    input   wire        sys_rst_n   ,   //系统复位，低有效

    output  reg         beep            //输出蜂鸣器控制信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg     [24:0]  cnt         ;   //0.5s计数器
reg     [17:0]  freq_cnt    ;   //音调计数器
reg     [2:0]   cnt_500ms   ;   //0.5s个数计数
reg     [17:0]  freq_data   ;   //音调分频计数值

//wire  define
wire    [16:0]  duty_data   ;   //占空比计数值

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//设置50％占空比：音阶分频计数值的一半即为占空比的高电平数
assign  duty_data   =   freq_data   &gt;&gt;    1&#39;b1;

//cnt:0.5s循环计数器
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt &lt;=  25&#39;d0;
    else    if(cnt == TIME_500MS )
        cnt &lt;=   25&#39;d0;
    else
        cnt &lt;=  cnt +   1&#39;b1;

//cnt_500ms：对500ms个数进行计数，每个音阶鸣叫时间0.5s，7个音节一循环
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_500ms   &lt;=  3&#39;d0;
    else    if(cnt == TIME_500MS &amp;&amp; cnt_500ms ==  6)
        cnt_500ms   &lt;=  3&#39;d0;
    else    if(cnt == TIME_500MS)
        cnt_500ms   &lt;=  cnt_500ms + 1&#39;b1;

//不同时间鸣叫不同的音阶
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        freq_data   &lt;=  DO;
    else    case(cnt_500ms)
        0:  freq_data   &lt;=   DO;
        1:  freq_data   &lt;=   RE;
        2:  freq_data   &lt;=   MI;
        3:  freq_data   &lt;=   FA;
        4:  freq_data   &lt;=   SO;
        5:  freq_data   &lt;=   LA;
        6:  freq_data   &lt;=   XI;
        default:  freq_data   &lt;=   DO;
    endcase

//freq_cnt：当计数到音阶计数值或跳转到下一音阶时，开始重新计数
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        freq_cnt    &lt;=  18&#39;d0;
    else    if(freq_cnt == freq_data || cnt == TIME_500MS)
        freq_cnt    &lt;=  18&#39;d0;
    else
        freq_cnt    &lt;=  freq_cnt +  1&#39;b1;

//beep：输出蜂鸣器波形
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        beep    &lt;=  1&#39;b0;
    else    if(freq_cnt &gt;= duty_data)
        beep    &lt;=  1&#39;b1;
    else
        beep    &lt;=  1&#39;b0;

endmodule



`timescale  1ns/1ns

module  tb_beep();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg     sys_clk     ;   //时钟
reg     sys_rst_n   ;   //复位

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//对时钟，复位信号赋初值
initial
    begin
        sys_clk     =   1&#39;b1;
        sys_rst_n   &lt;=  1&#39;b0;
        #100
        sys_rst_n   &lt;=  1&#39;b1;
    end

//产生时钟信号
always #10 sys_clk =   ~sys_clk;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

beep
#(
    .TIME_500MS(25&#39;d2499 ),   //0.5s计数值
    .DO        (18&#39;d190  ),   //&quot;哆&quot;音调分频计数值（频率262）
    .RE        (18&#39;d170  ),   //&quot;来&quot;音调分频计数值（频率294）
    .MI        (18&#39;d151  ),   //&quot;咪&quot;音调分频计数值（频率330）
    .FA        (18&#39;d143  ),   //&quot;发&quot;音调分频计数值（频率349）
    .SO        (18&#39;d127  ),   //&quot;梭&quot;音调分频计数值（频率392）
    .LA        (18&#39;d113  ),   //&quot;拉&quot;音调分频计数值（频率440）
    .XI        (18&#39;d101  )    //&quot;西&quot;音调分频计数值（频率494）
)
beep_inst
(
    .sys_clk     (sys_clk   ),   //系统时钟,频率50MHz
    .sys_rst_n   (sys_rst_n ),   //系统复位，低有效

    .beep        (beep      )    //输出蜂鸣器控制信号
);

endmodule
</code></pre>
<h2 id="十五-动态数码管显示"><a href="#十五-动态数码管显示" class="headerlink" title="十五.动态数码管显示"></a>十五.动态数码管显示</h2><p>让六位数码管显示从十进制数 0 开始计数，每 0.1s 加 1，一直到加到十进制数 999999。到达 999999 之后回到 0 开始重新计数。</p>
<h3 id="1-实现-2"><a href="#1-实现-2" class="headerlink" title="1.实现"></a>1.实现</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cbae469f08cf53fc9d5f56e3059bb4f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/696166e97ce5d3b1a2be055ac6dc925c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b28c0e71220e72cd013719c820965bed.png"></p>
<h4 id="data-gen"><a href="#data-gen" class="headerlink" title="&lt;1&gt;data_gen"></a>&lt;1&gt;data_gen</h4><pre><code>    生成0-999999的计数值，用20位二进制表示。bcd_8421生成6位十进制8421码。再转化成相应段码。


`timescale  1ns/1ns

module  data_gen
#(
    parameter   CNT_MAX = 23&#39;d4999_999, //100ms计数值
    parameter   DATA_MAX= 20&#39;d999_999   //显示的最大值
)
(
    input   wire            sys_clk     ,   //系统时钟，频率50MHz
    input   wire            sys_rst_n   ,   //复位信号，低电平有效

    output  reg     [19:0]  data        ,   //数码管要显示的值
    output  wire    [5:0]   point       ,   //小数点显示,高电平有效
    output  reg             seg_en      ,   //数码管使能信号，高电平有效
    output  wire            sign            //符号位，高电平显示负号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//reg   define
reg     [22:0]  cnt_100ms   ;   //100ms计数器
reg             cnt_flag    ;   //100ms标志信号

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//不显示小数点以及负数
assign  point   =   6&#39;b000_000;
assign  sign    =   1&#39;b0;

//cnt_100ms:用50MHz时钟从0到4999_999计数即为100ms
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_100ms   &lt;=  23&#39;d0;
    else    if(cnt_100ms == CNT_MAX)
        cnt_100ms   &lt;=  23&#39;d0;
    else
        cnt_100ms   &lt;=  cnt_100ms + 1&#39;b1;

//cnt_flag:每100ms产生一个标志信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_flag    &lt;=  1&#39;b0;
    else    if(cnt_100ms == CNT_MAX - 1&#39;b1)
        cnt_flag    &lt;=  1&#39;b1;
    else
        cnt_flag    &lt;=  1&#39;b0;

//数码管显示的数据:0-999_999
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data    &lt;=  20&#39;d0;
    else    if((data == DATA_MAX) &amp;&amp; (cnt_flag == 1&#39;b1))
        data    &lt;=  20&#39;d0;
    else    if(cnt_flag == 1&#39;b1)
        data    &lt;=  data + 1&#39;b1;
    else
        data    &lt;=  data;

//数码管使能信号给高即可
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        seg_en  &lt;=  1&#39;b0;
    else
        seg_en  &lt;=  1&#39;b1;

endmodule
</code></pre>
<h4 id="bcd-8421"><a href="#bcd-8421" class="headerlink" title="&lt;2&gt;bcd_8421"></a>&lt;2&gt;bcd_8421</h4><pre><code>`timescale  1ns/1ns

module  bcd_8421
(
    input   wire            sys_clk     ,   //系统时钟，频率50MHz
    input   wire            sys_rst_n   ,   //复位信号，低电平有效
    input   wire    [19:0]  data        ,   //输入需要转换的数据

    output  reg     [3:0]   unit        ,   //个位BCD码
    output  reg     [3:0]   ten         ,   //十位BCD码
    output  reg     [3:0]   hun         ,   //百位BCD码
    output  reg     [3:0]   tho         ,   //千位BCD码
    output  reg     [3:0]   t_tho       ,   //万位BCD码
    output  reg     [3:0]   h_hun           //十万位BCD码
);

//********************************************************************//
//******************** Parameter And Internal Signal *****************//
//********************************************************************//

//reg   define
reg     [4:0]   cnt_shift   ;   //移位判断计数器
reg     [43:0]  data_shift  ;   //移位判断数据寄存器
reg             shift_flag  ;   //移位判断标志信号

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//cnt_shift:从0到21循环计数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_shift   &lt;=  5&#39;d0;
    else    if((cnt_shift == 5&#39;d21) &amp;&amp; (shift_flag == 1&#39;b1))
        cnt_shift   &lt;=  5&#39;d0;
    else    if(shift_flag == 1&#39;b1)
        cnt_shift   &lt;=  cnt_shift + 1&#39;b1;
    else
        cnt_shift   &lt;=  cnt_shift;
       
//data_shift：计数器为0时赋初值，计数器为1~20时进行移位判断操作
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_shift  &lt;=  44&#39;b0;
    else    if(cnt_shift == 5&#39;d0)
        data_shift  &lt;=  &#123;24&#39;b0,data&#125;;
    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1&#39;b0))
        begin
            data_shift[23:20]   &lt;=  (data_shift[23:20] &gt; 4) ? (data_shift[23:20] + 2&#39;d3) : (data_shift[23:20]);
            data_shift[27:24]   &lt;=  (data_shift[27:24] &gt; 4) ? (data_shift[27:24] + 2&#39;d3) : (data_shift[27:24]);
            data_shift[31:28]   &lt;=  (data_shift[31:28] &gt; 4) ? (data_shift[31:28] + 2&#39;d3) : (data_shift[31:28]);
            data_shift[35:32]   &lt;=  (data_shift[35:32] &gt; 4) ? (data_shift[35:32] + 2&#39;d3) : (data_shift[35:32]);
            data_shift[39:36]   &lt;=  (data_shift[39:36] &gt; 4) ? (data_shift[39:36] + 2&#39;d3) : (data_shift[39:36]);
            data_shift[43:40]   &lt;=  (data_shift[43:40] &gt; 4) ? (data_shift[43:40] + 2&#39;d3) : (data_shift[43:40]);
        end
    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1&#39;b1))
        data_shift  &lt;=  data_shift &lt;&lt; 1;
    else
        data_shift  &lt;=  data_shift;

//shift_flag：移位判断标志信号，用于控制移位判断的先后顺序
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        shift_flag  &lt;=  1&#39;b0;
    else
        shift_flag  &lt;=  ~shift_flag;

//当计数器等于20时，移位判断操作完成，对各个位数的BCD码进行赋值
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        begin
            unit    &lt;=  4&#39;b0;
            ten     &lt;=  4&#39;b0;
            hun     &lt;=  4&#39;b0;
            tho     &lt;=  4&#39;b0;
            t_tho   &lt;=  4&#39;b0;
            h_hun   &lt;=  4&#39;b0;
        end
    else    if(cnt_shift == 5&#39;d21)
        begin
            unit    &lt;=  data_shift[23:20];
            ten     &lt;=  data_shift[27:24];
            hun     &lt;=  data_shift[31:28];
            tho     &lt;=  data_shift[35:32];
            t_tho   &lt;=  data_shift[39:36];
            h_hun   &lt;=  data_shift[43:40];
        end

endmodule
</code></pre>
<p> BCD码分类：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bbbe960d9a46469be4d41b77fe63590.png"></p>
<p> BCD码转换原理：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce08eac2cbdaba2d66e7242c75655e6e.png"></p>
<pre><code>    如上图所示，十进制数 234 其对应的二进制数为 1110_1010，首先第一步我们在其前面补上若干个 0，这里我们就需要 12 位 BCD 码，故我们就在前面补 12 个 0。 **第二步我们需要进行判断运算移位操作，首先判断每一个 BCD 码其对应的十进制数是否大于 4，如果大于 4 就对 BCD 码做加 3 操作，若小于等于 4 就让其值保持不变** 。当对每 一个 BCD 码进行判断运算后，都需要将运算后的数据像左移 1 位。移完位后我们仍按前面所述进行判断运算，判断运算后需再次移位，以此循环，当我们进行 8 次判断移位后的BCD 码部分数据就是我们转换的数据。这里需要注意的是我们**输入转换的二进制码有多少位我们就需要进行多少次判断移位操作** ，这里输入的是 8 位二进制，我们就进行 8 次判断移位操作。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2782237565cfc547af71d1efbb7664d.png"></p>
<pre><code>    cnt_shift：移位判断计数器，前面我们说到我们输入转换的二进制码有多少位我们就需要进行多少次判断移位操作，这里我们 data 数据的位宽为 20 位，所以这里我们声明移位判断计数器对移位 20 次进行判断控制。

    data_shift：移位判断数据寄存器，该寄存器用于存储移位判断操作过程中的数据，这里我们输入的二进制位宽为 20 位，待转换成的 BCD 码位宽为 24 位，所以这里我们声明该 寄存器的位宽为输入的二进制位宽和待转换完成的 BCD 码位宽之和，即 44 位。根据波形 图可知，这里我们设计当移位计数器等于 0 时寄存器的低 20 位即为待转换数据，而由于还 没开始进行转换，高 24 位的 BCD 码我们补 0 即可。

    shift_flag：移位判断操作标志信号。前面说到我们需要对数据进行移位和判断，判断在前移位在后，所以这里我们声明一个标志信号，用于控制判断和移位的先后顺序，**当 shift_flag 为低时对数据进行判断，当 shift_flag 为高时对数据进行移位** 。需要注意的是无论 是移位操作和判断操作都是在单个系统时钟下完成的，故我们判断 20 次移位 20 次在 40 个 系统时钟内就能完成。 
</code></pre>
<h4 id="seg-dynamic"><a href="#seg-dynamic" class="headerlink" title="&lt;3&gt; seg_dynamic"></a>&lt;3&gt; seg_dynamic</h4><pre><code>`timescale  1ns/1ns

module  seg_dynamic
(
    input   wire            sys_clk     , //系统时钟，频率50MHz
    input   wire            sys_rst_n   , //复位信号，低有效
    input   wire    [19:0]  data        , //数码管要显示的值
    input   wire    [5:0]   point       , //小数点显示,高电平有效
    input   wire            seg_en      , //数码管使能信号，高电平有效
    input   wire            sign        , //符号位，高电平显示负号

    output  reg     [5:0]   sel         , //数码管位选信号
    output  reg     [7:0]   seg           //数码管段选信号
);

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//

//parameter define
parameter   CNT_MAX =   16&#39;d49_999;  //数码管刷新时间计数最大值 1ms

//wire  define
wire    [3:0]   unit        ;   //个位数
wire    [3:0]   ten         ;   //十位数
wire    [3:0]   hun         ;   //百位数
wire    [3:0]   tho         ;   //千位数
wire    [3:0]   t_tho       ;   //万位数
wire    [3:0]   h_hun       ;   //十万位数

//reg   define
reg     [23:0]  data_reg    ;   //待显示数据寄存器
reg     [15:0]  cnt_1ms     ;   //1ms计数器
reg             flag_1ms    ;   //1ms标志信号
reg     [2:0]   cnt_sel     ;   //数码管位选计数器
reg     [5:0]   sel_reg     ;   //位选信号
reg     [3:0]   data_disp   ;   //当前数码管显示的数据
reg             dot_disp    ;   //当前数码管显示的小数点

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//data_reg：控制数码管显示数据
 always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_reg    &lt;=  24&#39;b0;
//若显示的十进制数的十万位为非零数据或需显示小数点，则六个数码管全显示
    else    if((h_hun) || (point[5]))
        data_reg    &lt;=  &#123;h_hun,t_tho,tho,hun,ten,unit&#125;;
//若显示的十进制数的万位为非零数据或需显示小数点，则值显示在5个数码管上
//打比方我们输入的十进制数据为20’d12345，我们就让数码管显示12345而不是012345
    else    if(((t_tho) || (point[4])) &amp;&amp; (sign == 1&#39;b1))//显示负号
        data_reg &lt;= &#123;4&#39;d10,t_tho,tho,hun,ten,unit&#125;;//4&#39;d10我们定义为显示负号
    else    if(((t_tho) || (point[4])) &amp;&amp; (sign == 1&#39;b0))
        data_reg &lt;= &#123;4&#39;d11,t_tho,tho,hun,ten,unit&#125;;//4&#39;d11我们定义为不显示
//若显示的十进制数的千位为非零数据或需显示小数点，则值显示4个数码管
    else    if(((tho) || (point[3])) &amp;&amp; (sign == 1&#39;b1))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d10,tho,hun,ten,unit&#125;;
    else    if(((tho) || (point[3])) &amp;&amp; (sign == 1&#39;b0))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,tho,hun,ten,unit&#125;;
//若显示的十进制数的百位为非零数据或需显示小数点，则值显示3个数码管
    else    if(((hun) || (point[2])) &amp;&amp; (sign == 1&#39;b1))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d10,hun,ten,unit&#125;;
    else    if(((hun) || (point[2])) &amp;&amp; (sign == 1&#39;b0))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,hun,ten,unit&#125;;
//若显示的十进制数的十位为非零数据或需显示小数点，则值显示2个数码管
    else    if(((ten) || (point[1])) &amp;&amp; (sign == 1&#39;b1))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d10,ten,unit&#125;;
    else    if(((ten) || (point[1])) &amp;&amp; (sign == 1&#39;b0))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,ten,unit&#125;;
//若显示的十进制数的个位且需显示负号
    else    if(((unit) || (point[0])) &amp;&amp; (sign == 1&#39;b1))
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d10,unit&#125;;
//若上面都不满足都只显示一位数码管
    else
        data_reg &lt;= &#123;4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,4&#39;d11,unit&#125;;

//cnt_1ms:1ms循环计数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_1ms &lt;=  16&#39;d0;
    else    if(cnt_1ms == CNT_MAX)
        cnt_1ms &lt;=  16&#39;d0;
    else
        cnt_1ms &lt;=  cnt_1ms + 1&#39;b1;

//flag_1ms:1ms标志信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        flag_1ms    &lt;=  1&#39;b0;
    else    if(cnt_1ms == CNT_MAX - 1&#39;b1)
        flag_1ms    &lt;=  1&#39;b1;
    else
        flag_1ms    &lt;=  1&#39;b0;

//cnt_sel：从0到5循环数，用于选择当前显示的数码管
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        cnt_sel &lt;=  3&#39;d0;
    else    if((cnt_sel == 3&#39;d5) &amp;&amp; (flag_1ms == 1&#39;b1))
        cnt_sel &lt;=  3&#39;d0;
    else    if(flag_1ms == 1&#39;b1)
        cnt_sel &lt;=  cnt_sel + 1&#39;b1;
    else
        cnt_sel &lt;=  cnt_sel;

//数码管位选信号寄存器
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        sel_reg &lt;=  6&#39;b000_000;
    else    if((cnt_sel == 3&#39;d0) &amp;&amp; (flag_1ms == 1&#39;b1))
        sel_reg &lt;=  6&#39;b000_001;
    else    if(flag_1ms == 1&#39;b1)
        sel_reg &lt;=  sel_reg &lt;&lt; 1;
    else
        sel_reg &lt;=  sel_reg;

//控制数码管的位选信号，使六个数码管轮流显示
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_disp    &lt;=  4&#39;b0;
    else    if((seg_en == 1&#39;b1) &amp;&amp; (flag_1ms == 1&#39;b1))
        case(cnt_sel)
        3&#39;d0:   data_disp    &lt;=  data_reg[3:0]  ;  //给第1个数码管赋个位值
        3&#39;d1:   data_disp    &lt;=  data_reg[7:4]  ;  //给第2个数码管赋十位值
        3&#39;d2:   data_disp    &lt;=  data_reg[11:8] ;  //给第3个数码管赋百位值
        3&#39;d3:   data_disp    &lt;=  data_reg[15:12];  //给第4个数码管赋千位值
        3&#39;d4:   data_disp    &lt;=  data_reg[19:16];  //给第5个数码管赋万位值
        3&#39;d5:   data_disp    &lt;=  data_reg[23:20];  //给第6个数码管赋十万位值
        default:data_disp    &lt;=  4&#39;b0        ;
        endcase
    else
        data_disp   &lt;=  data_disp;

//dot_disp：小数点低电平点亮，需对小数点有效信号取反
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        dot_disp    &lt;=  1&#39;b1;
    else    if(flag_1ms == 1&#39;b1)
        dot_disp    &lt;=  ~point[cnt_sel];
    else
        dot_disp    &lt;=  dot_disp;

//控制数码管段选信号，显示数字
always@(posedge sys_clk or  negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        seg &lt;=  8&#39;b1111_1111;
    else    
        case(data_disp)
            4&#39;d0  : seg  &lt;=  &#123;dot_disp,7&#39;b100_0000&#125;;    //显示数字0
            4&#39;d1  : seg  &lt;=  &#123;dot_disp,7&#39;b111_1001&#125;;    //显示数字1
            4&#39;d2  : seg  &lt;=  &#123;dot_disp,7&#39;b010_0100&#125;;    //显示数字2
            4&#39;d3  : seg  &lt;=  &#123;dot_disp,7&#39;b011_0000&#125;;    //显示数字3
            4&#39;d4  : seg  &lt;=  &#123;dot_disp,7&#39;b001_1001&#125;;    //显示数字4
            4&#39;d5  : seg  &lt;=  &#123;dot_disp,7&#39;b001_0010&#125;;    //显示数字5
            4&#39;d6  : seg  &lt;=  &#123;dot_disp,7&#39;b000_0010&#125;;    //显示数字6
            4&#39;d7  : seg  &lt;=  &#123;dot_disp,7&#39;b111_1000&#125;;    //显示数字7
            4&#39;d8  : seg  &lt;=  &#123;dot_disp,7&#39;b000_0000&#125;;    //显示数字8
            4&#39;d9  : seg  &lt;=  &#123;dot_disp,7&#39;b001_0000&#125;;    //显示数字9
            4&#39;d10 : seg  &lt;=  8&#39;b1011_1111          ;    //显示负号
            4&#39;d11 : seg  &lt;=  8&#39;b1111_1111          ;    //不显示任何字符
            default:seg  &lt;=  8&#39;b1100_0000;
        endcase

//sel:数码管位选信号赋值
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        sel &lt;=  6&#39;b000_000;
    else
        sel &lt;=  sel_reg;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//

//---------- bsd_8421_inst ----------
bcd_8421    bcd_8421_inst
(
    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n),   //复位信号，低电平有效
    .data        (data     ),   //输入需要转换的数据

    .unit        (unit     ),   //个位BCD码
    .ten         (ten      ),   //十位BCD码
    .hun         (hun      ),   //百位BCD码
    .tho         (tho      ),   //千位BCD码
    .t_tho       (t_tho    ),   //万位BCD码
    .h_hun       (h_hun    )    //十万位BCD码
);

endmodule
</code></pre>
<h4 id="top-seg-dynamic"><a href="#top-seg-dynamic" class="headerlink" title="&lt;4&gt;top_seg_dynamic"></a>&lt;4&gt;top_seg_dynamic</h4><pre><code>`timescale  1ns/1ns

module  top_seg_dynamic
(
    input   wire            sys_clk     ,   //系统时钟，频率50MHz
    input   wire            sys_rst_n   ,   //复位信号，低电平有效

    output  wire    [5:0]   sel         ,   //数码管位选信号
    output  wire    [7:0]   seg             //数码管段选信号
);

//********************************************************************//
//******************** Parameter And Internal Signal *****************//
//********************************************************************//
//wire  define
wire    [19:0]  data    ;   //数码管要显示的值
wire    [5:0]   point   ;   //小数点显示,高电平有效top_seg_595
wire            seg_en  ;   //数码管使能信号，高电平有效
wire            sign    ;   //符号位，高电平显示负号

//********************************************************************//
//**************************** Main Code *****************************//
//********************************************************************//
//-------------data_gen_inst--------------
data_gen    data_gen_inst
(
    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n),   //复位信号，低电平有效
    
    .data        (data     ),   //数码管要显示的值
    .point       (point    ),   //小数点显示,高电平有效
    .seg_en      (seg_en   ),   //数码管使能信号，高电平有效
    .sign        (sign     )    //符号位，高电平显示负号
);

//-------------seg7_dynamic_inst--------------

seg_dynamic seg_dynamic_inst
(
    .sys_clk     (sys_clk  ),   //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n),   //复位信号，低有效
    .data        (data     ),   //数码管要显示的值
    .point       (point    ),   //小数点显示,高电平有效
    .seg_en      (seg_en   ),   //数码管使能信号，高电平有效
    .sign        (sign     ),   //符号位，高电平显示负号

    .sel         (sel      ),   //数码管位选信号
    .seg         (seg      )    //数码管段选信号

);

endmodule
</code></pre>
<h3 id="2-仿真-6"><a href="#2-仿真-6" class="headerlink" title="2.仿真"></a>2.仿真</h3><pre><code>`timescale  1ns/1ns

// Author  : EmbedFire
// 实验平台: 野火FPGA系列开发板
// 公司    : http://www.embedfire.com
// 论坛    : http://www.firebbs.cn
// 淘宝    : https://fire-stm32.taobao.com


module  tb_top_seg_dynamic();

//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire    sel    ;   //数码管位选信号
wire    seg    ;   //数码管段选信号


//reg   define
reg     sys_clk     ;
reg     sys_rst_n   ;

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//对sys_clk,sys_rst_n赋初始值
initial
    begin
        sys_clk     =   1&#39;b1;
        sys_rst_n   &lt;=  1&#39;b0;
        #100
        sys_rst_n   &lt;=  1&#39;b1;
    end

//clk:产生时钟
always  #10 sys_clk &lt;=  ~sys_clk;

//重新定义参数值，缩短仿真时间
defparam  top_seg_dynamic_inst.seg_dynamic_inst.CNT_MAX =    9;
defparam  top_seg_dynamic_inst.data_gen_inst.CNT_MAX    =  239;

//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------- seg_595_static_inst -------------
top_seg_dynamic  top_seg_dynamic_inst
(
    .sys_clk     (sys_clk   ),  //系统时钟，频率50MHz
    .sys_rst_n   (sys_rst_n ),  //复位信号，低电平有效

    .sel         (sel       ),  //串行数据输入
    .seg         (seg       )   //输出使能信号
);

endmodule
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807">https://blog.csdn.net/qq_32971095/article/details/132314807</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">HDL语法——FPGA学习笔记＜1＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 23:19:14" itemprop="dateCreated datePublished" datetime="2023-08-15T23:19:14+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>542</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E6%A6%82%E8%BF%B0">一.Verilog概述</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%85%B7%E4%BD%93%E8%AF%AD%E6%B3%95">二.Verilog具体语法</a></p>
<p><a href="about:blank#1.%E6%A0%87%E8%AF%86">1.标识</a></p>
<p><a href="about:blank#2.%E9%80%BB%E8%BE%91%E5%80%BC">2.逻辑值</a></p>
<p><a href="about:blank#3.%E5%B8%B8%E9%87%8F">3.常量</a></p>
<p><a href="about:blank#4.%E5%8F%98%E9%87%8F">4.变量</a></p>
<p><a href="about:blank#5.%E5%8F%82%E6%95%B0">5.参数</a></p>
<p><a href="about:blank#6.%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">6.赋值语句</a></p>
<p><a href="about:blank#7.%E8%BF%90%E7%AE%97%E7%AC%A6">7.运算符</a></p>
<p><a href="about:blank#8.%E8%AF%AD%E5%8F%A5">8.语句</a></p>
<p><a href="about:blank#9.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">9.系统函数</a></p>
<hr>
<p>参考书目：《野火FPGA Verilog 开发实战指南》</p>
<h2 id="一-Verilog概述"><a href="#一-Verilog概述" class="headerlink" title="一.Verilog概述"></a>一.Verilog概述</h2><p>1.IEEE定义标准Verilog语法参考文档</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/1620780" title="IEEE Standard for Verilog Hardware Description
Language">IEEE Standard for Verilog Hardware Description Language<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://ieeexplore.ieee.org/document/1620780</a><img src="https://i-blog.csdnimg.cn/blog_migrate/f28180bb6ad7d5e7cf2d0be08bed5b87.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42b3b557654abe4183f82a59a0ba6d84.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/83f261e770d0298d5b3c99ef2a82a1af.png"></p>
<h2 id="二-Verilog具体语法"><a href="#二-Verilog具体语法" class="headerlink" title="二.Verilog具体语法"></a>二.Verilog具体语法</h2><p>**  KEY WORD：标识符、逻辑值、常量、变量、参数、赋值语句、注释、运算符、语句、系统函数**</p>
<h3 id="1-标识"><a href="#1-标识" class="headerlink" title="1.标识"></a>1.标识</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5faa8d75ee441d53d178a116fc8754d8.png"></p>
<h3 id="2-逻辑值"><a href="#2-逻辑值" class="headerlink" title="2.逻辑值"></a>2.逻辑值</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90dc5515dae6c757c524019fa8383c66.png"></p>
<h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcf1e8adfc490d537036a7ab48c212e7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/019cf81e0945052440e899cf52edd6cb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d078c9fd4a40ce4295d4b0744c878321.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18d269aa4707511f0473895823444f06.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb92bfc53bec3fd438009b3ae9a773f.png"></p>
<h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d098bdb00c939fa2dcf3efe1100fb3b.png"></p>
<h3 id="5-参数"><a href="#5-参数" class="headerlink" title="5.参数"></a>5.参数</h3><p>有parameter和localparam两种，前者可以通过实例化在model外部改变</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bf3c357e7436845ff568400d9196dc4e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3be814a053d3080ca8ca49ad54ab5a65.png"></p>
<h3 id="6-赋值语句"><a href="#6-赋值语句" class="headerlink" title="6.赋值语句"></a>6.赋值语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39d62da1b54d44b352732de96396a766.png"></p>
<h3 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edd387a12d3e04f5571e0679c848aebb.png"></p>
<p> 注:^异或运算</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3c0a5e86253afeb65e89f7f4e001e28c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/908f2d529d157eac38981769103cf85a.png"></p>
<h3 id="8-语句"><a href="#8-语句" class="headerlink" title="8.语句"></a>8.语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efec5da318903ecd4b9ebe1870d3c8db.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2fbf03e1dc5171c9a448486ed7563340.png"></p>
<h3 id="9-系统函数"><a href="#9-系统函数" class="headerlink" title="9.系统函数"></a>9.系统函数</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1b041ff1b50feb52ba7288198de8082.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca2d1eaf85929c7ff512190c9a77271.png"></p>
<p> wirte与display区别：不自动换行</p>
<p>strobe：最后执行<img src="https://i-blog.csdnimg.cn/blog_migrate/fac806b50bdd1a8089f129b7e824e507.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4be67eab72d8fffa966896974f67a64.png"></p>
<p>monitor：当变量变化时打印</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb492cf19fd7d3df4ad2a237caf4ee09.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87b31817095385274983dbecfcaab5d1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/71bdc0b1d1cd629da73bac8834b0c764.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4b45c51ab3699a795f370bf588fd3e7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/367dd47eb20337132f7bf1dd5641e3f1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6e281793195ce7abdddbcbc97812adb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21be8673f8f0217c17967439be42ccdd.png"></p>
<p>注：a是位宽为8bit，深度为20的存储器；reg [7:0]是一个变量类型</p>
<p>三.VHDL概述</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209">https://blog.csdn.net/qq_32971095/article/details/132308209</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/10/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/10/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/" class="post-title-link" itemprop="url">FPGA基本概念及资源整理——FPGA学习笔记＜0＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-10 23:39:14" itemprop="dateCreated datePublished" datetime="2023-08-10T23:39:14+08:00">2023-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p>
<p><a href="about:blank#%E4%B8%80.FPGA%C2%A0">一.FPGA </a></p>
<p><a href="about:blank#%E4%BA%8C.FPGA%2BAI">二.FPGA+AI</a></p>
<p><a href="about:blank#%E4%B8%89.HDL">三.HDL</a></p>
<p><a href="about:blank#%E5%9B%9B.XILINX">四.XILINX</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">五.学习资源</a></p>
<p><a href="about:blank#%E5%85%AD.%E5%85%B6%E4%BB%96">六.硬件命名规则</a></p>
<p><a href="about:blank#%E4%B8%83.vivado%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">七.vivado使用介绍</a></p>
<p>[八.FPGA Arm-Cortex-M1软核配置](about:blank#%E5%85%AB.FPGA%20Arm-<br>Cortex-M1%E8%BD%AF%E6%A0%B8%E9%85%8D%E7%BD%AE)</p>
<p><a href="about:blank#%E4%B9%9D.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">九.xilinx Zynq UltraScale+ MPSoC
</a></p>
<p><a href="about:blank#%E5%8D%81.%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E6%B1%87%E6%80%BB">十.学习实践汇总</a></p>
<hr>
<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><p>作者的“FPGA学习笔记”系列将采用野火 XILINX-Artix7-FPGA 升腾开发板作为学习平台进行学习，总结学习过程中的收获。</p>
<p><strong>学习实践汇总</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="​​​​​​verilog语法——FPGA学习笔记＜1＞">​​​​​​verilog语法——FPGA学习笔记＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132308209?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞xilinx FPGA<br>verilog工程设计流程<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132314807?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132779996?spm=1001.2014.3001.5502" title="基础设计二（IP核）——FPGA学习笔记＜3＞">基础设计二（IP核）——FPGA学习笔记＜3＞xilinx fpga<br>基础设计学习笔记，学习资料来自野火<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132779996?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132818565?spm=1001.2014.3001.5502" title="基础设计三（RS232、I2C）——FPGA学习笔记＜4＞">基础设计三（RS232、I2C）——FPGA学习笔记＜4＞参考书目：《野火FPGA Verilog<br>开发实战指南》<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132818565?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132993678?spm=1001.2014.3001.5502" title="基础设计四（信号采集、发生）——FPGA学习笔记＜5＞">基础设计四（信号采集、发生）——FPGA学习笔记＜5＞频率测量法：在时间 t 内对被测时钟信号的时钟周期 N<br>进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。周期测量法：先测量出被测时钟信号的时钟周期 T，然后根据频率 f &#x3D; 1／T<br>求出被测时钟信号的频率。但是上述两种方法都会产生±1<br>个被测时钟周期的误差，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量，但二者都不能兼顾高低频率同样精度的测量要求。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132993678?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133174030?spm=1001.2014.3001.5502" title="基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞">基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态，<br>但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会<br>改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率<br>的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少。​。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133174030?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133233092?spm=1001.2014.3001.5502" title="Zynq简介——FPGA学习笔记＜7＞">Zynq简介——FPGA学习笔记＜7＞Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on<br>Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和<br>Virtex 系列。每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和<br>UltraScale+（16nm），以提供不同的性能和功耗比。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133233092?spm&#x3D;1001.2014.3001.5502</a></p>
<h2 id="一-FPGA"><a href="#一-FPGA" class="headerlink" title="一.FPGA"></a>一.FPGA</h2><p>1.FPGA——可编程逻辑器件，大家都知道。大家可能之前还做过电子线路实验，用过Quartus II，但是当看到各种各样的型号比如Xilinx<br>Artix-7 XC7A35T、Altera Cyclone IV<br>EP4CE10时完全不知道这是什么，推荐看一下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117974989" title="FPGA最全科普总结">FPGA最全科普总结</a></p>
<p>大家还会看到Soc这个词，实际上就像是以前学的mcu：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lqingqing/article/details/51566841" title="MCU, SOC 区别">MCU, SOC<br>区别</a></p>
<p>2.关键名词：</p>
<p>可编程逻辑器件(PLD,Programmable Logic Device)</p>
<p>可编程整列逻辑(PAL,Progarmmable Array Logic)</p>
<p>CPLD(Complex Progarmmable Logic Device)</p>
<p>FPGA(Field Programmable Gate Array)</p>
<p>FPGA配置模式：并行主模式为一片FPGA加一片EPROM的方式；主从模式可以支持一片PROM编程多块FPGA；串行模式可以采用串行PROM编程FPGA；外设模式可以将FPGA作为微处理器的外设，由微处理器对其进行编程</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/efb548d7fce00591ae02781195aab027.png" alt="da0a19b036704759be5eef2f40178dcd.png"></p>
<p>详细硬件介绍：参考图书或</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EE411475Z/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="从零开始系统学FPGA">从零开始系统学FPGA</a></p>
<h2 id="二-FPGA-AI"><a href="#二-FPGA-AI" class="headerlink" title="二.FPGA+AI"></a>二.FPGA+AI</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/89259418a2a5dcdcc118aea94879ed42.png" alt="0b2255268293419fa2598d8863ca129f.png"><br>用FPGA来干什么？方向FPGA+AI：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428224002" title="Xilinx助力FPGA+AI时代">Xilinx助力FPGA+AI时代</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/152167194?source_id=1005" title="两大FPGA公司的“AI技术路线">两大FPGA公司的“AI技术路线</a></p>
<p>FPGA在AI领域的优势：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv13109378/?spm_id_from=333.999.collection.opus.click" title="FPGA图像处理的前景如何？">FPGA图像处理的前景如何？</a></p>
<h2 id="三-HDL"><a href="#三-HDL" class="headerlink" title="三.HDL"></a>三.HDL</h2><p>1.FPGA使用硬件描述语言，可参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617299598" title="《Verilog》·第2章·硬件描述语言基础">《Verilog》·第2章·硬件描述语言基础</a></p>
<p>可能会用到的知识：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337168442583105536&__biz=MzIyMDc2NTQ0Mw==#wechat_redirect" title="基于Verilog的图像处理实现">基于Verilog的图像处理实现</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e33ffc8e402126dade14098a34c12b84.png" alt="01fbbd3b3ead49f68bc9187966e35cf5.png"><br>2.VHDL(VHSIC[Very-High-Speed Integrated Circuit] hardware Description<br>Language)</p>
<p>VHDL支持多层次抽象描述： <strong><strong>行为层次（Behavioral）关注模块功能描述和仿真验证；寄存器传输层次（RTL，Register Transfer<br>Level）关注模块的可综合电路的实现；逻辑门层次（Logic）考虑如何用门级电路实现给定功能；布图层次（Lay<br>Out）考虑如何将电路适配到FPGA的资源中。</strong></strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcec777e5ea768a2abd0eb8059465495.jpeg" alt="a66a88467432488caf83079131890d3d.jpeg"></p>
<p>VHDL基本设计单元：实体（Entity）、构造体（Architecture）、配置（Configuration）；包集合（Package）；库（Library）</p>
<p>3.Verilog HDL</p>
<h2 id="四-XILINX"><a href="#四-XILINX" class="headerlink" title="四.XILINX"></a>四.XILINX</h2><p>xilinx公司的产品系列：<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-devices/fpga.html" title="FPGA 和 3D IC (xilinx.com)">FPGA 和 3D IC<br>(xilinx.com)</a></p>
<p>文档搜索库：<a target="_blank" rel="noopener" href="https://docs.xilinx.com/" title="Homepage • AMD Adaptive Computing
Documentation Portal (xilinx.com)">Homepage • AMD Adaptive Computing Documentation Portal<br>(xilinx.com)</a></p>
<p>Artix-7官方文档：[搜索结果 • AMD 自适应计算文档门户<br>(xilinx.com)](<a target="_blank" rel="noopener" href="https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&content-">https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&amp;content-</a><br>lang&#x3D;en-US “搜索结果 • AMD 自适应计算文档门户 (xilinx.com)“)</p>
<p>设计软件平台：</p>
<p>xilinx开发工具有哪些：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv17335988/?spm_id_from=333.999.collection.opus.click" title="Vitis AI 系列视频 QA&amp;目录（待续）">Vitis AI 系列视频<br>QA&amp;目录（待续）</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e0feb3e8280ba4e06a7efb6f968a73b.png" alt="b6db89dc700f40f7bcd5b85b40226fe7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/477090c37771b370ac8383bca92b9df3.png" alt="2b70623234004a648a9341940d8cc42d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a884e13a6ae351570f5d5a459a8e6615.png" alt="8bf4e434fdf24062be63b880cc577862.png"></p>
<p> Vitis-AI：[Vitis AI (xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/design-">https://china.xilinx.com/products/design-</a><br>tools&#x2F;vitis&#x2F;vitis-<br>ai.html#:~:text&#x3D;Vitis%E2%84%A2%20AI%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%20Xilinx%20%E7%9A%84%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%9C%A8%20Xilinx%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%8C%85%E6%8B%AC%E8%BE%B9%E7%BC%98%E5%99%A8%E4%BB%B6%E5%92%8C%20Alveo,Vitis%20AI%20%E4%BB%A5%E9%AB%98%E6%95%88%E6%98%93%E7%94%A8%E4%B8%BA%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E5%8F%AF%E5%9C%A8%20Xilinx%20FPGA%20%E5%92%8C%20ACAP%20%E4%B8%8A%E5%85%85%E5%88%86%E5%8F%91%E6%8C%A5%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8A%A0%E9%80%9F%E7%9A%84%E6%BD%9C%E5%8A%9B%E3%80%82.<br>“Vitis AI (xilinx.com)“)</p>
<p>Vitis-AI官方支持：<a target="_blank" rel="noopener" href="https://china.xilinx.com/developer/products/vitis-ai.html" title="Vitis
AI 快速上手 (xilinx.com)">Vitis AI 快速上手<br>(xilinx.com)</a></p>
<p>视频：[Vitis AI 全流程讲解<br>(xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-">https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-</a><br>to-finish_FanZhang_region.html “Vitis AI 全流程讲解 (xilinx.com)“)</p>
<p>Vitis下载：<a target="_blank" rel="noopener" href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vitis.html" title="下载 (xilinx.com)">下载<br>(xilinx.com)</a></p>
<p>注：Vitis是为无FPGA设计经验的人设计的软件开发平台；Vitis-AI是面向算法开发者进行深度学习开发的高级加速库和设计工具；频繁出现的DPU：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145142691" title="科普 | 什么是DPU？">科普 | 什么是DPU？</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4c07fd2ab54f220e025e0ba093c633b.png" alt="7a9ddd30cbdf4a63b7835c9b544bbe84.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/715135ad31ba1890ad0059989b959629.png" alt="96dccbd6cf2047299a08800ca75c7427.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/28c6afc7b5621b2c4ef9da58d3121937.png"></p>
<p>Model Zoo：使用公共数据集训练良好的Caffe、pytorch、TensorFlow框架模型</p>
<p>处理流程：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f36b2ab3b83d541a095d93b84af4e6c3.png" alt="2504e79b6665483da00848b8f78ee776.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/09e7b9fd2103db6fbce09719a58a1d52.png" alt="4a08eebc031e484090a0653b6b345ce2.png"></p>
<p>相关问题对话ChatGPT：<a target="_blank" rel="noopener" href="https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f">https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f</a></p>
<p>xilinx社区：<a target="_blank" rel="noopener" href="https://xilinx.eetrend.com/" title="电子创新网赛灵思社区 | 电子创新网 (eetrend.com)">电子创新网赛灵思社区 | 电子创新网 (eetrend.com)</a></p>
<p>xilinx技术支持社区：<a target="_blank" rel="noopener" href="https://support.xilinx.com/s/?language=zh_CN" title="主页 (xilinx.com)">主页 (xilinx.com)</a></p>
<h2 id="五-学习资源"><a href="#五-学习资源" class="headerlink" title="五.学习资源"></a>五.学习资源</h2><p>1.竞赛平台提供</p>
<p>FPGA创新大赛：<a target="_blank" rel="noopener" href="http://fpga.icisc.cn/video?value=4" title="培训视频_全国大学生fpga创新设计竞赛官网">培训视频_全国大学生fpga创新设计竞赛官网</a></p>
<p>龙芯杯：[LoongsonEdu&#x2F;nscscc-wiki (gitee.com)](<a target="_blank" rel="noopener" href="https://gitee.com/loongson-">https://gitee.com/loongson-</a><br>edu&#x2F;nscscc-wiki “LoongsonEdu&#x2F;nscscc-wiki (gitee.com)“)</p>
<p>英特尔杯：[英特尔杯在线培训中心](<a href="https://www.xn--48sz67d.xn--">https://www.xn--48sz67d.xn--</a><br>fiqs8s&#x2F;p&#x2F;t_pc&#x2F;course_pc_detail&#x2F;big_column&#x2F;p_624f9a63e4b04e8d902ce9ce<br>“英特尔杯在线培训中心”)</p>
<p>2.野火资源</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA系列Xilinx Artix7教学视频">FPGA系列Xilinx<br>Artix7教学视频</a></p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/products/link/zh/latest/index.html" title="野火产品资料下载中心">野火产品资料下载中心</a></p>
<p>3.图书资源</p>
<p>《XILINX FPGA设计基础》《XILINX FPGA权威设计指南》《野火FPGAVerilog开发实战指南》</p>
<p>4.b站资源</p>
<p>推荐up主视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dg4y1v7P8/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="第0期 - 介绍与规划 -基于FPGA的数字信号处理系统开发笔记">第0期 - 介绍与规划<br>-基于FPGA的数字信号处理系统开发笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/505234/channel/collectiondetail?sid=308669" title="Vitis&#x2F;Vitis AI开发笔记">Vitis&#x2F;Vitis<br>AI开发笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/473639301/channel/collectiondetail?sid=852953" title="ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis HLS开发">ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis<br>HLS开发</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/2139404925/channel/collectiondetail?sid=197586" title="FPGA图像处理">FPGA图像处理</a></p>
<p>5.正点原子资料</p>
<p>[MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档](<a target="_blank" rel="noopener" href="http://www.openedv.com/docs/boards/fpga/zdyz-">http://www.openedv.com/docs/boards/fpga/zdyz-</a><br>MPSOC.html “MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档”)</p>
<h2 id="六-硬件命名规则"><a href="#六-硬件命名规则" class="headerlink" title="六.硬件命名规则"></a>六.硬件命名规则</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9226e376971648da400fbec74c13e90.png" alt="3e62452446cd4e6db0ddeefee5a67020.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/31c9c122639646bdec9d69319b9313b3.png" alt="b3c7340adb9443c79cae1972129a00b7.png"><br>芯片资源</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/03842299e0ad76ca983e82f57289b07c.png" alt="1efa2f0f7686467791b576d34bc3d035.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/798af551557b2512a1d100f95fed5b77.png" alt="445d93be180549c688a0fe8c5617979b.png"></p>
<h2 id="七-vivado使用介绍"><a href="#七-vivado使用介绍" class="headerlink" title="七.vivado使用介绍"></a>七.vivado使用介绍</h2><p>参考《xilinx fpga权威设计指南》</p>
<p>1.首先书目介绍了新一代UltraScale结构，介绍了其CLB，包含LUT、触发器、查找表什么的，以此构成多路复用器、进位逻辑、存储等基本结构。（粗略浅看未看完）</p>
<p>2.vivado以前的版本是个IDE，现在出现了GUI，前后者的关系类似Windows的shell和图形界面的关系。而在之前所使用的是 **XDC  **语言，由标准约束语言 **Tcl  **演变而来，二者相似。vivado工程目录下的 .Journal 文件和 .Log 文件则可以记录Tcl命令和执行反馈，据此可在工程调试中导出.Journal文件制成Tcl命令脚本，实现快速自动化处理。<a target="_blank" rel="noopener" href="https://xilinx.eetrend.com/content/2019/100046350.html#:~:text=XDC%20%E6%98%AF%20Xilinx%20Design%20Constraints%20%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%8C%E4%BD%86%E5%85%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%9D%A5%E6%BA%90%E4%BA%8E%E4%B8%9A%E7%95%8C%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BA%A6%E6%9D%9F%E8%A7%84%E8%8C%83SDC%E3%80%82%20XDC%20%E5%9C%A8%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF,I%2FO%20%E7%AD%89%E8%AF%AD%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%9C%A8%20Vivado%20%E4%B8%AD%20source%20%E4%B8%80%E4%B8%AA%20Tcl%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%A1%A5%E5%85%85%E3%80%82" title="XDC时钟约束 | 电子创新网赛灵思社区">XDC时钟约束 | 电子创新网赛灵思社区</a></p>
<p>3.接下来介绍vivado集成开发界面：</p>
<p>打开主界面三栏：快速开始（包含打开&#x2F;创建工程、<strong>打开示例工程</strong><br>）、Task（IP核操作、硬件管理器【要连接板子，下载步骤时也要打开】、Tcl商店）、资料中心（文档、<strong>视频</strong> 、注释向导）</p>
<p>任意打开一个工程，主界面左侧<strong>FlowNavigator（流程向导）</strong> ，包含：工程管理器（添加原文件、IP目录）、IP<br>集成器（设计用户IP核）、仿真、<strong>RTL分析（RTL ANALYSIS【<a target="_blank" rel="noopener" href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513" title="RTL
闪退解决">RTL<br>闪退解决</a>】，生成网表图、硬件引脚连接，生成.XDC文件）、综合（SYNTHESIS）、实现（IMPLEMENTATION）</strong>、编程和调试（生成比特流、打开硬件管理器）</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhikaidetb/article/details/128295529" title="Vivado的RTL分析（RTL analysis）、综合（synthesis）和实现（implementation）的区别？">Vivado的RTL分析（RTL<br>analysis）、综合（synthesis）和实现（implementation）的区别？</a></p>
<p><strong>源窗口Source</strong> ，用于管理工程源文件，Hierarchy（层次）将工程按层次分组展示，Compile<br>order可设置工程文件编译顺序，文件右键点击set as top可设置为顶层文件。</p>
<p>4.然后是高层次综合工具Vidado HLS</p>
<p>原理即<strong>将高级语言如c&#x2F;c++转换成RTL级实现，还支持OpenCV函数</strong></p>
<h2 id="八-FPGA-Arm-Cortex-M1软核配置"><a href="#八-FPGA-Arm-Cortex-M1软核配置" class="headerlink" title="八.FPGA Arm-Cortex-M1软核配置"></a>八.FPGA Arm-Cortex-M1软核配置</h2><pre><code>    打开vivado IP manager，搜索 arm 显示可使用的 arm 核——Arm-Cortex-M1，若未安装可点击链接下载。Arm 官网下载 IP 核需要提前一周注册，提供免费使用的 IP 核有 M1 和 M3。
</code></pre>
<h2 id="九-xilinx-Zynq-UltraScale-MPSoC"><a href="#九-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="九.xilinx Zynq UltraScale+ MPSoC"></a>九.xilinx Zynq UltraScale+ MPSoC</h2><p>[Zynq UltraScale+ MPSoC](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivity
for ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p>
<p><a target="_blank" rel="noopener" href="http://www.pynq.io/" title="PYNQ -
Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p>
<pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。

    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132220627">https://blog.csdn.net/qq_32971095/article/details/132220627</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/07/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/07/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">2023年电赛E题完整设计暨电赛全记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-07 23:56:59" itemprop="dateCreated datePublished" datetime="2023-08-07T23:56:59+08:00">2023-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1">一.2023年E题完整设计</a></p>
<p><a href="about:blank#%3C1%3E%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88">&lt;1&gt;选择方案</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务一：实现按键按下复位（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务二：实现激光点绕边框一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务三：实现激光点绕A4纸边缘一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89">任务四：实现绿色激光追踪红色激光（发挥部分）</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D">&lt;2&gt;任务分配</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">&lt;3&gt;代码分析</a></p>
<p><a href="about:blank#1.stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.stm32上关键源码分析</a></p>
<p><a href="about:blank#I.%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86">I.基本部分</a></p>
<p><a href="about:blank#II.%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81">II.模块代码</a></p>
<p><a href="about:blank#%281%29Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97">(1)Timer——定时器延时函数模块</a></p>
<p><a href="about:blank#%282%29servo_motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">(2)servo_motor——云台舵机控制模块</a></p>
<p><a href="about:blank#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC">①控制舵机的旋转</a></p>
<p><a href="about:blank#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9">②控制激光点到达某一像素点</a></p>
<p><a href="about:blank#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson%20nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87">③与上位机jetson<br>nano通讯接收点坐标</a></p>
<p><a href="about:blank#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC">④得到一点坐标对应的舵机pwm波OC值</a></p>
<p><a href="about:blank#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF">⑤控制激光点沿四边形巡线</a></p>
<p><a href="about:blank#III.%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86">III.主函数与中断函数部分</a></p>
<p><a href="about:blank#%281%29%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(1)红色激光云台</a></p>
<p><a href="about:blank#%282%29%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(2)绿色激光云台</a></p>
<p><a href="about:blank#2.jetson%20nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2.jetson<br>nano上关键源码分析</a></p>
<p><a href="about:blank#I.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4">I.相机参数的调整</a></p>
<p><a href="about:blank#II.%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95">II.关键识别算法</a></p>
<p><a href="about:blank#%281%29%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(1)铅笔线识别及顶点的计算</a></p>
<p><a href="about:blank#%282%29A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(2)A4纸顶点识别及巡线顶点的计算</a></p>
<p><a href="about:blank#%283%29%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89">(3)区分红绿激光</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">二.学习资料分享</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A">&lt;1&gt;学习笔记</a></p>
<p><a href="about:blank#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99%EF%BC%9A">&lt;2&gt;其他资料</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95">三.备赛阶段记录</a></p>
<p><a href="about:blank#%E5%9B%9B.%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD">四.电赛总结及经验教训</a></p>
<p><a href="about:blank#%3C1%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84%EF%BC%9A">&lt;1&gt;本次比赛作品的不足、改进之处</a></p>
<p><a href="about:blank#%3C2%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%EF%BC%9A">&lt;2&gt;本次比赛的经验教训</a></p>
<hr>
<p>“愿大家都少走弯路，在迷茫时看到希望！”</p>
<h3 id="一-2023年E题完整设计"><a href="#一-2023年E题完整设计" class="headerlink" title="一.2023年E题完整设计"></a>一.2023年E题完整设计</h3><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="&lt;1&gt;选择方案"></a>&lt;1&gt;选择方案</h3><h4 id="任务一：实现按键按下复位（基础部分）"><a href="#任务一：实现按键按下复位（基础部分）" class="headerlink" title="任务一：实现按键按下复位（基础部分）"></a>任务一：实现按键按下复位（基础部分）</h4><p>方法①：识别四顶点位置-&gt;连接对角线得到中心点-&gt;PID调节使激光点与中心点重合</p>
<p>方法②：识别四顶点位置-&gt;对角顶点坐标求平均值得中心点位置-&gt;PID调节使重合</p>
<p>方法③：固定所有器件位置，保证各点PWM值不变，得到中心点PWM固定值，开环设定</p>
<h4 id="任务二：实现激光点绕边框一周（基础部分）"><a href="#任务二：实现激光点绕边框一周（基础部分）" class="headerlink" title="任务二：实现激光点绕边框一周（基础部分）"></a>任务二：实现激光点绕边框一周（基础部分）</h4><p>步骤I：激光点由中心点到达边线左上角</p>
<p>步骤II：顺时针绕一圈</p>
<pre><code>    方法①：两点定线，先确定两点坐标，连线确定等分点，使用PID算法在等分点间移动

    方法②：不使用PID，利用与目标点坐标差计算移动方向，每次移动距离为舵机最小精度值

    方法③：求PWM和坐标(x,y)的函数关系（近似线性），直接设定PWM值到达指定点
</code></pre>
<h4 id="任务三：实现激光点绕A4纸边缘一周（基础部分）"><a href="#任务三：实现激光点绕A4纸边缘一周（基础部分）" class="headerlink" title="任务三：实现激光点绕A4纸边缘一周（基础部分）"></a>任务三：实现激光点绕A4纸边缘一周（基础部分）</h4><p>（与任务二区别：矩形放置角度可以倾斜；要区分两矩形宽度以识别A4纸）</p>
<h4 id="任务四：实现绿色激光追踪红色激光（发挥部分）"><a href="#任务四：实现绿色激光追踪红色激光（发挥部分）" class="headerlink" title="任务四：实现绿色激光追踪红色激光（发挥部分）"></a>任务四：实现绿色激光追踪红色激光（发挥部分）</h4><p>方法①：区分红绿色激光并得到坐标-&gt;PID直接跟踪</p>
<h3 id="任务分配"><a href="#任务分配" class="headerlink" title="&lt;2&gt;任务分配"></a>&lt;2&gt;任务分配</h3><p>将上述任务分解成多个要完成的技术，以便分工：</p>
<p>1.硬件平台搭建</p>
<p>2.stm32控制算法：</p>
<p>①PID控制激光点移动到目标点算法（核心）</p>
<p>②舵机以最小分度值移动算法（细微调节）</p>
<p>③给定两点以及等分数计算所有等分点算法（线上移动减少偏差）</p>
<p>④在PID寻点时获取基本点（矩形顶点及中心）PWM值算法</p>
<p>⑤stm32和jetson nano的通信规则设计与数据互传</p>
<p>3.OpenCV识别算法</p>
<p>①识别铅笔线边框：灰度图转换-&gt;阈值分割成二值图-&gt;霍夫直线变换得到直线上两点（非端点）-&gt;从得到的多条直线中筛选去重-&gt;编写“已知两直线上两点求直线交点”算法-&gt;求得四端点</p>
<p>②识别A4纸边框：阈值分割后利用Harris角点检测出A4框的8个顶点-&gt;编写“从8个顶点中识别两两相邻顶点”算法-&gt;求得框中心线4顶点</p>
<p>③区分红绿激光点算法：转换到Hsv色彩空间-&gt;分别设置阈值，在Hsv空间中二值化图像提取红绿色区域以得到激光点坐标  </p>
<p>4.主函数（程序流程）设计</p>
<p>5.电赛报告书写</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="&lt;3&gt;代码分析"></a>&lt;3&gt;代码分析</h3><h4 id="1-stm32上关键源码分析"><a href="#1-stm32上关键源码分析" class="headerlink" title="1.stm32上关键源码分析"></a>1.stm32上关键源码分析</h4><h5 id="I-基本部分"><a href="#I-基本部分" class="headerlink" title="I.基本部分"></a>I.基本部分</h5><p>(1)引脚使用说明</p>
<pre><code>//*************************引脚使用说明*************************
/*
oled.h				GPIOA PIN0/1
bluetooth.h			GPIOA PIN2/3
joystick.h			GPIOA PIN4/5 ADC1_CH4/5 GPIOB PIN11/12/13 EXTI12/13
Pwm.h				GPIOA PIN8/11 TIM1_CH1/4 50hz
usart.h				GPIOA PIN9/10 TX/RX Black/White
beep.h				GPIOB PIN14
led.h				GPIOB PIN15
Timer.h				TIM2/3
*/
</code></pre>
<p>(2)头文件声明</p>
<pre><code>//************************头文件声明************************
#include &quot;public.h&quot;				//公用引用函数封装
//#include &quot;bluetooth.h&quot;		//蓝牙模块
#include &quot;oled.h&quot;				//OLED显示屏模块
#include &quot;Pwm.h&quot;				//PWM波生成模块
#include &quot;servo_motor.h&quot;		//云台控制函数模块
#include &quot;joystick.h&quot;			//摇杆控制模块
#include &quot;string.h&quot;				
#include &quot;Delay.h&quot;				
#include &quot;Timer.h&quot;				//定时器模块
#include &quot;usart.h&quot;				//uart通信模块
#include &quot;beep.h&quot;				//蜂鸣器模块
#include &quot;led.h&quot;				//led灯模块
#include &quot;dma.h&quot;				//dma数据转存模块
</code></pre>
<p>(3)全局变量和宏定义声明</p>
<pre><code>//************************全局变量和宏定义声明************************
//#define OpenLoop_OL		//开环实现功能执行
#define CloseLoop_CL		//闭环实现功能执行

extern float Voltage[2];	//ad测量电压值[0.3.3]			//ad.c
extern char  USART_RX_INFO[USART_REC_LEN];	//uart接收数据	//usart.c
extern int x,y;				//激光当前坐标					//servo_motor.c
extern int Vertex[4][2];	//四顶点位置						//servo_motor.c
extern int Vertex_Peak_Pos[4][2];
extern int Vertex_A4[4][2];
extern Pwm Center_Pwm;
extern Pwm Peak_Pwm[4];
extern Pwm A4_Pwm[4];

int Programme_Progress=0;					//比赛程序进度
int order=0;								//蓝牙接收到的命令
int Main_Wait_Stop_Sign =1;					//主程序等待标志位
extern int JoyStick_Control_Stop_Sign;		//摇杆控制程序结束标志位
int Get_Depend_Point_Pos_Stop_Sign=1;
int Get_A4_Point_Pos_Stop_Sign=1;
extern int Follow_Track_Stop_Sign;			//矩形寻迹结束标志位
extern int Follow_Point_Stop_Sign;			//绿激光跟随红激光结束标志位
</code></pre>
<h5 id="II-模块代码"><a href="#II-模块代码" class="headerlink" title="II.模块代码"></a>II.模块代码</h5><h6 id="1-Timer——定时器延时函数模块"><a href="#1-Timer——定时器延时函数模块" class="headerlink" title="(1)Timer——定时器延时函数模块"></a>(1)Timer——定时器延时函数模块</h6><pre><code>#include &quot;Timer.h&quot;

//TIM2/3

void Timer_Init(void)
&#123;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	
	TIM_InternalClockConfig(TIM2);
	TIM_InternalClockConfig(TIM3);
	
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = 60000 - 1;	//分辨率1us,最大60ms
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);
	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);
	
&#125;

void Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM2,ENABLE); //启动定时器
	while(TIM2-&gt;CNT &lt; xus);
	TIM2-&gt;CNT = 0;
	TIM_Cmd(TIM2,DISABLE); //关闭定时器
&#125;

void Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)Timer_delay_us(1000);
&#125;

//外部中断专用延时函数
void EXIT_LINE_Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM3,ENABLE); //启动定时器
	while(TIM3-&gt;CNT &lt; xus);
	TIM3-&gt;CNT = 0;
	TIM_Cmd(TIM3,DISABLE); //关闭定时器
&#125;

void EXIT_LINE_Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)EXIT_LINE_Timer_delay_us(1000);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>在Timer_Init()中开启了两个定时器TIM1&#x2F;2，由Timer_delay_us()和EXIT_LINE_Timer_delay_us()分别使用，分别在中断函数内外使用，<strong>避免重复调用冲突</strong></p>
<h6 id="2-servo-motor——云台舵机控制模块"><a href="#2-servo-motor——云台舵机控制模块" class="headerlink" title="(2)servo_motor——云台舵机控制模块"></a>(2)servo_motor——云台舵机控制模块</h6><h6 id="①控制舵机的旋转"><a href="#①控制舵机的旋转" class="headerlink" title="①控制舵机的旋转"></a>①控制舵机的旋转</h6><pre><code>int Oc_Lp[4]=&#123;750,750,750,750&#125;;
int Oc_Vp[4]=&#123;763,763,763,763&#125;;
/*********************************************************
函数功能：云台水平方向旋转
*********************************************************/
void Spinnig_Level(int diff)
&#123;
	if(diff&lt;0)
	&#123;
		Oc_Lp[0]=Oc_L=(Oc_L+diff)&lt;660?660:(Oc_L+diff);
	&#125;
	else if(diff&gt;0)
	&#123;
		Oc_Lp[0]=Oc_L=(Oc_L+diff)&gt;840?840:(Oc_L+diff);	
	&#125;
	TIM_SetCompare1(TIM1,Oc_L);	
	int i;
	for(i=3;i&gt;0;i--)Oc_Lp[i]=Oc_Lp[i-1];
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>这里的Oc_Lp存储的是控制舵机的pwm波参数中的OC寄存器中的值，作为舵机运动最基本的函数，<br><em><strong>舵机的控制通过改变pwm波参数中的OC寄存器中的值实现</strong></em><br>。这里定义数组实现记忆功能，可存储前三次的OC值。并通过三元运算符设定上下限，将最终的OC值通过TIM_SetCompare1()设定。</p>
<h6 id="②控制激光点到达某一像素点"><a href="#②控制激光点到达某一像素点" class="headerlink" title="②控制激光点到达某一像素点"></a>②控制激光点到达某一像素点</h6><pre><code>/*********************************************************
函数功能：云台控制激光点到达某一点
函数参数：目标点的坐标
*********************************************************/
int x=360,y=360;		//跟随点当前坐标
int Reach_Pos_CL_Stop_Sign=1;
//云台水平方向旋转PID值
float Level_Kp=0.06;
float Level_Ki=0.02;
float Level_Kd=0.01;
//云台竖直方向旋转PID值
float Vert_Kp=0.06;
float Vert_Ki=0.02;
float Vert_Kd=0.01;
void Reach_Pos_CL(int Target_X,int Target_Y,int Reach_Pos_CL_MODE)
&#123;
	int Sign(int num);
	void Get_Point_Pos(void);
	int near(int Target_X,int Target_Y);
	
	int diff_x,diff_y;
	while(Reach_Pos_CL_Stop_Sign)
	&#123;
		Timer_delay_ms(30);
		Get_Point_Pos();
		if(near(Target_X,Target_Y)&lt;=6)
		&#123;
			Beep_Times(10,1,NORMAL_MODE);
			break;
		&#125;
		if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&gt;60)					//用pid计算舵机单位数
		&#123;
			diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,Target_X,x,PID_REALIZE);
			diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,Target_Y,y,PID_REALIZE);
		&#125;
		else if(Reach_Pos_CL_MODE==MINMIZE_MODE)		//以舵机最小分辨率为单位
		&#123;
			diff_x=-Sign(x-Target_X);
			diff_y=-Sign(y-Target_Y);
		&#125;
		else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&lt;=60)					//用pid计算舵机单位数
		&#123;
			diff_x=-Sign(x-Target_X);
			diff_y=-Sign(y-Target_Y);
			Timer_delay_ms(30);
		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;

int Sign(int num)
&#123;
	if(num&gt;5)return 1;
	else if(num&lt;-5)return -1;
	else return 0;
&#125;

int my_abs(int a,int b)
&#123;
	return a-b&gt;0?a-b:b-a;
&#125;

int near(int Target_X,int Target_Y)
&#123;
	return my_abs(Target_X,x)+my_abs(Target_Y,y);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：目标点像素坐标；追踪模式（PID【PID与最小精度混合】模式和最小精度值模式）</p>
<p><strong>追踪过程：</strong></p>
<p>——得到当前激光点坐标：Get_Point_Pos()</p>
<p>——如果接近目标点则蜂鸣器鸣叫并退出【near(Target_X,Target_Y)&lt;&#x3D;6，说明当前坐标与目标横纵坐标差之和{“距离”}小于6个像素】</p>
<p>——如果使用PID模式：</p>
<pre><code>    ——“距离”大于60时采用PID算法快速靠近，计算出OC变化值diff_x、diff_y

    ——“距离”小于60时使用最小精度模式缓慢靠近，利用“符号函数sign()”计算diff
</code></pre>
<p>——调用Spinnig_Level()、Spinnig_Level()进行水平和垂直舵机的旋转</p>
<h6 id="③与上位机jetson-nano通讯接收点坐标"><a href="#③与上位机jetson-nano通讯接收点坐标" class="headerlink" title="③与上位机jetson nano通讯接收点坐标"></a>③与上位机jetson nano通讯接收点坐标</h6><p><strong>a.激光点坐标的实时接收</strong></p>
<pre><code>/*********************************************************
函数功能：stm32获取当前激光坐标
*********************************************************/
void Get_Point_Pos(void)
&#123;
	if(USART_RX_INFO[0]==&#39;x&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
	&#125;
	if(USART_RX_INFO[4]==&#39;y&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>规定上位机每次发送数据格式为：以#开头，以$结尾；stm32usart模块对接收数据进行解析</p>
<p>上位机坐标数据格式为：x123y456；123、456代表三位坐标值，字符’x’、’y’起定位作用</p>
<p>stm32对接收到的字符坐标进行解析如上</p>
<p><strong>b.特殊坐标接收</strong></p>
<pre><code>//********************************************************高级控制函数(CloseLoop--CL)********************************************************
int Vertex_Peak_Pos[4][2];
int Center_Pos[2];
Pwm Center_Pwm;
Pwm Peak_Pwm[4];
Pwm A4_Pwm[4]; 
//获取重要点坐标
void Get_Point_5(void)
&#123;
	int i,j;
	while(1)
	&#123;
		for(i=0;i&lt;8;i++)
		&#123;
			if(USART_RX_INFO[4*i]==&#39;a&#39;+i)continue;
			else break;
		&#125;
		if(i==8)
		&#123;
			for(i=0;i&lt;4;i++)
			&#123;
				for(j=0;j&lt;2;j++)Vertex_Peak_Pos[i][j]=(USART_RX_INFO[4*(2*i+j)+1]-&#39;0&#39;)*100+(USART_RX_INFO[4*(2*i+j)+2]-&#39;0&#39;)*10+(USART_RX_INFO[4*(2*i+j)+3]-&#39;0&#39;);
			&#125;
			break;
		&#125;
	&#125;
	
	while(!(USART_RX_INFO[0]==&#39;i&#39;&amp;&amp;USART_RX_INFO[4]==&#39;j&#39;));
	
	Center_Pos[0]=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
	Center_Pos[1]=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
	Beep_Times(50,5,NORMAL_MODE);
	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>这里接收的是铅笔线框四个顶点的坐标和中心点坐标，但是一次发送的数据长度不能太长，这里拆分成两部分接收（数据格式为：axxxbxxxcxxx…hxxx共8组值四个坐标），<br><em><strong>关键在于两部分的衔接</strong></em></p>
<p>while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<em><strong>确保收到四个顶点坐标后持续等待中心点坐标的发送</strong></em></p>
<h6 id="④得到一点坐标对应的舵机pwm波OC值"><a href="#④得到一点坐标对应的舵机pwm波OC值" class="headerlink" title="④得到一点坐标对应的舵机pwm波OC值"></a>④得到一点坐标对应的舵机pwm波OC值</h6><pre><code>int sum_num(int *num,int n)
&#123;
	int i,sum;
	for(i=sum=0;i&lt;n;i++)sum+=num[i];
	return sum;
&#125;	
//获取目标点pwm值
void Get_Pwm(int px,int py,Pwm *target_pwm,int n)
&#123;
	Reach_Pos_CL(px,py,PID_MODE);
	target_pwm-&gt;level=sum_num(Oc_Lp,n)/n;
	target_pwm-&gt;vert=sum_num(Oc_Vp,n)/n;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>通过②控制函数控制激光点到达指定点后记录目标点pwm值并返回；Pwm结构体定义如下</p>
<pre><code>typedef struct Pwm&#123;
	int level;
	int vert;
&#125;Pwm;
</code></pre>
<p>可以通过改变参数n的值选择是否滤波，4&gt;n&gt;1时进行滤波，取前几次OC值的平均值，不建议滤波</p>
<h6 id="⑤控制激光点沿四边形巡线"><a href="#⑤控制激光点沿四边形巡线" class="headerlink" title="⑤控制激光点沿四边形巡线"></a>⑤控制激光点沿四边形巡线</h6><pre><code>//巡线
void Follow_Track(int Vertex[4][2],int divide_num)
&#123;
	int i,j;
	float sub_l,sub_v;
	Pwm Vertex_Pwm[4];
	for(i=0;i&lt;4;i++)Get_Pwm(Vertex[i][0],Vertex[i][1],&amp;Vertex_Pwm[i],1);
	
	for(i=0;i&lt;4;i++)
	&#123;
		sub_l=(Vertex_Pwm[(i+1)%4].level-Vertex_Pwm[i].level);	//下一个顶点与当前顶点pwm之差
		sub_v=(Vertex_Pwm[(i+1)%4].vert-Vertex_Pwm[i].vert);	//下一个顶点与当前顶点纵坐标之差
		for(j=0;j&lt;divide_num;j++)
		&#123;
			Reach_Pos_OL(Vertex_Pwm[i].level+j*sub_l/divide_num,Vertex_Pwm[i].vert+j*sub_v/divide_num);
			Timer_delay_ms(200);
		&#125;
		Reach_Pos_OL(Vertex_Pwm[(i+1)%4].level,Vertex_Pwm[(i+1)%4].vert);
		Timer_delay_ms(300);
	&#125;
	
	Beep_Times(50,5,NORMAL_MODE);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：四边形顺时针顺序顶点坐标、每段等分数divide_num</p>
<p><strong>巡线过程：</strong></p>
<p>——得到四个顶点坐标对应的水平、数值舵机OC值</p>
<p>——在for循环内依次经过四个顶点，视作四个大任务</p>
<pre><code>    ——内部使用for循环分解小任务，根据等分段数divide_num计算等分点横纵pwm值并移动至
</code></pre>
<p>——任务结束鸣叫示意</p>
<h5 id="III-主函数与中断函数部分"><a href="#III-主函数与中断函数部分" class="headerlink" title="III.主函数与中断函数部分"></a>III.主函数与中断函数部分</h5><h6 id="1-红色激光云台"><a href="#1-红色激光云台" class="headerlink" title="(1)红色激光云台"></a>(1)红色激光云台</h6><pre><code>//*************************主函数部分*************************
//重新重启初值还原设置
void Programme_Reset(void)
&#123;
	Beep_Times(1000,1,NORMAL_MODE);
	Led_Times(1000,1,NORMAL_MODE);
	Programme_Progress=0;
	
	Main_Wait_Stop_Sign=1;
	JoyStick_Control_Stop_Sign=1;
	Follow_Track_Stop_Sign=1;
	
	Get_A4_Point_Pos_Stop_Sign=1;
	Get_Depend_Point_Pos_Stop_Sign=1;
&#125;

int main(void)
&#123;	
	//********************初始化程序********************
	Timer_Init();				//定时器初始化
//	BlueToothInit(9600,USART_Parity_No,USART_StopBits_1,USART_WordLength_8b);	//蓝牙初始化
	OLED_Init();				//oled初始化
	Beep_Init();				//蜂鸣器初始化
	Led_Init();					//led灯初始化
	TIM1_PWM_Init(9999,143);	//一周期20ms，分辨率20ms/10000）
	TIM_SetCompare1(TIM1,750);	//对齐角度为90度(1.5ms)
	TIM_SetCompare4(TIM1,763);	//对齐角度为90度(1.5ms)
	uart_init(115200);			//uart1初始化
	JoyStick_Init();			//JoyStick摇杆初始化
			
	//*************************比赛程序部分*************************
	while(1)
	&#123;
		int i;
		//重新重启初值还原设置
		Programme_Reset();
//		Reach_Pos_CL(50,50,PID_MODE);
		
		Axes_Init();
		
//		Follow_Track(Vertex_Peak_Pos,1);
		
		while(Main_Wait_Stop_Sign);
		//摇杆控制
		JoyStick_Control();
	
		
//#ifdef OpenLoop_OL
//			Follow_Track_OL();
//#endif			
//#ifdef CloseLoop_CL
//		//等待上位机发送初始坐标
//		Get_Depend_Point_Pos();
//		//环绕正方形顺时针旋转一周
//		while(Get_Depend_Point_Pos_Stop_Sign);

		//Follow_Track_CL(Vertex_Peak_Pos,2,PID_MODE);
		
//#endif

		Pwm_Track(Peak_Pwm,1);
		while(Follow_Track_Stop_Sign);
				
		Get_A4_Point_Pos();
		Timer_delay_ms(2000);
//		Follow_Track_CL(Vertex_A4,4,MINMIZE_MODE);
//		Follow_Track(Vertex_A4,4);
		for(i=0;i&lt;4;i++)Get_Pwm(Vertex_A4[i][0],Vertex_A4[i][1],&amp;A4_Pwm[i],1);
		Pwm_Track(A4_Pwm,6);
		while(Get_A4_Point_Pos_Stop_Sign);
		
	&#125;
&#125;


//*********************************************中断函数部分*********************************************
//按键中断函数
void EXTI15_10_IRQHandler()
&#123;
	if (EXTI_GetITStatus(EXTI_Line11) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0)		//软件防抖
		&#123;
			Beep_Times(50,2,EXIT_LINE_MODE);
			Reach_Pos_OL(Oc_L,Oc_V);						//保持激光当前指向位置
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0); 	//等待按键松开

			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11==1)); 	//等待按键松开
			Beep_Times(50,2,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line11);
		&#125;
	&#125;
	
	else if (EXTI_GetITStatus(EXTI_Line12) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0)		//软件防抖
		&#123;
			Programme_Progress++;
			Beep_Times(500,1,EXIT_LINE_MODE);
			if(Programme_Progress==1)
			&#123;
				Main_Wait_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==2)
			&#123;
				JoyStick_Control_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==3)
			&#123;
//				Get_Depend_Point_Pos_Stop_Sign=0;
				Follow_Track_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==4)
			&#123;
				Get_A4_Point_Pos_Stop_Sign=0;
//				Follow_Track_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==5)
			&#123;
//				Get_A4_Point_Pos_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==6)
			&#123;
				;
			&#125;
			else if(Programme_Progress==7)
			&#123;
				;
			&#125;
			else
			&#123;
				Programme_Reset();
			&#125;
			
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0); 	//等待按键松开
			EXTI_ClearITPendingBit(EXTI_Line12);
		&#125;
		
	&#125;
	
	else if (EXTI_GetITStatus(EXTI_Line13) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0)		//软件防抖
		&#123;
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			Reach_Pos_OL(Center_Pwm.level,Center_Pwm.vert);
			
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0); 	//等待按键松开

			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13==1)); 	//等待按键松开
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line13);
		&#125;
	&#125;	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>主函数与中断函数相辅相成，程序整体使用外部中断推进以及实现一些特殊功能（立即复位）；</p>
<p>由于主函数内小功能函数都借助while()循环实现，设置循环标志位Stop_Sign和程序阶段标志位Programme_Progress来推进主函数；</p>
<p>按下GPIOB,GPIO_Pin_12的按键触发中断，Programme_Progress++以及相应的Stop_Sign&#x3D;0，以控制目前运行小功能停止并进入下一阶段；</p>
<p>在程序开始和结束处执行Programme_Reset()函数，重置各标志位实现程序重新运行；</p>
<p><strong>注意：</strong></p>
<p>在中断函数内部涉及到的延时函数统统使用EXIT_LINE_Timer_delay_ms()函数，区别外部使用的Timer_delay_ms()函数，防止调用冲突程序卡死</p>
<h6 id="2-绿色激光云台"><a href="#2-绿色激光云台" class="headerlink" title="(2)绿色激光云台"></a>(2)绿色激光云台</h6><pre><code>//绿车
int r_x=0,r_y=0;
void Get_RaG_Point_Pos(void)
&#123;
	if(USART_RX_INFO[0]==&#39;g&#39;&amp;&amp; USART_RX_INFO[8]==&#39;r&#39;&amp;&amp; USART_RX_INFO[4]==&#39;y&#39;&amp;&amp; USART_RX_INFO[12]==&#39;y&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
		y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
		r_x=(USART_RX_INFO[9]-&#39;0&#39;)*100+(USART_RX_INFO[10]-&#39;0&#39;)*10+USART_RX_INFO[11]-&#39;0&#39;;
		r_y=(USART_RX_INFO[13]-&#39;0&#39;)*100+(USART_RX_INFO[14]-&#39;0&#39;)*10+USART_RX_INFO[15]-&#39;0&#39;;
	&#125;
&#125;

void G_Follow_R(int Reach_Pos_CL_MODE)
&#123;
	int Sign(int num);
	void Get_RaG_Point_Pos(void);
	int near(int r_x,int Target_Y);
	
	int diff_x,diff_y,dis;
	while(Reach_Pos_CL_Stop_Sign)
	&#123;
		if(x==0&amp;&amp;y==0)Reach_Pos_OL(750,750);
		Get_RaG_Point_Pos();
		dis=near(r_x,r_y);
		if(dis&lt;=20)
		&#123;
			Beep_Times(300,1,NORMAL_MODE);
			Led_Times(300,1,NORMAL_MODE);
			continue;
		&#125;
		if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&gt;60)					//用pid计算舵机单位数
		&#123;
			Get_RaG_Point_Pos();
			diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,r_x,x,PID_REALIZE);
			diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,r_y,y,PID_REALIZE);
		&#125;
		else if(Reach_Pos_CL_MODE==MINMIZE_MODE)		//以舵机最小分辨率为单位
		&#123;
			Get_RaG_Point_Pos();
			diff_x=-0.5*Sign(x-r_x);
			diff_y=-0.5*Sign(y-r_y);
		&#125;
		else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&lt;=60)					//用pid计算舵机单位数
		&#123;
			Get_RaG_Point_Pos();
			diff_x=-0.4*Sign(x-r_x);
			diff_y=-0.4*Sign(y-r_y);

		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>上位机数据格式为：g123y123r123y123，实时传输红绿激光点两个坐标；</p>
<p>执行点到点的跟踪即可，在主函数中不断重复即可，即while(1)G_Follow_R(PID_MODE);</p>
<h4 id="2-jetson-nano上关键源码分析"><a href="#2-jetson-nano上关键源码分析" class="headerlink" title="2.jetson nano上关键源码分析"></a>2.jetson nano上关键源码分析</h4><p><strong>文件说明：</strong></p>
<p>mian_10、main_11、mian_12是测试函数，分别测试<strong>铅笔线识别效果</strong> 、<strong>A4纸识别效果</strong> 、<strong>红绿激光分别识别效果</strong><br>。设置了滑动条供<strong>调参</strong> 使用，确定好参数</p>
<p>q_1、q_2、q_3即为三个问题对应的程序，分别实现<strong>发送铅笔线顶点和中心坐标后实时传输红色激光点坐标</strong><br>、<strong>发送A4纸顶点坐标后实时传输红色激光点坐标</strong> 、<strong>实时传输红色和绿色激光点坐标</strong></p>
<h5 id="I-相机参数的调整"><a href="#I-相机参数的调整" class="headerlink" title="I.相机参数的调整"></a>I.相机参数的调整</h5><pre><code>string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
&#123;
   return &quot;nvarguscamerasrc exposurecompensation=1 ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +
       to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +
       &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +
       to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;
&#125;
</code></pre>
<p>这里设置好管道参数，主要调整曝光和饱和度，方便之后线条的检测以及红绿激光的区分</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h5 id="II-关键识别算法"><a href="#II-关键识别算法" class="headerlink" title="II.关键识别算法"></a>II.关键识别算法</h5><h6 id="1-铅笔线识别及顶点的计算"><a href="#1-铅笔线识别及顶点的计算" class="headerlink" title="(1)铅笔线识别及顶点的计算"></a>(1)铅笔线识别及顶点的计算</h6><p><strong>变量解析：</strong></p>
<pre><code>int Find = 0, l_x = 0, l_y = 0, r_x = 0, r_y = 0;
int l[2][2],r[2][2],u[2][2],d[2][2];
int ul[2],ur[2],dl[2],dr[2],ce[2];
</code></pre>
<p>Find有效个数标志位，表示找到了几组有效的边上两点；</p>
<p>l_x、l_y、r_x、r_y寻找标志位，为1则分别表示上下左右边未找到有效值的两点值</p>
<p>l[2][2]、r[2][2]、u[2][2]、d[2][2]分别存储上下左右边上两点坐标</p>
<p>ul[2]、ur[2]、dl[2]、dr[2]、ce[2]分别存储最终的顶点和中心点坐标</p>
<p><strong>过程：</strong></p>
<p>——转换成灰度图-&gt;阈值划分成二制图-&gt;霍夫直线检测得到直线并输出直线上两点坐标</p>
<pre><code>    ——设计算法过滤筛选重复直线并存储两点坐标


for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
                x1 = linesPPHT[i][0], y1 = linesPPHT[i][1], x2 = linesPPHT[i][2], y2 = linesPPHT[i][3];
                line(image, Point(x1, y1), Point(x2, y2), Scalar(0), 1, 8);

                if (x1 &lt; 150 &amp;&amp; x2 &lt; 150 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !l_x)&#123;Find++;l_x = (x2 + x1) / 2;l[0][0]=x1;l[0][1]=y1;l[1][0]=x2;l[1][1]=y2;&#125;
                else if (y1 &lt; 150 &amp;&amp; y2 &lt; 150 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !l_y)&#123;Find++;l_y = (y1 + y2) / 2;u[0][0]=x1;u[0][1]=y1;u[1][0]=x2;u[1][1]=y2;&#125;
                else if (x1 &gt; 570 &amp;&amp; x2 &gt; 570 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !r_x)&#123;Find++;r_x = (x2 + x1) / 2;r[0][0]=x1;r[0][1]=y1;r[1][0]=x2;r[1][1]=y2;&#125;
                else if (y1 &gt; 570 &amp;&amp; y2 &gt; 570 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !r_y)&#123;Find++;r_y = (y1 + y2) / 2;d[0][0]=x1;d[0][1]=y1;d[1][0]=x2;d[1][1]=y2;&#125;
            &#125;
</code></pre>
<p>linesPPHT是霍夫直线检测函数的输出，linesPPHT.size()表示检测到直线的条数；这里根据直线上两点坐标值大小判断属于四条边的那一条；属于其中一条且之前未存储（标志位为1）（见if语句中的判断）则存储并将找点标志位Find+1；Find&#x3D;&#x3D;4时即寻找结束</p>
<p>——由于霍夫直线检测算法得到的并非顶点而是直线上两点，设计求两直线交点函数</p>
<pre><code>void crossline(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int cross[2])
&#123;
    cross[0]=(y3*x4*x2-y4*x3*x2-y3*x4*x1+y4*x3*x1-y1*x2*x4+y2*x1*x4+y1*x2*x3-y2*x1*x3)/(x4*y2-x4*y1-x3*y2+x3*y1-x2*y4+x2*y3+x1*y4-x1*y3);
    cross[1]=(-y3*x4*y2+y4*x3*y2+y3*x4*y1-y4*x3*y1+y1*x2*y4-y1*x2*y3-y2*x1*y4+y2*x1*y3)/(y4*x2-y4*x1-y3*x2+x1*y3-y2*x4+y2*x3+y1*x4-y1*x3);
&#125;
</code></pre>
<p>输入的(x1,y1)~(x4,y4)是两条直线上四点坐标，输出交点坐标并赋值给cross；</p>
<pre><code>crossline(l[0][0],l[0][1],l[1][0],l[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ul);
crossline(r[0][0],r[0][1],r[1][0],r[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ur);
crossline(l[0][0],l[0][1],l[1][0],l[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dl);
crossline(r[0][0],r[0][1],r[1][0],r[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dr);

crossline(ul[0],ul[1],dr[0],dr[1],ur[0],ur[1],dl[0],dl[1],ce);
</code></pre>
<p>输入之前得到的坐标计算四个顶点值和中心坐标</p>
<p>——向下位机stm32输出坐标</p>
<pre><code>sprintf(m,&quot;#a%03db%03dc%03dd%03de%03df%03dg%03dh%03d$\n&quot;,ul[0],ul[1],ur[0],ur[1],dr[0],dr[1],dl[0],dl[1]);
uart.sendUart(m);
usleep(50000);
sprintf(m,&quot;#i%03dj%03d$\n&quot;,ce[0],ce[1]);
uart.sendUart(m);
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png"></p>
<h6 id="2-A4纸顶点识别及巡线顶点的计算"><a href="#2-A4纸顶点识别及巡线顶点的计算" class="headerlink" title="(2)A4纸顶点识别及巡线顶点的计算"></a>(2)A4纸顶点识别及巡线顶点的计算</h6><p>过程：</p>
<p>——灰度图-&gt;二值化-&gt;角点检测得到角点坐标CornerImg</p>
<pre><code>    ——设计算法过滤筛选得到八个顶点P[8][2]（绝缘胶布内外边形成两个矩形）


#define MAX_DIS 20
int Is_Exit(int i, int j)
&#123;
    int k = 0;
    for (k = 0; k &lt; Find; k++) 
    &#123;
        if (myabs(P[k][0]-i)+ myabs(P[k][1]-j)&lt;MAX_DIS)return 1;
    &#125;
    return 0;
&#125;


int P[8][2] = &#123; 0 &#125;;
int Find = 0;

for (int j = 0; j &lt; CornerImg.rows; j++) &#123;
    for (int i = 0; i &lt; CornerImg.cols; i++) &#123;
        if (CornerImg.at&lt;float&gt;(j, i) &gt; 150.0f) &#123;
            if (!Is_Exit(i, j))
            &#123;                            
                P[Find][0] = i;
                P[Find][1] = j;
                Find++;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>Is_Exit()函数遍历已经视作有效的点，如果与当前坐标(i,j)接近则不存储；找到八个有效点退出</p>
<p>——设计根据八个顶点P[8][2]求得巡线四边形的顶点Vertex[4][2]（同一个角的内外顶点的中点）</p>
<pre><code>int Vertex[4][2] = &#123; 0 &#125;;
int sign[8] = &#123; 0 &#125;;
int i,j,k,dis,min = 1000;
int temp1, temp2;
for (k=0,i = 0; i &lt; 8; i++)
&#123;
    if (sign[i])continue;
    min = 2000;
    for (j = 0; j &lt; 8; j++)
    &#123;
        if (i == j||sign[j])continue;
        dis = myabs(P[i][0] - P[j][0]) + myabs(P[i][1] - P[j][1]);
        if (dis&lt; min)
        &#123;
            min = dis;
            temp1 = i;
            temp2 = j;
        &#125;
    &#125;
    sign[temp1] = 1;
    sign[temp2] = 1;
    Vertex[k][0] = (P[temp1][0] + P[temp2][0])/2;
    Vertex[k][1] = (P[temp1][1] + P[temp2][1])/2;
    k++;
&#125;
</code></pre>
<p>这里使用for循环遍历P[8][2]中顶点，将距离最近的两点视为A4纸一个角内外两边的两个顶点，求其中点存储在Vertex[4][2]中</p>
<p>——设计算法使巡线的四个端点按照顺时针传输给下位机，否则巡线顺序错误</p>
<pre><code>int temp;
//先整体按y值大小排序
for(i=0;i&lt;4;i++)
&#123;
    for(min=Vertex[i][1],j=k=i;j&lt;4;j++)
    &#123;
        if(Vertex[j][1]&lt;=min)k=j;
    &#125;
    temp=Vertex[k][0];
    Vertex[k][0]=Vertex[i][0];
    Vertex[i][0]=temp;
    temp=Vertex[k][1];
    Vertex[k][1]=Vertex[i][1];
    Vertex[i][1]=temp;
&#125;
//y值中等的两点按x值排序
if(Vertex[1][0]&lt;Vertex[2][0])
&#123;
    temp=Vertex[1][0];
    Vertex[1][0]=Vertex[2][0];
    Vertex[2][0]=temp;
    temp=Vertex[2][1];
    Vertex[2][1]=Vertex[1][1];
    Vertex[1][1]=temp;
&#125;


if(Vertex[0][0]&amp;&amp; Vertex[0][1]&amp;&amp;Vertex[1][0]&amp;&amp;Vertex[1][1]&amp;&amp;Vertex[3][0]&amp;&amp; Vertex[3][1]&amp;&amp;Vertex[2][0]&amp;&amp; Vertex[2][1])
&#123;
    sprintf(m,&quot;#k%03dl%03dm%03dn%03do%03dp%03dq%03dr%03d$\n&quot;, Vertex[0][0], Vertex[0][1],Vertex[1][0], Vertex[1][1],Vertex[3][0], Vertex[3][1],Vertex[2][0], Vertex[2][1]);
    u.sendUart(m);
&#125;
</code></pre>
<p><strong>观察任意矩形顶点坐标规律，要顺时针发送，可将y值最小的作为第一个发送，y值最大的第三个发送，介于中间的两点按x值大小判断，x小的最后发送，大的第二个发送</strong></p>
<p>即先整体按y值大小排序，y值中等的两点按x值排序-&gt;排序后按<strong>0<del>1</del>3~2的顺序</strong> 发送坐标</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png"></p>
<h6 id="3-区分红绿激光"><a href="#3-区分红绿激光" class="headerlink" title="(3)区分红绿激光"></a>(3)区分红绿激光</h6><p><strong>过程如下：</strong></p>
<pre><code>Point color_recognite(Mat image, Scalar Low, Scalar High)
&#123;

    vector&lt;vector&lt;Point&gt;&gt; g_vContours;
    vector&lt;Vec4i&gt; g_vHierarchy;
    vector&lt;Mat&gt; hsvSplit;
    double maxarea = 0;
    int maxAreaIdx = 0;
    Mat g_grayImage, hsv, g_cannyMat_output;

    cvtColor(image, hsv, COLOR_BGR2HSV);
    split(hsv, hsvSplit);
    equalizeHist(hsvSplit[2], hsvSplit[2]);
    merge(hsvSplit, hsv);
    inRange(hsv, Low, High, g_grayImage);//二值化识别颜色

    //开操作 (去除一些噪点)
    Mat element = getStructuringElement(MORPH_RECT, Size(2, 2));
    morphologyEx(g_grayImage, g_grayImage, MORPH_OPEN, element);

    //闭操作 (连接一些连通域)
    morphologyEx(g_grayImage, g_grayImage, MORPH_CLOSE, element);
    //  Canny(g_grayImage, g_cannyMat_output, 80, 80 * 2, 3);

    // 寻找轮廓
    findContours(g_grayImage, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));

    //假设contours是用findContours函数所得出的边缘点集
    RotatedRect box;
    Point centre;

    if (g_vContours.size() != 0)
    &#123;
        for (int index = 0; index &lt; g_vContours.size(); index++)
        &#123;
            double tmparea = fabs(contourArea(g_vContours[index]));
            if (tmparea &gt; maxarea)
            &#123;
                maxarea = tmparea;
                maxAreaIdx = index;//记录最大轮廓的索引号
            &#125;
        &#125;

        box = minAreaRect(g_vContours[maxAreaIdx]);
        rectangle(image, box.boundingRect(), Scalar(0, 0, 255), 2);
        centre = box.center;
    &#125;
    return centre;
&#125;
</code></pre>
<p>关键是调用inRange()函数HSV色彩空间二值化的阈值上下限设置</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Home_Wood/article/details/88613977" title="OpenCV学习笔记-inRange()阈值操作函数怎么用_cv.inrange函数">OpenCV学习笔记-<br>inRange()阈值操作函数怎么用_cv.inrange函数</a></p>
<p>并设置滑动条调整参数获得经验值</p>
<p><strong>最终评判标准：</strong></p>
<p>激光在绝缘胶布上是能否识别（黑色胶布吸光；通过提高曝光，调参，增大激光功率等可以解决）</p>
<p>红绿激光靠近时能否区分（红绿在HSC空间互斥，更亮的会掩盖另一个；调inRange()参数解决）</p>
<h2 id="二-学习资料分享"><a href="#二-学习资料分享" class="headerlink" title="二.学习资料分享"></a>二.学习资料分享</h2><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="&lt;1&gt;学习笔记"></a>&lt;1&gt;学习笔记</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797?spm=1001.2014.3001.5501" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697?spm=1001.2014.3001.5501" title="图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-CSDN博客">图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991?spm=1001.2014.3001.5501" title="图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-CSDN博客">图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?spm=1001.2014.3001.5501" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-CSDN博客">图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041?spm=1001.2014.3001.5501" title="图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-CSDN博客">图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399?spm=1001.2014.3001.5501" title="PID控制算法理解_switch_swq的博客-CSDN博客">PID控制算法理解_switch_swq的博客-<br>CSDN博客</a></p>
<h3 id="其他资料"><a href="#其他资料" class="headerlink" title="&lt;2&gt;其他资料"></a>&lt;2&gt;其他资料</h3><p>1.<a target="_blank" rel="noopener" href="https://space.bilibili.com/28143041/?spm_id_from=333.999.0.0" title="唐老师讲电赛的个人空间-唐老师讲电赛个人主页-哔哩哔哩视频">唐老师讲电赛的个人空间-唐老师讲电赛个人主页-<br>哔哩哔哩视频</a></p>
<p>2.电赛资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ehPdgMU8T16tcQXeLU1xaQ?pwd=1234#list/path=%2F" title="电赛资料_免费高速下载|百度网盘-分享无限制 (baidu.com)">电赛资料_免费高速下载|百度网盘-分享无限制<br>(baidu.com)</a>提取码：1234</p>
<p>3.我的“电赛”、“VS Studio”、“cmake”、“opencv”、“makefile”、“linux、操作系统”、“stm32”收藏夹</p>
<p>3.以及上面笔记中所包含信息</p>
<h2 id="三-备赛阶段记录"><a href="#三-备赛阶段记录" class="headerlink" title="三.备赛阶段记录"></a><strong>三.备赛阶段记录</strong></h2><p>7.2.2023</p>
<ul>
<li>问题 <ol>
<li>Nano板子供电5v4A，需求电流较大</li>
<li>实验室现有开关电源模块似乎调不了5v，需自己设计电源模块</li>
<li>作为底层主要负责，如何为项目打下坚实基础</li>
<li>硬件使用有明确目标，如何学习</li>
</ol>
</li>
<li>解决 <ol>
<li>先不考虑电源模块，用适配器及直流电源供电</li>
<li>先把电机控制写好，提供友善接口</li>
<li>先用简单硬件过度，后期转高级的。如电机先用直流后用伺服。先拼起来，再细化雕琢</li>
</ol>
</li>
<li>收获 <ol>
<li>用vscode远程开发jetson，下载remote-ssh插件，ssh jetson@IP地址；快捷键ctrl+o调出要打开页面</li>
</ol>
</li>
</ul>
<p>7.3.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32很多知识忘记，如定时器和A&#x2F;D、D&#x2F;A；是否需要复习，因复习耗时且不一定需要stm32</li>
<li>目前目标尚不明确</li>
</ol>
</li>
<li>解决 <ol>
<li>先将stm32相关知识看完，stm32作为保底</li>
<li>先搭一个蓝牙遥控小车！</li>
</ol>
</li>
<li>收获 <ol>
<li>修好了学长的小车，看到了PID实现双轮平衡小车的现象</li>
<li>学会了MG995型号舵机控制（控制脉冲占空比实现角度控制）</li>
<li>搭建了测试平台（OLED屏、蓝牙、i2c通讯）</li>
<li>搭建了简单的两轮遥控小车，采用直流电机控制，未加入PWM波调速，实现简单的前进、倒退、转弯。</li>
</ol>
</li>
</ul>
<p>7.4.2023</p>
<ul>
<li>问题 <ol>
<li>昨天做的小车电源直接冒烟，因为电源采用两节3.7V锂电池供电，buck升压到12V以匹配LM298N，电流过大</li>
</ol>
</li>
<li>解决 <ol>
<li>暂时给l298n提供5V电压，驱动能力下降，但系统可以运行。以后电源模块之后重新设计或使用小功率电机</li>
</ol>
</li>
<li>收获 <ol>
<li>主要将昨天搭好的小车完善，并加入了测压模块（利用STM32的ADC外设）</li>
<li>复习了stm32相关知识（外部中断，定制器TIM设置，定时器比较OC产生PWM波）</li>
<li>打开了jetson nano的摄像头，它睁开了眼</li>
</ol>
</li>
</ul>
<p>7.5.2023</p>
<ul>
<li>问题 <ol>
<li>编码器旋转无响应，电机也不动了</li>
<li>烧了一个stm32板子，当时接的自制稳压模块，之前都是好的，不知道什么原因</li>
</ol>
</li>
<li>解决 <ol>
<li>重新测试电机是否能正常工作</li>
<li>在小车到达前有时间学习MPU6050，相关姿态轨迹传输算法</li>
</ol>
</li>
<li>收获 <ol>
<li>在jetson nano上跑了例程及自己上传的几张图片</li>
<li>学会了linux的vim的使用</li>
<li>复习了stm32相关知识（定时器IC输入捕获模式）</li>
<li>学会了超声波测距CS100A模块和红外传感模块以及电机编码器部分</li>
</ol>
</li>
</ul>
<p>7.6.2023</p>
<ul>
<li>问题 <ol>
<li>如何解决电机编码器输出波形峰值小，stm32无法接收</li>
<li>Pwm波和电源需供电，不然波形失真</li>
</ol>
</li>
<li>解决 <ol>
<li>昨天电机不转是因为接线不紧，编码器不行是因为输出电压太小，只有0.5v左右</li>
<li>考虑IO口输出模式，不行加电压比较器，ref&#x3D;0.33V</li>
<li>要重新系统性设计电源了，所有信号共地！</li>
</ol>
</li>
<li>收获 <ol>
<li>拼好了大车，发现了诸多问题，舵机控制程序完成</li>
<li>浅浅学了PCB绘制流程</li>
</ol>
</li>
</ul>
<p>7.7.2023</p>
<ul>
<li>问题 <ol>
<li>控制函数太过简陋，后续仍需不断升级</li>
<li>图像识别进度为零</li>
</ol>
</li>
<li>解决 <ol>
<li>《基于opencv的数字图像处理技术》</li>
</ol>
</li>
<li>收获 <ol>
<li>用洞洞板搭建好了电源系统（12V-5V-3.7V），系统完全移植到大车</li>
<li>新车编码器输出足够大，无需放大器，编码器计数正常</li>
</ol>
</li>
</ul>
<p>7.8.2023</p>
<ul>
<li>收获 <ol>
<li>学会在Windows配置OpenCV环境，掌握OpenCV图像视频基本操作以及一些基础知识</li>
<li>PCB绘制进展</li>
</ol>
</li>
</ul>
<p>7.9.2023</p>
<ul>
<li>收获 <ol>
<li>学会在linux中运行调用OpenCV的c++文件（cmake的使用）</li>
<li>学习OpenCV基本数据结构和类的使用</li>
<li>进一步了解VS studio上编译选项配置以及debug和release的区别</li>
</ol>
</li>
</ul>
<p>7.10.2023</p>
<ul>
<li>收获 <ol>
<li>学会OpenCV灰度变换、直方图、边缘检测、霍夫检测直线和圆</li>
</ol>
</li>
</ul>
<p>7.11.2023</p>
<ul>
<li>问题 <ol>
<li>源码在linux上无法运行（OpenCV调用摄像头出问题，采用CMake方法编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>今天下午加晚上未解决</li>
</ol>
</li>
<li>收获 <ol>
<li>学会阈值分割（图像二值化方法）</li>
</ol>
</li>
</ul>
<p>7.12.2023</p>
<ul>
<li>问题 <ol>
<li>C++无法编译成功，Mat类未定义引用（QT上编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>使用python编写运行成功</li>
</ol>
</li>
<li>收获 <ol>
<li>看完特征提取和目标检测（HOG特征+SVM基本流程；LBP特征+级联分类器）</li>
</ol>
</li>
</ul>
<p>7.13.2023</p>
<ul>
<li>问题 <ol>
<li>依旧无法运行以C++运行OpenCV代码</li>
<li>可以运行的OpenCV代码不能直接以videocapture capture(0)的方法获取视频流</li>
</ol>
</li>
<li>解决 <ol>
<li>重新系统性安装OpenCV库并重走CMake流程</li>
<li>将视频流通过管道gstreamer传输</li>
</ol>
</li>
<li>收获 <ol>
<li>学会CMake以及基本编译链接流程</li>
<li>重新安装配置OpenCV4.8.0，成功在jetson nano上运行OpenCV代码</li>
</ol>
</li>
</ul>
<p>7.14.2023</p>
<ul>
<li>问题 <ol>
<li>但运行自己编写的直线检测程序过于卡顿，一秒一帧</li>
<li>蓝牙模块无法正常工作</li>
</ol>
</li>
<li>解决 <ol>
<li>霍夫直线检测运算量大，不使用该算法</li>
<li>调整视频大小及帧率</li>
<li>经检测应是蓝牙模块问题，重新购买</li>
</ol>
</li>
<li>收获 <ol>
<li>使用画好的pcb搭建小车，将全部器件搭载在小车上</li>
</ol>
</li>
</ul>
<p>7.15.2023</p>
<ul>
<li>问题 <ol>
<li>电机控制出错，一边电机不受控制</li>
<li>目前控制算法学的太少，但图像识别进展不够</li>
</ol>
</li>
<li>解决 <ol>
<li>GPIO口选到了下载口JTDI&#x2F;O，换GPIO口控制</li>
<li>先用超声波模块、MPU6050、红外传感等模块写避障、路径记录、寻迹等功能</li>
</ol>
</li>
<li>收获 <ol>
<li>学会jetson nano上的GPIO使用（基本和树莓派一样）</li>
<li>解决了电机的基本控制问题并将电机的四控制线改成了两根</li>
<li>jetson使用电池供电（器件全供地）；实现stm32与jetson nano的usart通信（照搬蓝牙）</li>
</ol>
</li>
</ul>
<p>7.16.2023</p>
<ul>
<li>问题 <ol>
<li>超声波测距模块中断代码写的不好，拔下模块进入while循环等待，系统卡住</li>
<li>拉肚子</li>
</ol>
</li>
<li>解决 <ol>
<li>使用static变量，进入中断模式改为EXTI_Trigger_Rising_Falling…</li>
<li>休息一天（今日中午至明天中午）</li>
</ol>
</li>
</ul>
<p>7.17.2023</p>
<ul>
<li>问题 <ol>
<li>欲添加mpu6050模块，但其与oled、蓝牙、超声波模块冲突（非引脚分配问题）</li>
</ol>
</li>
<li>解决 <ol>
<li>更改方案，debug试试。仍不行</li>
</ol>
</li>
</ul>
<p>7.18.2023</p>
<ul>
<li>问题 <ol>
<li>昨天问题仍然存在</li>
<li>多个中断之间不协调，影响超声波测距精度。以及测角度过于耗时</li>
</ol>
</li>
<li>解决 <ol>
<li>使用江科大自动化的例程代码，简洁明了，解决冲突</li>
<li>更改各个中断优先级，控制mpu6050的使用</li>
</ol>
</li>
<li>收获</li>
</ul>
<p>7.19.2023</p>
<ul>
<li>收获 <ol>
<li>学会PID算法</li>
<li>重新绘制PCB，解决若干问题</li>
</ol>
</li>
</ul>
<p>7.20.2023</p>
<ul>
<li>问题 <ol>
<li>SysTick定时器冲突问题（外部和中断同时调用delay_us函数会卡死）</li>
</ol>
</li>
<li>解决 <ol>
<li>避免了0.1s定时器中断（数据刷新）的SysTick定时函数</li>
</ol>
</li>
<li>收获 <ol>
<li>使用编码器利用PID编写行驶给定长度函数及测速</li>
</ol>
</li>
</ul>
<p>7.21.2023</p>
<ul>
<li>问题 <ol>
<li>后退时编码器反向计数，上限不明确，速度测算出现问题</li>
</ol>
</li>
<li>解决 <ol>
<li>通过TIM_EncoderInterfaceConfig设置编码器反转依旧向上计数</li>
</ol>
</li>
<li>收获 <ol>
<li>编写小车倒车定长距离</li>
</ol>
</li>
</ul>
<p>7.22.2023</p>
<ul>
<li>收获 <ol>
<li>编写小车以恒定速度行驶和拐弯90度算法</li>
</ol>
</li>
</ul>
<p>7.23.2023</p>
<ul>
<li>收获 <ol>
<li>焊好新到的板子</li>
</ol>
</li>
</ul>
<p>7.24.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson配置难，yolo难跑通</li>
<li>要求设计完整程序，在jetson开机时自动执行</li>
</ol>
</li>
<li>解决 <ol>
<li>学习OpenCV备用</li>
<li>学习python或c++可执行文件Linux开机自动执行方法</li>
</ol>
</li>
</ul>
<p>7.25.2023</p>
<ul>
<li>问题 <ol>
<li>采用硬盘直接克隆方式克隆SD卡依旧无法启动jetson nano系统</li>
</ol>
</li>
<li>解决 <ol>
<li>烧录官方镜像文件，成功还原系统。并发现python和C++环境已经配好，之前不会用。解决yolov5摄像头实时检测问题，方案参考亚博论坛。C++也是，g++编译时加上一个参数就行</li>
</ol>
</li>
</ul>
<p>7.26.2023</p>
<ul>
<li>收获 <ol>
<li>看今年电赛器件清单，简单编写完云台代码，购买K210等器材</li>
</ol>
</li>
</ul>
<p>7.27.2023</p>
<ul>
<li>收获 <ol>
<li>简单编写完红外寻迹功能</li>
<li>解决nano开机启动python文件</li>
</ol>
</li>
</ul>
<p>7.28.2023</p>
<ul>
<li>问题 <ol>
<li>分析电赛清单，云台摄像头加激光笔应该涉及到动态物体追踪</li>
</ol>
</li>
<li>解决 <ol>
<li>学习视频目标跟踪</li>
</ol>
</li>
</ul>
<p>7.29.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32定时器资源有限无法满足云台的加入</li>
</ol>
</li>
<li>解决 <ol>
<li>使用pca9685驱动</li>
</ol>
</li>
<li>收获 <ol>
<li>采用stm32管脚重定义解决pca9685驱动的使用问题</li>
</ol>
</li>
</ul>
<p>7.30.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson nano的C++库不包含串口uart相关内容</li>
</ol>
</li>
<li>解决 <ol>
<li>使用其设备&#x2F;dev&#x2F;tthTSH1，研究网上代码</li>
</ol>
</li>
<li>收获 <ol>
<li>编写以及pca9685控制云台函数</li>
</ol>
</li>
</ul>
<p>7.31.2023</p>
<ul>
<li>问题 <ol>
<li>霍夫圆检测一定也不稳定</li>
</ol>
</li>
<li>解决 <ol>
<li>调整参数或使用深度学习识别物体的方法</li>
</ol>
</li>
<li>收获 <ol>
<li>终于解决串口通信问题，实现C++语言的nano和电脑以及stm32通信</li>
<li>完善霍夫圆检测代码，加入uart传输圆心坐标</li>
<li>学会nano开机自启动程序方法</li>
<li>编写stm32的PID点跟踪函数，实现点跟踪</li>
</ol>
</li>
</ul>
<p>8.1.2023</p>
<ul>
<li>问题 <ol>
<li>走定长不精确，大约是设定5cm行驶6cm这个比例</li>
</ol>
</li>
<li>收获 <ol>
<li>编写摇杆控制云台程序</li>
<li>发现之前使用的pid算法全犯了低级错误，本应用float定义PID值结果用了int，修改后大范围应用，各个控制加入PID平稳精确了很多</li>
</ol>
</li>
</ul>
<h2 id="四-电赛总结及经验教训"><a href="#四-电赛总结及经验教训" class="headerlink" title="四.电赛总结及经验教训"></a>四.电赛总结及经验教训</h2><h3 id="本次比赛作品的不足、改进之处"><a href="#本次比赛作品的不足、改进之处" class="headerlink" title="&lt;1&gt;本次比赛作品的不足、改进之处"></a>&lt;1&gt;本次比赛作品的不足、改进之处</h3><p>1.stm32和jetson<br>nano通讯不稳定（可能原因：杜邦线传输能力差、波特率可能设置高了【但低了影响系统处理速度】）（实际原因：while写成了if，导致时机很难对上，通信规则设计失误！）</p>
<p>2.stm32主函数设计不行，没花时间改进，想要重复运行某个程序只能重启，人机交互也不友好</p>
<p>3.比赛报告没有在头脑风暴之后就开始写，导致后期书写太急，不够规范</p>
<p>4.linux操作不熟，开机自启动程序出现问题，且jetson nano上的程序设计缺乏系统性结构性（每问都写了一个程序，而不是整合成一个大的测试程序）</p>
<p>5.所有任务完成太晚，没有留下时间仔细调试调参找问题。而且全流程过一遍后立马就要封箱了，急急忙忙乱改代码导致出现了<strong>意想不到的错误！再给一天就刚好了啊！！！</strong></p>
<h3 id="本次比赛的经验教训"><a href="#本次比赛的经验教训" class="headerlink" title="&lt;2&gt;本次比赛的经验教训"></a>&lt;2&gt;本次比赛的经验教训</h3><p>1.器件准备很重要：比赛发布器件清单后要备齐，最好每个器件都多买几个。以满足比赛器件需求并防止比赛时器件损坏！（本次比赛oled屏、舵机都反复坏过）</p>
<p>2.器件精度很重要：比赛前统计自己所有器件清单，并实测是否可以使用？精度如何？硬件精度不足会直接导致结果无法满足！（本次比赛刚开始使用的舵机为20kg大扭矩低精度，调了一晚PID参数舵机仍然运动不准，最后才发现是精度问题）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132150694">https://blog.csdn.net/qq_32971095/article/details/132150694</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">790k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


</body>
</html>
