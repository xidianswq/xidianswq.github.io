<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:11" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%BD%9C%E4%B8%9A%E6%A6%82%E8%BF%B0%EF%BC%9A">作业概述：</a></p>
<p><a href="about:blank#%E4%B8%80.%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Sobel%E7%AE%97%E5%AD%90">一.一阶导数算子——Sobel算子</a></p>
<p><a href="about:blank#%E4%BA%8C.%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Canny%E7%AE%97%E5%AD%90">二.二阶导数算子——Canny算子</a></p>
<p><a href="about:blank#%E9%99%84%E5%BD%95%EF%BC%9A">附录：</a></p>
<p><a href="about:blank#1.%E4%BD%BF%E7%94%A8%E7%9A%84sobel%E7%AE%97%E5%AD%90">1.使用的sobel算子</a></p>
<p><a href="about:blank#2.%E4%BD%BF%E7%94%A8%E7%9A%845*5%E9%AB%98%E6%96%AF%E5%B9%B3%E6%BB%91%E6%A8%A1%E7%89%88">2.使用的5*5高斯平滑模版</a></p>
<p><a href="about:blank#3.%E6%BA%90%E4%BB%A3%E7%A0%81">3.源代码</a></p>
<hr>
<p>西安电子科技大学_计算机视觉_作业一_边缘检测</p>
<h2 id="作业概述："><a href="#作业概述：" class="headerlink" title="作业概述："></a>作业概述：</h2><p>作业 1：边缘检测 编程语言：Matlab（推荐） 或 Python（可能需要使用 OpenCV）</p>
<p>题目内容：</p>
<p>自选一张图像，编程实现以下操作：</p>
<p>• 分别采用 Sobel 算子和 Canny 算子滤波，进行边缘提取；</p>
<p>• 显示原始图像以及不同滤波器滤波后的结果</p>
<p>• 对于 Sobel 滤波结果，显示 x 方向的梯度、y 方向的梯度、梯度幅度、梯 度角度等</p>
<p>• 对于 Canny 算子滤波，显示滤波后边缘检测结果 并分析不同滤波结果的差异。</p>
<p>说明：</p>
<p>（1）基于原理，自行实现，进行计算（禁止使用自带函数进行滤波）。各种滤 波函数应进行封装，并在统一的 test 文件（test.m or<br>test.py）中调用使用。</p>
<p>（2） 所得各图像，按照子图样式显示(subplot)，并标注(title)</p>
<p>（3） 打包文件夹，包含代码和文档，文档中应包含上述结果的截图及最终分 析。</p>
<p>要求：内容完备（包含计算过程），结构清晰、排版美观。</p>
<h2 id="一-一阶导数算子——Sobel算子"><a href="#一-一阶导数算子——Sobel算子" class="headerlink" title="一.一阶导数算子——Sobel算子"></a>一.一阶导数算子——Sobel算子</h2><p>通过求导可以得到边缘，边缘像素变化快，导数绝对值大。在离散点中则使用差分近似，通过与特定的卷积核卷积实现差分运算，并近似出该点导数。</p>
<p>而Sobel算子分为x轴方向和y轴方向，分别卷积获得各像素点x、y轴梯度x_g和y_g。梯度幅值用x_g和y_g的2-范数（平方和开根）求得（也可用1-范数[绝对值求和]近似，减少运算量），相位用arctan求得。</p>
<p><strong>测试结果：</strong></p>
<p>原图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f089df392b290c82c2217105c8da4e7f.jpeg"></p>
<p>sobel滤波：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8b9d8d83a6334aa1992c110a768b94f4.jpeg"></p>
<p>x方向梯度：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e38d99b56bbf67908f656b8eadabd2f.jpeg"></p>
<p>y方向梯度：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/087357e370b158b125a780536caff592.jpeg"></p>
<p>从图中可以清晰看到x轴方向和y轴方向的Sobel算子检测结果的差异。梯度的幅度和相位保存在mat文件中。</p>
<h2 id="二-二阶导数算子——Canny算子"><a href="#二-二阶导数算子——Canny算子" class="headerlink" title="二.二阶导数算子——Canny算子"></a>二.二阶导数算子——Canny算子</h2><p>Canny边缘检测算法包括以下步骤[1]：</p>
<p>1.高斯平滑，滤除噪声</p>
<p>2.计算梯度强度和方向</p>
<p>3.应用非极大值抑制法（Nom-Maximum Suppression，NMS），以消除杂散效应</p>
<p>4.应用滞后阈值法检测边缘</p>
<p>（5.边缘跟踪得到单像素宽度的边缘图像）</p>
<p>这里主要说明第3步：</p>
<pre><code>    图像梯度矩阵中的元素值大，不能直接用来判断该点为边缘。NMS可以剔除伪边缘信息。如果该像素满足梯度局部最大值，则判断该像素为边缘，并对其余像素的相关信息进行抑制。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ca59c955dc405d499ac1b357d0cce8c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e8cafc9ef237158894971f55f7c810c.jpeg"></p>
<pre><code>    中心点周围有8个领域点，但做中心点梯度方向的直线的交点并不一定的8-领域点，根据交点所在的区域可以将领域划分为4块，交点PM、PN的值通过线性插值计算。

    最后放大保留下来的像素点，这里简单地将满足双阈值间的点灰度设置为255。
</code></pre>
<p><strong>测试结果：</strong></p>
<p>高斯平滑：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9399bb1b0692b68d6e2be51c27872fb9.jpeg"></p>
<p>高斯平滑后sobel滤波：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f203482fda90f8be278e727cc58328f0.jpeg"></p>
<p>非极大值抑制：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/622487c3dba1ca0f1f6324d30ded53d1.jpeg"></p>
<p>双阈值处理：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07e60e31a5360caee06a12687e923136.jpeg"></p>
<p>可以通过调整双阈值来调整最终结果保留细节的多少</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb56bf290e418556ec6cdf1684206f85.jpeg"></p>
<h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><h3 id="1-使用的sobel算子"><a href="#1-使用的sobel算子" class="headerlink" title="1.使用的sobel算子"></a>1.使用的sobel算子</h3><p>s_x&#x3D;1&#x2F;8*[1,0,-1;2,0,-2;1,0,-1];</p>
<p>s_y&#x3D;1&#x2F;8*[-1,-2,-1;0,0,0;1,2,1];</p>
<h3 id="2-使用的5-5高斯平滑模版"><a href="#2-使用的5-5高斯平滑模版" class="headerlink" title="2.使用的5*5高斯平滑模版"></a>2.使用的5*5高斯平滑模版</h3><p>gs&#x3D;1&#x2F;159*[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];</p>
<h3 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3.源代码"></a>3.源代码</h3><pre><code>function []=Sobel_Canny_Filter(Src_img)
%% 输入参数：同路径下照片名。使用举例：Sobel_Canny_filter(&#39;Test.jpg&#39;)

%%  一阶导数——Sobel算子。
F=imread(Src_img);
f=double(rgb2gray(F));
[row,col]=size(f);

%   Sobel核处理结果
X_grad=zeros(row,col);
Y_grad=zeros(row,col);
S_dir=zeros(row,col);
Output_img=zeros(row,col);

%   Sobel核
s_x=[1,0,-1;2,0,-2;1,0,-1];
s_y=[-1,-2,-1;0,0,0;1,2,1];

for i=2:row-1
    for j=2:col-1
        %   卷积运算
        fx=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];
        fy=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];
        Sx=0.125*s_x.*fx;
        Sy=0.125*s_y.*fy;
        x_g=sum(Sx,&#39;all&#39;);
        y_g=sum(Sy,&#39;all&#39;);
        
        %   关键数值求解
        S_dir(i,j)=atan2(y_g,x_g);        
        A=sqrt(x_g^2+y_g^2);
        X_grad(i,j)=abs(x_g);
        Y_grad(i,j)=abs(y_g);
        Output_img(i,j)=A;
    end
end

%%   绘图
figure(8);

%   原图
subplot(2,4,1);
imshow(F);
title(&#39;source&#39;);

%   sober滤波后图
subplot(2,4,2);
imshow(Output_img,[]);
title(&#39;sobel-filter&#39;);
imwrite(uint8(Output_img),&#39;sobel_filter.jpg&#39;);

%   x方向梯度
subplot(2,4,3);
imshow(X_grad,[]);
title(&#39;x-grad&#39;);
imwrite(uint8(X_grad),&#39;X_grad.jpg&#39;);

%   y方向梯度
subplot(2,4,4);
imshow(Y_grad,[]);
title(&#39;y-grad&#39;);
imwrite(uint8(Y_grad),&#39;Y_grad.jpg&#39;);

%   保存梯度的幅度和相位
save(&#39;Amplitude.mat&#39;,&quot;A&quot;);
save(&#39;dir.mat&#39;,&quot;S_dir&quot;);

%% 二阶导数——Canny算子。
%%   高斯滤波  
Gs=zeros(row,col);
Gs_sobel=zeros(row,col);
Canny_temp=zeros(row,col);
Canny=zeros(row,col);
%   5*5高斯核
gs=[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];
for i=3:row-2
    for j=3:col-2
        gg=[f(i-2,j-2),f(i-2,j-1),f(i-2,j),f(i-2,j+1),f(i-2,j+2);f(i-1,j-2),f(i-1,j-1),f(i-1,j),f(i-1,j+1),f(i-1,j+2);f(i,j-2),f(i,j-1),f(i,j),f(i,j+1),f(i,j+2);f(i+1,j-2),f(i+1,j-1),f(i+1,j),f(i+1,j+1),f(i+1,j+2);f(i+2,j-2),f(i+2,j-1),f(i+2,j),f(i+2,j+1),f(i+2,j+2)];
        s_g=gs.*gg/159;
        Gs(i,j)=sum(s_g,&#39;all&#39;);
    end
end

%%   高斯平滑
for i=3:row-2
    for j=3:col-2
        gsx=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];
        gsy=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];
        Sx=0.125*s_x.*gsx;
        Sy=0.125*s_y.*gsy;
        gsx_g=sum(Sx,&#39;all&#39;);
        gsy_g=sum(Sy,&#39;all&#39;);
        
        GSS_dir(i,j)=atan(gsx_g/gsy_g);        
        GSA=sqrt(gsx_g^2+gsy_g^2);
        GSX_grad(i,j)=abs(x_g);
        GSY_grad(i,j)=abs(y_g);
        Gs_sobel(i,j)=GSA;
    end
end

%%   高斯平滑后sobel滤波
for i=3:row-2
    for j=3:col-2
        k=abs(tan(GSS_dir(i,j)));
        %   非极大值抑制
        %   判断领域点(非8-领域点可划分为4部分)并进行相应线性插值并判断是否为局部大优点（进行保留）
        if (GSS_dir(i,j)&gt;=0 &amp;&amp; GSS_dir(i,j)&lt;pi/4) || (GSS_dir(i,j)&gt;=-pi &amp;&amp; GSS_dir(i,j)&lt;-3*pi/4)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j+1)+(Gs_sobel(i+1,j+1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j-1)+(Gs_sobel(i-1,j-1)-Gs_sobel(i-1,j))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end        
        elseif (GSS_dir(i,j)&gt;=pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi/2) || (GSS_dir(i,j)&gt;=-3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;-pi/2)
            if Gs(i,j) &gt;= (Gs_sobel(i-1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i-1,j-1))/k) &amp;&amp; Gs_sobel(i,j) &gt;= (Gs_sobel(i+1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i+1,j+1))/k)
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        elseif (GSS_dir(i,j)&gt;=pi/2 &amp;&amp; GSS_dir(i,j)&lt;3*pi/4) || (GSS_dir(i,j)&gt;=-pi/2 &amp;&amp; GSS_dir(i,j)&lt;-pi/4)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i+1,j-1))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i-1,j+1))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        elseif (GSS_dir(i,j)&gt;=3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi) || (GSS_dir(i,j)&gt;=-pi/4 &amp;&amp; GSS_dir(i,j)&lt;0)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i+1,j-1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i-1,j+1)-Gs_sobel(i-1,j))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        end
    end
end

%%   双阈值变换
lowTh  = 0.02 *max(max(Canny_temp));%高阈值
higtTh = 1 *max(max(Canny_temp));%低阈值

for i = 3 : row-2
    for j = 3 : col-2
        %   灵活设置保留值
        if Canny_temp(i,j) &gt;=lowTh &amp;&amp; Canny_temp(i,j) &lt;= higtTh
            %Canny(i,j) = Canny_temp(i,j);
            Canny(i,j) = 255;
        end
    end
end

%% 绘图
%   高斯平滑结果
subplot(2,4,5);
imshow(Gs,[]);
title(&#39;gauss-filter&#39;);
imwrite(uint8(Gs),&#39;gauss_filter.jpg&#39;);

%   高斯平滑后sobel滤波结果
subplot(2,4,6);
imshow(Gs_sobel,[]);
title(&#39;gauss-sobel-filter&#39;);
imwrite(uint8(Gs_sobel),&#39;Gs_sobel_filter.jpg&#39;);

%   非极大值抑制后结果
subplot(2,4,7);
imshow(Canny_temp,[]);
title(&#39;Canny-temp&#39;);
imwrite(uint8(Canny_temp),&#39;Canny_temp.jpg&#39;);

%   阈值间处理
subplot(2,4,8);
imshow(Canny,[]);
title(&#39;Canny-filter&#39;);
imwrite(uint8(Canny),&#39;Canny_filter.jpg&#39;);

%保存结果
saveas(8,&#39;result.jpg&#39;);
 
end
</code></pre>
<p>参考文献</p>
<p>[1]柳林.基于OpenCV的数字图像处理技术[M].杭州:浙江大学出版社，2020：202-203.</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133420554">https://blog.csdn.net/qq_32971095/article/details/133420554</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:30:50" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：在源代码中 “ctrl+单击” 可查看详细信息  </p>
<h2 id="一-头文件"><a href="#一-头文件" class="headerlink" title="一.头文件"></a>一.头文件</h2><pre><code>#include &quot;xparameters.h&quot; //器件参数信息
#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义
#include &quot;xil_printf.h&quot; //包含 print()函数
#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数
#include &quot;sleep.h&quot; //包含 sleep()函数
</code></pre>
<h2 id="二-宏定义"><a href="#二-宏定义" class="headerlink" title="二.宏定义"></a>二.宏定义</h2><pre><code>//PS_LED1 连接到 MIO38
#define MIO_LED1 38 

//宏定义 GPIO_DEVICE_ID
#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
</code></pre>
<h2 id="三-函数"><a href="#三-函数" class="headerlink" title="三.函数"></a>三.函数</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h3><h4 id="器件初始化"><a href="#器件初始化" class="headerlink" title="&lt;1&gt;器件初始化"></a>&lt;1&gt;器件初始化</h4><pre><code>//PS 端 GPIO 驱动实例
XGpioPs gpiops_inst; 
//PS 端 GPIO 配置信息
XGpioPs_Config *gpiops_cfg_ptr; 


//根据器件 ID 查找配置信息
gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
//初始化器件驱动
Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);
//判断是否初始化成功
if (Status != XST_SUCCESS)return XST_FAILURE;






XGpioPs_Config *XGpioPs_LookupConfig(u16 DeviceId);
/**
*
* This function looks for the device configuration based on the unique device
* ID. The table XGpioPs_ConfigTable[] contains the configuration information
* for each device in the system.
*
* @param	DeviceId is the unique device ID of the device being looked up.
*
* @return	A pointer to the configuration table entry corresponding to the
*		given device ID, or NULL if no match is found.
*
* @note		None.
*
******************************************************************************/



s32 XGpioPs_CfgInitialize(XGpioPs *InstancePtr, const XGpioPs_Config *ConfigPtr,u32 EffectiveAddr);
/*****************************************************************************/
/**
*
* This function initializes a XGpioPs instance/driver.
* All members of the XGpioPs instance structure are initialized and
* StubHandlers are assigned to the Bank Status Handlers.
*
* @param	InstancePtr is a pointer to the XGpioPs instance.
* @param	ConfigPtr points to the XGpioPs device configuration structure.
* @param	EffectiveAddr is the device base address in the virtual memory
*		address space. If the address translation is not used then the
*		physical address should be passed.
*		Unexpected errors may occur if the address mapping is changed
*		after this function is invoked.
*
* @return	XST_SUCCESS always.
*
* @note		None.
*
******************************************************************************/



int XGpio_Initialize(XGpio *InstancePtr, u16 DeviceId);
/****************************************************************************/
/**
* Initialize the XGpio instance provided by the caller based on the
* given DeviceID.
*
* Nothing is done except to initialize the InstancePtr.
*
* @param	InstancePtr is a pointer to an XGpio instance. The memory the
*		pointer references must be pre-allocated by the caller. Further
*		calls to manipulate the instance/driver through the XGpio API
*		must be made with this pointer.
* @param	DeviceId is the unique id of the device controlled by this XGpio
*		instance. Passing in a device id associates the generic XGpio
*		instance to a specific device, as chosen by the caller or
*		application developer.
*
* @return
*		- XST_SUCCESS if the initialization was successful.
*		- XST_DEVICE_NOT_FOUND  if the device configuration data was not
*		  found for a device with the supplied device ID.
*
* @note		None.
*
*****************************************************************************/
</code></pre>
<h4 id="中断配置"><a href="#中断配置" class="headerlink" title="&lt;2&gt;中断配置"></a>&lt;2&gt;中断配置</h4><pre><code>//建立中断系统，使能KEY按键的下降沿中断
//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针
//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针
//  @param   GpioIntrId是Gpio中断ID
//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILURE
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)
&#123;
    int status;
    XScuGic_Config *IntcConfig;     //中断控制器配置信息

    //查找中断控制器配置信息并初始化中断控制器驱动
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == IntcConfig) &#123;
        return XST_FAILURE;
    &#125;

    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,
            IntcConfig-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS) &#123;
        return XST_FAILURE;
    &#125;


    //设置并使能中断异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);
    Xil_ExceptionEnable();
    //为中断设置中断处理函数
    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,
            (Xil_ExceptionHandler) intr_handler, (void *) gpio);
    if (status != XST_SUCCESS) &#123;
        return status;
    &#125;
    //使能来自于Gpio器件的中断
    XScuGic_Enable(gic_ins_ptr, GpioIntrId);
    //设置KEY按键的中断类型为下降沿中断，按ctrl+单击查看其他类型
    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);
    //使能按键KEY中断
    XGpioPs_IntrEnablePin(gpio, KEY);

    return XST_SUCCESS;
&#125;


//设置中断优先级和触发类型(高电平触发)
XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
</code></pre>
<p> 中断处理函数：</p>
<pre><code>//中断处理函数
//  @param   CallBackRef是指向上层回调引用的指针
static void intr_handler(void *callback_ref)
&#123;
    XGpioPs *gpio = (XGpioPs *) callback_ref;

    //读取KEY按键引脚的中断状态，判断是否发生中断
    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;
        key_press = TRUE;
        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断
        //XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断
        //XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断
    &#125;
&#125;
</code></pre>
<h4 id="uart配置"><a href="#uart配置" class="headerlink" title="&lt;3&gt;uart配置"></a>&lt;3&gt;uart配置</h4><pre><code>//UART初始化函数
int uart_init(XUartPs* uart_ps)
&#123;
    int status;
    XUartPs_Config *uart_cfg;

    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);
    if (NULL == uart_cfg)
        return XST_FAILURE;
    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //UART设备自检
    status = XUartPs_SelfTest(uart_ps);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置工作模式:正常模式
    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);
    //设置波特率:115200
    XUartPs_SetBaudRate(uart_ps,115200);
    //设置RxFIFO的中断触发等级
    XUartPs_SetFifoThreshold(uart_ps, 1);

    return XST_SUCCESS;
&#125;
</code></pre>
<p>中断函数</p>
<pre><code>//UART中断处理函数
void uart_intr_handler(void *call_back_ref)
&#123;
    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;
    u32 rec_data = 0 ;
    u32 isr_status ;                           //中断状态标志

    //读取中断ID寄存器，判断触发的是哪种中断
    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_IMR_OFFSET);
    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_ISR_OFFSET);

    //判断中断标志位RxFIFO是否触发
    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;
    	rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);
        //清除中断标志
        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,
                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;
    &#125;
    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);
&#125;
</code></pre>
<h3 id="2-GPIO操作"><a href="#2-GPIO操作" class="headerlink" title="2.GPIO操作"></a>2.GPIO操作</h3><pre><code>//设置指定引脚的方向：0 输入，1 输出
XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);
//使能指定引脚输出：0 禁止输出使能，1 使能输出
XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);
//向指定引脚写入数据：0 或 1
XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); 
//从指定引脚读入数据
XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2)


//配置PL AXI GPIO
XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断
</code></pre>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><pre><code>    //uart打印	
    print(&quot;MIO Test! \n\r&quot;);    

    //延时 1 秒
	sleep(1); 
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136315297">https://blog.csdn.net/qq_32971095/article/details/136315297</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:15" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">一.xilinx Zynq UltraScale+ MPSoC
</a></p>
<p><a href="about:blank#1.MPSoC%20%E7%AE%80%E4%BB%8B">1.MPSoC 简介</a></p>
<p><a href="about:blank#2.FPGA%E7%AE%80%E4%BB%8B">2.FPGA简介</a></p>
<p><a href="about:blank#3.MPSoC%20PL%20%E7%AE%80%E4%BB%8B">3.MPSoC PL 简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E5%8F%AF%E7%BC%96%E7%A8%8B%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83">（1）可编程输入&#x2F;输出单元</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83">（2）基本可编程逻辑单元</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9D%97%20RAM">（3）嵌入式块<br>RAM</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%B8%83%E7%BA%BF%E8%B5%84%E6%BA%90">（4）丰富的布线资源</a></p>
<p><a href="about:blank#%EF%BC%885%EF%BC%89%E5%BA%95%E5%B1%82%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83">（5）底层嵌入功能单元</a></p>
<p><a href="about:blank#%EF%BC%886%EF%BC%89%E5%86%85%E5%B5%8C%E4%B8%93%E7%94%A8%E7%A1%AC%E6%A0%B8">（6）内嵌专用硬核</a></p>
<p><a href="about:blank#4.MPSoC%20PS%20%E7%AE%80%E4%BB%8B">4.MPSoC PS 简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89APU%EF%BC%88Application%20Processing%20Unit%EF%BC%89">（1）APU（Application Processing<br>Unit）</a></p>
<p>[（2）RPU（Real-Time Processing<br>Unit）](about:blank#%EF%BC%882%EF%BC%89RPU%EF%BC%88Real-<br>Time%20Processing%20Unit%EF%BC%89)</p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89GPU%EF%BC%88Graphics%20Processing%20Unit%EF%BC%89">（3）GPU（Graphics Processing<br>Unit）</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89DDR%20Memory%20Controller">（4）DDR Memory<br>Controller</a></p>
<p><a href="about:blank#%EF%BC%885%EF%BC%89PMU%EF%BC%88Platform%20Management%20Unit%EF%BC%89">（5）PMU（Platform Management<br>Unit）</a></p>
<p>[（6）High-Speed Connect Zynq](about:blank#%EF%BC%886%EF%BC%89High-<br>Speed%20Connect%20Zynq)</p>
<p><a href="about:blank#%EF%BC%887%EF%BC%89%E6%99%AE%E9%80%9A%E5%A4%96%E8%AE%BE%E6%8E%A7%E5%88%B6%E5%99%A8">（7）普通外设控制器</a></p>
<p>[（8）PS-PL AXI 接口](about:blank#%EF%BC%888%EF%BC%89PS-<br>PL%20AXI%20%E6%8E%A5%E5%8F%A3)</p>
<p><a href="about:blank#5.DFZU2EG%20MPSoc%20%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90">5.DFZU2EG MPSoc<br>硬件连接资源</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89IO%20%E5%88%86%E9%85%8D">（1）IO 分配</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E7%94%B5%E6%BA%90%E7%B3%BB%E7%BB%9F">（2）电源系统</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">（3）启动模式</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89%E5%85%B6%E4%BB%96%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">（4）其他硬件资源</a></p>
<p><a href="about:blank#6.%E5%85%B6%E4%BB%96">6.其他</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">（1）注意事项</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%AD%A6%E4%B9%A0%20MPSoC%20%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%EF%BC%9A">（2）学习 MPSoC<br>基本方法：</a></p>
<hr>
<p>官网介绍：</p>
<p>[Zynq UltraScale+ MPSoC](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivity
for ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p>
<p><a target="_blank" rel="noopener" href="http://www.pynq.io/" title="PYNQ -
Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p>
<p>参考书目：《正点原子 DFZU2EG&#x2F;4EV MPSoc 之 FPGA 开发指南》</p>
<h2 id="一-xilinx-Zynq-UltraScale-MPSoC"><a href="#一-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="一.xilinx Zynq UltraScale+ MPSoC"></a>一.xilinx Zynq UltraScale+ MPSoC</h2><pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。

    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。
</code></pre>
<h3 id="1-MPSoC-简介"><a href="#1-MPSoC-简介" class="headerlink" title="1.MPSoC 简介"></a>1.MPSoC 简介</h3><pre><code>    Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和 Virtex 系列。

    每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和 UltraScale+（16nm），以提供不同的性能和功耗比。

    Xilinx 的 SoC 是将可编程逻辑部分和处理器单元以及常见处理器外设封装在一起，集成到单颗芯片中， 并命名为“ZYNQ”，同样分为不同的系列，如 Zynq-7000（28nm）、Zynq UltraScale+ MPSoC（16nm）、 Zynq UltraScale+ RFSoC（16nm），如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/60b09a0ae2714b38a861d02d63e5efb1.png">​</p>
<pre><code>    Zynq7000 系列组合了一个双核 Arm Cortex-A9 处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件。由于该器件的可编程逻辑部分基于 Xilinx 28nm 工艺的 7 系列 FPGA，因此该系列产品的名称中添加了 “7000”，以保持与 7 系列 FPGA 的一致性，同时也方便日后本系列新产品的命名。

    Zynq UltraScale+ MPSoC 的系统级性能功耗比相对 Zynq-7000 SoC 系列提升高达 5 倍。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器** 、**双核 Arm Cortex-R5F 实时处理器** 和一个传统的现场可编程门阵列（FPGA）逻辑部件，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。

    Zynq UltraScale+ MPSoC 部分系列的产品，还包含了**Arm Mail-400MP2（GPU）** 和 H.264/H.265 视频编 解码器，可提供原生 UltraHD 压缩及专用引擎，满足动态电源管理与安全配置需求，可以说是对 ZYNQ 7000 的升级版本。Zynq UltraScale+ MPSoC 非常适用于 5G 无线基础设施、面向数据中心和有线通信的软件定义网络、新一代汽车驾驶员辅助系统和无人驾驶系统 (ADAS)、工业物联网系统 (IIoT)、超高清和超高画质摄像机、航空电子以及便携式软件定义无线电等各种应用。

    Zynq UltraScale+ RFSoC 在 SoC 架构中集成数千兆采样 RF 数据转换器和软判决前向纠错 (SD-FEC)。 配有 ARM Cortex-A53 处理子系统和 UltraScale +可编程逻辑，该系列是业界唯一单芯片自适应射频平台。 Zynq UltraScale+ RFSoC 系列可为模拟、数字和嵌入式设计提供适当的平台，从而可简化信号链上的校准和 同步。多代产品系列包含广泛的器件类型，具有不同的直接 RF 性能，可满足各种频谱需求和使用案例。

    Zynq UltraScale+ MPSoC 产品在单个设备中集成了功能丰富的**嵌入式处理系统(PS)和可编程逻辑(PL) UltraScale+架构** ，并且还包括片上存储器、多端口外部存储器接口以及丰富的外设连接接口集等等。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1885099ee6dfb7367468dd7d96d6923.png">​</p>
<pre><code>    Zynq UltraScale+ MPSoC除了嵌入式处理系统功能强大外，它还包含了可编程逻辑(PL) UltraScale+架构， 能够灵活的去编辑我们想要的逻辑运算，实现各种各样的复杂功能。从**本质上来讲，它还是一个片上处理系统（System on Chip，SoC）** 。
</code></pre>
<p>注：板上系统 （System-on-a-Board）示意图如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b104c9b15be132b83147ceabf67924e.png"></p>
<p>​</p>
<p>而片上系统（System-on-<br>Chip）指的是在单个硅芯片就可以实现整个系统的功能。<strong>在一个芯片里就实现了存储、处理、逻辑和接口等各个功能模块，而不是像板上系统那样，需要用几个不同的物理芯片来实现。</strong></p>
<pre><code>    在过去，SoC 这个术语常用于指**专用集成电路（Application Specific Integrated Circuit，ASIC）** 。基于 ASIC 的 SoC 的代表性例子包括在 PC、平板和智能手机上使用的处理器，如华为旗舰手机中的麒麟系列芯片。这些处理器典型地是由至少两个处理器核、存储器、图形处理器、接口和其他功能模块组合起来的。 基于 ASIC 的 SoC 的主要缺点有两个：
</code></pre>
<p>1、开发周期长且成本巨大；</p>
<p>2、缺乏灵活性。</p>
<pre><code>    开发 ASIC 时不可重 用的工程投入是巨大的，使得这种 SoC 类型只适合于**大批量而且寿命有限** 的产品中。 ASIC SoC 的局限性导致它们不适用于很多应用，特别是当快速投入市场能力、灵活性和升级能力已 经成为重要的关键因素。对于小批量或中批量的产品，ASIC SoC 也不是好的解决方案。

    可编程片上系统**（SOPC，System-on-Progammable-Chip）** 为上述应用提供了一个更灵活的解决方案： 一种在可编程、可重新配置的芯片上实现的 SoC。可编程的芯片指的就是 FPGA。FPGA 天生的灵 活性使其可以被随心所欲地重新配置，以实现不同系统的功能，包括嵌入式处理器。和使用 ASIC 来实现 SoC 相比，FPGA 能构成更为基础灵活的平台，方便系统的升级。

    与基于 ASSP 的固定 SoC 解决方案不同，Zynq UltraScale+ MPSoC 能通过灵活的 **32 或 64 位数据宽度** 的处理系统提供最大的可扩展性。它能将关键应用（例如图形和视频管线）分配给专用处理模块来处理，并通过有效的电源域 (power domain) 和电源孤岛 (power island) 来开启和关闭模块。Zynq UltraScale+ MPSoC 提供多种互连选项、DSP 模块以及可编程逻辑选择，因而具备整体灵活性，可满足 用户的各种 应用需求。该产品系列具备出色可扩展性，使设计人员能够利用单个平台和行业标准工具开发出低成本以 及高性能应用。
</code></pre>
<h3 id="2-FPGA简介"><a href="#2-FPGA简介" class="headerlink" title="2.FPGA简介"></a>2.FPGA简介</h3><pre><code>    可编程逻辑器件（Programmable Logic Device，PLD），目前常见的 PLD 大体上可以分为 **SPLD（simple PLD，简单 PLD）、CPLD（complex PLD，复杂 PLD）和 FPGA（field-programmable gate array，现场可编程门阵列）** 。SPLD 中又可分为 PLA、PAL 和 GAL 几种类型。FPGA 也是一种可编程逻辑器件，但由于在电路结构上与早期已经广为应用的 PLD 不 同，所以采用 FPGA 这个名称，以示区别。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1560887deaa66558322d142f691a7c4.png"></p>
<pre><code>    通过扩展 SPLD 的概念就可以得到 CPLD。CPLD 是复杂可编程逻辑器件，相当于将**多个 PAL 用可编程互联阵列（Programmable Interconnect Array，PIA）连接** 起来，形成一个大的 PLD，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51b23c0e4eccaa6ca1148046910d0d8c.png"></p>
<pre><code>    上图中的 Logic block（逻辑块）通常被称为逻辑阵列模块，或者**LAB（Logic Array Block）** 。每个 LAB 相当于一个 PAL 电路，不同型号的 CPLD 器件可以包含十几个甚至上百个 LAB。通过 PIA 将这些 LAB 连接起来，就可以构成规模更大的逻辑电路了。另外，在 PAL 中，I/O 管脚是直接连接到逻辑的。而在 CPLD 中，I/O 管脚是通过 PIA 从器件的主要逻辑中分离出来的。I/O 管脚有它自己的控制逻辑，I/O 控 制单元可以根据需要将相应的引脚设置成输入、输出或双向工作模式。

    CPLD 相对于 SPLD 最大的优势就是拥有更大的逻辑资源和布线的可能性。CPLD 中 LAB 逻辑和 PIA 是完全可编程的，使得它具有在单芯片中非凡的设计灵活性。CPLD 的 I/O 特性和功能也远比 SPLD 中简 单的 I/O 更有价值。

    FPGA 由许多“可配置逻辑模块”（Configurable Logic Block，CLB）、输入/输出单元（I/O Block， IOB）和分布式的可编程互联矩阵（Programmable Interconnection Matrix，PIM）组成。在 FPGA 中，CLB 被布置成阵列的形式，如图 1.2.7 所示。可编程的布线资源分布在 CLB 与 CLB 之间，像大城市的街道一 样纵横联接。这些布线资源分为行互联和列互联，可以跨过整个器件，也可以是局部 CLB 之间的互联。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1f8eacf99307c89a4e2491e222287e7.png"></p>
<pre><code>    我们将图进行对比可以发现，FPGA 中的布线资源看上去似乎比 CPLD 中的互联阵列更简单，但它实际上提供了更大的功能性和连通性。FPGA 中的布线资源使得器件中所有的逻辑资源都可 以与芯片内其他资源进行通信，这种结构可以实现更大容量、低成本的逻辑器件。

    在前面所讲的各种 SPLD 和 CPLD 电路中，都采用了与或逻辑阵列加上输出逻辑单元的结构形式。而 FPGA 则采用了完全不同的电路结构形式（查找表，LUT）
</code></pre>
<h3 id="3-MPSoC-PL-简介"><a href="#3-MPSoC-PL-简介" class="headerlink" title="3.MPSoC PL 简介"></a>3.MPSoC PL 简介</h3><pre><code>    Zynq UltraScale+ MPSoC PL 部分等价于 FPGA，因此我们将首先介绍 FPGA 的架构。

    简化的 FPGA 基本结构由 6 部分组成，分别为可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核等，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/278fa7234a1f4ee107063ffe158ca141.png"></p>
<h4 id="（1）可编程输入-输出单元"><a href="#（1）可编程输入-输出单元" class="headerlink" title="（1）可编程输入&#x2F;输出单元"></a>（1）可编程输入&#x2F;输出单元</h4><pre><code>    目前大多数 FPGA 的 I/O 单元被设 计为可编程模式，即通过软件的灵活配置，可以适配不同的电气标准与 I/O 物理特性；可以调整**匹配阻抗特性、上下拉电阻、以及调整驱动电流的大小** 等。         FPGA 支持的 I/O 电气标准有 LVTTL，LVCMOS，SSTL，HSTL，LVDS，LVPECL 和 PCI 等。一些高端 FPGA 通过 DDR 寄存器 技术，甚至可以支持高达 2Gbit/s 的数据数率。

    Zynq UltraScale+ MPSoC 上的通用输入/输出功能（IOB）合起来被称作 SelectIO 资源，每个 I/O 都是可配置的，**可以遵循多种 I/O 标准** 。I/O 分为**高范围(HR，high-range)、高性能(HP)和高密度(HD)** 三种类型。其中 HR 类型提供最广泛的电压支持，**从 1.2V 到 3.3V** 。HP 类型支持 1.0V 到 1.8V 它对性能操作进行了优化。HD 类型的 IO 一般一个 BANK 上由 24 个 IO 组成，能提供从 1.2V 到 3.3V 的电压支持。

    所有的 I/O 引脚都封装在 BANK 中，每个 BANK 上可以封装 52 个 HP 引脚，或者 52 个 HR 引脚，或 者 24 个 HD 引脚。每个 BANK 有一个公共的 VCCO 输出缓冲器电源，除了给输出缓冲器供电外也可以为 输入缓冲器供电。此外，HR BANK 可以一分为二，这两部分各自都有自己的 VCCO 供电。一些单端输入缓冲器需要一个内部产生的或外部应用的参考电压(VREF)。VREF 引脚可以直接连接 PCB，或者从 FPGA 内 部产生。
</code></pre>
<p>**         所有输入和输出 IO 可以配置为组合型（wire）或注册型（reg）<strong>。所有输入和输出</strong>均支持 DDR (Double data<br>rate)** 。任何输入或输出都可以单独延迟高达 1,250ps，<strong>分辨率为 5-15ps</strong> ，这种延迟被称为<strong>IDELAY 和 ODELAY</strong><br>。我们可以通过增减 IODELAY 的延迟步进进而调整 IODELAY 的延迟时间，也可以将 IODELAY 级联在一起，使单个方向上的延迟量增加一倍。</p>
<pre><code>    Zynq UltraScale+ MPSoC 的 IO 资源还支持串并转换。每个 I/O 引脚拥有一个 IOSERDES(ISERDES 和 OSERDES)，能够执行 2、4 或 8 位可编程宽度的串行到并行或并行到串行转换。
</code></pre>
<h4 id="（2）基本可编程逻辑单元"><a href="#（2）基本可编程逻辑单元" class="headerlink" title="（2）基本可编程逻辑单元"></a>（2）基本可编程逻辑单元</h4><pre><code>    基本可编程逻辑单元是可编程逻辑的主体，可以根据设计灵活地改变其内部连接与配置，完成不同的逻 辑功能。FPGA 一般是基于 SRAM 工艺的，其基本可编程逻辑单元几乎都是由**查找表（LUT，Look Up Table） 和寄存器（Register）** 组成。Xilinx UltraScale 系列 FPGA 内部查找表可以配置为带有**一个输出的 6 输入 LUT** ， 或者**两个带有独立输出但共用输入的 5 输入 LUT** ，查找表一般完成纯组合逻辑功能。FPGA 内部寄存器结构相当灵活，**可以配置为带同步/异步复位或置位的时钟使能触发器，也可以配置成锁存器** ，FPGA 依赖寄 存器完成同步时序逻辑设计。 一般来说，比较经典的基本可编程逻辑单元的配置是一个寄存器加一个查找表，但是不同厂商的寄存器 与查找表也有一定的差异，而且寄存器与查找表的组合模式也不同。当然这些可编程逻辑单元的配置结构随着器件的不断发展也在不断更新，最新的一些可编程逻辑器件常常根据需求设计新的 LUT 和寄存器的配置比率，并优化其内部的连接构造。 例如，Altera 可编程逻辑单元通常被称为 LE（Logic Element），由一个寄存器加一个 LUT 构成。Altera 大多数 FPGA 将 **10 个 LE 有机地组合在一起，构成更大的功能单元——逻辑阵列模块（LAB，Logic Array Block）** 。LAB 中除了 LE 还包含 LE 之间的进位链，LAB 控制信号，局部互联线资源，LUT 级联链，寄存器级联链等连线与控制资源。 Xilinx UltraScale 系列 FPGA 中的可编程逻辑单元叫 **CLB（Configurable Logic Block，可配置逻辑块）** 每个 CLB 包含一个逻辑运算片（**每个逻辑运算片包含 8 个 LUT 16 个寄存器** ）。逻辑运算片有两种类型， 分别是 SLICEL 和 SLICEM。SLICEM 中的 LUT 可以配置为 64 位 RAM、32 位移位寄存器(SRL32)或两个 16 位移位寄存器。与上一代 Xilinx 设备中的 CLB 相比，UltraScale 体系结构中的 CLB 增加了路由和连接 性。并且 UltraScale 的 CLB 还有额外的控制信号去使能更大的寄存器封装，可以提高设备的利用率。
</code></pre>
<p><strong>注：xilinx新一代 UltraScale 结构可参考《xilinx FPGA 权威设计指南》</strong></p>
<h4 id="（3）嵌入式块-RAM"><a href="#（3）嵌入式块-RAM" class="headerlink" title="（3）嵌入式块 RAM"></a>（3）嵌入式块 RAM</h4><pre><code>    目前大多数 FPGA 都有内嵌的**块 RAM（Block RAM）** ，FPGA 内部嵌入可编程 RAM 模块，大大地拓展了 FPGA 的应用范围和使用灵活性。不同器件商或不同器件族的内嵌块 RAM 的结构不同，Lattice 常用的 块 RAM 大小是 9Kbit；Altera 的块 RAM 最灵活，一些高端器件内部同时含有 3 种块 RAM 结构，分别是 M512 RAM，M4K RAM，M9K RAM。 每个基于 UltraScale 架构的设备都包含大量的 36Kb 块 RAM（Block RAM，简称 BRAM），可以配置 为一个 36Kb RAM 或两个独立的 18Kb RAM；每个块 RAM 都有两个完全独立的端口，且每个端口都可以读写数据，读写数据由时钟进行控制。每个块 RAM 列中有一个使能信号，这个信号能够让垂直相邻的块 RAM 之间级联，这样就可以创建大型、快速的存储阵列或者创建 FIFO，而且大大降低了功耗。 对于 RAM 来说，所有输入的数据、地址、时钟使能信号和写入使能都会被寄存。比如说输入一个地址 数据，这个地址数据就会被锁定(除非地址锁关闭)寄存，在下一次操作来临之前，地址寄存器的值是不会发生改变的。在写操作期间，也可以输出数据，输出的数据可以是先前存储的数据也可以是新写入的数据，当然在写操作期间也可以不输出数据。对于在设计中未使用的块 RAM 会**自动关闭，以减少总功耗** 。在每个块 RAM 上还具有额外的引脚来控制动态功率的门控特性。 对于 Xilinx UltraScale 系列 FPGA 来说，除了具有 BRAM 资源外，还有一种 **UltraRAM** 资源。UltraRAM 是一种高密度、双端口、同步内存块，用于一些 UltraScale+系列器件。这两个端口共用同一个时钟，可以处理 **4K x 72 位** 的数据，每个端口都可以独立地对内存数组进行读写操作。UltraRAM 支持两种类型的写操作方案，第一种模式与块 RAM 写操作模式一致；第二种模式允许控制数据的奇偶字节写入。多个 UltraRAM块可以级联在一起创建更大的内存阵列。UltraRAM 可以用专用的路径使整个列的存储区域连接在一起，这 使得 UltraRAM 成为替代 SRAM 等外部存储器的理想解决方案，它可以灵活的支持级联从 288Kb 到 36Mb 的存储空间，用以满足许多不同的内存需求。
</code></pre>
<h4 id="（4）丰富的布线资源"><a href="#（4）丰富的布线资源" class="headerlink" title="（4）丰富的布线资源"></a>（4）丰富的布线资源</h4><pre><code>    布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速 度。FPGA 芯片内部有着丰富的布线资源，这些布线资源根据工艺、长度、宽度和分布位置的不同而划分为 4 类不同的类别：

    第一类是**全局布线资源** ，用于芯片内部**全局时钟和全局复位/置位** 的布线；

    第二类是**长线资源** ，用以完成芯片 **Bank 间的高速信号和第二全局时钟信号的布线** ；

    第三类是**短线资源** ，用于完成基本逻辑单元之间的逻辑互连和布线；

    第四类是分布式的布线资源，用于专有时钟、复位等控制信号线。

    在实际中设计者不需要直接选择布线资源，布局布线器可自动地根据输入逻辑网表的拓扑结构和约束条件选择布线资源来连通各个模块单元。从本质上讲，布线资源的使用方法和设计的结果有直接的关系。
</code></pre>
<h4 id="（5）底层嵌入功能单元"><a href="#（5）底层嵌入功能单元" class="headerlink" title="（5）底层嵌入功能单元"></a>（5）底层嵌入功能单元</h4><pre><code>    底层**嵌入功能单元** 的概念比较笼统，这里我们指的是那些通用程度较高的嵌入式功能模块，比如 **PLL （Phase Locked Loop）、DLL（Delay Locked Loop）、DSP、CPU** 等。随着 FPGA 的发展，这些模块被越来 越多地**嵌入到 FPGA 的内部** ，以满足不同场合的需求。 目前大多数 FPGA 厂商都在 FPGA 内部**集成了 DLL 或者 PLL 硬件电路** ，用以完成时钟的高精度、低抖动的倍频、分频、占空比调整、相移等功能。目前，高端 FPGA 产品集成的 DLL 和 PLL 资源越来越丰富， 功能越来越复杂，精度越来越高。 另外，越来越多的高端 FPGA 产品将包含 DSP 或 CPU 等**硬核** ，从而 FPGA 将由传统的硬件设计手段逐步过渡到系统级设计平台。例如 Altera 的 Stratix IV、Stratix V 等器件内部集成了 DSP 核；Xilinx 的 Virtes II 和 Virtex II pro 系列 FPGA 内部集成了 Power PC450 的处理器。FPGA 内部嵌入 DSP 或 CPU 等处理器， 使 FPGA 在一定程度上具备了实现软硬件联合系统的能力，FPGA 正逐步成为 SOPC 的高效设计平台。
</code></pre>
<h4 id="（6）内嵌专用硬核"><a href="#（6）内嵌专用硬核" class="headerlink" title="（6）内嵌专用硬核"></a>（6）内嵌专用硬核</h4><pre><code>    这里的**内嵌专用硬核** 与前面的底层嵌入单元是有区分的，这里讲的内嵌专用硬核主要指那些**通用性相对较弱** ，不是所有 FPGA 器件都包含硬核。 在 ZYNQ UltraScale 的 PL 端和 PS 端各有一个**系统监视模块——System Monitors** ，它就是一个硬核。 System Monitors 包含一个模数转换器（ADC），一个模拟多路复用器，片上温度和片上电压传感器等。我们可以利用这个模块监测芯片温度和供电电压，也可以用来测量外部的模拟电压信号。
</code></pre>
<h3 id="4-MPSoC-PS-简介"><a href="#4-MPSoC-PS-简介" class="headerlink" title="4.MPSoC PS 简介"></a>4.MPSoC PS 简介</h3><pre><code>    MPSoC 实际上是 一个以处理器为核心的系统，**PL 只是它的一个外设** 。MPSoC 系列的亮点在于它**包含了完整的 ARM 处理器系统** ，且处理器系统中集成了内存控制器和大量的外设，使 **Cortex-A53 处理器可以完全独立于可编程逻辑单元** 。而且实际上在 MPSoC 中，**PL 和 PS 两部分的供电电路是独立的** ，这样 PS 或 PL 部分不被使用的话就可以被断电。

    在前面我们介绍 SOPC 时提到过，FPGA 可以用来搭建嵌入式处理器，像 **Xilinx 的 MicroBlaze 处理器 或者 Altera 的 Nios II 处理器** 。像这种使用 FPGA 的可编程逻辑资源搭建的处理器我们称之为“**软核”处理器** ，它的优势在于**处理器的数量以及实现方式的灵活性** 。

    而 MPSoC 中集成的是一颗**“硬核”处理器** ，它是硅芯片上专用且经过优化的硬件电路，硬核处理器的优势是它可以获得相对**较高的性能** 。另外，MPSoC 中的硬件处理器和软核处理器并不冲突，我们完全可以**使用 PL 的逻辑资源搭建一个 Microblaze 软核处理器** ，**来和 ARM 硬核处理器协同工作** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/064f01639500be171eeaf8ff627142be.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6e7b726f843d04b79e0d395bc15ad1fb.png"></p>
<pre><code>    从上面的结构图中可以很清楚的看到 MPSoC 的结构，它分为 PS 和 PL 两部分。在 PS 部分中它主要由 Arm Cortex-A53（APU 共 4 个核）、Arm Cortex-R5F（RPU 共两个核）以及 Arm Mali-400 MP2（GPU）三 种内核处理器构成，并且还包括 DDR 控制单元、平台管理单元、高速外设控制器以及普通外设控制器等外设组成。
</code></pre>
<h4 id="（1）APU（Application-Processing-Unit）"><a href="#（1）APU（Application-Processing-Unit）" class="headerlink" title="（1）APU（Application Processing Unit）"></a>（1）APU（Application Processing Unit）</h4><p>APU 主要是由两个或者四个 ARM 处理器核组成的，Cortex-A53 核心是基于 Arm-v8A 架构的 32 位&#x2F;64<br>位应用程序处理器，拥有极佳的性能&#x2F;功率比，每一个 Cortex-A53 核心拥有 32KB 指令和数据 L1 缓存，具 有奇偶校验、ECC 保护、NEON<br>SIMD 引擎、单精度和双精度浮点单元。除了这些模块，APU 还有一个 snoop 控制单元以及一个带 ECC 保护的 1MB L2<br>缓存，这样的设计可以更好的提高系统级的性能。该 APU 还具有 内置的中断控制器支持虚拟中断。</p>
<p>它的结构框图如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/106eae5a24e0a7fb2a345b01badee237.png"></p>
<h4 id="（2）RPU（Real-Time-Processing-Unit）"><a href="#（2）RPU（Real-Time-Processing-Unit）" class="headerlink" title="（2）RPU（Real-Time Processing Unit）"></a>（2）RPU（Real-Time Processing Unit）</h4><pre><code>    PS 中的 RPU 包含一个双核 Arm Cortex-R5F 处理器，Cortex-R5F 是 32 位实时处理器，它是基于 Arm-v7R 架构的处理器内核。每个 Cortex-R5F 核都有 32KB 的指令和数据缓存（L1），除了 L1 缓存，每个 Cortex-R5F 核心还具有 128KB 的紧耦合内存(TCM)接口，用于实时单周期访问。RPU 还有一个专用的中断控制器。 两个 RPU 既可工作在独立模式，也可以工作在同步模式。在独立模式中两个处理器都是独立运行的；在同步模式下，它们彼此并行运行，逻辑资源也会综合到一起，并且 TCM 资源也整合成 256KB。RPU 还可以通过 **AXI-4 端口** 与 PS 端的 LPD 区域进行通信或者与 PL 端进行低延迟通信。支持实时 DEBUG 和信号跟踪， 每个内核还具有一个嵌入式跟踪宏单元(ETM)方便 Arm 内核调试。

    Cortex-R5 处理器是用于深度嵌入式实时系统的 CPU，它采用了 **Thumb-2 技术** 以获得最佳的代码密度和处理吞吐量，它还具有一个算术逻辑单元(ALU)，为了更加有效地利用其他资源（例如寄存器资源），算术逻辑单元会执行有限的双重指令。Cortex-R5 处理器会通过重新启动和加载多个指令来保持较低的中断延迟，并且还会使用一个专用的外围端口来实现对中断控制器的低延迟访问。处理器具有紧密耦合内存(TCM) 端口，用于低延迟和确定性地访问本地 RAM。错误检查和纠正功能(ECC)是用于 Cortex-R5 处理器端口和 Level 1 (L1) 存储器的，这样可以提高系统的可靠性和准确性。Cortex-R5 处理器的结构框图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21571fa533509d390545702afb58271c.png"></p>
<h4 id="（3）GPU（Graphics-Processing-Unit）"><a href="#（3）GPU（Graphics-Processing-Unit）" class="headerlink" title="（3）GPU（Graphics Processing Unit）"></a>（3）GPU（Graphics Processing Unit）</h4><pre><code>    GPU 是基于 **Arm Mali - 400 MP2** 硬件加速器的 2D 和 3D 图形子系统。它由一个**几何图形处理器（GP）、 两个像素处理器（PP）、64KB L2 缓存控制器（L2）、针对 GP 和每个 PP 的独立内存管理单元(MMU)以及 128 位 AXI 总线接口构成** 。Arm Mali-400 MP2 作为 PS 专用的图形处理器它可以支持 2D 和 3D 图形加速， 最高分辨率为 1080p，对于 3D 图形它能够支持 OpenGL ES 1.1 and 2.0 规范而对于 2D 的矢量图形它只能支 持 Open VG 1.1 标准。它的几何处理器(GP)和 2 个像素处理器会并行地执行贴图渲染操作。它为 GP 和像素处理器提供了专用的内存管理单元，支持 4 KB 的页面大小。

    GPU 还有 64KB 的二级(L2)只读缓存，它支持 4X 和 16X 全场景抗锯齿(FSAA)功能。它有内置的硬件纹理解压缩，允许纹理在图形硬件中保持压缩(ETC 格式)，并在运行中解压所需的样本。它还支持在不消耗额外带宽的情况下有效地混合多个硬件层，它的像素填充率为 200 万像素/秒/MHz，三角形填充率为 0.1Mvertex/秒/MHz。GPU 支持广泛的纹理格式为 RGBA 8888、565、1556 以及 YUV 格式，对于功率敏感 的应用，GPU 支持对每个 GP、像素处理器和 L2 缓存的时钟和功率进行门控。在功率门控过程中，GPU 不 消耗任何静态或动态功率；在时钟门控过程中，它只消耗静态电源。
</code></pre>
<h4 id="（4）DDR-Memory-Controller"><a href="#（4）DDR-Memory-Controller" class="headerlink" title="（4）DDR Memory Controller"></a>（4）DDR Memory Controller</h4><pre><code>    DDR 存储控制器通过**六个 AXI 数据接口** 和一**个 AXI 控制接口** 连接到 MPSoC 的其余部分，其中一条数据路径连接到实时处理单元(RPU)，两条数据路径连接到缓存相干互连(CCI-400)，其他的在 DisplayPort 控 制器、FPD、DMA 和编程逻辑(PL) 上多路复用。在 6 个接口中，5 个是 128 位宽，而第 6 个接口(绑定到 RPU)是 64 位宽。DDR 子系统支持 DDR3、DDR3L、LPDDR3、DDR4 和 LPDDR4，它可以通过 AXI 总线 接口接收来自 6 个应用主机端口的读写请求，这些请求在内部排队访问 DRAM 设备。存储器控制器**在 DDRPHY 接口上向 PHY 模块发出命令** ，PHY 模块从 DRAM 中读取和写入数据。DDR Memory Controller 的结 构如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a8305f1515bf5ca6c2a3121525a2e38.png"></p>
<h4 id="（5）PMU（Platform-Management-Unit）"><a href="#（5）PMU（Platform-Management-Unit）" class="headerlink" title="（5）PMU（Platform Management Unit）"></a>（5）PMU（Platform Management Unit）</h4><pre><code>    Zynq UltraScale+ MPSoC包括一个专用的用户可编程处理器，用于电源、错误管理的**平台测量单元(PMU) 处理器** ，以及用于功能安全应用的可选软件测试库(STL)。由于 PMU 的结构和配置相当复杂这里我们只简 要列出他的功能，更加详细的介绍大家可以参考 Xilinx 官方文档 ug1085。 PMU 的功能如下：1、 使用系统监视器检查电源水平，以确保 CSU 和 LP 域的其余部分正常运行。 2、 初始化 pll 的默认配置和他们潜在的旁路。 3、 触发和排序必要的扫描和 MBIST。 4、 捕获并发出错误信号，错误 ID 可以通过 JTAG 读取。 5、 释放复位到 CSU。 6、 在应用程序和实时处理器处于睡眠状态时充当它们的委托，并在接收到它们的唤醒请求之后对他 们进行开机和重启。 7、 在任何时候维护系统电源状态。 8、 处理不同块的上电、下电、复位、内存内置自修复(MBISR)、MBIST 和扫描归零所需的低级事件序列。 9、 在休眠模式下管理系统，并基于各种触发机制唤醒系统。 10、 PS-level 错误捕获。
</code></pre>
<h4 id="（6）High-Speed-Connect-Zynq"><a href="#（6）High-Speed-Connect-Zynq" class="headerlink" title="（6）High-Speed Connect Zynq"></a>（6）High-Speed Connect Zynq</h4><pre><code>    UltraScale+ MPSoC 的 PS 端集成了 5 个高速外设，分别是 **DP 控制器、USB3.0 控制器、SATA3.1 控制器、PCIE 1.0/2.0 控制器以及 PS-GTR 收发器** 。

    1、DP接口（**DisplayPort 控制器** ）：Zynq UltraScale+ MPSoC 的 PS 端集成了 DisplayPort 控制器，它可以从内存(非实时输入)或(实时输入)可编程逻辑(PL)中获取数据，并将这些数据处理过后通过 DisplayPort 源控制器块输出到外部显示设备或 PL(实时输出)上。DisplayPort 控制器由 **DMA、缓冲区管理器、显示渲染块、音频混音块、DisplayPort 源控制器以及 PS-GTR 模块** 组成，它可以支持 超高清(UHD)视频，因此 **DP 接口常用来做视频图像传输的接口** 。

    2、 USB3.0：USB 3.0 控制器由两个独立的 DRD (dual-role device)控制器组成，两者都可以单独配置为 在任何给定时间作为主机或从机设备工作。USB 3.0 DRD 控制器通过高级的可扩展 AXI 从接口， 可以为系统软件提供一个可扩展的主控制器接口(xHCI)。控制器中有一个内部的 DMA 引擎，它利 用 AXI 主接口来传输数据。三个双端口 RAM 的配置可以实现 RX 数据 FIFO、TX 数据 FIFO 和描 述符/寄存器缓存功能，AXI 主端口与协议层可以通过缓冲区管理单元访问不同的 RAM。

    3、 SATA3.1：SATA 控制器是一种高性能双端口主机控制器，具有 AHCI 兼容的命令层，该命令层对 使用端口乘法器的系统来说，具有支持基于本地命令队列和帧信息结构(FIS)交换的高级功能。 SATA 使用 ATA/ATAPI 命令集，但是通过不同的导线可以实现与 SATA 第 1 代、第 2 代或第 3 代 相对应的 1.5、3.0 或 6.0 Gb/sec 的速率进行串行通信。串行数据采用 8B/10B 编码，确保数据模式 中有足够的转换以确保直流平衡（这里的转换指数据的 0/1 转换，关于直流平衡的知识大家可以自行了解或者看我们 HDMI 相关的视频，其中有涉及），并使时钟数据恢复电路能够从输入数据模式中提取时钟。

    4、 PCIe 1.0/2.0 控制器：MPSoC 集成了一个 PCIe 通信控制器，用于实现 PCIe 的通信，它包含**AXI-PCIe 桥和 DMA 组件** ，AXI-PCIe 桥主要是为 PCIe 和 AXI 提供高性能桥接。模块示意图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db511727b124ee7bc65a3c18c44c9ac5.png"></p>
<pre><code>    从上图中可以看到控制器由两个子模块组成，其中 PCIe 桥的主要功能除了**将 PCIe 协议与 AXI 协议相互转换** 外还可以转换入口/出口地址，为 DMA 和 Root Port/Endpoint (RP/EP)模式切换提供特定的服务。

    5、 PS-GTR 收发器：千兆 GTR 收发器为串行输入输出单元(SIOU)的外围设备、媒体访问控制器(mac) 以及它们的高速通信链路提供专用的 I/O。Zynq UltraScale+ MPSoC 共有四个可编程高速收发器， 可以支持数据速率高达 6gb /s 的子层协议。
</code></pre>
<h4 id="（7）普通外设控制器"><a href="#（7）普通外设控制器" class="headerlink" title="（7）普通外设控制器"></a>（7）普通外设控制器</h4><pre><code>    Zynq UltraScale+ MPSoC 的 PS 端除了集成的高速通信外设之外，还有一些普通的低速外设，其中包括 **GigE、USB2.0、CAN、UART、SPI、Quad SPI NOR、NAND 以及 SD/eMMC** 等外设控制器。
</code></pre>
<h4 id="（8）PS-PL-AXI-接口"><a href="#（8）PS-PL-AXI-接口" class="headerlink" title="（8）PS-PL AXI 接口"></a>（8）PS-PL AXI 接口</h4><pre><code>    MPSoC 将高性能 ARM Cotex-A 系列处理器与高性能 FPGA 在单芯片内紧密结合，为设计带来了如减小体积和功耗、降低设计风险，增加设计灵活性等诸多优点。在将不同工艺特征的处理器与 FPGA 融合在 一个芯片上之后，片内处理器与 FPGA 之间的互联通路就成了 MPSoC 芯片设计的重中之重。如果 Cotex-A53 与 FPGA 之间的数据交互成为瓶颈，那么处理器与 FPGA 结合的性能优势就不能发挥出来。 Xilinx 从 Spartan-6 和 Virtex-6 系列开始**使用 AXI 协议来连接 IP 核** 。在 7 系列、Zynq-7000 和 Zynq UltraScale+ MPSoC 器件中，Xilinx 在 IP 核中继续使用 AXI 协议。AXI 的英文全称是 **Advanced eXtensible Interface，即高级可扩展接口** ，它是 ARM 公司所提出的 AMBA（Advanced Microcontroller Bus Architecture）协议的一部分。

    AXI 协议是一种高性能、高带宽、低延迟的片内总线，具有如下特点：

    1、总线的**地址/控制和数据通道是分离** 的；

    2、支持**不对齐的数据传输** ；

    3、支持突发传输，突发传输过程中只需要首地址；

    4、具有分离的读/写数据通道；

    5、支持显著传输访问和乱序访问；

    6、更加容易进行时序收敛。

    在数字电路中只能传输二进制数 0 和 1，因此可能需要一组信号才能高效地传输信息，这一组信号就组成了接口。AXI4 协议支持以下三种类型的接口：

    1、 **AXI4** ：高性能存储映射接口。

    2、 **AXI4-Lite** ：简化版的 AXI4 接口，用于较少数据量的存储映射通信。

    3、 **AXI4-Stream** ：用于高速数据流传输，非存储映射接口。

    AXI4 协议支持**突发传输** ，主要用于处理器访问存储器等需要指定地址的高速数据传输场景。AXI-Lite 为外设提供单个数据传输，主要用于访问一些低速外设中的寄存器。而 AXI-Stream 接口则像 FIFO 一样， 数据传输时**不需要地址** ，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接 口等需要高速数据传输的场合。

    在 **PS 和 PL 之间的主要连接是通过一组 12 个 AXI 接口** ，每个接口有多个通道组成。这些形成了 PS 内部的互联以及与 PL 的连接，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fbe5480df361ea6c20b12f14e4d0579.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/24463930ff0801a294b79279e850f73d.png"></p>
<pre><code>    上图给出了每个接口的简述，标出了主机是 PL 还是 PS（按照惯例，主机是控制总线并发起会话的， 而从机是做响应的）。需要注意的是，接口命名的第一个字母表示的是 PS 的角色，也就是说，第一个字 母 “M” 表示 PS 是主机，而第一个字母“S”表示 PS 是从机。

    S_AXI_HP&#123;0:3&#125;_FPD/S_AXI_HPC&#123;0,1&#125;_FPD：六个 **PL 侧高性能（High Performance）AXI 主接口连接到 PS 侧的 FPD（Full-power domain）**，主要**用于访问 DDR 内存** ，进行大量数据的传输，如摄像头图像数据等。所有的六个高性能 AXI 主接口都经过了 PS 中的 **SMMU（System Memory Management Unit）** ， SMMU 能够使用**物理和虚拟地址转换** 。其中一致性 S_AXI_HPC 接口连接到了 **CCI（Cache-coherent interconnect）** ，可以**访问 L1 和 L2 Cache** ，也正是连接到了 CCI，所以在访问 DDR 控制器时，相比于 S_AXI_HP 接口来说，延时会较大。

    S_AXI_LPD：主机 PL 连接至从机 PS 侧**LPD（Low-power domain）** 的高性能 AXI 接口，它能够低延 时地访问 OCM（On-chip Memory）和 TCM（Tightly-coupled Memory）。         S_AXI_ACE_FPD：主机 PL 与从机 PS 中的 CCI 相连接，它能够支持 PS 和 PL 中的硬件块之间的**完全一致性（双向）** 。该接口使用的是 ACE（AXI coherency extension）协议，与 AXI 接口相比，ACE 协议 使用了五个额外的通道，三个通道用于监听，两个用于应答。         S_AXI_ACP_FPD：该接口实现了 PL 和 PS 之间的低延时访问，PL 端可以直接访问 APU 的 L1 和 L2 Cache 以及 DDR 内存。

    M_AXI_HPM&#123;0,1&#125;_FPD：该高性能接口由主机 **PS 侧 FPD 连接至从机 PL** ，可以用于 CPU、 DMA、 PCIe 等传输大量数据到 PL。

    M_AXI_HPM0_LPD：该高性能接口由主机 PS 侧 LPD 连接至从机 PL，该接口适合于为 PS 中的 LPD 主机（例如 LP-DMA）提供对 PL 中的存储器的访问，也经常用于配置 PL 端的寄存器。

    上面每条总线都是由一组信号组成的，这些总线上的会话是根据 AXI4 总线协议进行通信的。
</code></pre>
<h3 id="5-DFZU2EG-MPSoc-硬件连接资源"><a href="#5-DFZU2EG-MPSoc-硬件连接资源" class="headerlink" title="5.DFZU2EG MPSoc 硬件连接资源"></a>5.DFZU2EG MPSoc 硬件连接资源</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/285558105285fc578ebeac7655e5f78a.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/356e3108207098fd32f04578acc1619b.png"></p>
<pre><code>    具体说明见参考书目 P38~P42 ；注意点说明：1.纽扣电池座：DFZU2EG/4EV MPSoC 开发板板载一个纽扣电池座，在开发板断电时，电池可以持续为 MPSoC 芯片内 部的 RTC 实时时钟模块进行供电，以维持计时的功能。2. 1.8 V IO 电平扩展口和 3.3 V IO 电平扩展口。
</code></pre>
<p>详细说明：</p>
<h4 id="（1）IO-分配"><a href="#（1）IO-分配" class="headerlink" title="（1）IO 分配"></a>（1）IO 分配</h4><pre><code>    Zynq UltraScale+ MPSoC 系列的 xczu2cg-sfvc784-2、 xczu2eg-sfvc784-2 和 xczu4ev-sfvc784-1，总共有 14 个用户 BANK（指连接外设的 BANK，不包 BANK224）。这 14 个 BANK 中有 6 个属于 PS 端，8 个属于 PL 端，不同的 BANK 上连接有不同的外设。

    **PL 端** 的 IO 被分成 8 组也就是 8 个 BANK，同一个 BANK 中 IO 供电是相同的，不同的 BANK 之间供电电压可以不相同。在 DFZU2EG/4EV MPSoC 开发板中 PL 端 BANK24、BANK44、BANK25 以及 BANK26 都是 3.3V 电压供电，而 BANK64、BANK65 是 1.2V 供电，BANK0、BANK66 是 1.8V 供电。之所以不同 BANK 之间的供电不同主要和它们连接的外设，即承担的功能有关，遵循的原则就是**速度越快电压越低** ，例如 BANK64 连接的是 DDR4 芯片，需要处理高速的数据吞吐，因此它的供电电压较低，为 1.2V。举例 BANK 的原理图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ea8e0b7083b76eb21ac3a85c38d02a8e.png"></p>
<pre><code>    从原理图中可以看出 DFZU2EG/4EV MPSoC 开发板的 PL 端引脚是非常多的，为了方便大家查找我们将例程用到的整理成了一张表格，可在参考书目P55~P59查看。

    **PS 端** 一共包含了 6 个 IO BANK，与 PL 端 IO BANK 不同的是，**PS 端的 IO 连接是是相对固定的** ，用户不能够像 PL 引脚那样，将 PS 端的 IO 随意分配到某个外设。PS 端外设的 IO 口与 MIO（多路复用 IO）之间，具有**固定关系的映射** ，某 个外设的 IO 口可能会映射到不同的 MIO 上，某个 MIO 也有可能会具有多个外设的 IO 口映射到其上面。 可在参考书目P63~P65查看。
</code></pre>
<h4 id="（2）电源系统"><a href="#（2）电源系统" class="headerlink" title="（2）电源系统"></a>（2）电源系统</h4><p>下图是电源的拓扑结构，标出了降压模块和降压后的电压：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d78702e8eff3db86591525204aea5c5.png"></p>
<pre><code>    这里要特别提醒一下大家，板子上有的已经有一种电压了例如 1.8V，为什么后 面还要再转个 1.8V 出来，而且同一种电压还会有好几个名称，这主要是因为有很多器件是有**上电顺序** 的，**不可以同时上电** ，虽然工作电压都相等，但是上电顺序有先后要求，所以我们就通过一定的电路设计让整 个板子上的器件有一个先后的上电顺序，这就是为什么同一种电压转换了多次或者好几个名字，主要是每 个名字代表的电压产生的顺序不同。
</code></pre>
<p>电源适配器供电的电源接口原理图如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/774c4af01a11930c7c6f55af86cbf36e.png"></p>
<pre><code>    上图电路的作用是将外部输入的+12V 电压经过降压芯片转换为 5V 电源 VBTN 输出。参考书目上有各个模块供电的说明P67~P76。        
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/86bcd774d1cd313007ac19e14a85151b.png"></p>
<p><strong>启动顺序： VCC_PSAUX &gt;DDR_1V2&gt;VCC_3V3&gt;PL_VCU_0V9（1.8V&gt;1.2V&gt;3.3V&gt;0.9V）</strong></p>
<pre><code>    PS 端在全功率域（FPD）可以工作之前，低功率域（LPD）必须工作。

    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了低功率域（LPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。

    1.VCC_PSINTLP

    2.VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL 以任何顺序或同时进行。

    3.VCCO_PSIO

    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了全功率域（FPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。 、

    1.由同一电源驱动的 VCC_PSINTFP 和 VCC_PSINTFP_DDR。         

    2.VPS_MGTRAVCC 和 VCC_PSDDR_PLL 以任何顺序或同时进行。

    3.VPS_MGTRAVTT 和 VCCO_PSDDR 以任何顺序或同时进行。

    官方推荐的 PS 端低功率域（LPD）上电顺序为：VCC_PSINTLP→VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL→VCCO_PSIO。

    官方推荐的 PS 端 全 功 率 域 （ FPD ） 上 电 顺 序 为 ： VCC_PSINTFP 和 VCC_PISNTFP_DDR→ VPS_MGTRAVCC 和 VCC_PSDDR_PLL→VPS_MGTRAVTT 和 VCCO_PSDDR。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0dd10c2803ebb95a035348f35d63475.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/30ba53b3d6ab97f14bf66dc9246ad6d9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad6edabb65d61577965736979d110b08.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f70d5d4b2d9e764aae43aef8f2f91aa2.png"></p>
<h4 id="（3）启动模式"><a href="#（3）启动模式" class="headerlink" title="（3）启动模式"></a>（3）启动模式</h4><pre><code>    DFZU2EG/4EV MPSoC 开发板支持 8 种启动模式，我们常用的启动模式是 **JTAG 启动、FLASH 启动以 及 SD 卡启动，此外还支持 eMMC 启动以及 USB 启动** 。具体的启动方式选择可以通过拨动拨码开关去控制，拨码开关拨动的值和对应的启动模式，在原理图中以表格的形式给大家列举出来了。其原理图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ee1a75579935f6c78af98f0332fc8eb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9fee6f910356db649db8c4e9ac714e0.png"></p>
<h4 id="（4）其他硬件资源"><a href="#（4）其他硬件资源" class="headerlink" title="（4）其他硬件资源"></a>（4）其他硬件资源</h4><pre><code>    此外，参考书目**P76~P101** 列出了 _PL 端千兆以太网、PS 端千兆以太网、USB3.0 接口、USB HUB 芯片、MINI DP 接口、PS 端串口、PL 端串口、XADC 接口、时钟振荡器、J19 扩展口、J1 扩展口、EEPROM、PCIe 接口、PS 端 4 片 DDR4、PL 端 1 片 DDR4、eMMC、风扇接口、PL和 PS 端按键、PL 和 PS 端 LED、MIPI CSI 接口、PL 配置完成指示灯、电源指示灯、HDMI 接口WIRELESS 接口、**ATK-MODULE** 、PL 和 PS 端复位、TF 卡接口、**QSPI FLASH** 、RGB888 TFT-LCD_ 等的**电路连接、引脚说明、时序结构** 等说明。
</code></pre>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><h4 id="（1）注意事项"><a href="#（1）注意事项" class="headerlink" title="（1）注意事项"></a>（1）注意事项</h4><pre><code>    为了让大家更好的使用 DFZU2EG/4EV MPSoC 开发板，我们在这里总结该开发板使用的时候尤其要 注意的一些问题，希望大家在使用的时候多多注意，以减少不必要的问题。

    1\. 当你想使用某个 IO 口用作其他用处的时候，请先看**看开发板的原理图** ，该 IO 口是否有连接在开发板的某个外设上，如果有，该外设的这个信号是否会对你的使用造成干扰， 先确定无干扰，再使用这个 IO。

    2\. 开发板上的**拨码开关需要拨到对应的模式** 才能启动开发板，如果模式和启动方式不对应会造成代码下载失败或者板子启动不起来。

    3\. 当液晶显示白屏的时候，请先检查液晶模块是否插好（拔下来重新插试试），如果 还不行，可以通过串口看看 LCD ID 是否正常，再做进一步的分析。
</code></pre>
<h4 id="（2）学习-MPSoC-基本方法："><a href="#（2）学习-MPSoC-基本方法：" class="headerlink" title="（2）学习 MPSoC 基本方法："></a><strong>（2）学习 MPSoC 基本方法：</strong></h4><p>**         &lt;1&gt;了解 MPSoC 的基本结构**</p>
<pre><code>    学习 MPSoC 之前需要先对 **MPSoC 基本结构和其功能** 有个大概的了解，如 PS、AXI 总线、锁相环 PLL、FIFO 等。需要知道 PLL 是用来产生不同频率的时钟，如使用 HDMI 时需要生成 75MHz 的时钟； FIFO 用于数据的缓存和异步时钟域数据的传递等。
</code></pre>
<p>**         &lt;2&gt;了解 Verilog HDL 基本语法**</p>
<pre><code>    Verilog HDL 做为一种硬件描述语言，是 对数字电路的一种描述，而数字电路是并行工作的，因而在编写 Verilog HDL 时要有**并行的思想** ，不同于 软件设计语言，软件设计语言是由 CPU 统一进行处理，一条指令一条指令的串行运行，所以软件设计语 言是基于串行的设计思想，因而在写 Verilog HDL 代码的时候要注意这种差别。另外对于 Verilog HDL 的 基本语法是务必要掌握的，如一般常用的 module/endmodule、input/output/inout、wire/reg、begin/end、 posedge/negedge、always/assign、if/else、case/default/endcase/parameter/localparam 等关键字要清楚它们的作用和区别。掌握了 Verilog HDL 的基本语法和 Verilog HDL 的并行设计思想后，会觉得 Verilog HDL 和 C 语言一样简单。
</code></pre>
<p>**         &lt;3&gt;MPSoC PS 的学习**</p>
<pre><code>    学习 MPSoC PS 首先要了解 C 语言的基本语法。然后了解 **PS 端基本的系统框架和外设** ，例如 **PS 端架构、片内互连、AXI 总线、DDR 控制器** 等等。最关键的是 **PS 端的 C 程序** 。软件系统可以被认为是建立于基于硬件的系统上的一个栈，或者说是一系列层，**从底至上依次是基础硬件系统（来自 Vivado 的自定义硬件）、板级支持包、Operating System、软件应用** 。

    初学者可以多看看官方的文档和资料，对于 PS 端的软件，**xilinx 提供了丰富的库函数** ，很多时候用户直接调用调用即可，读者要学会利用这些库函数。遇到问题时，读者可以借助 xilinx 的 SDK 开发环境中的各种调试功能来定位错误，以帮助解决问题。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133233092">https://blog.csdn.net/qq_32971095/article/details/133233092</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:30:48" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：《DFZU2EG_4EV MPSoC 之嵌入式 VITIS 开发指南》——正点原子</p>
<h2 id="一-自定义-IP-核-呼吸灯实验"><a href="#一-自定义-IP-核-呼吸灯实验" class="headerlink" title="一.自定义 IP 核-呼吸灯实验"></a>一.自定义 IP 核-呼吸灯实验</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>   通过**创建和封装 IP 向导** 的方式来自定义 IP 核，将模块集成到 Vivado 中的 IP 库中。本 次实验选择常用的方式，即创建一个带有 AXI 接口的 IP 核，该 IP 核通过 AXI 协议实现 PS 和 PL 的数据通信。
</code></pre>
<h4 id="硬件框图"><a href="#硬件框图" class="headerlink" title="&lt;1&gt;硬件框图"></a>&lt;1&gt;硬件框图</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7f69746d9c8b2612a562e216cbcb06d.png"></p>
<pre><code>    自定义一个 LED IP 核，来控制 PL LED 呈现呼吸灯的效果，并且 **PS 可以通过 AXI 接口来控制呼吸灯的开关和呼吸的频率** 。
</code></pre>
<h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><h4 id="step1：自定义IP核"><a href="#step1：自定义IP核" class="headerlink" title="step1：自定义IP核"></a>step1：自定义IP核</h4><h5 id="创建IP核"><a href="#创建IP核" class="headerlink" title="&lt;1&gt;创建IP核"></a>&lt;1&gt;创建IP核</h5><pre><code>    在vivado进入界面点击“Tasks”栏中的“Manage IP”。在弹出的选项中选择“New IP Location...”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/75f9ff5dc9db70244cab46a870f0688d.png"></p>
<p>设置工程路径**“IP Location”**   和 器件**“Part”（后续可重新指定）：**</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3b1e3885d4a1f135051044efbbe1a2b.png"></p>
<pre><code>    工程创建完成后，运行**创建和封装 IP 向导** 。点击**菜单栏的“Tools”** ，选择**“Create and Package New IP”** ，在弹出的界面中，点击“NEXT”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4052ba288d62dba075506fe808c59d.png"></p>
<p>可选择封装 IP 或者创建一个带 AXI4 接口的 IP 核 ：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d966c8cd8965f275b224c4f87af580a0.png"></p>
<pre><code>    接下来分别设置 IP 核名称（Name）、版本号（Version）、显示名（Display name）、描述（Description） 和路径（IP location）。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb004f9d3e754f9cc51b150f9afb459d.png"></p>
<p>接下来对 AXI 接口进行设置：</p>
<p><strong>Name（名称）</strong> ：这里修改成 S0_AXI。</p>
<p><strong>Interface Tpye（接口类型）</strong> ：共三种接口类型可选，分别是 <strong>Lite、Full 和 Stream</strong> 。AXI4-Lite<br>接口是<strong>简化版</strong> 的 AXI4 接口，用于较少数据量的存储映射通信；AXI4-Full 接口是<strong>高性能存储映射接口</strong><br>，用于较多数据量的存储映射通信；AXI4-Stream 用于<strong>高速数据流传输</strong> ，非存储映射接口。本次实验只需少量数据的通信， 因此接口类型选择默认的<br>Lite 接口。</p>
<p><strong>Interface Mode（接口模式）</strong> ：接口模式有 <strong>Slave（从机）和 Master（主机）</strong> 两种模式可选，AXI<br>协议是<strong>主机和从机通过“握手”的方式建立连接</strong> ，这里选择默认的 <strong>Slave 接口模式</strong> 。</p>
<p><strong>Data Width（数据宽度）</strong> ：数据位宽保持默认，即 32 位位宽。</p>
<p><strong>Memory Size（存储器大小）</strong> ： 在 AXI4-Lite 接口模式下，该选项不可设置。</p>
<p><strong>Number of Registers（寄存器数量）</strong> ：用于配置 PL LED 呼吸灯寄存器的数量，这里保持默认。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/91283af0eb0913bef4fd7d225f3b9a7b.png"></p>
<pre><code>    最后弹出封装接口的总结描述和下一步操作选项的界面。这里保持默认，即**将 IP 添加至 IP 库中** ， 点击“Finish”按钮完成 IP 核的创建和封装。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/413f0da1496d94c764828b274017a30e.png"></p>
<pre><code>     在 **IP Catalog 界面** 中可以看到刚刚添加的 IP 核，位于 **User Repository** 一栏中的 AXI Peripheral 下，名称 为“breath_led_ip_v1.0”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a18c63c55f085bf15281c34ab989331.png"></p>
<h5 id="编辑IP核"><a href="#编辑IP核" class="headerlink" title="&lt;2&gt;编辑IP核"></a>&lt;2&gt;编辑IP核</h5><pre><code>    右击 breath_led_ip_v1.0 IP 核， 选择“**Edit in IP Packager** ”，在弹出的界面中点击“OK”。此时会打开一个新的工程：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/63e543b57d5d554d9b74780351c6fb78.png"></p>
<pre><code>    双击 breath_led_ip_v1_0.v文件即可开始编辑代码，来添加控制 PL LED 呼吸灯所需要的参数和端口信号：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e30dec6de76b6e61b1aa50c039589999.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3f8c3ad3ebbdf5bdc9e7ad185618452.png"></p>
<pre><code>    在创建和封装 IP 核向导中，我们总共定义了 4 个寄存器，代码中的 slv_reg0 至 slv_reg3 是寄存器地址 0 至寄存器地址 3 对应的数据，通过例化呼吸灯模块，**将寄存器地址对应的数据和呼 吸灯模块（breath_led****） 的控制端口相连接**，即可实现对呼吸灯的控制。 
</code></pre>
<p>breath_led_ip_v1_0.v文件：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/252b8cca44230059c49602a5452d9998.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f62dc01cb25ae99d4f697d5b7638e66.png"></p>
<pre><code>    breath_led_ip_v1_0_S0_AXI.v文件。 breath_led_ip_v1_0_S0_AXI 模块实现了 AXI4 协议下的读写寄存器的功能：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/425827ac7a64452aea8a0413ea593bcf.png"></p>
<p>时我们还需要在代码的第 401 行例化 breath_led.v 文件：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ffed17009e2230f835db7440ba21eee.png"></p>
<pre><code>	// Add user logic here
    breath_led #(
        .START_FREQ_STEP(START_FREQ_STEP)
    )
    u_breath_led(
        .sys_clk (S_AXI_ACLK),
        .sys_rst_n (S_AXI_ARESETN),
        .sw_ctrl (slv_reg0[0]),
        .set_en (slv_reg1[31]),
        .set_freq_step (slv_reg1[9:0]),
        .led (led)
    );
	// User logic ends

    代码中的 **slv_reg0 和 slv_reg1 是寄存器地址 0 和寄存器地址 1 对应的数据** ，我们通过寄存器地址 0 对应 的数据来控制呼吸灯的使能（sw_ctrl），寄存器地址 1 对应数据的最高位控制呼吸灯频率的设置有效信号 （set_en），寄存器地址 1 对应数据的低 10 位控制呼吸灯频率的步长（set_freq_step）。

    此时工程中缺失 breath_led.v 文件，breath_led.v 文件用于实现呼吸灯的功能。右击**“Design Sources”** ，选择**“Add Sources…”** ，在弹出的界面中选择“**Add or Create design source”** ， 点击“NEXT”；点击“**Create File ”** 创建一个新的文件，在弹出的界面输入名称 breath_led ，路径 为../**_custom_ip/ip_repo/breath_led_ip_1.0/_ hdl**，点击“OK”按钮
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e3c33e0d2c764bd425828a96898b80d.png"></p>
<pre><code>    在弹出的**模块定义界面中点击“OK”按钮** ，接下来在弹出的确认按钮中点击“YES”。双击 u_breath_led(breath_led.v)文件并编辑代码如下：


module breath_led(
    input          sys_clk        , //时钟信号
    input          sys_rst_n      , //复位信号
    input          sw_ctrl        , //呼吸灯开关控制信号 1：亮 0:灭
    input          set_en         , //设置呼吸灯频率设置使能信号
    input   [9:0]  set_freq_step  , //设置呼吸灯频率变化步长
    
    output         led              //LED
);

//*****************************************************
//**                  main code
//*****************************************************

//parameter define
parameter  START_FREQ_STEP = 10&#39;d100; //设置频率步长初始值

//reg define
reg  [15:0]  period_cnt  ;      //周期计数器
reg  [9:0]   freq_step   ;      //呼吸灯频率间隔步长
reg  [15:0]  duty_cycle  ;      //设置高电平占空比的计数点
reg          inc_dec_flag;      //用于表示高电平占空比的计数值,是递增还是递减
                                //为1时表示占空比递减,为0时表示占空比递增
//wire define
wire         led_t       ;

//将周期信号计数值与占空比计数值进行比较，以输出驱动led的PWM信号
assign led_t = ( period_cnt &lt;= duty_cycle ) ? 1&#39;b1 : 1&#39;b0 ;
assign led = led_t &amp; sw_ctrl;

//周期信号计数器在0-50_000之间计数
always @ (posedge sys_clk) begin
    if (!sys_rst_n)
        period_cnt &lt;= 16&#39;d0;
    else if(!sw_ctrl)
        period_cnt &lt;= 16&#39;d0;
    else if( period_cnt == 16&#39;d50_000 )
        period_cnt &lt;= 16&#39;d0;
    else
        period_cnt &lt;= period_cnt + 16&#39;d1;
end

//设置频率间隔
always @(posedge sys_clk) begin
    if(!sys_rst_n)
        freq_step &lt;= START_FREQ_STEP;
    else if(set_en) begin
        if(set_freq_step == 0)
            freq_step &lt;= 10&#39;d1;
        else if(set_freq_step &gt;= 10&#39;d1_000)
            freq_step &lt;= 10&#39;d1_000;
        else    
            freq_step &lt;= set_freq_step;
    end        
end

//设定高电平占空比的计数值
always @(posedge sys_clk) begin
    if (sys_rst_n == 1&#39;b0) begin
        duty_cycle &lt;= 16&#39;d0;
        inc_dec_flag &lt;= 1&#39;b0;
    end     
    else if(!sw_ctrl) begin          //呼吸灯开关关闭时，信号清零
        duty_cycle &lt;= 16&#39;d0;
        inc_dec_flag &lt;= 1&#39;b0;
    end    
    //每次计数完了一个周期，就调节占空比计数值
    else if( period_cnt == 16&#39;d50_000 ) begin
        if( inc_dec_flag ) begin  //占空比递减
            if( duty_cycle == 16&#39;d0 )     
                inc_dec_flag &lt;= 1&#39;b0;
            else if(duty_cycle &lt; freq_step)
                duty_cycle &lt;= 16&#39;d0;
            else    
                duty_cycle &lt;= duty_cycle - freq_step;
        end
        else begin  //占空比递增
            if( duty_cycle &gt;= 16&#39;d50_000 )  
                inc_dec_flag &lt;= 1&#39;b1;
            else
                duty_cycle &lt;= duty_cycle + freq_step;
        end 
    end 
    else  //未计数完一个周期时，占空比保持不变
        duty_cycle &lt;= duty_cycle ;
end
  
endmodule

    模块实现了呼吸灯的功能。呼吸灯的使能由输入的端口信号 sw_ctrl 控制，呼吸灯的呼吸频率由输入的端口信号 set_en 和 set_freq_step 控制。输入的 set_freq_step 范围是 1~1000。

    在左侧 Flow Navigator 导航栏中找到 SYNTHESIS，点击 该选项中的 **“Run Synthesis”** ，等待代码编译完成。
</code></pre>
<h5 id="IP-封装"><a href="#IP-封装" class="headerlink" title="&lt;3&gt;IP 封装"></a>&lt;3&gt;IP 封装</h5><pre><code>    将界面切换至 Package IP，也可以通过 **IP-XACT** 界面下的 **component.xml** 重新打开：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1c22b4d8b6ddec5fb30e7748ee701a2.png"></p>
<pre><code>    Identification 这一栏的选项直接保持默认，需要注意的是，我们可以点击图 6.3.31 中 **Categories** 选项下 的“+”按钮来**修改 IP 的分类** ，这里不做修改。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e936bc92628f578319803047bbae7cc5.png"></p>
<pre><code>    这里勾选“zynq”和“zynquplus”两项，表示该 IP 核支持 ZYNQ 和 ZYNQ MPSOC 器件。而 Life-cycle 表明该 IP 核当前的产品生命周期，这里选择“**Pre-Production** ”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f16af805e5acec286ff245098ff0bdf9.png"></p>
<pre><code>    点击 File Groups，然后点击界面上的“Merge Changes from File Groups Wizard”，此时可以在 Verilog Synthesis 一栏中查看工程中的三个模块。

    点击 **Customization Parameters** ，点击界面上的“**Merge Changes from Customization Parameters Wizard”** ，此时多了 Hidden Parameters 一栏，展开这个界面，可以看到程序中自定义的参数 START_FREQ_STEP， 右击这个参数，选择“Edit Parameter…”，弹出编辑参数的界面：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0dc10a436eeb939c31cf5a88916780d3.png"></p>
<pre><code>    在弹出的页面中勾选“Visible in Customization GUI”，将此参数显示在 GUI 参数界面中； Format 格式改为“long”； 勾选“Specify Range”来设定此参数的范围。将 Type 改为“Range of integers”，Minimum 的值改为 1， Maximum 的值改为 1000，将 Default Value 的值改为 100，点击“OK”按钮：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7bab0fc3776af968cd45566c20131a0.png"></p>
<pre><code>    点击“Customization GUI”，可以在“Layout”界面拖动 Page 0 下的参数来调整参数在 GUI 显示 的位置，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c5ef7a9cd6f3c7a15449f3584ad9974.png"></p>
<pre><code>    点击**“Review and Package”** ，然后点击“**IP has been modified”** 更新总结界面，最后点击**“Re-Package IP”** ，如下图所示： 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d280db132f7fdb24445364a47d6a502d.png"></p>
<pre><code>    IP 核封装完成后，在 IP 核所在路径（...\custom_ip\ip_repo\breath_led_ip_1.0\drivers\breath_led_ip_v1_0\src） 目录下，Vivado 软件会自动生成.c 和.h 文件，方便在 VITIS 软件中对 IP 核进行操作。最后关闭工程IP核创建结束。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/161d049dd7e3bf4ca866b0d0354554ae.png"></p>
<h4 id="step2：创建vivado工程"><a href="#step2：创建vivado工程" class="headerlink" title="step2：创建vivado工程"></a>step2：创建vivado工程</h4><pre><code>    创建 Vivado 工程名为 user_led，具体过程见前。点击菜单栏的“Tools”， 选择“Setting”，把自定义的IP核添加至本工程的IP库中：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/62472d612e15937378ba85ce4929f62b.png"></p>
<pre><code>    点击“IP”一栏下的“Repository”，然后点击“+”来添加自定义的 IP 核。选择../custom_ip/**ip_repo/breath_led_ip_1.0** ，点击“Select”，点击“OK”按钮添加 IP 核：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/91eae14f825c3128bdcadc291c08c7ed.png"></p>
<h4 id="step3：使用-IP-Integrator-创建-Processing-System"><a href="#step3：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step3：使用 IP Integrator 创建 Processing System"></a>step3：使用 IP Integrator 创建 Processing System</h4><pre><code>    在左侧导航栏（Flow Navigator）中，单击 IP Integrator 下的 Create Block Design。然后在弹出的对话框中指定所创建的 Block Design 的名称，这里使用默认的“design_1”。在 Diagram 窗口中给设计添加 IP。点击图中加号“+”，会打开 IP 目录（IP Catalog）。在搜索栏中 键入“zynq”，找到并双击“ZYNQ Ultrascale+ MPSoC”，将 MPSOC 处理系统 IP 添加到设计中。和前面搭建嵌入式最小系统不同的是，我们保留了 pl_clk0、pl_resetn0、maxihpm0_lpd_aclk 和 M_AXI_HPM0_LPD 接口，只是添加了 UART 控制器（MIO42 和 MIO43），修改 Bank 电压和修改 DDR4 控制器**（见前）** 其它保持默认。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/16e20796ae329a0e1e72eb83e2676f4a.png"></p>
<pre><code>     接下来添加 Breath LED IP 核，点击“+”图标，在搜索框中输入“led”，即可找到之前添加的“breath_led_ip_v1.0”IP，添加此IP核，可以双击 led IP 核来设置参数，可以看到我们自定义的参数（Start Freq Step）和其它四个参数：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/89e3ce79246c6299be15abc7c427678b.png"></p>
<pre><code>    接下来点击**“Run Connection Automation”** 来自动连线，在弹出的窗口中勾选 **All Automation** ，然后点击 OK。此时原理图中还没有 LED 的引脚，右击 breath_led_ip_0 的 led 引脚，选择“Make External”，将引出的 led_0 改为 led：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42ab2d5ad83cb9c00869f8e240a49e7b.png"></p>
<h4 id="step4：生成顶层-HDL-模块"><a href="#step4：生成顶层-HDL-模块" class="headerlink" title="step4：生成顶层 HDL 模块"></a>step4：生成顶层 HDL 模块</h4><pre><code>    在 Sources 窗口中，选中 **Design Sources** 下的 design_1.bd，这就是我们刚刚完成的 Block Design 设 计。右键点击 design_1.bd，在弹出的菜单栏中选择**“Generate Output Products”** ，等待 Generate 完成。在 Sources 窗口中，右键点击 design_1.bd，在弹出的菜单栏中选择**“Create HDL Wrapper”** 。
</code></pre>
<h4 id="step5：生成-Bitstream-文件并导出-Hardware。"><a href="#step5：生成-Bitstream-文件并导出-Hardware。" class="headerlink" title="step5：生成 Bitstream 文件并导出 Hardware。"></a>step5：生成 Bitstream 文件并导出 Hardware。</h4><pre><code>    在左侧 Flow Navigator 导航栏中找到 RTL ANALYSIS，点击该选项中的**“Open Elaborated Design”** 。在 ELABORATED DESIGN 界面下方找到 I/O Ports 一栏。如果没有找到则通过在菜单栏中点击 Layout， 然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 一栏对 PL 部分的接口进行管脚分配，led 分配至**BANK44**  的 **AE10** 引脚，该 BANK 的供电电压为**3.3V** ，因此 I/O Std 一列对应的电平也需要修改。

    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“user_led”。在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的**“Generate Bitstream”** 。在连续弹出的对话框中依次点击“YES”、“OK”。然后 Vivado 工具开始依次对设计进行综合、实现、并生成 Bitstream 文件。在菜单栏中选择 File &gt; Export &gt; **Export hardware** 。在弹出的对话框中，勾选“**Include bitstream** ”，然后点 击“OK”按钮。

    新建 vitis 文件夹，将 xsa 文件拷贝到里面。选择菜单 Tools-&gt;Launch Vitis。在弹出的界面中，指定路径到..\custom_ip\user_led\vitis 下，点击 “Launch”，打开 Vitis 软件。
</code></pre>
<h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>新建vitis工程user_led，流程同前，main.c文件内容如下：</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;breath_led_ip.h&quot;
#include &quot;xil_io.h&quot;
#include &quot;sleep.h&quot;

#define  LED_IP_BASEADDR    XPAR_BREATH_LED_IP_0_S0_AXI_BASEADDR  //LED IP基地址
#define  LED_IP_REG0        BREATH_LED_IP_S0_AXI_SLV_REG0_OFFSET  //LED IP寄存器地址0
#define  LED_IP_REG1        BREATH_LED_IP_S0_AXI_SLV_REG1_OFFSET  //LED IP寄存器地址1

//main函数
int main()
&#123;
 int freq_flag;      //定义频率状态，用于循环改变呼吸灯的呼吸频率
 int led_state;      //定义LED灯的状态

 xil_printf(&quot;LED User IP Test!\n\r&quot;);
 while(1)&#123;
     //根据freq_flag的标志位,切换呼吸灯的频率
     if(freq_flag == 0)&#123;
    	 BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x800000ef);
         freq_flag = 1;
     &#125;
     else&#123;
    	 BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x8000002f);
         freq_flag = 0;
     &#125;
     //获取LED当前开关状态   1:打开  0:关闭
     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);
     //如果开关关闭,打开呼吸灯
     if(led_state == 0)&#123;
    	 BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 1);
         xil_printf(&quot;Breath LED ON\n\r&quot;);
     &#125;
     sleep(5);
     //获取LED当前开关状态   1:打开  0:关闭
     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);
     //如果开关打开,关闭呼吸灯
     if(led_state == 1)&#123;
    	 BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 0);
         xil_printf(&quot;Breath LED OFF\n\r&quot;);
     &#125;
     sleep(1);
 &#125;
&#125;

    在代码的第 8 行至第 10 行，我们对 Breath LED IP 基地址、寄存器地址 0 和寄存器地址 1 进行了宏定义。按住 Ctrl 键不放，将鼠标移动到这些参数上，单击鼠标左键，会自动跳转到定义这些参数的地方。其中 BREATH LED IP 寄存器地址 0 和寄存器地址 1 位于**breath_led_ip.h** 文件内，这个文件是系统自动为我们生成的。

    程序中的 main 函数实现了每 6 秒钟（点亮 5 秒+关闭 1 秒）打开和关闭 LED 呼吸灯的开关，并切换 LED 灯呼吸频率的功能。我们通过 **BREATH_LED_IP_mReadReg()** 函数来**读取寄存器地址的数据** ，通过 **BREATH_LED_IP_mWriteReg()** 函数来**写入寄存器地址的数据** ，这两个函数同样位于 breath_led_ip.h 文件中。

    在硬件设计的自定义 IP 核部分中，我们例化 breath_led 代码的时候，将寄存器 0 的数据（slv_reg0）连接至呼吸灯的开关控制信号（sw_ctrl），寄存器 1 的数据高位（slv_reg1[31]）连接至呼吸灯频率设置使能信号（set_en），寄存器 1 的数据低位（slv_reg1[9:0]）连接至呼吸灯频率间隔设置（set_freq_step）。因此，在 Vitis 应用程序中，可以很方便的**通过 Breath LED IP 寄存器地址 0 和寄存器地址 1 来控制 LED 呼吸灯的开关和频率** 。

    值得一提的是，在 Vitis 中添加导出的硬件平台文件后，自**定义 IP 核的库函数也会导入进来** ，而这个 库函数是在自定义 IP 核时，由 Vivado 软件自动生成的：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b90ad057bdb4f0e9b727ccacfb8609e6.png"></p>
<p>接着“build project”，如果编译出现error，可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62179548/article/details/132042828" title="Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-CSDN博客">Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-<br>CSDN博客</a></p>
<p>若run时出现错误：</p>
<p>Error while launching program: Hardaware specification file used in the launch<br>configuration ‘Debugger_user_led_ip-Default’ doesn’t exist at the location<br>…..</p>
<h3 id="4-下载验证"><a href="#4-下载验证" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><pre><code>    打开 Vitis Terminal 终端，设置并连接串口。在应用工程 user_led 上右击，选择**“Run As”** ，然后选择第一项**“1 Launch on Hardware (System Debugger)”** 。
</code></pre>
<h2 id="二-程序固化实验"><a href="#二-程序固化实验" class="headerlink" title="二.程序固化实验"></a>二.程序固化实验</h2><pre><code>   之前都是通过 JTAG 接口将 FPGA 配置文件和应用程序下载到 MPSOC 器件中。接下来尝试把程序存储在非易失性存储器中，在上电或者复位时让程序自动运行，这个过程需要启动引导程序**（Boot Loader）** 的参与。**Boot Loader 会加载 FPGA 配置文件，以及运行在 ARM 中的软件应用。**
</code></pre>
<p>**        <strong>本章的实验任务是在“AXI GPIO 按键控制 LED 实验”的基础上</strong>创建 FSBL** ，实现程序上电自启动，<strong>包括从 SD<br>卡启动，QSPI Flash 和 eMMC 启动三种方式</strong> 。</p>
<h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.*简介"></a>1.*简介</h3><pre><code>    MPSOC 的系统启动过程由**平台管理单元**(**PMU**)和**配置安全单元**(**CSU**)管理和执行。启动过程包括三个功能阶段：**预配置阶段、配置阶段和后配置阶段** 。

   _ **预配置阶段** 由**平台管理单元** 控制。平台管理单元运行 **PMU ROM** 代码以设置系统。PMU 处理所有复位和唤醒过程。_

    _**在配置阶段** ，**BootROM(CSU ROM 代码的一部分)** 解释引导头以配置系统，并在安全或非安全引导模式下将处理系统(PS)的**第一阶段引导加载程序(FSBL)代码** 加载到**片上 RAM(OCM)** 中。引导头定义了许多引导参数，包括安全模式和**执行 FSBL 的处理器 MPCore** 。在引导期间，CSU 还将 **PMU 用户固件(PMU FW)** 加载到**PMU RAM** 中，以与 PMU ROM 一起提供**平台管理服务** 。对于**基于 Xilinx 的 FSBL 和系统软件，PMU FW 必须存在于大多数系统中** 。_

   _  FSBL 执行开始后，CSU ROM 代码进入**后配置阶段** ，该阶段负责系统干预响应。CSU 硬件提供持续的硬件支持，以验证文件，**通过 PCAP 配置 PL，存储和管理安全密钥，解密文件** 。_
</code></pre>
<h4 id="启动流程-Boot-Flow"><a href="#启动流程-Boot-Flow" class="headerlink" title="启动流程(Boot Flow)"></a><strong>启动流程(Boot Flow)</strong></h4><p>**         **PMU对内部寄存器、存储器等进行复位，检查电压，则验证 CSU ROM 完整性并释放对 CSU 的复位。PMU<br>负责处理主要的预引导任务和 PS 的管理，以确保系统资源的可靠通电断电。启动 PMU<br>的上电复位(POR)操作，直接或间接的释放了预期上电模块的复位。在这种情况下，PMU 需要 ROM 代码来保持初始化上电顺序。即使在启动过程之后，PMU<br>仍在运行，并且负责处理各种系统复位。在更改系统电源状态时也会使用它(例如上电、睡眠和唤醒)。在初始化启动期间，POR 将 PMU 从复位中释放，然后执行<br>PMU ROM。</p>
<pre><code>下面描述了 PMU 处理器在 POR 复位后，通过运行 PMU ROM 预启动代码完成的操作序列：

1、 初始化 PS SYSMON 和引导单元所需的 PLL。

2、 清除 PMU RAM 和 CSU RAM(仅外部 POR)。

3、 验证 PLL 锁。

4、 通过 PS SYSMON 单元验证 LPD、AUX 和 IO 电源范围。

5、 清除低功耗和全功耗域。

6、 如果前面的步骤没有错，PMU 将释放 CSU 复位并进入 PMU 服务模式。如果有错，将产生一个启动错误标志。

当 CSU 复位被释放，CSU 将按照下面序列运行：

1、 初始化 OCM

2、 通过读取引导模式寄存器来确定启动模式。

3、 CSU 继续在 OCM 中加载 FSBL，以供 RPU 或 APU 执行。然后，CSU 将 PMU 用户固件加载到 PMU RAM 中，以供 PMU 固件执行。
</code></pre>
<h4 id="启动模式-Boot-Modes"><a href="#启动模式-Boot-Modes" class="headerlink" title="启动模式(Boot Modes)"></a><strong>启动模式(Boot Modes)</strong></h4><pre><code>    BootROM 可以通过 Quad-SPI，SD，eMMC，USB2.0 控制器 0 或 NAND 等外部设备启动系统。

    MPSOC 使用多个模式引脚来决定配置器件的类型，软件的存储位置以及其他的系统设置，这些引脚共享 PS 端的 MIO 引脚。总共有 7 个模式引脚，分别为 MIO[8:2]。其中，前四个引脚定义启动模式，第五个引脚定义是否使用 PLL，第六个和第七个引脚定义上电过程中 MIO bank0 和
</code></pre>
<p>bank1 的 bank 电压。如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7fd4d98a93ce3511d9f836a14f2f9eb9.png"></p>
<h4 id="整个系统的启动过程"><a href="#整个系统的启动过程" class="headerlink" title="整个系统的启动过程"></a><strong>整个系统的启动过程</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6da7cbc34256053b4b7e3b7c4ee48dc5.png"></p>
<p>更详细的内容可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133468006?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22133468006%22,%22source%22:%22qq_32971095%22%7D" title="嵌入式Linux_Petalinux一——三.1软件栈">嵌入式Linux_Petalinux一——三.1软件栈</a></p>
<h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><pre><code>    本次实验在“AXI GPIO 按键控制 LED 实验”的基础上进行，另存为本次实验工程，工程名为 axi_gpio_fsbl。

    接下来对系统的硬件设计进行修改。在 Vivado 界面左侧选择 Open Block Design，然后在右侧的 Diagram 界面中双击 Zynq UltraScale+ MPSOC 模块修改其配置。

    首先**使能 QSPI 外设** 。在左侧的导航栏中选择 I/O Configuration，在打开的右侧页面中，依次展开 Low Speed &gt; Memory Interfaces，然后勾选 QSPI 并在后面的下拉菜单中选择 Single，QSPI Data Mode 选择 x4， QSPI IO 默认为 MIO0..5，勾选 Feedback Clk 并选择 MIO6，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29757f782abd8955ade80399b026870b.png"></p>
<pre><code>    然后**打开 SD 卡外设** 。在上一步的页面中，展开 SD 外设，勾选 SD1，在后面的菜单栏中选择 MIO46..51， Slot Type 选择 SD2.0，Data Transfer Mode 选择 4Bit，勾选**CD 用于检测 SD 卡插入** 并选择 MIO45，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/446f0a292906d77dee9052eabc0e669b.png"></p>
<pre><code>    最后**打开 eMMC 外设** 。在同样的页面中，勾选 SD0 并选择 MIO13..22，Slot Type 设置成 eMMC，Data Transfer Mode 选择 8bit，勾选 Reset 并选择 MIO23，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c686ddf6f2ebcb2be138150d60ba3ff9.png"></p>
<pre><code>    上面两幅图中具体每个外设所连接的 MIO 引脚可以通过查看开发板原理图得知，设置完成后点击“OK”。然后在 Diagram 窗口空白处右击，然后选择“Validate Design”验证设计。验证完成后弹出对话框提示 “Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键“Ctrl + S”保存设计。

    接下来在 Source 窗口中右键点击 Block Design 设计文件“design_1.bd”，执行“Generate Output Products”。 最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 对设计进行综合、实现、并生成 Bitstream 文件。

    在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”。

    新建 vitis 文件夹，将生成的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境。在弹出的对话框中，将路径指定到新建 的 vitis 文件夹下，点击 Launch 启动 Vitis。
</code></pre>
<h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    新建vitis工程如上，main.c代码：


#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xgpio.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;sleep.h&quot;

//宏定义
#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID
#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID
#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID
#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID

#define MIO_LED      38                           //PS_LED1 连接到  MIO38
#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1
#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义

//函数声明
void instance_init();                             //初始化器件驱动
void axi_gpio_handler(void *CallbackRef);         //中断服务函数

//全局变量
XScuGic            scugic_inst;                   //中断控制器    驱动实例
XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息
XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例
XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息
XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例

int led_value = 1;                                //LED显示状态

int main()
&#123;
	printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);

	//初始化各器件驱动
	instance_init();

	//配置PS GPIO
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出
	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED

	//配置PL AXI GPIO
	XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断

    //设置中断优先级和触发类型(高电平触发)
    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
    //关联中断ID和中断处理函数
    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);
    //使能AXI GPIO中断
    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    		(Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);
    Xil_ExceptionEnable();

    while(1);

    return 0;
&#125;

//初始化各器件驱动
void instance_init()
&#123;
	//初始化中断控制器驱动
	scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);
	XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);

	//初始化PS端  GPIO驱动
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);

	//初始化PL端  AXI GPIO驱动
	XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);
&#125;

//PL端  AXI GPIO 中断服务(处理)函数
void axi_gpio_handler(void *CallbackRef)
&#123;
	int key_value = 1;
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	print(&quot;Interrupt Detected!\n&quot;);
	XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能
    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据
    if(key_value == 0)&#123;                                     //判断按键按下
    	led_value = ~led_value;
    	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态
    &#125;
    sleep(1);                                               //延时1s 按键消抖
    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断
    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断
&#125;

   **保存并编译工程** 后，**创建启动镜像** 。选中应用工程，右键选择**Create Boot Image。** 接下来，在弹出的界面中添加生成 boot.bin 所需的文件，然后点击“Create Image”，如图
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/372e816b5fc79bf2ae14f19e207cdfbb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a22a2517141020dac5bd2d4d4f4cce68.png"></p>
<pre><code>    从上图中可以看到，软件已经给我们自动添加所需的文件。首先是 **Bootloader 启动文件** ，也就是序号 4 处的**fsbl.elf** 。其次是 **FPGA 的配置文件** design_1_wrapper.**bit** ，在上图中序号 5 处。最后是**应用程序** axi_gpio_fsbl.elf 文件，上图中序号 6 处。注意这三个文件的顺序不能错。

    序号 2 处的 bif 文件是生成**BOOT 的配置文件** ，序号 3 处的 **BOOT.bin** 就是我们需要的**启动文件** ，可以烧录到 QSPI Flash 或 eMMC 中，也可以放到 SD 中来启动 ZYNQ MOPSOC。        

    创建完成后，在指定的路径下可以看到生成的两个文件，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a4d08531d1eab8186a97364d2ed699b7.png"></p>
<h3 id="4-下载验证-1"><a href="#4-下载验证-1" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><h4 id="从SD卡中启动程序"><a href="#从SD卡中启动程序" class="headerlink" title="&lt;1&gt;从SD卡中启动程序"></a>&lt;1&gt;从SD卡中启动程序</h4><pre><code>    将 Micro SD 卡插入读卡器，然后在电脑上将其格式化为 FAT32 格式，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/93b44a4a8a61b36fb0f834c0b31a9c62.png"></p>
<pre><code>    将生成的 BOOT.bin 文件拷贝到 SD 卡根目录下，开发板启动模式改为从SD卡启动即可。
</code></pre>
<h4 id="固化至QSPI-Flash中"><a href="#固化至QSPI-Flash中" class="headerlink" title="&lt;2&gt;固化至QSPI Flash中"></a>&lt;2&gt;固化至QSPI Flash中</h4><pre><code>    将程序固化到 QSPI Flash 需要使用 JTAG 下载器。首先我们将下载器与开发板上的 JTAG 接口连接，下载器另外一端与电脑连接。接下来将开发板上的启动模式开关设置为  JTAG 模式。

    在 Vitis 软件的菜单栏中点击“Program Flash”，如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef30f083ed0db0516b72f0c5fa19d0a1.png"></p>
<pre><code>    在弹出的对话框中指定前面所生成的镜像文件 BOOT.bin 以及 FSBL.elf 文件，如下图中 1 和 2 处所示。 Flash Type 选择 qspi-x4-single，并勾选 Verify after flash。点击“Program”，开始对 Flash 进行编程：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/84bec15e9c53965b8eef13f5187856f4.png"></p>
<pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 32bit QSPI Flash 启动即可。
</code></pre>
<h4 id="固化到-eMMC-中"><a href="#固化到-eMMC-中" class="headerlink" title="&lt;3&gt;固化到 eMMC 中"></a>&lt;3&gt;固化到 eMMC 中</h4><pre><code>    步骤和&lt;2&gt;相同，在Program Flash中的 **Flash Type 选择 emmc** ， 并勾选 Verify after flash，然后点击 Program，如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cd484d42fb06f898814fb196a4dab72.png"></p>
<pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 emmc 启动即可。
</code></pre>
<h2 id="三-UART-串口中断实验"><a href="#三-UART-串口中断实验" class="headerlink" title="三.UART 串口中断实验"></a>三.UART 串口中断实验</h2><pre><code>    我们在使用 PS 的时候，通常会添加 UART 控制器，用于打印信息和调试代码。除此之外，PS 在和外部设备通信时，也会经常使用串口进行通信。进一步向大家 UART 控制器以及 UART 控制器利用中断进行通信的方法。
</code></pre>
<h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="MPSOC内UART控制器"><a href="#MPSOC内UART控制器" class="headerlink" title="&lt;1&gt;MPSOC内UART控制器"></a>&lt;1&gt;MPSOC内UART控制器</h4><pre><code>    MPSOC内UART控制器支持可编程的波特率发生器、64 字节的接收 FIFO 和发送 FIFO、产生中断、RXD 和 TXD 信号的环回模式设置以及可配置的数据位长度、停止位和校验方式等。

    UART 控制器的配置以及状态的获取由**控制（Control）和状态寄存器（Status Registers）** 完成。另外， UART 控制器不仅可以连接至 MIO，也可以**映射到 EMIO** ，从而使用 **PL 的端口来实现串口通信的功能** 。

    当 UART 控制器连接到 MIO 时，只有 Tx（发送）和 Rx（接收）两个引脚；而当连接 EMIO 时，除 Tx 和 Rx 引脚外，可选的还有 CTS、RTS、DSR、DCD、RI、DTR 等引脚，这些引脚用于串口的流控制。

    UART 控制器采用独立的接收和发送数据路径，每个路径包含一个 **64 字节的 FIFO** ，控制器对发送和接 收 FIFO 中的数据进行**串并转** 换操作。

    **FIFO 的中断标志** 支持**轮询处理** 或**中断驱动处理** 两种方式。另外，控制器中还有一个模式开关，支持 RXD 和 TXD 信号的各种环回配置。UART 控制器内部框图如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be9467098457f02d978fdaf7b35594d6.png"></p>
<pre><code>    UART 控制器的寄存器通过 **APB 从机接口和 PS AXI 总线** 互联，控制器的寄存器用于对 UART 控制器 进行配置和获取状态。波特率发生器（**Baud Rate Generator** ）为 UART 控制器的接收端和发送端提供位周期 时钟；中断控制器（**GIC** ）为串口的收发提供了中断服务的功能。

    APB 总线接口通过**向 TxFIFO 寄存器写值** ，将数据加载到 TxFIFO 存储器中。当数据加载至 TxFIFO 后， TxFIFO 的空标志变成无效的状态，直到最后一个数据从 TxFIFO 中移出，加载至传**输移位寄存器** ，TxFIFO 恢复空的标志位。同时 TxFIFO 使用 TFULL（满中断状态）用于表示当前 TxFIFO 已经写满，并且会阻止 数据继续写入。如果此时继续执行写操作，那么会触发溢出，数据不会加载到 TxFIFO 中。

    RxFIFO 存储器接收来自接收移位寄存器的数据，当接收完数据后，RxFIFO 空标志信号同样变成无效 的状态，直到所有的数据通过 APB 总线发送出去。RxFIFO 的满标志状态用于表示 RxFIFO 已经写满，并且 会阻止更多的数据写入。

    模式切换（**Mode Switch** ）控制 RxD 和 TxD 的信号连接方式，总共分为四种模式，分别为： **正常模式（Normal Mode）、自动回音模式（Automatic Echo Mode）、本地环回模式（Local Loopback Mode）和远程环回模式（Remote Loopback Mode）** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a18a6641a26bc471d59113f30b2dd803.png"></p>
<pre><code>    如果我们只是 用串口来**打印信息** 的话，那么可以直接使用**print()或者 xil_printf()** 函数就可以了，无需在程序中对串口做配置。但是如果我们需要使用 UART 来完成某些特定功能的话，如**串口接收中断** ，那么就要了解 UART 控制器**初始化、UART 中断初始化以及 UART 常用的 API 函数** 等相关内容了。
</code></pre>
<h4 id="UART启动和配置"><a href="#UART启动和配置" class="headerlink" title="&lt;2&gt;UART启动和配置"></a>&lt;2&gt;UART启动和配置</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ddbf21ee27e9c33362e57354d5eca70.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a310074e7bd0be3b5e5e715bd69bcec.png"></p>
<h4 id="收发数据"><a href="#收发数据" class="headerlink" title="&lt;3&gt;收发数据"></a>&lt;3&gt;收发数据</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/12b95a7bcc6acd13e957f41db6c99ca3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/611810d31ceb34a9530dbcfd49af8288.png"></p>
<h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>DDR4 中存放和运行程序、UART 实现串口通信。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9d5d8180c6ece37e8e66b243cb97514.png"></p>
<pre><code>    本次实验嵌入式系统的搭建和Hello World 实验完全相同，工程名为 uart_intr_loop。 _MPSOC 开发板上的 USB UART 连接的引 脚是 MIO42 和 MIO43，因此在配置界面选择的是 UART0 MIO42..MIO43_ 。图中的 Modem signals 表示是否添加**串口的流控制功能，即调制解调器** ，如果选中的话，会额外增加一些引脚，一般不勾选。需要注意的 是，串口的流控制功能只能用于**EMIO 接口** ，MIO 接口不支持此功能。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/769bdbcd35d49412cc93d1e56acb5bd4.png"></p>
<pre><code>    接下来，直接导出硬件，然后新建 vitis 文件夹，将导出的 xsa 文件拷贝到里面，最后打开 Vitis 软件， 并将路径指向新建的 vitis 文件夹下。
</code></pre>
<h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    Vitis 中创建了一个名为**uart_intr_loop 的应用工程** 。展开 design_1_wrapper，找到 **platform.spr** 并双击，右面的界面中出现 **design_1_wrapper 的标签页** ，然后找到**板级支持包** 并点击，可以看到**UART 文档和导入示例:**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4761e85c7ba0a68757090675cb7507de.png"></p>
<pre><code>    如果我们点击**Import Examples** ，会弹出下图所示的导入示例界面，关于**UART 有 5 个示例，** 其中 xuartps_intr_example 是串口中断的示例，可供参考。

    新建main.c文件，代码如下：


#include &quot;xparameters.h&quot;
#include &quot;xuartps.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;stdio.h&quot;

#define UART_DEVICE_ID     XPAR_XUARTPS_0_DEVICE_ID     //串口设备ID
#define INTC_DEVICE_ID     XPAR_SCUGIC_SINGLE_DEVICE_ID //中断ID
#define UART_INT_IRQ_ID    XPAR_XUARTPS_0_INTR          //串口中断ID

XScuGic Intc;              //中断控制器驱动程序实例
XUartPs Uart_Ps;           //串口驱动程序实例

//UART初始化函数
int uart_init(XUartPs* uart_ps)
&#123;
    int status;
    XUartPs_Config *uart_cfg;

    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);
    if (NULL == uart_cfg)
        return XST_FAILURE;
    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //UART设备自检
    status = XUartPs_SelfTest(uart_ps);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置工作模式:正常模式
    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);
    //设置波特率:115200
    XUartPs_SetBaudRate(uart_ps,115200);
    //设置RxFIFO的中断触发等级
    XUartPs_SetFifoThreshold(uart_ps, 1);

    return XST_SUCCESS;
&#125;

//UART中断处理函数
void uart_intr_handler(void *call_back_ref)
&#123;
    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;
    u32 rec_data = 0 ;
    u32 isr_status ;                           //中断状态标志

    //读取中断ID寄存器，判断触发的是哪种中断
    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_IMR_OFFSET);
    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_ISR_OFFSET);

    //判断中断标志位RxFIFO是否触发
    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;
    	rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);
        //清除中断标志
        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,
                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;
    &#125;
    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);
&#125;

//串口中断初始化
int uart_intr_init(XScuGic *intc, XUartPs *uart_ps)
&#123;
    int status;
    //初始化中断控制器
    XScuGic_Config *intc_cfg;
    intc_cfg = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == intc_cfg)
        return XST_FAILURE;
    status = XScuGic_CfgInitialize(intc, intc_cfg,
            intc_cfg-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler)XScuGic_InterruptHandler,
            (void *)intc);
    Xil_ExceptionEnable();

    //为中断设置中断处理函数
    XScuGic_Connect(intc, UART_INT_IRQ_ID,
            (Xil_ExceptionHandler) uart_intr_handler,(void *) uart_ps);
    //设置UART的中断触发方式
    XUartPs_SetInterruptMask(uart_ps, XUARTPS_IXR_RXOVR);
    //使能GIC中的串口中断
    XScuGic_Enable(intc, UART_INT_IRQ_ID);
    return XST_SUCCESS;
&#125;

//main函数
int main(void)
&#123;
    int status;

    status = uart_init(&amp;Uart_Ps);    //串口初始化
    if (status == XST_FAILURE) &#123;
        xil_printf(&quot;Uart Initial Failed\r\n&quot;);
        return XST_FAILURE;
    &#125;

    uart_intr_init(&amp;Intc, &amp;Uart_Ps); //串口中断初始化
    while (1);
    return status;
&#125;
</code></pre>
<h5 id="分析："><a href="#分析：" class="headerlink" title="*分析："></a>*分析：</h5><pre><code>    XScuGic 和 XUartPs 为程序中定义的两个结构体。如果在 Vitis 软件中， 按住 Ctrl 键不放，将鼠标移动到 XScuGic 或者 XUartPs 上，当鼠标变成手指状时，单击鼠标左键，会自动 跳转到定义这两个结构体的地方。其中 **XScuGic 包含了中断控制器相关的参数和数据** ，而 **XUartPs 则包含 了串口相关的参数和数据** 。

    在代码的第 15 行至第 40 行完成了对 UART 的初始化。其中代码的第 28 行 **XUartPs_SelfTest** 函数实现 了 UART 设备自检的功能，即使用 UART**本地环回** 的模式，并验证数据是否可以正确发送和接收。 **XUartPs_SetOperMode** 函数设置**串口的工作模式** ，这里输入的参数 XUARTPS_OPER_MODE_NORMAL 为 正常的工作模式。**XUartPs_SetBaudRate** 函数用于设置串口的通信**波特率** ，这里设置的波特率为 115200，如 果需要修改成其它波特率，可直接在此修改输入的参数即可。**XUartPs_SetFifoThreshold** 函数用于设置 RxFIFO 的中断触发等级，即**触发** **RxFIFO 中断的数据个数** ，**这里设置的值为 1（字节）** ，即每收到一个值就触发中断。注意，中断触发等级最大值不超过 63。

    在代码的第 65 行至第 94 行完成了串口中断的初始化。程序首先对**中断控制器进行初始化** ，随后设置 并打开**中断异常处理** 的功能。接下来为串口中断设置**中断处理函数** ，通过 **XScuGic_Connect** 函数进行设置，这里设置的串口中断处理函数为 **uart_intr_handler** 。**XUartPs_SetInterruptMask** 函数用于设置 UART 的**中断触发方式** ，函数输入的参数为 **XUARTPS_IXR_RXOVR** ，**表示达到 RxFIFO 的触发等级** 时，开始触发中断，当然也可以设置成 RxFIFO 为满时触发中断或者为空时触发中断等。最后，通过 **XScuGic_Enable** 函数来**使能 GIC** 中的串口中断。

    在代码的第 42 行至第 63 行为 **UART 中断处理函数** ，由于 RxFIFO 的触发等级设置为 1，因此每次接收到数据都会进入此中断函数。程序中首先**读取中断 ID 寄存器** ，判断触发的是**哪种中断** ，再读取**中断的状态** 。 当判断中断标志位为 **RxFIFO 触发中断** 时，通过 **XUartPs_RecvByte** 函数来**读取接收到的数据** ，并**清除对应的中断标志位** 。最后通过 **XUartPs_SendByte** 函数**发送接收到的数据** ，实现串口环回的功能。
</code></pre>
<p>注：首先程序会对 UART 串口进行初始化，我们知道，当使用一些打印函数的时候（如：xil_printf()），实际上调用的还是 UART 相关的 API<br>函数，如果在<strong>初始化的过程中， 使用打印函数，或者在打印的过程中对串口进行初始化，都会导致串口助手打印信息出错。</strong></p>
<h2 id="四-定时器中断实验"><a href="#四-定时器中断实验" class="headerlink" title="四.定时器中断实验"></a>四.定时器中断实验</h2><pre><code>    MPSOC 中 PS 部分包含许多不同类型的定时器，包括**全局定时器、TTC 定时器、系统看门狗定时器** 等。 定时器可以不受 CPU 的干预，自己独立运行，来完成计时、定时、中断以及计算来自 MIO 或 EMIO 引脚 的信号脉冲宽度等。本章我们将向大家介绍 **TTC**(**三路定时器**)以 TTC(三路定时器)**中断** 的使用方法。
</code></pre>
<h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136352300">https://blog.csdn.net/qq_32971095/article/details/136352300</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:13" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.Hello%20World%20%E5%AE%9E%E9%AA%8C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">一.Hello World 实验
</a></p>
<p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">1.硬件设计</a></p>
<p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p>
<p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p>
<p><a href="about:blank#%3C1%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20UART">&lt;1&gt;配置 PS 的<br>UART</a></p>
<p><a href="about:blank#%3C2%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20DDR4%20%E6%8E%A7%E5%88%B6%E5%99%A8">&lt;2&gt;配置 PS 的 DDR4<br>控制器</a></p>
<p><a href="about:blank#%3C3%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%E6%97%B6%E9%92%9F">&lt;3&gt;配置 PS<br>的时钟</a></p>
<p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL%20%E6%A8%A1%E5%9D%97">step3：生成顶层 HDL<br>模块</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#2.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.软件设计</a></p>
<p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p>
<p><a href="about:blank#3.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">3.下载验证</a></p>
<p><a href="about:blank#step6%EF%BC%9A%E6%9D%BF%E7%BA%A7%E9%AA%8C%E8%AF%81">step6：板级验证</a></p>
<p><a href="about:blank#%E4%BA%8C.GPIO%20%E4%B9%8B%20MIO%20%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">二.GPIO 之 MIO 控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4">2.实验步骤</a></p>
<p><a href="about:blank#3.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.硬件设计</a></p>
<p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p>
<p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p>
<p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL">step3：生成顶层<br>HDL</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#4.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">4.软件设计</a></p>
<p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p>
<p><a href="about:blank#5.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">5.下载验证</a></p>
<p><a href="about:blank#%E4%B8%89.GPIO%20%E4%B9%8B%20EMIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">三.GPIO 之 EMIO 按键控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#%E5%9B%9B.GPIO%E4%B9%8BMIO%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C">四.GPIO之MIO按键中断实验</a></p>
<p><a href="about:blank#%C2%A01.%E7%AE%80%E4%BB%8B"> 1.简介</a></p>
<p><a href="about:blank#%3C1%3E.%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B">&lt;1&gt;.处理器中断类型</a></p>
<p><a href="about:blank#%3C2%3E%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8GIC">&lt;2&gt;中断控制器GIC</a></p>
<p><a href="about:blank#%3C3%3EGPIO%20%E7%9A%84%20MIO%20%E7%9A%84%E4%B8%AD%E6%96%AD">&lt;3&gt;GPIO 的 MIO<br>的中断</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#%E4%BA%94.AXI%20GPIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">五.AXI GPIO 按键控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#step2%3Avivado%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0">step2:vivado硬件平台</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#4.%E8%A1%A5%E5%85%85">4.补充</a></p>
<hr>
<h2 id="一-Hello-World-实验"><a href="#一-Hello-World-实验" class="headerlink" title="一.Hello World 实验"></a>一.Hello World 实验</h2><pre><code>    在MPSOC开发板上搭建MPSOC嵌入式最小系统，并使用串口打印“Hello World” 信息。通过本次实验我们将了解 **MPSOC 嵌入式系统的开发流程** ，熟悉 **MPSOC 嵌入式最小系统的搭建**。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/66ab6afbb3d420e1b7089143e4466727.png"></p>
<pre><code>    如上图所示，开发流程大体可以分为 6 步。其中 step1 至 step4 为硬件设计部分，在 Vivado 软件中实现； step5 为软件设计部分，在 Vitis 软件中实现；step6 为功能的验证。复杂的程序还涉及 Debug，这个也是在 Vitis 软件中实施。

    嵌入式最小系统的概念包括以下两个方面：一、它是使系统正常工作的最小条件；二、它是其他系统建立的基础。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d830912c59cd7970e89dc798be2e099d.png"></p>
<pre><code>    以 ARM Cortex 为核心、DDR 为内存，加上传输信息使用的 UART 串口就构成了 MPSOC 嵌入式最小系统。可以看到，这个最小系统只包括了 MPSOC 中的 PS 部分。
</code></pre>
<h3 id="1-硬件设计"><a href="#1-硬件设计" class="headerlink" title="1.硬件设计"></a>1.硬件设计</h3><h4 id="step1：创建-Vivado-工程"><a href="#step1：创建-Vivado-工程" class="headerlink" title="step1：创建 Vivado 工程"></a><strong>step1：创建 Vivado 工程</strong></h4><pre><code>    注意project type界面选择rtl project并且“Do not specify sources at this time”；器件型号选择“xczu2eg-sfvc784-2-i”；
</code></pre>
<h4 id="step2：使用-IP-Integrator-创建-Processing-System"><a href="#step2：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a><strong>step2：使用 IP Integrator 创建 Processing System</strong></h4><pre><code>    在左侧导航栏（**Flow Navigator）** 中，单击 **IP Integrator** 下的 **Create Block Design** ；接下来在 Diagram 窗口中给设计添加 IP。点击上图中箭头所指示的加号(两个任选一个)“+”，会 打开 IP 目录（IP Catalog）。也可以通过快捷键 Ctrl + I，或者右键点击 Diagram 工作区中的空白位置，然后选择“ADD IP”；打开 IP 目录后，在搜索栏中键入“ZYNQ”，找到并双击**“Zynq UltraScale+MPSOC”** ，将 Zynq UltraScale+MPSOC IP 添加到设计中。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff638c73b44ed84dd4f13a3e9db79fab.png"></p>
<pre><code>    双击所添加的 Zynq UltraScale+MPSOC 模块，进入处理系统的配置界面。界面左侧为页面导航面板， 右侧为配置信息面板。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac3239cf0f859b989c7d926f407b66f5.png"></p>
<p>下面我们简要地介绍一下页面导航面板中各个页面的作用：</p>
<p><strong>PS UltraScale+ Block Design</strong> 页面显示了 zynq 硬核的整体架构图，其中绿色部分是可配置模块，可以点<br>击进入相应的编辑界面进行配置，当然也可以在左侧导航栏选择相应的编辑界面。</p>
<p><strong>I&#x2F;O Configuration</strong> 页面可以选择不同的 I&#x2F;O 外设并进行相应的配置。</p>
<p><strong>Clock Configuration</strong> 页面分为 Input Clocks 和 Output Clocks 两个标签页，用来配置 PS<br>输入时钟、外设 时钟，以及 DDR 和 CPU 时钟等。</p>
<p><strong>DDR Configuration</strong> 页面用于设置 DDR 控制器配置信息。</p>
<p><strong>PS-PL Configuration</strong> 用于 PS 和 PL 交互的相关配置，包括常用的中断、复位信号和数据接口。</p>
<h5 id="配置-PS-的-UART"><a href="#配置-PS-的-UART" class="headerlink" title="&lt;1&gt;配置 PS 的 UART"></a>&lt;1&gt;配置 PS 的 UART</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00b2930a9fea37d61d892e33ef7cfc19.png"></p>
<pre><code>    点击导航面板中 I/O Configuration，PS 和外部设备之间的连接主要是通过复用的输入/输出**（Multiplexed Input/Output，MIO）** 来实现的。**BANK501 中的 MIO42 和 MIO43 被用作 UART 串口通信的引脚，并最终与开发板上的 USB 转串口芯片 CH340 连接** 。因此，为了实现串口 通信的功能，我们需要在 PS 中将 MIO42 和 MIO43 配置成 UART0 模块的接口引脚。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9253bb0e6120f4d7752df56866af224e.png"></p>
<h5 id="配置-PS-的-DDR4-控制器"><a href="#配置-PS-的-DDR4-控制器" class="headerlink" title="&lt;2&gt;配置 PS 的 DDR4 控制器"></a>&lt;2&gt;配置 PS 的 DDR4 控制器</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/86cb4773d4bce9fa668f8588f3fc7151.png"></p>
<h5 id="配置-PS-的时钟"><a href="#配置-PS-的时钟" class="headerlink" title="&lt;3&gt;配置 PS 的时钟"></a>&lt;3&gt;配置 PS 的时钟</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dde78d189b9ec8cdb96dfb848af3aee2.png"></p>
<pre><code>    点击左侧 Clock Configuration 打开时钟配置页面，该界面主要是配置 MPSOC PS 中的时钟频率。比如 输入时钟默认是 33.33333Mhz，这与我们开发板上的 PS 端输入时钟频率相同。对于 CPU 的时钟、DDR 的 时钟以及其它外设的时钟，我们直接保持默认设置即可。

    因为本实验是**搭建 MPSOC 的嵌入式最小系统，只需要使用 MPSOC 中的 PS 端。因此我们将 PS 中与 PL 端交互的接口信号移除。**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b22291cae6354b595278fd575ac76.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcbef3d3c3dcc0ebeb8c1b682b5ff426.png"></p>
<pre><code>    返回到 Vivado 界面后，在 Diagram 中可以看到 ZYNQ UltraScale+ MPSOC IP 模块变化，该模块少了四组接口，这正是因为我们在配置该 IP 核的过程中**移除了与 PL 相关的接口信号** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df81e05298566f091c3790ff47385a18.png"></p>
<p>点击下图中箭头所指示的按钮“validate design”，对我们配置的 IP 核进行验证</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/77b0703425768c83045ffcca779129a2.png"></p>
<h4 id="step3：生成顶层-HDL-模块"><a href="#step3：生成顶层-HDL-模块" class="headerlink" title="step3：生成顶层 HDL 模块"></a><strong>step3：生成顶层 HDL 模块</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/073a28eee47c2b6b618081420d2e35e3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d2b3b14a1a9f8a64a8dfe31c7a52bdf.png"></p>
<pre><code>    在对话框中，Synthesis Options 选择 Out of context per IP，这里我们保持默认；Run Setings 用于设置生 成过程中要使用的处理器的线程数，进行多线程处理，保持默认或设置为个人电脑处理器最大可使用线程 数都可以，一般选择最大可使用线程数。然后点击“Generate”来生成设计的综合、实现和仿真文件。

    在“Generate”过程中会为设计生成所有需要的输出结果。比如 Vivado 工具会自动生成处理系统的 XDC 约束文件，因此我们不需要手动对 MPSOC PS 引出的接口（DDR 和 FIXED_IO）进行管脚分配。

    Generate 完成后，在弹出的对话框中点击“OK”。

    在 Sources 窗口中，点击“IP Source”标签页，可以看到 Generate 过程生成的输出结果。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9460672d014aabbdfd341cc584c1458e.png"></p>
<p>在“Hierarchy”标签页再次右键点击 system.bd，然后选择“Create HDL Wrapper”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/096595aeafc1562dc64f78ee57d7a9d6.png"></p>
<p>在弹出的对话框中确认勾选“Let Vivado manage wrapper and auto-update”，然后点击“OK”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/04b4162c472bae880b5b708ef1df3bff.png"></p>
<pre><code>    design_1_wrapper.v 为创建的 Verilog 文件，箭头所指的“品”字形图标指示当前模块为顶层模块。该模 块使用 Verilog HDL 对设计进行封装，主要完成了对 block design 的例化，大家也可以双击打开该文件查看 其中的内容。

    另外我们勾选了“Let Vivado manage wrapper and auto-update”，这样我们在修改了 Block Design 之后就不需要再重新生成顶层模块，**Vivado 工具会自动更新该文件** 。
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware"><a href="#step4：生成-Bitstream-文件并导出-Hardware" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    **如果设计中使用了 PL 的资源，则需要添加引脚约束并对该设计进行综合、实现并生成 Bitstream 文件。** 本次实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需将硬件导出。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/84d183341bcdf40ec8db6c00d6a74a7d.png"></p>
<pre><code>    在弹出的对话框中，因为没有生成 bitstream 文件，所以无需勾选“Include bitstream”，直接点击“OK” 按钮。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/552ed376805a0dbd4f0ec780a3273a85.png"></p>
<pre><code>    上图中，XSA file name 一栏是产生的硬件信息文件的文件名，这里我们保持默认。Export to 后面的路 径是生成的包含硬件信息文件的路径，生成的文件如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b2274963b330c10cb807b4ed637907e.png"></p>
<p>新建 vitis 文件夹，将xsa文件移入备用，后续作为 vitis 软件开发存储路径。</p>
<p>在菜单栏中选择 T<strong>ools &gt; Launch Vitis，启动 Vitis 开发环境</strong>。如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a4c3976d15c6c83da2f8fb04b618df2.png"></p>
<p>在弹出的对话框中，<strong>我们将工程路径指定到新建的 vitis 文件夹下</strong> ，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d79b59e6a49e77327e778f9e71f0ab45.png"></p>
<pre><code>    到这里，我们已经完成了 MPSOC 嵌入式系统的硬件设计部分。接下来需要到 Vitis 软件中进行应用程 序开发，也就是软件设计部分。
</code></pre>
<h3 id="2-软件设计"><a href="#2-软件设计" class="headerlink" title="2.软件设计"></a>2.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程"><a href="#step5：在-Vitis-中创建应用工程" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><p>在菜单栏选择 File &gt; New &gt; Application Project, 新建一个 vitis 应用工程</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f33bd6da382274b4e043b9c2b8bd96fb.png"></p>
<p>在弹出的对话框中，输入工程名“hello_world”，其它选项保持默认，点击“Next”，如下图 所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0198478b7f07905b054d257837434c1a.png"></p>
<p>打开 Create a new platform from hardware(XSA)标签页，<strong>点击“+”添加 xsa 文件</strong> ，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca8dc52ec3036fad0de51d0e881659c.png"></p>
<p>添加之前生成的xca文件，添加 xsa 文件后后点击 next。</p>
<p>在弹出的页面中有一个 Generate boot components 选项，如果勾选，软件会自动生成 fsbl 工程，这 里我们选择默认勾选，然后点击<br>next，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/288d2ba5ef4342f13cc8d63a597b4e5b.png"></p>
<p>在弹出的工程模板选择页面里，我们选择已有的 Hello World 模板，然后点击 Finish</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbca540ff2514ca9d5a8846fed7eee51.png"></p>
<pre><code>    工程建立完成后的页面如下图所示，我看可以看到生成了两个工程，一个是硬件平台工程，即 **platform 工程** ，一个是**应用工程** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/117f8abd36ad2af8f6b1d02788b749e6.png"></p>
<pre><code>    双击打开 hello_world/src 工程目录下 helloworld.c 文件，可以看到源代码。

    可以看到程序中主函数调用了 3 个函数，分别是 **init_platform()、cleanup_platform()和 print()** 函数。我们将鼠标停留在各个函数名上，vitis 就会显示该函数的声明。如果想查看函数的定义，可以**按住 Ctrl 键不放， 用鼠标点击相应的函数，就会跳转到其定义的地方** 。

    可以看到 init_platform 函数的作用是使能 caches 和初始化 uart；cleanup_platform 函数的作用是取消使 能 caches。实际上这两个函数在该工程中并没有启动任何作用，因为这两个函数是针对于特定平台如 Microblaze 的，对于我们使用的 MPSOC 平台而言是不起作用的，所以 main 函数中只需包含第 9 行的 print 语句就可以了，出于平台的通用性和可移植性，此处我们保留这两个函数。

    另外需要注意程序中打印字符串“Hello World”使用的是 **print()** 函数，而不是 C 语言里的 **printf()** 函数。 print()函数是 Xilinx 定义的一个用于打印字符串的函数，调用该函数需要包含头文件**“xil_printf.h”。**
</code></pre>
<p>选中应用工程，右键 Build Project 对工程进行编译。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/27b2222431094b40193d6127c4c5b66c.png"></p>
<pre><code>    编译进度可以在工具下方的控制台面板（Console）中进行查看，编译完成后显示“Finished building： hello_world.elf”，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bfb4630e5ba6a99f44351730d5dd7bde.png"></p>
<h3 id="3-下载验证"><a href="#3-下载验证" class="headerlink" title="3.下载验证"></a>3.下载验证</h3><pre><code>    首先我们将下载器与 MPSOC 开发板上的 **JTAG 接口连接** ，下载器另外一端与电脑连接。使用 USB 连接线将开发板 **USB_UART ( PS_PORT)**接口与电脑连接，用于串口通信。接下来将开发板上四个启动模式开关均置为 ON，即**设置为 JTAG 模式** 。最后连接开发板电源给开发板上电。

    注意第一次连接开发板 USB_UART 接口时，需要安装 CH340 驱动(USB 串口驱动)。
</code></pre>
<h4 id="step6：板级验证"><a href="#step6：板级验证" class="headerlink" title="step6：板级验证"></a>step6：板级验证</h4><pre><code>    在 Vitis 软件的下方，找到 Terminal 窗口。如果界面中没有找到该窗口，或者操作过程中把该窗口 给关闭了，则可以通过在菜单栏中选择 Window &gt; Show View &gt; Other，在 Show View窗口中搜索添加 Terminal。
</code></pre>
<p>添加 Terminal 后如下图所示，点击箭头处的图标对串口进行设置。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/170e4143f360ea63e740c76d3b806da9.png"></p>
<p>在弹出的窗口中，Choose terminal 一栏中，下拉选择 Serial Terminal<br>串口终端，选择串口终端后，接下来需要对串口设置。这里设置波特率为 “115200”，数据位为 8 位，停止位为 1 位，然后点击 OK，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3f622888054796bdd0a2450834d5f07b.png"></p>
<p>配置完成，连接成功后如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fee5583261c8e02c05908b44d905ac77.png"></p>
<p>右键 hello_world 工程，选择**“Run As”** ，选择**“Run Confagurations…”** ， 下载程序：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7378853644c71f828f51c56cf93f0dbc.png"></p>
<pre><code>    在打开的下载页面中，没有出现下载选项，这时需要双击左侧列表中 Single Application Debug 一项，双击后，该项下面出现新的项 Debugger_hello_world-default，同时在右侧出现的页面中选择 Target Setup 标签 页，**勾选复位** ，然后点击 run 下载程序，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ac2948aee4eca8357489df5e2904f51.png"></p>
<pre><code>    下载完成后，应用程序会将字符串“Hello World”通过 MPSOC PS 端的串口模块发送出去。在 Terminal 窗口可以看到上位机接收到的字符串，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1069bf74b114b8f0a8ecf6565c000d3c.png"></p>
<h2 id="二-GPIO-之-MIO-控制-LED-实验"><a href="#二-GPIO-之-MIO-控制-LED-实验" class="headerlink" title="二.GPIO 之 MIO 控制 LED 实验"></a>二.GPIO 之 MIO 控制 LED 实验</h2><pre><code>    GPIO 可以通过 **MIO** 连接到 **PS** 端的引脚，也可以通过 **EMIO** 连接到 **PL** 。本章将介绍如何使用 GPIO 外设通过 MIO 控制 PS 端的 LED。
</code></pre>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    MPSOC 分为 PS 和 PL 两部分，那么器件的引脚（Pin）资源同样也分成了两部分。MPSOC PS 中的外设可以通过 MIO（Multiuse I/O，多用输入/输出）模块连接到 PS 端的引脚上，也可以通过 EMIO 连接到 PL 端的引脚。MPSOC 系列芯片一般有 78 个 MIO。

    图是 GPIO 的框图，从中我们可以看到 GPIO 分为 6 个 Bank，其中 **Bank0、Bank1 和 Bank2 连接到 MIO；而 Bank3、Bank4 和 Bank5 连接到 EMIO** 。Bank0、Bank1 和 Bank2 分别有 26bit，总共 78bit，也就是说有 78 个 MIO。Bank3、Bank4 和 Bank5 分 别有 32bit，也就是说 PS 端可以使用 96 个 EMIO。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32042201490b2369989d7e8ca0fac313.png"></p>
<pre><code>    PS 所有的外设都可以通过 MIO 访问，这些外设也是与 MIO 进行连接，每个 MIO 虽然可以独立控制， 以及独立驱动单个引脚的外设，但对于 QSPI、USB、以太网等这些外设，对于 MIO 的连接有着特殊的要求， 如图 2.1.2 所示，对于以太网而言，要与 MIO26~37、MIO38~49、MIO52~63 和 MIO64~75 引脚连接，而且 以太网与 MIO26 连接的引脚只能作为以太网的 tx_clk 使用，可见当其作为以太网的接口引脚时，相应的 MIO 的功能就已经确定下来了。从图中 MIO 一览表中我们可以看到 **MIO 一但选定，引脚位置就已经确定下来了，不需要添加引脚约束** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/caa5d520533e9acf50023b1178d6daab.png"></p>
<pre><code>    MIO 与 PS 是如何连接的？ 图展示 PS 的 IO 外设。PS 外设的大多数 I/O 信号可以通过 MIO 路由到 PS 引脚，或通过 EMIO 路由到 PL 引脚。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/287affef4a19c843b014f61d1d6bdd42.png"></p>
<pre><code>    这里我们重点介绍外设系统图中箭头所指的部分。**PS 通过 APB 总线对 控制、状态寄存器的读写实现对 GPIO 的驱动**，具体可以参见下图。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6a0f8cbf358581c776ffb063389cf74.png"></p>
<pre><code>    左边的一列是寄存器，上半部分是关于中断的，这部分我们在涉及到中断的时候会讲解，这里 我们重点介绍下红色框圈出的下半部分。

    **DATA_RO** 是数据只读寄存器，通过该寄存器能够观察器件引脚上的值。如果 GPIO 信号配置为**输出** ， 则通常会反映输出上驱动的值，**写入此寄存器将被忽略** 。

    **DATA** 是**数据寄存器** ，该寄存器控制 GPIO 信号**配置为输出时要输出的值** 。该寄存器的所有 **32 位** 都是一次写入的。读取该寄存器返回写入 **DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;** 的先前值，它不会返回器件引脚上的当前值。

    MASK_DATA_LSW 和 MASK_DATA_MSW 是**数据掩码寄存器** ，该寄存器使软件能够有选择地一次更改所需的输出值。可以写入最多 16 位的任意组合，MASK_DATA_LSW 控制 Bank 的低 16 位， MASK_DATA_MSW 控制高 16 位。未写入的那些位保持不变并保持其先前的值。读取该寄存器返回写入 DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;的先前值;它不会返回器件引脚上的当前值。该寄存器避免了对未更改位的读-修改-写序列的需要。 **DIRM** 是**方向模式寄存器** ，用于控制 I/O 引脚是用作**输入还是输出** 。当 **DIRM [x] == 0** 时，**输出驱动器被禁用** ，该引脚作为**输入引脚** 使用。 **OEN** 是使能**输出寄存器** 。将 I/O 配置为输出时，该寄存器控制是否启用输出。**禁用输出时，引脚为 3 态** 。当 **OEN [x] == 0** 时，**输出被禁用** 。

    从这些寄存器中我们可以看到，如果配置引脚为输出，不仅需要**设置方向，还要使能输出** 。关于这些寄存器的具体介绍，可参考 ug1085 手册。需要说明的是我们在程序中操作 MIO 时直接调用 **Xilinx 官方提供的函数** 即可，无需直接操作这些寄存器。

    另外需要说明的是 MIO 信号对 PL 部分是不可用的，所以**对 MIO 的操作是纯 PS 的操作** ，且每个 GPIO 都可独立动态编程为输入、输出或中断检测。

    **从上面看出，Zynq  的 PS 部分就像 stm32 一样，本质都是配置外设的寄存器，利用开发商或者其他提供的友好接口的库函数对寄存器进行配置开发。 stm32 使用 ARM公司提供的cortex-M3内核，通过下载器将机器码下载至存储器代码段。**
</code></pre>
<p>**         此时再回过头来看 stm32 的 SoC 架构和总线系统相比 Zynq 的也容易看了许多，之后再看stm32<br>的数据手册也多了一些理解。还有之后的 stm32 的学习，可以使用 keil5 的调试功能，检查各个寄存器的值和执行的汇编语言，从而更深层面了解微机原理和<br>CPU 的运作。**</p>
<h3 id="2-实验步骤"><a href="#2-实验步骤" class="headerlink" title="2.实验步骤"></a>2.实验步骤</h3><pre><code>    本章的实验任务是使用 GPIO 通过 MIO 控制 PS 端 LED 的亮灭，实现 LED 闪烁的效果。

    从实验任务我们可以画出如下的系统框图，DDR4 中**存放和运行程序** 、UART 打印信息、MIO 驱动 LED 外设。虽然本实验可以不需要 UART，不过为了方便打印一些信息，此处我们加上 UART。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/15845bb43a515dafb87742974f7da7e1.png"></p>
<p><strong>注意养成绘制系统框图的习惯，帮助理解系统架构</strong></p>
<h3 id="3-硬件设计"><a href="#3-硬件设计" class="headerlink" title="3.硬件设计"></a><strong>3.硬件设计</strong></h3><h4 id="step1：创建-Vivado-工程-1"><a href="#step1：创建-Vivado-工程-1" class="headerlink" title="step1：创建 Vivado 工程"></a>step1：创建 Vivado 工程</h4><pre><code>    此处介绍如何在**先前工程的基础上继续实验** 而不破坏先前的工程。

    先打开《第一章 Hello World》实验的 Vivado 工程，打开后选择菜单栏的 File-&gt; Project-&gt;**Save As...。** 在弹出的另存为界面中可以输入新的工程名或更改保存位置，此处我们输入新的工程名“gpio_mio”， 工程位置保持默认即可，然后**取消勾选 Include run results** ，最后点击“OK”。（ _注意：文件所在路径不能过长，最多280个字符，如果保存失败修改存储路径；**另外之前的“Creat_Block_Design”之所以选择默认的“design_1”而不是特定的“hello_world”是因为这个名字设定之后便不可修改，另存之后仍是之前的名字**_ ）
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a300da9bfaa27e3b089ee32f0c5ce58e.png"></p>
<h4 id="step2：使用-IP-Integrator-创建-Processing-System-1"><a href="#step2：使用-IP-Integrator-创建-Processing-System-1" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a>step2：使用 IP Integrator 创建 Processing System</h4><pre><code>    在 Flow Navigator 中，点击 IP INTEGRATOR 下的 Open Block Design，在打开的下图 Diagram 窗口，双击打开 Zynq UltraScale+ MPSOC 重定义窗口。

    在下图所示的重定义窗口，点击左侧的 I/O Configuration，在右侧的界面中展开 Low Speed，展开 I/O Peripherals，展开 GPIO，然后**勾选 GPIO0 MIO 和 GPIO1 MIO** 。另外开发板上的 Bank0 即原理图中的 BANK500 为 1.8V，所以我们将 5 处的 **Bank0、6 处的 bank2 电压设置为 LVCOMS 1.8V** ，最后点击 OK。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/22d22a4f6b00a858b25620f9107a6e89.png"></p>
<pre><code>    实际用到的 GPIO_MIO 与原理图相关。为了方便大家的查找和使用，MPSOC PS 端 IO 引脚分配我们都列在了资料盘开发板原理图文件夹下的 IO 引脚分配总表中，我们摘录部分如下图
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/06d6440e02418eff773e87c0e910e21a.png"></p>
<p>按 Ctrl+S 快捷键保存 Diagram。</p>
<h4 id="step3：生成顶层-HDL"><a href="#step3：生成顶层-HDL" class="headerlink" title="step3：生成顶层 HDL"></a>step3：生成顶层 HDL</h4><pre><code>    在弹出的下图中，Synthesis Options 选择 Global，Run Setings 保持默认选择，然后点击 Generate。
</code></pre>
<p>注意与实验一区别，实验一是“Out of context per IP”，这里是“Global”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/789eafaaea99b49efbeba278724a37c7.png"></p>
<pre><code>    创建顶层 HDL Wrapper 因为我们在创建 Hello World 实验时创建顶层 HDL Wrapper 使用的是下图所示的 Let Vivado manage wrapper and auto-update选项，所以此处无**需再创建顶层HDL Wrapper** ，Vivado会**自动更新** 顶层HDL Wrapper。 此时第三步完成。
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware-1"><a href="#step4：生成-Bitstream-文件并导出-Hardware-1" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    由于本实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需导出 hardware 即可。步骤和实验一相同。
</code></pre>
<h3 id="4-软件设计"><a href="#4-软件设计" class="headerlink" title="4.软件设计"></a>4.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程-1"><a href="#step5：在-Vitis-中创建应用工程-1" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><pre><code>    基本与实验一相同。工程名改为“gpio_mio”；选择工程模版“Empty Application”，本章将自行创建工程文件，故选择空模板，然后点击“Finish” 按钮，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff2d68a7c22fa4b09d43e81130318de6.png"></p>
<pre><code>    双击硬件平台目录下 **platform.spr** 文件，找到点击板级支持包“Board_Support_Package”，点击展开 “Peripheral Drivers”，右侧有相关文档和示例。找到 GPIO，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f3d3d587cd53c95f702a694e8f53a48.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/50988f6dd1c1fbc068ae09865a09fcab.png"></p>
<pre><code>    点击 **Documentation** 将在浏览器窗口打开 GPIO 的 API 文档，里面有关于 GPIO 的详细信息，想了解 GPIO 的，可以仔细浏览其中的信息。

    导入示例。如果我们点击 I**mport Examples（Documentation 旁边的按钮）** ，会弹出下图所示的导入示例界面，关于 GPIO 有两个示 例，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f685cd0fd33c4130ea055d933944d57.png"></p>
<pre><code>    这两个示例的介绍可以在刚才打开的**API 文档** 中看到。在 API 文档中点击左侧的 **Examples** ，右侧出现 这两个示例的介绍信息，如图所示： xgpiops_intr_example.c 包含有关如何**直接使用 XGpiops** 驱动程序的示例。此示例显示了**中断模式下驱动程序** 的用法，并使用 GPIO 的中断功能检测按钮事件，根据输入控制 LED 输出。xgpiops_polled_example.c 同样包含有关如何直接使用 XGpiops 驱动程序的示例。此示例提供了用于**读取/写入各个引脚** 的 API 的用法。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8162740976bf76b39eb8589e7b500a26.png"></p>
<pre><code>    们因为本实验暂未使用到中断，所以应该选择 xgpiops_polled_example 示例。选择 好示例后，点击“OK”按钮。

    在 **Explorer 中，新增了 xgpiops_polled_example_1 目录** ，我们打开其 src 目录下的 xgpiops_polled_example.c 文件。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/072ba1557df31687c6828beaba8efd56.png"></p>
<pre><code>    显示行数。此处我们说一下如何显示代码的行数，在下图所示的 **1 处箭头** 所指的上或下方点击鼠标右键，在弹出的菜单中选择 2 处的 **Show Line Numbers** ，就会显示代码的行数。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b9b755efab66ebd848ace23a8d60d223.png"></p>
<pre><code>    xgpiops_polled_example.c 文件有四个函数，其中 **GpioInputExample** 函数由于我们本实验只用 MIO 输出所以未用到。该文件代码虽然是为特定开发板使用的，不过我们稍作修改也可以拿来使用。有两个 LED 分别接到 PS 的 MIO38 和 MIO39，这里我们使用 PS_LED1，即连接 MIO38。 我们修改该文件第 193 行的 Output_Pin 为 38，保存该文件，然后编译，编译完成后下载到开发板会看到板 上的 LED1 灯闪烁，闪烁时间约为 2 秒，随后 LED 灯熄灭。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e37cf706e4506426aa0b2ecddfaba1b7.png"></p>
<pre><code>    现在我们自己动手写一个驱动 MIO 的代码。

    新建源文件。首先我们在 **gpio_mio/src** 目录上右键，选择 **New- &gt; File**，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/96a7b91131fcef0da025feaca171ac69.png"></p>
<pre><code>    在添加源文件界面中，File name 一栏我们输入文件名“main.c”，然后点击“Finish”按钮。输入源代码。我们在新建的 main.c 文件中输入以下代码：


#include &quot;xparameters.h&quot; //器件参数信息
#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义
#include &quot;xil_printf.h&quot; //包含 print()函数
#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数
#include &quot;sleep.h&quot; //包含 sleep()函数

//宏定义 GPIO_DEVICE_ID
#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
//连接到 MIO 的 LED
#define MIOLED0 38 //连接到 MIO38
#define MIOLED1 39 //连接到 MIO39

 XGpioPs Gpio; // GPIO 设备的驱动程序实例

 int main()
 &#123;
	int Status;
	XGpioPs_Config *ConfigPtr;
	
	print(&quot;MIO Test! \n\r&quot;);
	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
	Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);
	
	if (Status != XST_SUCCESS)&#123;
		return XST_FAILURE;
	&#125;
	//设置指定引脚的方向：0 输入，1 输出
	XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);
	XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED1, 1);
	//使能指定引脚输出：0 禁止输出使能，1 使能输出
	XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);
	XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED1, 1);
	
	while (1) &#123;
		XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); //向指定引脚写入数据：0 或 1
		XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x0);
		sleep(1); //延时 1 秒
		XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x1);
		XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x1);
		sleep(1);
	&#125;
	return XST_SUCCESS;
 &#125;


    该代码实现了 LED 灯每隔 1 秒闪一次的功能。

    代码第 8 行我们宏定义了 **GPIO_DEVICE_ID** ，使其为 **XPAR_XGPIOPS_0_DEVICE_ID** ，如果在 Vitis 软件中，按住 Ctrl 键不放，将鼠标移动到 XPAR_XGPIOPS_0_DEVICE_ID 上，当鼠标变成手指状时，单击 鼠标左键，会自动跳转到 **xparameters.h** 文件中，该文件定义了各个外设的基地址、器件 ID、中断等，我们 这里重新宏定义 XPAR_XGPIOPS_0_DEVICE_ID 是为了以后方便修改。

    代码第 10 行宏定义了 **MIOLED0** ，其值为 38，因为其连接到 PS 的 MIO38 引脚。一般对于这种 MIO 的 使用，驱动某一引脚，在代码中使用该引脚对应的 MIO 数字标号即可。

    代码第 21 行至 26 行是**获取 GPIO 的 ID 和基址信息并初始化其配置** ，以及判断是否初始化成功。代码第 28 行的 **XGpioPs_SetDirectionPin** 和 31 行 **XGpioPs_SetOutputEnablePin** 函数分别是设置 **GPIO 的方向（输 入还是输出）** 函数和**使能输出函数** ，代码第 35 行的 **XGpioPs_WritePin** 是向指定 **GPIO 引脚写入数据的函数** ， 关于这三个函数的具体使用可以查看其定义。查看其定义的简便方法是在 VITIS 软件中，按住 Ctrl 键不放， 将鼠标移动到想查看定义的函数名上，当鼠标变成手指状时，单击鼠标左键，即可跳转到定义或声明的地方。

    代码第 37 和第 40 行的 sleep 函数为秒延时函数，延时 m 秒就使用 sleep(m)语句。还有一个微秒延时函数 usleep(m)，延时 m 微秒。

    编译工程。保存 main.c 文件，右键点击应用工程 gpio_mio，在弹出的菜单中选择 **Build Project** ， 如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9e8f14d55907d0b645cf585020c1c212.png"></p>
<p>编译完成后，生成 elf 文件，</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4acd636a64b21b3d624d428a56fa75bb.png"></p>
<h3 id="5-下载验证"><a href="#5-下载验证" class="headerlink" title="5.下载验证"></a>5.下载验证</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fc2a33922f6e87d7a4af525f2d2b3bed.png"></p>
<h2 id="三-GPIO-之-EMIO-按键控制-LED-实验"><a href="#三-GPIO-之-EMIO-按键控制-LED-实验" class="headerlink" title="三.GPIO 之 EMIO 按键控制 LED 实验"></a>三.GPIO 之 EMIO 按键控制 LED 实验</h2><pre><code>    PS 和外部设备之间的通信主要是通过**复用的输入/输出（Multiplexed Input/Output，MIO）** 实现的。除此之外，PS 还可以通过扩展的**MIO（Extended MIO，EMIO）** 来实现与外部设备的连接。**EMIO 使用了 PL 的 I/O 资源** ，当 PS 需要扩展**超过 78 个引脚的时候可以用 EMIO** ，也可以用它来**连接 PL 中实现的 IP 模块** 。
</code></pre>
<h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    在大多数情况下，PS 端经由 EMIO 引出的接口会直接连接到 PL 端的器件引脚上，**通过 IO 管脚约束来指定所连接 PL 引脚的位置** 。通过这种方式，EMIO 可以为 PS 端实现**额外的 96 个输入引脚或 96 个带有输出使能的输出引脚** 。EMIO 还有一种使用方式，就是**用于连接 PL 内实现的功能模块（IP 核）** ，此时 PL 端 的 IP 作为 PS 端的一个外部设备。

    本章的实验任务是使用 MPSOC 开发板上的两个 **PS 端按键控制 PL 端 LED 亮灭** ，**两个 PL 端按键去控 制 PS 端 LED 的亮灭** 。
</code></pre>
<h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b00b29d17bda34dc8e2021d19b3da5c7.png"></p>
<pre><code>    在配置界面中，点击左侧的 I/O Configuration。然后在右侧展开 GPIO 一栏，勾选 GPIO EMIO，并设置**位宽为 4** 。该设置将通过 EMIO 扩展一个 4 位的 GPIO 接口信号，此信号将用于连接 PL 端的引脚。注意这里 GPIO0 和 GPIO1 已经勾选。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f91ebcf53451f5c237c47a5fee50e1a7.png"></p>
<pre><code>    完成配置后，点击右下角的“OK”按钮。然后在 Diagram 窗口中可以看到 Zynq UltraScale+ MPSoC 多 了一个 GPIO_0 端口，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6db0239064ee56374c85381472489777.png"></p>
<pre><code>    将光标移动到上图中箭头所指示的位置，会发现光标变成了铅笔的样式。点击选中该端口，然后点击 鼠标右键，在弹出的列表中选择“**Make External** ”。点击选中该接口，在左侧 External Interface Properties 一栏中将该接口的名称修改为 GPIO_EMIO。如下 图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87308bc75d7d72d6921777208d4fd904.png"></p>
<pre><code>    在 Sources 窗口中展开 Design Sources，然后右键点击 design_1_wrapper 下的 design_1.bd，在弹出 的菜单中选择 Generate Output Products（在之前的实验中，我们创建顶层模块时选择了“Let Vivado manage wrapper and auto-update”选项，所以 此处无需再创建顶层 HDL Wrapper，Vivado 会自动更新顶层 HDL Wrapper。）
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware-2"><a href="#step4：生成-Bitstream-文件并导出-Hardware-2" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    在左侧**Flow Navigator 导航栏** 中找到 **RTL ANALYSIS** ，点击该选项中的“**Open Elaborated Design** ”。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed28803feaff06157fb29b7ac79959b0.png"></p>
<p>注意：如果出现闪退<a target="_blank" rel="noopener" href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513?spm=1001.2014.3001.5506" title="Vivado RTL 闪退问题的解决办法">Vivado RTL<br>闪退问题的解决办法</a></p>
<pre><code>    在 ELABORATED DESIGN 界面下方找到 I/O Ports 窗口。如果没有找到 I/O Ports 一栏则通过在菜单栏 中点击 Layout，然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 窗口中对 PL 部分的接口进行管 脚分配。PS 端的管脚约束文件，在图 3.3.12 中选择“Generate Output Products”之后，Vivado 工具会自动创建。

    在本次实验中，EMIO 扩展了四个 GPIO 的接口信号，即上图中的 GPIO_EMIO_tri_io[0]， GPIO_EMIO_tri_io[1]，GPIO_EMIO_tri_io[2]，GPIO_EMIO_tri_io[3]。这里，我们将 GPIO_EMIO_tri_io[0] 接到 PL_KEY1 引脚，GPIO_EMIO_tri_io[1]接到 PL_KEY2 引脚，GPIO_EMIO_tri_io[2]接到 PL_LED1 引脚， GPIO_EMIO_tri_io[3]接到 PL_LED2 引脚。 查看原理图可知，这四个引脚的管脚约束分别是，PL_KEY1 为 AD11，PL_KEY2 为 AD10，PL_LED1 为 AE10，PL_LED2 为 AF10，且都在 BANK44 上，该 BANK 电压为 3.3V。接下来在软件中进行管脚分配， I/O Std 一列对应的电平也需要修改。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae0e2d2e82480a55119adb7ff3b0fcb2.png"></p>
<pre><code>    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“pin”，最后点击“OK”。

    在左侧Flow Navigator 导航栏中找到PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 然后在连续弹出的对话框中依次点击“YES”、“OK”。此时，Vivado 工具开始对设计进行综合、实现、并生 成 Bitstream 文件。生成 Bitstream 完成后，在弹出的对话框中选择“Open Implemented Design”。点击“OK”，如果弹出对话框提示关闭 Elaborated Design，则点击“YES”。 在 IMPLEMENTED DESIGN 界面我们可以查看设计对 PL 资源的使用情况。在左侧 Flow Navigator 导 航栏中找到 **IMPLEMENTATION** ，点击该选项中的“**Report Utilization** ”，然后在弹出的对话框中点击“OK”。

    在界面下方的 Utilization 标签页中，选择左侧的 Summary，然后在右侧会以表格和柱状图两种方式显 示当前 PL 资源的使用情况。在我们本次实验中，只消耗了 PL 端 4 个 LUT 和 4 个 IO 资源，这个 IO 就是 PS 通过 EMIO 扩展 GPIO 接口信号时所使用的 PL 引脚。如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/36d3b2fa130b81b99840523163257bd8.png"></p>
<pre><code>    在菜单栏中选择 File &gt; Export &gt; Export hardware。 在弹出的对话框中，**勾选“Include bitstream”** ，然后点击“OK”按钮。在此处需要注意，如果我们的设计使用了 PL 的资源，比如使用了 PL 的引脚，或者在 PL 内实现了部 分功能模块，那么我们就需要生成 Bitstream 文件，并在导出硬件的时候包含该文件。
</code></pre>
<h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot; 
#define GPIOPS_ID XPAR_XGPIOPS_0_DEVICE_ID //PS 端 GPIO 器件 ID

#define MIO_LED1 38 //PS_LED1 连接到 MIO38
#define MIO_LED2 39 //PS_LED2 连接到 MIO39
#define MIO_KEY1 40 //PS_KEY1 连接到 MIO40
#define MIO_KEY2 41 //PS_LEY2 连接到 MIO41
#define EMIO_KEY1 78 //PL_KEY1 连接到 EMIO0
#define EMIO_KEY2 79 //PL_KEY2 连接到 EMIO1
#define EMIO_LED1 80 //PL_LED1 连接到 EMIO2
#define EMIO_LED2 81 //PL_LED2 连接到 EMIO3

int main()
&#123;
	printf(&quot;EMIO TEST!\n&quot;);
	
	XGpioPs gpiops_inst; //PS 端 GPIO 驱动实例
	XGpioPs_Config *gpiops_cfg_ptr; //PS 端 GPIO 配置信息
	
	//根据器件 ID 查找配置信息
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	//初始化器件驱动
	XGpioPs_CfgInitialize(&amp;gpiops_inst,gpiops_cfg_ptr,gpiops_cfg_ptr-&gt;BaseAddr);
	
	//设置 LED 为输出
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED1, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED2, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED1, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED2, 1);
	//使能 LED 输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED1, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED2, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED1, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED2, 1);
	
	//设置 KEY 为输入
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY1, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY2, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY1, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY2, 0);
	
	//读取按键状态，控制 LED 亮灭
	while(1)&#123;
		XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED1,
		~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY1));
		
		XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED2,
		~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY2));
		
		XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED1,
		~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY1));
		
		XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED2,
		~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2));
	
	&#125;
	
	return 0;
&#125;


    在代码的第 7 至 10 行，我们指定了 PS 端输出 LED 和输入 KEY 的 MIO 编号，这些编号可以从 MPSOC 开 发板的原理图中查到。在代码的 11 至 14 行指定了 PL 端 LED 和按键 KEY 的 EMIO 编号。

    在本章的简介部分我们提到过，MPSOC 的 GPIO 被分成了 6 组，其中通过 EMIO 扩展的 GPIO 接口位于 BANK3 至 BANK5 中。在本次实验中我们通过 EMIO 扩展了 4 个 GPIO 信号，即 BANK3 的 EMIO0，EMIO1，EMIO2，EMIO3，由于 GPIO 的 BANK0，BANK1，BANK2 分别有 26 个信号，即 MIO 共有 78 个信号，**所以 BANK3 的 EMIO0 是第 79 个信号，编号为 78（从 0 开始编号）。**

    我们按住 Ctrl 键，然后点击代码开头处所引用的头文件“xgpiops.h”以打开该文件。在 xgpiops.h 文件第 162 行给出了 MPSOC 器件 GPIO 最大的引脚数目，共 174 个，分别位于 6 个 Bank 中。在下面的注释中则分别列出了各 Bank 的引脚编号范围，同样可以看到 Bank3 的第一个引脚编号为 78。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a05a2ccf9124d96bc86553e3879682d.png"></p>
<h2 id="四-GPIO之MIO按键中断实验"><a href="#四-GPIO之MIO按键中断实验" class="headerlink" title="四.GPIO之MIO按键中断实验"></a>四.GPIO之MIO按键中断实验</h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="处理器中断类型"><a href="#处理器中断类型" class="headerlink" title="&lt;1&gt;.处理器中断类型"></a>&lt;1&gt;.处理器中断类型</h4><p>• 可屏蔽中断（Maskable Interrupts，IRQ)</p>
<p>• 不可屏蔽中断（Non-Maskable Interrupts，NMI)</p>
<p>• <strong>处理器间中断（Inter-Processor Interrupts，IPI)</strong><br>：—在多处理器系统中，一个处理器可能需要中断另一个处理器的操作。在这种情况下，就会产生一个 IPI，以便于处理器间通信或同步。</p>
<h4 id="中断控制器GIC"><a href="#中断控制器GIC" class="headerlink" title="&lt;2&gt;中断控制器GIC"></a>&lt;2&gt;中断控制器GIC</h4><pre><code>    ARM SOC 系统中 CPU 的中断信号仲裁器件：**GIC** （**general interrupt controller** ， 通用中断控制器） _**【功能和结构上类似于《微机原理》中的可编程中断控制器8259】**_


    当对应的中断源有效时，GIC 根据该中断源的配置，决定是否将该中断信号，发送给 CPU。如果有多 个中断源有效，那么 GIC 还会进行仲裁，选择最高优先级中断，发送给 CPU。 当 CPU 接受到 GIC 发送的中断，通过读取 GIC 的寄存器，就可以知道中断的来源来自于哪里，从而可以做相应的处理。 当 CPU 处理完中断之后访问 GIC 的寄存器，该中断处理完毕。GIC 接受到该信息后，将该中断源取消，避免又重新发送该中断给 CPU 以及允许中断抢占。

    Zynq Ultrascale+ MPSOC 包含两个中断控制器(GIC)，分别是符合 GICv2 架构规范的 Arm GIC-400 通用中断控制器 APU GIC 和符合 GICv1 架构规范的 Arm PL-390 通用中断控制器(PL390)。中断控制器框图如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/afde86e7494ef3caa5c1ecc3c4445dc8.png"></p>
<p>上图中 GIC-400 是 APU 中断控制器，其功能划分如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/796c758bb3becf08035866a7a7deb2c8.png"></p>
<p>详细功能：  </p>
<pre><code>    APU 中断控制器被分为两部分，第一部分是分发器(Distributor)，用来登记传送进来的中断并对它们进行排序，然后将中断送到正确的目标 CPU。distributor 对中断提供以下的功能：

–全局中断使能 –每个中断的使能 –中断的优先级 –中断的分组 –中断的目的 core –中断触发方式 –对于 SGI 中断，传输中断到指定的 core –每个中断的状态管理 –提供软件，可以修改中断的 pending 状态

    中断控制器第二部分(CPU Interface)和每个 CPU 的中断线连接，用来触发相关 Cortex-A53 的中断。 cpu interface 提供了一下的功能：

–将中断请求发送给 cpu –对中断进行认可（acknowledging an interrupt） –中断完成识别(indicating completion of an interrupt) –设置中断优先级屏蔽 –定义中断抢占策略 –决定当前处于 pending 状态最高优先级中断

     每个 Cortex-A53 有**四个中断线** 作为输入，分别是**普通优先级中断 nIRQ，高优先级（或快速）中断 nFIQ， 普通优先级虚拟中断 nVIRQ，高优先级（或快速）虚拟中断 nFIQ**

    APU 中断控制器处理三种类型中断：1**6 个软件产生的中断(SGI)，7 个私有外设中断(PPI)，92 个共享外设中断(SPI)**

    每个 CPU 都可以使用软件生成的中断来中断自身、另一个 CPU 或同时中断两个 CPU。有 16 个软件生成中断，具体见表。向软件产生的中断寄存器（GICD_SGIR）写入 SGI 中断编号并指定目标 CPU（或 两个 CPU），就产生了一个 SGI。该写操作通过 CPU 自己的专用（私有）总线进行。**每个 CPU 都有自己 的一组 SGI 寄存器** ，用于生成 16 个软件生成的中断中的一个或多个。所有的 SGI 都是边沿触发的，且其敏感性类型是固定的，不能修改。  
    每个 CPU 核连接到了一个有七个外设中断的私有组上，这七个外设中断见表。需要注意的是：**来自 PL 的快速中断（FIQ）信号和中断（IRQ）信号** 在发送给中断控制器之前，会在传输给 PS 的时候被**反转** 。因此，这些信号因此**在 PL 内低电平有效，在 PS-PL 接口处高电平有效** 。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc3fc6a7da9253c672f49890520b37d4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fa3a98c687d4b1476298098bdd3e11d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/232e30f977e6357aeb48fc33afd0f8a4.png"></p>
<pre><code>    共享外设中断(SPI)是一种可以被分配器路由到任意指定处理器的外设中断。这些送到 GIC 的线性中断源来自各种中断源。

    所有的中断请求，**无论是 PPI、SGI 还是 SPI，都分配了一个唯一的 ID 编号，以用于中断控制器的仲裁。**

    中断分配器具有中断、处理器和活跃信息的中央列表，并负责触发 CPU 的软件中断。为了给每个处理器提供单独的副本，SGI 和 PPI 分派器寄存器是分组的。硬件确保针对**多个 CPU 的中断同一时间只能被一个 CPU 获取** 。
</code></pre>
<p>RPU 中断控制器框图如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be784b536668403f3377da54da3b1333.png"></p>
<h4 id="GPIO-的-MIO-的中断"><a href="#GPIO-的-MIO-的中断" class="headerlink" title="&lt;3&gt;GPIO 的 MIO 的中断"></a>&lt;3&gt;GPIO 的 MIO 的中断</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/adf3469ae6c2d955307f37538bd069af.png"></p>
<p>寄存器说明：</p>
<pre><code>INT_MASK：这个寄存器是只读的，显示哪些位当前被屏蔽，哪些位未被屏蔽/启用。
INT_EN：向该寄存器的任何位写入 1，可以启用/解除中断信号的掩码。从该寄存器读取将返回一个不
可预测的值。
INT_DIS：向该寄存器的任何位写入 1 都会屏蔽该中断信号。从该寄存器读取会返回不可预测的值。
INT_STAT：该寄存器显示是否发生了中断事件。将 1 写入该寄存器中的某个位可清除该位的中断状态。
将 0 写入该寄存器中的某个位将被忽略。
INT_TYPE：该寄存器控制中断是边沿敏感还是电平敏感。
INT_POLARITY：该寄存器控制中断是低电平有效还是高电平有效（或下降沿敏感或上升沿敏感）。
INT _ANY：如果 INT_TYPE 设置为边沿敏感，则该寄存器在上升沿和下降沿都会启用中断事件。如果
INT_TYPE 设置为电平敏感，则忽略该寄存器。

    如果检测到中断，中断检测逻辑将 GPIO 的 **INT_STAT** 状态设置为真。如果中断未屏蔽，则 中断传输到一个或电路（图中未画出）。该或电路将**四个 BANK 中所有 GPIO 的所有中断组合成一个输出 （IRQ ID＃48）**到中断控制器。如果中断被禁止（屏蔽），则 INT_STAT 状态将保持直到被清除，但它**不会传输到中断控制器** ，除非稍后写入**INT_EN** 以禁用屏蔽。

    如果 GPIO 中断是边沿触发的，则 INT 状态由检测逻辑锁存。通过**向 INT_STAT 寄存器写入 1 来清除 INT 锁存器** 。对于电平触发的中断，必须**清零 GPIO 中断输入源** ，以清除中断信号。或者，软件可以使用 **INT_DIS 寄存器屏蔽该输入** 。

    **如果 INT_STAT = 1 且 INT_MASK = 0，则该中断信号有效。**
</code></pre>
<h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d39702d5ebb5e0669f52c86ede2c349.png"></p>
<p>沿用二中使用的硬件平台</p>
<h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>导入硬件平台后在选择模版时选择**“Empty Application”**<strong>自行创建工程文件</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a45e282be5173c86ff34d81074f56dba.png"></p>
<p> 添加main.c文件后输入代码：</p>
<pre><code>/***************************** Include Files *********************************/

#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xplatform_info.h&quot;
#include &lt;xil_printf.h&gt;
#include &quot;sleep.h&quot;

/************************** Constant Definitions *****************************/

//以下常量映射到xparameters.h文件
#define GPIO_DEVICE_ID      XPAR_XGPIOPS_0_DEVICE_ID      //PS端GPIO器件ID
#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID  //通用中断控制器ID
#define GPIO_INTERRUPT_ID   XPAR_XGPIOPS_0_INTR           //PS端GPIO中断ID

//定义使用到的MIO引脚号
#define KEY  40         //PS_KEY1 连接到 MIO40
#define LED  38         //PS_LED1 连接到 MIO38
#define LED2 39         //PS_LED2 连接到 MIO39

/************************** Function Prototypes ******************************/

static void intr_handler(void *callback_ref);
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId);

/**************************Global Variable Definitions ***********************/

XGpioPs gpio;   //PS端GPIO驱动实例
XScuGic intc;   //通用中断控制器驱动实例
u32 key_press;  //KEY按键按下的标志
u32 key_val;    //用于控制LED的键值




/************************** Function Definitions *****************************/

int main(void)
&#123;
    int status;
    XGpioPs_Config *ConfigPtr;     //PS 端GPIO配置信息

    xil_printf(&quot;Gpio interrupt test \r\n&quot;);

    //根据器件ID查找配置信息
    ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
    if (ConfigPtr == NULL) &#123;
        return XST_FAILURE;
    &#125;
    //初始化Gpio driver
    XGpioPs_CfgInitialize(&amp;gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);


    //设置KEY所连接的MIO引脚的方向为输入
    XGpioPs_SetDirectionPin(&amp;gpio, KEY, 0);
    //设置LED所连接的MIO引脚的方向为输出并使能输出
    XGpioPs_SetDirectionPin(&amp;gpio, LED, 1);
    XGpioPs_SetOutputEnablePin(&amp;gpio, LED, 1);
    XGpioPs_WritePin(&amp;gpio, LED, 0x0);
    //设置LED2连接的MIO引脚方向为输出并使能输出
    XGpioPs_SetDirectionPin(&amp;gpio, LED2, 1);
    XGpioPs_SetOutputEnablePin(&amp;gpio, LED2, 1);
    XGpioPs_WritePin(&amp;gpio, LED2, 0x0);             //PS_LED2默认关闭；


    //建立中断,出现错误则打印信息并退出
    status = setup_interrupt_system(&amp;intc, &amp;gpio, GPIO_INTERRUPT_ID);
    if (status != XST_SUCCESS) &#123;
        xil_printf(&quot;Setup interrupt system failed\r\n&quot;);
        return XST_FAILURE;
    &#125;


    //中断触发时，key_press为TURE，延时一段时间后判断按键是否按下，是则反转LED
    while (1) &#123;
        if (key_press) &#123;
            usleep(20000);
            if (XGpioPs_ReadPin(&amp;gpio, KEY) == 0) &#123;
                key_val = ~key_val;
                XGpioPs_WritePin(&amp;gpio, LED, key_val);
            &#125;
            key_press = FALSE;
            XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断
            XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断
        &#125;
    &#125;
    return XST_SUCCESS;
&#125;
</code></pre>
<p>中断服务程序：</p>
<pre><code>//中断处理函数
//  @param   CallBackRef是指向上层回调引用的指针
static void intr_handler(void *callback_ref)
&#123;
    XGpioPs *gpio = (XGpioPs *) callback_ref;

    //读取KEY按键引脚的中断状态，判断是否发生中断
    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;
        key_press = TRUE;
        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断
    &#125;
&#125;
</code></pre>
<p>**         由于所有 GPIO 共享相同的中断，因此软件必须同时考虑 INT_MASK 和 INT_STAT 以确定哪个 GPIO<br>导致中断**。这与stm32单片机每个端口使用一个中断号是不同的，<strong>因此中断服务程序也有很大区别</strong> 。</p>
<p>中断配置：</p>
<pre><code>//建立中断系统，使能KEY按键的下降沿中断
//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针
//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针
//  @param   GpioIntrId是Gpio中断ID
//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILURE
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)
&#123;
    int status;
    XScuGic_Config *IntcConfig;     //中断控制器配置信息

    //查找中断控制器配置信息并初始化中断控制器驱动
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == IntcConfig) &#123;
        return XST_FAILURE;
    &#125;
    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,
            IntcConfig-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS) &#123;
        return XST_FAILURE;
    &#125;


    //设置并使能中断异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);
    Xil_ExceptionEnable();
    //为中断设置中断处理函数
    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,
            (Xil_ExceptionHandler) intr_handler, (void *) gpio);
    if (status != XST_SUCCESS) &#123;
        return status;
    &#125;
    //使能来自于Gpio器件的中断
    XScuGic_Enable(gic_ins_ptr, GpioIntrId);
    //设置KEY按键的中断类型为下降沿中断
    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);
    //使能按键KEY中断
    XGpioPs_IntrEnablePin(gpio, KEY);

    return XST_SUCCESS;
&#125;
</code></pre>
<p> <strong>类比stm32的中断配置过程</strong> ：</p>
<pre><code>	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource13);
	
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line = EXTI_Line13;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_Init(&amp;EXTI_InitStructure);
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
	NVIC_Init(&amp;NVIC_InitStructure);
</code></pre>
<h2 id="五-AXI-GPIO-按键控制-LED-实验"><a href="#五-AXI-GPIO-按键控制-LED-实验" class="headerlink" title="五.AXI GPIO 按键控制 LED 实验"></a>五.AXI GPIO 按键控制 LED 实验</h2><pre><code>    在 PL 端**调用 AXI GPIO IP 核** ，并通过 AXI4-Lite 接口实现 PS 与 **PL 中 AXI GPIO 模块**的通信。
</code></pre>
<h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    AXI GPIO IP 核为 AXI 接口提供了一个通用的输入/输出接口。与 PS 端的 GPIO 不同，AXI GPIO 是一个软核（Soft IP），即 MPSOC 芯片在出厂时并不存在这样的一个硬件电路，而是由用户通过配置 PL 端的逻辑资源来实现的一个功能模块。而 PS 端的 GPIO 是一个硬核（Hard IP），它是一个生产时在硅片中实现的功能电路。

    AXI GPIO 可以配置成**单通道或者双通道** ，每个通道的**位宽** 可以单独设置。另外通过打开或者关闭三态缓冲器，AXI GPIO 的端口还可以被动态地配置成**输入或者输出接口** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcfd77f0e7a867a66966b28080460fab.png"></p>
<pre><code>    从图中可以看到，模块的左侧实现了一个 _**32 位的 AXI4-Lite 从接口**_ ，用于主机访问 AXI GPIO 内部各通道的寄存器。当右侧接口输入的信号发生变化时，模块还能向主机产生中断信号。不过只有在配置 IP 核时选择“使能中断”，才会启用模块的中断控制功能。
</code></pre>
<h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>系统框图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c51cad0adcbc38820dac88214135fe29.png"></p>
<pre><code>    在图中，PS 端的 M_AXI_HPM 作为主端口，与 PL 端的 AXI GPIO IP 核以 AXI4-Lite 总线相连接。 其中，**AXI 互联 IP（AXI Interconnect）用于连接 AXI 存储器映射（memory-mapped）的主器件和从器件** 。 
</code></pre>
<h4 id="step2-vivado硬件平台"><a href="#step2-vivado硬件平台" class="headerlink" title="step2:vivado硬件平台"></a>step2:vivado硬件平台</h4><p>增加PS到PL的全局复位信号及axi接口：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a6dafe34ae5d0e1778d7f04193aecdad.png"></p>
<p>增加PS到PL的时钟：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe48d12f2f77f094e6b3719c06695d57.png"></p>
<p>在二的基础上增加PL端中断及PS段端口，如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/39009b1c2ebe277967b7791935f49940.png"></p>
<pre><code>    另外我们还要用到 PS 端的 LED，因此需要在 I/O Configuration 界面勾选“GPIO1 MIO”，并设置 Bank0， Bank2 电压为 1.8V
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ae3c0baeb2513a1632d8da9312b1247.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f44edc425ad3ffe47efb17b246ba2931.png"></p>
<pre><code>    **M_AXI_HPM0_LPD 是通用（General Purpose）AXI 接口** ，它包含了一组信号。首字母 M 表示 PS 作 为主机（Master），PL 中的外设作为从机（Slave）。而左侧的 **maxihpm0_lpd_aclk 是这个接口的全局时钟信号** ，它是一个输入信号，M_AXI_HPM0_LPD 接口的所有信号都是在这个全局时钟的上升沿采样的。

    **pl_clk0 是 PS 输出的时钟信号** ，它将作为 PL 中外设模块的时钟源。在配置 MPSOC 的时候，该时钟默认为 100MHz。

    **pl_resetn0 是由 PS 输出到 PL 的全局复位信号** ，低电平有效。

   **  pl_ps_irq0[0:0]是由 PL 输出到 PS 的中断信号**。

    接下来我们要在 Block Design 中**添加 PL 端的 AXI GPIO IP 核** ，在 Diagram 窗口空白位置右击，然后选 择“Add IP”。在弹出的 IP 目录中搜索“AXI GPIO”，最后双击搜索结果中的“AXI GPIO”将其添加到设计中。
</code></pre>
<p>并双击进行配置：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b35bda5f46246c70ce0f5d793b90b9d0.png"></p>
<pre><code>    GPIO **接口的位宽“GPIO Width”，最大可以支持 32 位** 。这里我们只需要连接一个按键，因此将其设置为 1。另外我们还需要使能其中断功能， 所以需要勾选“Enable Interrupt”。

    我们也可以通过勾选图中的“All Inputs”或者“All Outputs”将 GPIO 指定为输入或者输出接口。这两个选项默认是没有勾选的，这样我们**可以在程序中将其动态地配置成输入或者输出接口** 。

    箭头 1 所指示的参数“**Default Tri State Value** ”，它配置 GPIO **默认情况下的输入输出模式** ，当其为 0xFFFFFFFF 时，表明 GPIO 所有的位默认为输入模式。

    另外勾选箭头 2 所指示的选项可以使能 GPIO 通道 2，GPIO 2 的配置与 GPIO 完全相同。该选项默认没有勾选，即该 IP 工作在单通道模式下。

    按住左键将中断接口“ip2intc_irpt”与 Zynq UltraScale+ MPSOC 的中断接口“pl_ps_irq0[0:0]”连接起来。鼠标指针放到 GPIO 接口上，右击选择 Make External。修改 AXI GPIO IP 核引出的 GPIO 端口的名称。点击引出的 GPIO_0 端口，在左侧外部端口属性一栏中 将其名称修改为“AXI_GPIO_KEY”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a865cb250e683464ce34579721b2fe85.png"></p>
<pre><code>    接下来点击上图中箭头所指示的 _**Run Connection Automation**_ ，在弹出的对话框左侧确认勾选 All Automation，下面列出了会自动连接的模块及其接口，点击“OK”，工具会自动连接 AXI GPIO IP 核的 S_AXI 接口。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd461f7dc04e37cc5487f425c7087cd8.png"></p>
<pre><code>    从上图中可以看到，在执行了自动连接之后，工具自动添加了两个 IP 核，分别是 **AXI 互联（AXI Interconnect）和处理器系统复位（Processor System Reseet）** 。AXI Interconnect IP 核用于将一个（或多个）AXI 存储器映射的主器件连接到一个（或多个）存储器映射的从器件。

    Processor System Reseet IP 核为整个处理器系统提供复位信号。它会处理输入端的各种复位条件，并在输出端产生相应的复位信号。在本次实验中，Processor System Reseet 接收 Zynq UltraScale+ MPSOC 输出的异步复位信号 pl_resetn0，然后**产生一个同步到 PL 时钟源 pl_clk0 的复位信号 peripheral_aresetn** ，用于**复位 PL 端的各外设模块** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d9347dbf7aa03eedbecec9d3a0b63a8.png"></p>
<pre><code>    可以看到 PL端所有外设模块的时钟接口都连接到了 Zynq UltraScale+ MPSOC 输出的时钟信号 pl_clk0 上。需要注意的是，该时钟同样连接到了 PS 端 maxihpm0_pld_aclk 端口，作为M_AXI_HPM0_LPD 接口的全局时钟信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a54df03d0cedfd028171a2669e7ce9ea.png"></p>
<pre><code>    在 Diagram 窗口空白处右击，然后选择**“Validate Design”** 验证设计。验证完成后弹出对话框提示“Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键 “Ctrl + S”保存设计。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d026edbf7c4ce40cb984637584191f12.png"></p>
<pre><code>    接下来在**Source 窗口中右键点击 Design Source 设计文件“design_1.bd”** ，然后依次执行**“Generate Output Products”和“Create HDL Wrapper”** 。 

    在左侧 Flow Navigator 导航栏中找到 **RTL ANALYSIS** ，点击该选项中的“Open Elaborated Design”。然 后在菜单栏中点击 Layout，在下拉列表中选择 **I/O Planning** 以打开 I/O Ports 窗口。我们将在 I/O Ports 窗口 中对 AXI GPIO 引出的接口 AXI_GPIO_KEY 进行管脚分配
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/10d614749b63a945e72f6d57f7e76e21.png"></p>
<pre><code>    管脚分配完成后按快捷键 Ctrl+S 保存管脚约束，在弹出的窗口中输入引脚约束文件名，然后点击 “OK”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0073c6eb2211efe47db4fdc9665158ad.png"></p>
<pre><code>     最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”，在弹出的窗口中点击“OK”，对设计进行综合、实现、并生成 Bitstream 文件。Bitstream 文件生成后，会弹出 Bitstream Generation Completed 对话框，这里直接点击取消。 

    在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”

    新建 vitis 文件夹，将产生的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境...
</code></pre>
<h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    创建vitis工程“axi_gpio”，新建main.c文件内容如下：


#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xgpio.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;sleep.h&quot;

//宏定义
#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID
#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID
#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID
#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID

#define MIO_LED      38                           //PS_LED1 连接到  MIO38
#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1
#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义

//函数声明
void instance_init();                             //初始化器件驱动
void axi_gpio_handler(void *CallbackRef);         //中断服务函数

//全局变量
XScuGic            scugic_inst;                   //中断控制器    驱动实例
XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息
XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例
XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息
XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例

int led_value = 1;                                //LED显示状态

int main()
&#123;
	printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);

	//初始化各器件驱动
	instance_init();

	//配置PS GPIO
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出
	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED

	//配置PL AXI GPIO
	XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断

    //设置中断优先级和触发类型(高电平触发)
    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
    //关联中断ID和中断处理函数
    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);
    //使能AXI GPIO中断
    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    		(Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);
    Xil_ExceptionEnable();

    while(1);

    return 0;
&#125;

//初始化各器件驱动
void instance_init()
&#123;
	//初始化中断控制器驱动
	scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);
	XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);

	//初始化PS端  GPIO驱动
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);

	//初始化PL端  AXI GPIO驱动
	XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);
&#125;

//PL端  AXI GPIO 中断服务(处理)函数
void axi_gpio_handler(void *CallbackRef)
&#123;
	int key_value = 1;
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	print(&quot;Interrupt Detected!\n&quot;);
	XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能
    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据
    if(key_value == 0)&#123;                                     //判断按键按下
    	led_value = ~led_value;
    	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态
    &#125;
    sleep(1);                                               //延时1s 按键消抖
    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断
    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断
&#125;

    在配置 PL 端 AXI GPIO 时，我们需要使能其中断功能，包括 AXI GPIO 通道 1 的中断和全局中断。

    配置 GIC时，每一个中断源都有自己唯一的标识——中断号（ID），具体的数值可以在头文件 xparameters.h 中查看。其中由 PL 产生的**共享外设中断（SPI）共 16 个** ，中断 ID 分别为 121 到 128，以及 136 到 143。我们在程序第 14 行定义了一个宏 **GPIO_INT_ID，用于标识 AXI GPIO 的中 断 ID，它的值为 121** 。

    配置 GIC 首先需要**设置中断 ID 所代表的中断源的优先级和触发类型** 。中断优先级共分为 **32 个等级** ，0 代表最高优先级，0xF8（10 进制数 248）代表最低优先级，各优先级之间的**步进值为 8** 。也就是说，支持的 优先级分别为 0、8、16、32...248。中断触发类型分为高**电平敏感类型** 和**上升沿敏感类型** 。AXI GPIO 在检测到输入接口的信号发生改变时，会产生一个电平类型的中断请求，高有效，因此将中断源 AXI GPIO 的触发类型设置为高电平敏感类型。

    然后还需要将中断 ID 与其中断服务函数关联起来。中断服务函数 axi_gpio_handler()是需要我们自己编写的，用于响应和处理 AXI GPIO 中断的函数。除此之外，还要调用函数 XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID)来使能中断 ID 所对应的中断源。

    最后我们需要初始化并设置 ARM 处理器的异常处理功能，如程序第 57 至 61 行所示。ARM 处理器支 持 7 种异常情况：复位、未定义指令、软件中断、指令预取中止、数据中止、中断请求（IRQ）和快速中断请求（FIQ）。每种异常也都有自己的 ID 标识，其中 XIL_EXCEPTION_ID_INT 用于标识中断请求（IRQ） 异常。我们通过调用函数 Xil_ExceptionRegisterHandler( XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler) XScuGic_InterruptHandler, &amp;scugic_inst )来给 IRQ 异常注册处理程序，它会将中断控制器 GIC 的中断处理程序与 ARM 处理器中的硬件中断处理逻辑连接起来。另外还要通过 Xil_ExceptionEnable( )函数使能 IRQ 异常。
</code></pre>
<h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><pre><code>    本章节需重点理解MPSOC的内部硬件结构，重点理解GIC的工作原理以及各类器件、中断ID的含义，进而才能看懂代码部分的配置过程。查阅官方支持文档《ug1085-zynq-ultrascale-trm.pdf》，补充以下内容：
</code></pre>
<p>除了APU GIC和RPU GIC，还有中断处理器件GIC proxy</p>
<ul>
<li><pre><code>  The **PMU** uses the **GIC proxy** interrupts when the RPU and APU cannot service an interrupt because the processor is powered down. The GIC proxy is a Xilinx architecture for the PMU external interrupt controller and is controlled by the PMU.
</code></pre>
</li>
</ul>
<p>（PMU作用：the platform measurement unit (PMU) processor for power, error<br>management, and execution of an optional software test library (STL) for<br>functional safety applications.）</p>
<ul>
<li><pre><code>   There are **148 system interrupts **that connect to **each GIC** , the GIC proxy interrupt structure, and the PL fabric. The system interrupts are normally handled by the RPU or APU MPCores. The user firmware in the PMU can process system interrupts in the absence of an RPU or APU. The CSU does not connect to the system interrupts.
</code></pre>
</li>
<li><pre><code>   GIC功能：
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5981c4c11abe191bf657a9eaeb5c5fb6.png"></p>
<p>另外APU和RPU的GIC分别有各自特殊功能</p>
<ul>
<li><pre><code>   系统中断：

  The table lists the IRQ numbers for the RPU and APU interrupt controllers, as well as the GIC proxy bit assignments.（部分如下，总共148个：40~187）
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/052ea371c37f250ed9ee30b7a3920bba.png"></p>
<p>包含中断号、位的分配信息等</p>
<ul>
<li><pre><code>   中断控制器框图解析（图见四—1.简介）

  The **shared peripheral interrupts （SPI）** are generated from various subsystems that include the _**I/O peripherals in the PS and logic in the PL.（SPI来源）**_
</code></pre>
</li>
</ul>
<p><strong>——RPU GIC Interrupt Controller</strong></p>
<pre><code>    There are **two interfaces** between the **RPU MPCore** and the **RPU GIC.**

    • Distributor interface is used to **assign the interrupts** to each of the Cortex-R5F MPCore processors.

    • CPU interface with a separate set of **4 KB memory-mapped registers** for each CPU. This provides protection **against unwanted accesses by one CPU to interrupts that are assigned to the other.**

    The **APU MPCores** processors access the RPU_GIC interrupt controller (Figure 13-2) **through their peripheral interface.**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e56a76baae5943bc6ec5fd907725da9.png"></p>
<pre><code>     *        三种中断：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a019922da4e97554d75c88ffb2c3443.png"></p>
<p>软件中断的触发为边沿且无法更改。触发方式为将SGI interrupt number写入寄存器PL390.enable_sgi_control<br>(ICDSGIR)中，通过读取interrupt acknowledge寄存器PL390.control_n_int_ack_n<br>(ICCIAR)或写入interrupt clear-pending寄存器PL390.enable_sqi_pending (ICDICPR)结束中断。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b0f0d542bdc1c62b77a0dbec31a48.png"></p>
<pre><code>    *        优先次序 Interrupt Prioritization

    All of the **SGI and SPI interrupt** requests are assigned a unique ID number. The controller uses the ID number to arbitrate. The interrupt distributor holds the list of pending interrupts for each CPU and then selects the highest priority interrupt before issuing it to the CPU interface. Interrupts of equal priority are resolved by selecting **the lowest ID**.
</code></pre>
<p><strong>——APU GIC Interrupt Controller</strong></p>
<pre><code>    The APU uses an external GICv2 controller as a central resource to support and manage interrupts. There are **peripheral interrupts, software generated interrupts, and virtual interrupts.**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db6aa664b84592fa37a46fe03ff62b69.png"></p>
<pre><code>    *        Virtual Interrupt

    A virtual interrupt targets a **virtual machine** running on a processor and is typically signaled to the processor by the connected virtual CPU interface.（和虚拟机相关，详见文档）
</code></pre>
<ul>
<li><pre><code>   Interrupt Architecture

  The interrupt architecture includes eleven sets of registers with six registers per set. Each set is divided between **sending an interrupt (TRIG and OBS) and receiving an interrupt (ISR, IMR, IER, and IDR).（中断过程通过读写寄存器操作）**
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/55ac29cbbb0817418efc8baab3e18d99.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/63fb614cb09abdfa5dffa67bee11f4b5.png"></p>
<ul>
<li><pre><code>   Determine the Source of Interrupt（确定中断源）

  A processing unit reads its i**nterrupt status (ISR) and mask (IMR)** registers **to determine the source that caused the IRQ interrupt.** Once serviced, the ISR can be cleared by writing the data that was read from this register. The bits that were set are cleared while preserving any bits that got set after the read took place, which helps to eliminate missed interrupts
</code></pre>
</li>
<li><pre><code>   示例代码：
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/33f967286bcd5984c9f582d9fd3a340d.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133275810">https://blog.csdn.net/qq_32971095/article/details/133275810</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/UVa232%E8%A7%A3%E7%AD%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/UVa232%E8%A7%A3%E7%AD%94/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:57" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>    输入一个r行c列（1 &lt;= r,c &lt;= 10）的网格，黑格用*号表示，每个白格都填有一个字母。如果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边界），则称这个白格是一个起始格。首先把所有起始格从左到右，从上到下顺序编号1，2，3，……要求找出所有横向单词。这些单词必须从一个起始格开始，向右延伸到一个黑格的左边或者整个网格的最右边。最后找出所有的竖向单词。


#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;time.h&gt;
#define ROW 100
#define COL 100
char matrix[ROW][COL] = &#123;0&#125;;
//#define LOCAL

int judge(char str[ROW][COL], int r, int c) &#123;
    if (str[r][c] != &#39;*&#39;) &#123;
        if (r == 0 || c == 0 || str[r - 1][c] == &#39;*&#39; || str[r][c - 1] == &#39;*&#39;)return 1;
        else return 0;
    &#125;
    else return 0;    
&#125;

int main() &#123;
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif

    int i, j, k, r, c, Num = 1, num = 1;
    while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) == 2 &amp;&amp; r != 0) &#123;
        num = 1;
        for ( i = 0; i &lt; r; i++)&#123;
            scanf(&quot;%s&quot;, matrix[i]);
        &#125;
        printf(&quot;puzzle #%d:\nAcross\n&quot;, Num++);
        for (i = 0; i &lt; r; i++) &#123;
            for (j = 0; j &lt; c; j++) &#123;
                if (judge(matrix, i, j)) &#123;
                    printf(&quot;%3d.%c&quot;, num++,matrix[i][j]);
                    for (k = j+1; k &lt; c &amp;&amp; matrix[i][k] != &#39;*&#39;; k++) &#123;
                        if (judge(matrix, i, k))num++;
                        printf(&quot;%c&quot;, matrix[i][k]);
                    &#125;
                    j = k;
                    printf(&quot;\n&quot;);
                &#125;
            &#125;
        &#125;
        printf(&quot;DOWN\n&quot;);
        num = 1;
        for (j = 0; j &lt; c; j++) &#123;
            for (i = 0; i &lt; r; i++) &#123;
                if (judge(matrix, i, j)) &#123;
                    printf(&quot;%3d.%c&quot;, num++, matrix[i][j]);
                    for (k = i+1; k &lt; r &amp;&amp; matrix[k][j] != &#39;*&#39;; k++) &#123;
                        if (judge(matrix, k, j))num++;
                        printf(&quot;%c&quot;, matrix[k][j]);
                    &#125;
                    i = k;
                    printf(&quot;\n&quot;);
                &#125;
            &#125;
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    //printf(&quot;TIME USED: %.5f&quot;, (double)clock() / CLOCKS_PER_SEC);
&#125;
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124302787">https://blog.csdn.net/qq_32971095/article/details/124302787</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:38" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-简要回顾PID"><a href="#一-简要回顾PID" class="headerlink" title="一.简要回顾PID"></a>一.简要回顾PID</h2><p>*代码：</p>
<pre><code>//**********pid.h**********
#ifndef _PID_H
#define _PID_H
#include &quot;public.h&quot;

#define PID_REALIZE	0	//位置式PID
#define PID_INCREASE 1	//增量式PID

int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode);

#endif



//**********pid.c**********
#include &quot;pid.h&quot;

//速度环控制
int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode)
&#123;
	int Pid_Num=0;		//返回的控制值
	
	static float Error_k=0;
	static float Error_k1=0;
	static float Error_k2=0;
	
	Error_k=Target_Num-Current_Num;
	Error_k1=Error_k-Error_k1;
	
	if(PID_Mode==PID_INCREASE)
	&#123;
		Error_k2=Error_k-2*Error_k1+Error_k2;
		Pid_Num=kp*Error_k+ki*Error_k2+kd*Error_k1;
	&#125;
	
	else if(PID_Mode==PID_REALIZE)
	&#123;
		Pid_Num=kp*Error_k+kd*Error_k1;
	&#125;

	Error_k2=Error_k1;
	Error_k1=Error_k;

	return Pid_Num;
&#125;
</code></pre>
<p>*所需参数：KP&#x2F;KI&#x2F;KD&#x2F;当前值Curr_Num</p>
<p>*返回值：Pid_Num（根据实际情境确定其物理意义，比如可以是增量：如控制电机转速，Pid_Num为增量，可代表增加的电压值等；也可以是直接确定值：如控制小车行进距离，Pid_Num代表当前小车速度）</p>
<p>*位置式PID和增量式PID区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/89508034" title="位置式PID与增量式PID区别浅析">位置式PID与增量式PID区别浅析</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="二-PID参数意义"><a href="#二-PID参数意义" class="headerlink" title="二.PID参数意义"></a>二.PID参数意义</h2><p>评估指标：最大超调量、上升时间、静差（稳定、准确、快速）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f816706c1aa1692d006fa201b2e511c2.png"></p>
<p> PID三参数：P用于提高响应速度，I减小静差、D减小静差</p>
<p>在实践生产工程中，不同的控制系统对控制器效果的要求不一样。比如平衡车、倒立摆对系统的快速性要求很高,响应太慢会导致系统失控。智能家居里面的门窗自动开合系统,对快速性要求就不高,但是对稳定性和准确性的要求就很高,所以需要严格控制系统的超调量和静差。</p>
<p>所以PID参数在不同的控制系统中是不一样的。只要我们理解了每个PID参数的作用,我们就可以应对工程中的各种项目的PID参数整定了。</p>
<p> 位置控制的调节经验可以总结为：先只使用P控制，增大P系数至系统震荡之后加入微分控制以增大阻尼,消除震荡之后再根据系统对响应和静差等的具体要求，调节P 和<br>I 参数。</p>
<p>一般而言,一个控制系统的控制难度,一般取决于系统的转动惯量和对响应的速度要求等。转动惯量越小、对响应速度要求越低, PID参数就越不敏感。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399">https://blog.csdn.net/qq_32971095/article/details/131927399</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:52" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注释给了一些要点</p>
<p>用requests库爬取时网页可能加载不完整，故用selenium库，加sleep延时使加载充分</p>
<p>主要利用re库，利用正则表达式提取html文件中的信息</p>
<p>threading是多线程运行，节省时间</p>
<p>如何使用？</p>
<pre><code>    配置selenium库，下载chomedriver，网上有教程

    更改range函数的范围就可以对该范围内用户信息爬取
</code></pre>
<p>存在问题：</p>
<pre><code>    太慢

    不稳定，会漏用户，测试中        

    用正则表达式麻烦
</code></pre>
<p>改进：</p>
<pre><code>    学习xpath、scrapy爬虫框架、线程池等


from selenium import webdriver
import re
import time
import threading

def blbl_uid_get(uid):

    url=&quot;https://space.bilibili.com/&quot;+str(uid)
    
    # 不开网页显示
    option = webdriver.ChromeOptions()
    option.add_argument(&quot;headless&quot;)

    # 使用selenium模块得到网页完整源码
    driver=webdriver.Chrome(chrome_options=option)
    driver.get(url) 
    respond=driver.page_source
    time.sleep(8)

    # 网页内容爬取测试
    # with open(&quot;blbl.html&quot;,&quot;wb+&quot;) as f:
    #     f.write(respond.encode())

    up_name=re.findall(r&#39;&lt;span id=&quot;h-name&quot;&gt;\s*(.*?)\s*&lt;/span&gt;&#39;,respond,re.S)
    up_fans=re.findall(r&#39;&lt;p id=&quot;n-fs&quot; class=&quot;n-data-v space-fans&quot;&gt;\s*(.*?)\s*&lt;/p&gt;&#39;,respond,re.S)
    # 网页还是缺失了部分信息如下
    # zan_num=re.findall(r&#39;视频、动态、专栏累计获赞([^&quot;]*)&#39;,respond,re.S)
    # watch_num=re.findall(r&#39;截止昨天，播放数总计为([^&quot;]*)&#39;,respond,re.S)
    # read_num=re.findall(r&#39;截止昨天，阅读数总计为([^&quot;]*)&#39;,respond,re.S)
    if len(up_fans)!=0 and len(up_name)!=0:
        # 摘取要寻找的信息
        record=&quot;&quot;
        record=up_name[0]+&quot; &quot;+up_fans[0]+&#39;\n&#39;# +&quot; &quot;+zan_num[0]+&quot; &quot;+watch_num[0]+&quot; &quot;+read_num[0]
        # 写入文件
        with open(&quot;up_fans.txt&quot;,&quot;a+&quot;) as f:
            f.write(record)
            f.close()

    # 一定要quit
    driver.quit()

# 并发执行爬虫
for i in range(348651384,348651400):
    t = threading.Thread(target=blbl_uid_get, args=(i,))
    t.start()
</code></pre>
<p>结果：</p>
<p>70975784467_bili 0<br>chnksxf 0<br>深蓝色五角枫 8<br>-SWQ- 27<br>w773727 0<br>If-There-If 2<br>bili75588510448 0<br>u723510 1<br>o206413 0<br>10292619012_bili 1<br>丶帝丶弑 0<br>t252791 0<br>why13643485777 0<br>丁嘉丽12334 0<br>80204814302_bili 0<br>ddzn17ZXZ 1</p>
<p>结论：显然，-SWQ-在一定范围内粉丝最多</p>
<p>2023年3月20日21:40:43更新</p>
<p>学习了xpath语言，利用lxml库，可以代替re正则表达式</p>
<p>相比正则表达式，xpath更加简单简洁！</p>
<p>注意tree的两种创建方式的不同：本地文件和网络请求</p>
<p>使用xpath要注重标签之间的结构！找好属性即其值，尽量缩小范围，不然很容易多得！</p>
<pre><code>from selenium import webdriver
import time
import threading
from lxml import etree

def blbl_uid_get(uid):

    url=&quot;https://space.bilibili.com/&quot;+str(uid)
    
    # 不开网页显示
    option = webdriver.ChromeOptions()
    option.add_argument(&quot;headless&quot;)

    # 使用selenium模块得到网页完整源码
    driver=webdriver.Chrome(chrome_options=option)
    driver.get(url) 
    time.sleep(2)
    respond=driver.page_source
    with open(&quot;blbl_xpath.html&quot;,&quot;wb&quot;) as f:
        f.write(respond.encode())

    # 利用xpath提取内容(本地调用方式！)
    # paser=etree.HTMLParser(encoding=&#39;utf-8&#39;)
    # tree=etree.parse(&#39;blbl_xpath.html&#39;,parser=paser)

    # 利用xpath提取内容(互联网中响应)
    tree=etree.HTML(respond)

    up_name=tree.xpath(&#39;//div[@class=&quot;h-basic&quot;]//span[@id=&quot;h-name&quot;]/text()&#39;)
    fans_num=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-fs&quot;]/text()&#39;)[0].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)
    # statistics=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-bf&quot;]/text()&#39;)
    work_title=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//a[@class=&quot;title&quot;]/text()&#39;)
    work_length=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;length&quot;]/text()&#39;)
    work_play=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;play&quot;]/text()&#39;)
    work_time=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;time&quot;]/text()&#39;)
    min_num=min(len(work_time),len(work_length),len(work_title),len(work_play))

    # 摘取要寻找的信息
    record=&quot;&quot;
    record=&quot;up昵称:&quot;+up_name[0]+&quot;\n&quot;+&quot;粉丝数:&quot;+fans_num+&#39;\n&#39;
    if(min_num!=0):
        record+=&#39;代表作:&#39;+&#39;\n&#39;
        for i in range(0,min_num):
            record+=&quot;作品名:&quot;+work_title[i]+&quot;\n&quot;+&quot;时长:&quot;+work_length[i]+&quot;\n&quot;+&quot;播放量:&quot;+work_play[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)+&quot;\n&quot;+&quot;发布时间:&quot;+work_time[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)
    record+=&#39;\n\n&#39;

    # 写入文件
    with open(&quot;blbl_xpath_2.txt&quot;,&quot;w+&quot;,encoding=&#39;utf-8&#39;) as f:
        f.write(record)
        f.close()

    
    # 一定要quit
    driver.quit()

# 并发执行爬虫
for i in range(348651375,348651390):
    t = threading.Thread(target=blbl_uid_get, args=(i,))
    t.start()
</code></pre>
<p>结果如下：</p>
<p>up昵称:68228791709_bili<br>粉丝数:0</p>
<p>up昵称:-SWQ-<br>粉丝数:27<br>代表作:<br>作品名:《刺客信条》6分49秒极限攀爬，同步率1000%<br>时长:04:18<br>播放量:164<br>发布时间:2022-3-20作品名:《消逝的光芒》对断桥、云端的向往以及信仰之跃<br>时长:09:35<br>播放量:419<br>发布时间:2022-2-1作品名:《生化危机2重制版》克莱尔打光弹药后手刃威廉G4<br>时长:12:14<br>播放量:310<br>发布时间:2022-2-1作品名:在西电中秋快乐的一天<br>时长:07:07<br>播放量:166<br>发布时间:2021-9-22作品名:4年菜鸡唯一一次五杀<br>时长:00:52<br>播放量:158<br>发布时间:2021-9-10作品名:沙雕室友们的日常<br>时长:00:21<br>播放量:51<br>发布时间:2020-8-22作品名:2020班级元旦晚会快来康康<br>时长:03:03<br>播放量:109<br>发布时间:2020-1-12作品名:社会我祥哥，同学冒死拍班主任<br>时长:00:13<br>播放量:114<br>发布时间:2019-8-19作品名:【建筑模型】建模锦标赛中华庭院模型展示<br>时长:02:39<br>播放量:2797<br>发布时间:2019-8-19</p>
<p>up昵称:p604904<br>粉丝数:0</p>
<p>up昵称:78992601564_bili<br>粉丝数:0</p>
<p>up昵称:10292619012_bili<br>粉丝数:1</p>
<p>up昵称:DMAP_<br>粉丝数:9<br>代表作:<br>作品名:拍拍猫猫<br>时长:02:03<br>播放量:89<br>发布时间:2022-11-29</p>
<p>up昵称:82212894921_bili<br>粉丝数:0</p>
<p>up昵称:bili75588510448<br>粉丝数:0</p>
<p>up昵称:丁嘉丽12334<br>粉丝数:0</p>
<p>up昵称:68228791709_bili<br>粉丝数:0</p>
<p>up昵称:80204814302_bili<br>粉丝数:0</p>
<p>up昵称:t229231<br>粉丝数:0</p>
<p>up昵称:chnksxf<br>粉丝数:0</p>
<p>up昵称:GH952105677<br>粉丝数:0</p>
<p>up昵称:52393731947_bili<br>粉丝数:0</p>
<p>up昵称:流口水的南方<br>粉丝数:0</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/129629331">https://blog.csdn.net/qq_32971095/article/details/129629331</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:42" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>源码下载：<a target="_blank" rel="noopener" href="https://29.s.bookln.cn/q?c=120EL4LP111&sh=sh&vt_=1688811733923#1688811735786" title="下载资源包 (bookln.cn)">下载资源包<br>(bookln.cn)</a></strong></p>
<p><strong>常用函数库：</strong></p>
<p>**         英文：**<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/" title="OpenCV:
OpenCV modules">OpenCV: OpenCV modules</a></p>
<p>**         中文：**<a target="_blank" rel="noopener" href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/index.html" title="Welcome to opencv documentation! — OpenCV 2.3.2 documentation">Welcome to opencv documentation! — OpenCV 2.3.2<br>documentation</a></p>
<p><strong>jetson nano上的OpenCV使用：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</p>
<p><strong>学习OpenCV的推荐网站和文章：</strong></p>
<p><a target="_blank" rel="noopener" href="https://learnopencv.com/getting-started-with-opencv/" title="Getting Started with OpenCV | LearnOpenCV">Getting Started with OpenCV | LearnOpenCV</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spmallick/learnopencv" title="spmallick&#x2F;learnopencv:
Learn OpenCV : C++ and Python Examples (github.com)">spmallick&#x2F;learnopencv: Learn OpenCV : C++ and Python Examples<br>(github.com)</a></p>
<p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">一.图像相关知识</a></p>
<p><a href="about:blank#%E4%BA%8C.opencv%E7%AE%80%E4%BB%8B">二.opencv简介</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%EF%BC%88VS2019%EF%BC%89%E3%80%81%E6%BA%90%E7%A0%81%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%EF%BC%88CMake%EF%BC%89%E3%80%81%E8%B0%83%E7%94%A8%E5%8A%A8%2F%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81cv%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81OpenCV%20API%E7%89%B9%E7%82%B9%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3InputArray%2FOutputArray%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81OpenCV%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81HighGui%E6%A8%A1%E5%9D%97%EF%BC%89">&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV<br>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">&lt;2&gt;示例代码：</a></p>
<p><a href="about:blank#1.%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%9A">1.展示图片：</a></p>
<p><a href="about:blank#2.%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91">2.播放视频</a></p>
<p><a href="about:blank#3.%E6%BB%91%E5%8A%A8%E6%9D%A1%E4%BD%BF%E7%94%A8%EF%BC%9A">3.滑动条使用：</a></p>
<p><a href="about:blank#4.%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%EF%BC%9A">4.鼠标事件响应：</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B%EF%BC%9A">&lt;3&gt;练手：</a></p>
<p><a href="about:blank#1.%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4">1.打开摄像头</a></p>
<p><a href="about:blank#2.%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%8C%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%9A%82%E5%81%9C%2F%E6%92%AD%E6%94%BE">2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</a></p>
<p><a href="about:blank#%3C4%3Elinux%E4%B8%8A%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%EF%BC%9A%E5%8F%82%E8%80%83%EF%BC%9ALinux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8CC%2B%2B%20OpenCV%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3_linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%A5%BDopencv%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%A0%E8%BD%BD_Adenialzz%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2">&lt;4&gt;linux上编译运行：参考：Linux下编译、链接、加载运行C++<br>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客</a></p>
<p><a href="about:blank#%E4%B8%89.OpenCV%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">三.OpenCV基本数据结构和基本组件</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%83%8F%E5%AE%B9%E5%99%A8Mat%E7%B1%BB%EF%BC%9B%E7%82%B9Point%E7%B1%BB%EF%BC%9B%E9%A2%9C%E8%89%B2Scalar%E7%B1%BB%EF%BC%9B%E5%B0%BA%E5%AF%B8Size%E7%B1%BB%EF%BC%9B%E7%9F%A9%E5%BD%A2Rect%E7%B1%BB%EF%BC%9B%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2RotatedRect%E7%B1%BB%EF%BC%9B%E5%9B%BA%E5%AE%9A%E5%90%91%E9%87%8FVec%E7%B1%BB%EF%BC%9B%E5%A4%8D%E6%95%B0%E7%B1%BBcomplexf%EF%BC%89">&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</a></p>
<p><a href="about:blank#%C2%A0%3C2%3E%E7%BB%83%E6%89%8B%E4%BB%A3%E7%A0%81"> &lt;2&gt;练手代码</a></p>
<p><a href="about:blank#1.Mat%E7%B1%BB%E6%93%8D%E4%BD%9C">1.Mat类操作</a></p>
<p><a href="about:blank#2.%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E6%B5%81%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2">2.摄像头图像流极坐标变换</a></p>
<p><a href="about:blank#3.%E8%AF%BB%E5%8F%96%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0RGB%E5%80%BC%EF%BC%88%E5%B7%A6%E9%94%AE%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%B8%85%E7%A9%BA%EF%BC%89">3.读取图像像素RGB值（左键显示，右键清空）</a></p>
<p><a href="about:blank#4.%E5%88%9B%E5%BB%BA%E4%B8%80%E5%AE%9A%E5%B0%BA%E5%AF%B83%E9%80%9A%E9%81%93RGB%E5%9B%BE%E5%83%8F%EF%BC%8C%E5%B9%B6%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE%E5%85%B6%E5%83%8F%E7%B4%A0%E5%80%BC%EF%BC%8C%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%80%E7%BB%BF%E8%89%B2%E5%B9%B3%E9%9D%A2">4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">四.数字图像灰度变换与空间滤波</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%EF%BC%9A%E7%BA%BF%E6%80%A7%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%EF%BC%9B%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9A%E6%A6%82%E7%8E%87%E3%80%81%E7%B4%AF%E8%AE%A1%EF%BC%89">&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">1.灰度变换函数</a></p>
<p><a href="about:blank#2.%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88%E6%A6%82%E7%8E%87%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%89%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0">2.直方图（概率直方图）绘制函数</a></p>
<p><a href="about:blank#%E4%B8%83.%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2">七.图像分割</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%EF%BC%9A%E7%AE%97%E5%AD%90%EF%BC%9A%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%EF%BC%88Sobel%2FPrewitt%2FRoberts%EF%BC%89%E3%80%81%E4%BA%8C%E9%98%B6%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%2FLOG%2FCanny%EF%BC%89%E3%80%81%E6%B7%B7%E5%90%88%EF%BC%9B%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%EF%BC%88%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%EF%BC%89%EF%BC%9A%E7%9B%B4%E7%BA%BF%EF%BC%89">&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</a></p>
<p><a href="about:blank#%EF%BC%88%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%E3%80%90%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E3%80%91%EF%BC%9A%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%EF%BC%89">（几何形状检测【霍夫变换】：直线、圆）</a></p>
<p><a href="about:blank#%EF%BC%88%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E3%80%90%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%91%EF%BC%9A%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E3%80%90OTSU%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%95%E3%80%91%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</a></p>
<p><a href="about:blank#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">​编辑<br>&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%92%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B">1.霍夫直线变换和霍夫圆检测</a></p>
<p><a href="about:blank#2.OTSU%E6%96%B9%E6%B3%95%E5%92%8C%E4%B8%89%E8%A7%92%E6%B3%95%E6%B1%82%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC">2.OTSU方法和三角法求全局阈值</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B">&lt;3&gt;练手</a></p>
<p><a href="about:blank#1.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8">1.边缘检测二阶导数算子使用</a></p>
<p><a href="about:blank#2.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%8F%8A%E9%9C%8D%E5%A4%AB%E5%9C%86%E7%9A%84%E6%A3%80%E6%B5%8B">2.霍夫直线变换及霍夫圆的检测</a></p>
<p><a href="about:blank#3.linux%EF%BC%88ubuntu18%EF%BC%89%E4%B8%8A%E5%AE%9E%E7%8E%B0%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%EF%BC%88%E5%8F%AF%E8%B0%83%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89">3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</a></p>
<p><a href="about:blank#4.%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%EF%BC%88OTSU%2F%E4%B8%89%E8%A7%92%E6%B3%95%2F%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</a></p>
<p><a href="about:blank#5.%E8%AF%86%E5%88%AB%E8%BD%A6%E9%81%93%EF%BC%88%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%81%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%EF%BC%89">5.识别车道（二值化、边缘检测、霍夫直线变换）</a></p>
<p><a href="about:blank#%E4%B9%9D.%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%92%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">九.特征提取和目标检测</a></p>
<p>[&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-<br>LIKE）（分类：SVM&#x2F;级联分类器）](about:blank#%3C1%3E%EF%BC%88%E7%89%B9%E5%BE%81%EF%BC%9AHOG%2FLBP%2FHAAR-<br>LIKE%EF%BC%89%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%9ASVM%2F%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%89)</p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.HOG%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%2BSVM">1.HOG特征提取+SVM</a></p>
<p>[2.获取LBP&#x2F;MB-LBP特征函数](about:blank#2.%E8%8E%B7%E5%8F%96LBP%2FMB-<br>LBP%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0)</p>
<p><a href="about:blank#3.cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E4%BD%BF%E7%94%A8">3.cascade级联分类器使用</a></p>
<hr>
<h2 id="一-图像相关知识"><a href="#一-图像相关知识" class="headerlink" title="一.图像相关知识"></a>一.图像相关知识</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb52f259aeff1a793a7899f7f1678e8e.jpeg"></p>
<h2 id="二-opencv简介"><a href="#二-opencv简介" class="headerlink" title="二.opencv简介"></a>二.opencv简介</h2><h5 id="（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV"><a href="#（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV" class="headerlink" title="&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV"></a>&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV</h5><p>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be8b3f267f375a33f3365797cbf719bd.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7637aa7bab9d022a85a835b6b07b0818.jpeg"></p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="&lt;2&gt;示例代码："></a>&lt;2&gt;示例代码：</h5><h6 id="1-展示图片："><a href="#1-展示图片：" class="headerlink" title="1.展示图片："></a>1.展示图片：</h6><pre><code>int main()
&#123;
	namedWindow(&quot;lena&quot;, WINDOW_NORMAL);
	//setWindowProperty(&quot;lena&quot;, WND_PROP_FULLSCREEN, WINDOW_FULLSCREEN);
	setWindowTitle(&quot;lena&quot;, &quot;Lena经典图像窗口&quot;);
	//resizeWindow(&quot;lena&quot;, 400, 300);
	//moveWindow(&quot;lena&quot;, 0, 0);
	createTrackbar(&quot;t1&quot;, &quot;lena&quot;, NULL, 10, NULL, NULL);
	Mat img = imread(&quot;lena512color.tiff&quot;); //读取图像
	if (img.empty()) &#123;
		return -1; //如果读取图像失败，则返回
	&#125;
	imshow(&quot;lena&quot;, img); //显示图像
	waitKey(0); //等待用户输入
    std::cout &lt;&lt; &quot;Hello World!\n&quot;; 
&#125;
</code></pre>
<h6 id="2-播放视频"><a href="#2-播放视频" class="headerlink" title="2.播放视频"></a>2.播放视频</h6><pre><code>void PlayVideo()
&#123;
	cv::VideoCapture capture(&quot;D:/files/picture and video/C0056.MP4&quot;);
	int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
	int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
	double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率
	double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数
	double dblStartFrames = dblFrameCnt / 2; //播放起始帧数
	capture.set(CAP_PROP_POS_FRAMES, dblStartFrames); //从视频中间开始播放

	cv::namedWindow(&quot;video&quot;,0 );
	resizeWindow(&quot;video&quot;, 800, 600);

	while (capture.isOpened()) &#123;
		Mat frame;
		capture &gt;&gt; frame;
		if (frame.empty()) &#123;
			break;
		&#125;
		imshow(&quot;video&quot;, frame);
		waitKey(10);
	&#125;
&#125;
</code></pre>
<h6 id="3-滑动条使用："><a href="#3-滑动条使用：" class="headerlink" title="3.滑动条使用："></a>3.滑动条使用：</h6><pre><code>滑动条的使用实例
const int g_nMaxAlphaValue = 100; //Alpha值的最大值
int g_nCurAlphaValue;   //当前滑动条对应的值
Mat g_srcImg1; //第1张图像
Mat g_srcImg2; //第2张图像
Mat g_mixImg;  //混合图像
const char cszWindowName[] = &quot;mix&quot;;
//拖动滑动条的响应函数
void on_Trackbar(int, void *)
&#123;
	//求出当前alpha值相对于最大值的比例
	double dblAlphaValue = double(g_nCurAlphaValue)/double(g_nMaxAlphaValue);
	//则beta值为1减去alpha值
	double dblBetaValue = 1.0 - dblAlphaValue;
	//根据alpha和beta的值，对两张图像进行线性混合
	addWeighted(g_srcImg1, dblAlphaValue, g_srcImg2, dblBetaValue, 0.0, g_mixImg);
	//显示混合图像的效果
	imshow(cszWindowName, g_mixImg);
	if (0 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix0.jpg&quot;, g_mixImg);
	&#125;
	if (50 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix50.jpg&quot;, g_mixImg);
	&#125;
	if (100 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix100.jpg&quot;, g_mixImg);
	&#125;
&#125;

int main(int argc, char ** argv)
&#123;
	//加载图像 (两图像的尺寸需相同)
	g_srcImg1 = imread(&quot;lenna.bmp&quot;, IMREAD_COLOR);
	if (g_srcImg1.empty()) &#123;
		std::cout &lt;&lt; &quot;读取第1张图像失败&quot; &lt;&lt; std::endl;
		return -1;
	&#125;
	g_srcImg2 = imread(&quot;tiffany.bmp&quot;, IMREAD_COLOR);
	if (g_srcImg2.empty())&#123;
		std::cout &lt;&lt; &quot;读取第2张图像失败&quot; &lt;&lt; std::endl;
		return -1;
	&#125;
	// 设置滑动条的初值为70
	g_nCurAlphaValue = 0;

	//创建窗口，自动调整大小
	namedWindow(&quot;mix&quot;, WINDOW_AUTOSIZE);
	//在创建的窗体中创建一个滑动条控件
	char TrackbarName[50];
	sprintf_s(TrackbarName, &quot;透明度 %d&quot;, g_nMaxAlphaValue);
	createTrackbar(TrackbarName, cszWindowName, &amp;g_nCurAlphaValue, g_nMaxAlphaValue, on_Trackbar);
	//调用一次回调函数，以显示图像
	on_Trackbar(g_nCurAlphaValue, 0);
	waitKey(0);
	return 0;
&#125;
</code></pre>
<h6 id="4-鼠标事件响应："><a href="#4-鼠标事件响应：" class="headerlink" title="4.鼠标事件响应："></a>4.鼠标事件响应：</h6><pre><code>Rect g_rectangle; //记录要绘制的矩形位置
bool g_bDrawingBox = false;//是否进行绘制
RNG g_rng(12345);  //随机数对象
const String strWndName = &quot;MouseWnd&quot;;
void DrawRactangle(Mat &amp; img, Rect rect)
&#123;
	//每次绘制矩形的颜色都是随机产生的
	rectangle(img, rect, Scalar(g_rng.uniform(0, 255), \
		g_rng.uniform(0, 255), g_rng.uniform(0, 255)), 4);
&#125;
void onMouseCallback(int event, int x, int y, int flags, void * param)
&#123;
	//将画矩形的图像作为参数传入回调函数
	Mat &amp;image = *(Mat*)param;
	switch (event)
	&#123;
		//鼠标移动时改变窗口的大小
	case EVENT_MOUSEMOVE:
		//如果g_bDrawingBox为真，则记录矩形信息到g_rectangle中
		if (g_bDrawingBox) &#123;
			g_rectangle.width = x - g_rectangle.x;
			g_rectangle.height = y - g_rectangle.y;
		&#125;
		break;
		//左键按下时记录窗口的起始位置
	case EVENT_LBUTTONDOWN:
		g_bDrawingBox = true;
		//记录g_rectangle的起点
		g_rectangle = Rect(x, y, 0, 0); 
		break;
		//左键抬起时将当前绘制的矩形信息写入到图像中
	case EVENT_LBUTTONUP:
		// 标识符为false
		g_bDrawingBox = false;
		//向起点左边绘制
		if (g_rectangle.width &lt; 0) &#123;
			g_rectangle.x += g_rectangle.width;
			g_rectangle.width *= -1;
		&#125;
		//向起点上边绘制
		if (g_rectangle.height &lt; 0) &#123;
			g_rectangle.y += g_rectangle.height;
			g_rectangle.height *= -1;
		&#125;
		//调用函数进行绘制
		DrawRactangle(image, g_rectangle);
		break;
	&#125;
&#125;
int main(int argc, char ** argv)
&#123;
	//准备参数
	g_rectangle = Rect(-1, -1, 0, 0);
	Mat srcImage(600, 800, CV_8UC3, Scalar(255,255,255)), tempImage;
	srcImage.copyTo(tempImage);
	g_rectangle = Rect(-1, -1, 0, 0);
	// 设置鼠标操作回调函数
	namedWindow(strWndName);
	setMouseCallback(strWndName, onMouseCallback, (void *)&amp;srcImage);
	// 程序主循环，当进行绘制的标识符为真的时候进行绘制
	while (true)
	&#123;
		//复制原图到临时变量，这样可以清除上一次的鼠标拖动结果
		srcImage.copyTo(tempImage); 
		if (g_bDrawingBox)&#123;
			//在鼠标拖动时，每次都对图像进行临时绘制
			Rect rectCur = g_rectangle;
			//鼠标向上或向左移动时，需要对坐标进行处理
			if (rectCur.width &lt; 0) &#123;
				rectCur.x += rectCur.width;
				rectCur.width *= -1;
			&#125;
			if (rectCur.height &lt; 0) &#123;
				rectCur.y += rectCur.height;
				rectCur.height *= -1;
			&#125;
			DrawRactangle(tempImage, rectCur);
		&#125;
		imshow(strWndName, tempImage);
		if (waitKey(10) == 27) // 按下ESC键，程序退出
			break;
	&#125;

	return 0;
&#125;
</code></pre>
<h5 id="练手："><a href="#练手：" class="headerlink" title="&lt;3&gt;练手："></a>&lt;3&gt;练手：</h5><h6 id="1-打开摄像头"><a href="#1-打开摄像头" class="headerlink" title="1.打开摄像头"></a>1.打开摄像头</h6><pre><code>#include &quot;pch.h&quot;                //viscalC++预编译头文件
#include &lt;iostream&gt;             //C++标准输入、输出流
#include &lt;opencv.hpp&gt;           //OpenCV头文件
#include &lt;highgui.hpp&gt;          //GUI界面头文件
using namespace cv;             //打开cv的名词空间

#pragma comment(lib, &quot;opencv_world480d.lib&quot;)//打开动态库

int main()
&#123;
	cv::namedWindow(&quot;camera&quot;, 0);    //新建名为“camera”的窗口
	VideoCapture capture(0);         //打开ID为0的摄像头
	Mat frame;                       //新建Mat变量（矩阵）
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; frame;            //用重载运算符方式获取视频帧
		if (frame.empty())break;
		imshow(&quot;camera&quot;, frame);     //在名为“camera”的窗口显示捕获帧
		waitKey(10);                 //刷新图像，否则无法正常显示
	&#125;
&#125;
</code></pre>
<h6 id="2-视频播放器，滑动条控制进度，双击暂停-播放"><a href="#2-视频播放器，滑动条控制进度，双击暂停-播放" class="headerlink" title="2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放"></a>2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</h6><pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;opencv.hpp&gt;
#include &lt;highgui.hpp&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* trackname = &quot;progress&quot;;
const char* windowname = &quot;videoplayer&quot;;
const char* filepath = &quot;D:/files/picture and video/C0056.MP4&quot;;
cv::VideoCapture capture(filepath, CAP_ANY);
int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率
double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数

const int g_nMaxProgressValue = 100;			//Alpha值的最大值
int g_nCurProgressValue;						//当前滑动条对应的值
int Cur_Frame;								//记录暂停时的帧数

Mat frame;
int sign = 0;

int main()
&#123;
	void on_Trackbar(int, void*);
	void onMouseCallback(int event, int x, int y, int flags, void* param);
	cv::namedWindow(windowname,0);
	setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
	resizeWindow(windowname, 400, 300);
	moveWindow(windowname, 0, 0);

	createTrackbar(trackname, windowname, &amp;g_nCurProgressValue, g_nMaxProgressValue, on_Trackbar);
	setMouseCallback(windowname, onMouseCallback, (void*)NULL);

	while(capture.isOpened())&#123;
		Cur_Frame = capture.get(CAP_PROP_POS_FRAMES);	//获取当前播放帧数
		//判断是否双击，双击则暂停播放
		if (sign)
		&#123;
			capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);
		&#125;

		capture &gt;&gt; frame;

		//如果播放完毕，等待按键，直接退出
		if (Cur_Frame == dblFrameCnt)
		&#123;
			waitKey(0);
			break;
		&#125;

		imshow(windowname, frame);

		//中途按		ESC可以直接退出
		if (waitKey(1) == 27)break;
	&#125;

&#125;

//滑动条回调函数
void on_Trackbar(int, void*)
&#123;
	capture.set(CAP_PROP_POS_FRAMES, g_nCurProgressValue * dblFrameCnt / g_nMaxProgressValue); //从视频中间开始播放
	capture &gt;&gt; frame;
&#125;

//鼠标回调函数
void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if(event==EVENT_LBUTTONDBLCLK)sign = (sign + 1) % 2;
&#125;
</code></pre>
<p>注意控制输出暂停的方法：</p>
<p>1.waitKey等待：键盘控制，可参考其他博主</p>
<p>2.一直输出上一帧：即本人使用方法</p>
<pre><code>capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);
</code></pre>
<p>3.直接用system（“pause”）  </p>
<h5 id="4-linux上编译运行：参考：-Linux下编译、链接、加载运行C"><a href="#4-linux上编译运行：参考：-Linux下编译、链接、加载运行C" class="headerlink" title="**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++"></a>**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++</h5><p>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506</a><br>“Linux下编译、链接、加载运行C++ OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客”)**</p>
<p><strong>CMakeLists.txt编辑：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuliuheng/p/9431275.html" title="[CMAKE]
详解CMakeLists.txt文件 - VictoKu - 博客园 (cnblogs.com)">[CMAKE] 详解CMakeLists.txt文件 - VictoKu - 博客园<br>(cnblogs.com)</a></strong></p>
<p><strong>或参考：jetson nano上的OpenCV使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="三-OpenCV基本数据结构和基本组件"><a href="#三-OpenCV基本数据结构和基本组件" class="headerlink" title="三.OpenCV基本数据结构和基本组件"></a>三.OpenCV基本数据结构和基本组件</h2><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p>&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</p>
<p>（辅助对象：迭代参数TermCriteria类；范围range类；指针Ptr类）</p>
<p>（工具和系统函数：数学、内存管理、性能优化、异常处理函数）</p>
<p>（图像绘制图形函数：线、矩形、圆、折线）</p>
<p>（图像保存函数；图像几何操作函数：均匀调整（尺寸）、仿射变换、对数极坐标变换）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1811f91ca180329611fd9be36e5e02b.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c2fcbc408c51032f372737fcdbc6a410.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4891ab8394f175c44875a74ca770271d.jpeg"></p>
<h5 id="练手代码"><a href="#练手代码" class="headerlink" title="&lt;2&gt;练手代码"></a>&lt;2&gt;练手代码</h5><h6 id="1-Mat类操作"><a href="#1-Mat类操作" class="headerlink" title="1.Mat类操作"></a>1.Mat类操作</h6><pre><code>int main()
&#123;
	namedWindow(&quot;image&quot;, WINDOW_NORMAL);
	setWindowTitle(&quot;image&quot;, &quot;image:&quot;);
	Mat img(Size(200, 100), CV_8UC3, Scalar(80, 160, 240));
	imshow(&quot;image&quot;, img);
	waitKey(0);
	return -1;
&#125;
</code></pre>
<h6 id="2-摄像头图像流极坐标变换"><a href="#2-摄像头图像流极坐标变换" class="headerlink" title="2.摄像头图像流极坐标变换"></a>2.摄像头图像流极坐标变换</h6><pre><code>const int g_nMaxValue = 100; //滑条值的最大值
int g_nCurValue = 0;   //当前滑动条对应的值

int main()
&#123;
	void on_Trackbar(int, void*);
	namedWindow(&quot;Polor&quot;, WINDOW_NORMAL);

	Mat frame;
	VideoCapture capture(0);
	int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
	int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
	createTrackbar(&quot;zoom factor&quot;, &quot;Polor&quot;, &amp;g_nCurValue, g_nMaxValue, on_Trackbar);
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; frame;
		if (frame.empty())break;
		logPolar(frame, frame, Point2i(nWidth / 2, nHeight / 2), g_nCurValue, WARP_FILL_OUTLIERS);
		imshow(&quot;Polor&quot;, frame);
		waitKey(1);
	&#125;

&#125;

void on_Trackbar(int, void*)
&#123;
	;
&#125;
</code></pre>
<h5 id="3-读取图像像素RGB值（左键显示，右键清空）"><a href="#3-读取图像像素RGB值（左键显示，右键清空）" class="headerlink" title="3.读取图像像素RGB值（左键显示，右键清空）"></a>3.读取图像像素RGB值（左键显示，右键清空）</h5><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* filepath = &quot;/test2.png&quot;;
const char* windowname = &quot;window&quot;;
const char* windowtitle = &quot;image&quot;;
const char* trackname = &quot;fontscale&quot;;	
int fontscale = 1;·								//字体大小及线条粗细
const int max_fontscale = 100;
Mat img = imread(filepath, IMREAD_COLOR);
Mat draw_board = img.clone();					//图片拷贝以实现清除
char string[5];

int main()
&#123;
	void on_Trackbar(int, void*);
	void onMouseCallback(int event, int x, int y, int flags, void* param);
	namedWindow(windowname, WINDOW_NORMAL);
	createTrackbar(trackname, windowname, &amp;fontscale, max_fontscale, on_Trackbar);
	setMouseCallback(windowname, onMouseCallback, (void*)NULL);
	if (draw_board.empty())return -1;
	while (!draw_board.empty())
	&#123;
		imshow(windowname, draw_board);
		if (waitKey(1) == 27)break;
	&#125;
	return 0;
&#125;

void on_Trackbar(int, void*)
&#123;
	;
&#125;

void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if (event == EVENT_LBUTTONDOWN)
	&#123;
		//读取鼠标所指像素的值
		int rgb[3] = &#123; img.at&lt;cv::Vec3b&gt;(x, y)[2],img.at&lt;cv::Vec3b&gt;(x, y)[1], img.at&lt;cv::Vec3b&gt;(x, y)[0] &#125;;
		//putText不支持\n换行，只能手动计算间隔：y + fontscale * 10 * i
		for (int i = 0; i &lt; 3; i++) &#123;
			sprintf_s(string, &quot;%d&quot;, rgb[i]);
			//文字写入图像
			putText(draw_board, string, Point(x, y + fontscale * 10 * i), FONT_HERSHEY_PLAIN, fontscale, Scalar(rgb[2], rgb[1], rgb[0]), fontscale, 8, false);
		&#125;
	&#125;
	if (event == EVENT_RBUTTONDOWN)
	&#123;
		//使显示图像为原始图像，即清零
		draw_board = img.clone();
	&#125;
&#125;
</code></pre>
<p>注：</p>
<p>①.at()函数访问多通道Mat数据元素时为只能用at()函数，且注意at&lt;&gt;内为 Vec3b</p>
<pre><code>at&lt;cv::Vec3b&gt;(x, y)[i]
</code></pre>
<p>②.putText()函数无法实现换行，需手动计算</p>
<h6 id="4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"><a href="#4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面" class="headerlink" title="4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"></a>4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* filepath = &quot;test2.png&quot;;
const char* windowname = &quot;window&quot;;
const char* windowtitle = &quot;image&quot;;
const char* trackname = &quot;fontscale&quot;;

#define WIDTH 800
#define HEIGHT 600

int main()
&#123;
	namedWindow(windowname, WINDOW_NORMAL);
	Mat img(WIDTH, HEIGHT, CV_8UC3, Scalar(0, 0, 0));
	for (int i = 0; i &lt; WIDTH; i++) &#123;
		for (int j = 0; j &lt; HEIGHT; j++) &#123;
			for (int k = 0; k &lt; 3; k++) &#123;
				img.at&lt;Vec3b&gt;(i, j)[k] = (i * j * k) % 256;
			&#125;
		&#125;
	&#125;
	Point p1(200, 50), p2(400, 200);
	rectangle(img,p1,p2,Scalar(0,255,0),8,8,0);
	imshow(windowname, img);
	//imwrite(&quot;C:/Users/user/Desktop/1.png&quot;, img);
	waitKey(0);
	
&#125;
</code></pre>
<h2 id="四-数字图像灰度变换与空间滤波"><a href="#四-数字图像灰度变换与空间滤波" class="headerlink" title="四.数字图像灰度变换与空间滤波"></a>四.数字图像灰度变换与空间滤波</h2><h5 id="（灰度变换：线性、非线性；直方图：概率、累计）"><a href="#（灰度变换：线性、非线性；直方图：概率、累计）" class="headerlink" title="&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）"></a>&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/10f1536c594c088a66be8508027e04c3.jpeg"></p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-灰度变换函数"><a href="#1-灰度变换函数" class="headerlink" title="1.灰度变换函数"></a>1.灰度变换函数</h6><p>①对数变换</p>
<pre><code>//对数变换
void LogTransform(Mat srcImg, Mat &amp;dstImg, const float c=1.0f)
&#123;
	if (srcImg.empty())&#123;
		cout &lt;&lt; &quot;No data&quot; &lt;&lt; endl;
		return;
	&#125;
	//Mat dstMat = Mat::zeros(srcImg.size(), srcImg.type());
	add(srcImg, Scalar(1.0), srcImg);  //计算 s+1
	srcImg.convertTo(srcImg, CV_32F);  //转化为32位浮点型
	cv::log(srcImg, dstImg); //计算log(1+s)
	dstImg = c*dstImg;
	//归一化处理
	normalize(dstImg, dstImg, 0, 255, NORM_MINMAX);
	//cout &lt;&lt; dstImg &lt;&lt; endl;
	cout &lt;&lt; dstImg.elemSize() &lt;&lt; endl;
	//将dstImg转换到CV_8U类型
	convertScaleAbs(dstImg, dstImg);
	return;
&#125;
</code></pre>
<p><strong>②*伽马变换</strong></p>
<pre><code>//伽马校正
void MyGammaCorrection(const Mat&amp; src, Mat&amp; dst, float fGamma)
&#123;
	//CV_Assert(src.data);
	if (src.empty())&#123;
		return;
	&#125;
	//只处理位深度为8位的图像
	CV_Assert(src.depth() != sizeof(uchar));
	//创建查找表
	unsigned char lut[256];
	for (int i = 0; i &lt; 256; i++)&#123;
		lut[i] = saturate_cast&lt;uchar&gt;(pow((float)(i / 255.0),\
			fGamma) * 255.0f);
	&#125;

	dst = src.clone();
	const int channels = dst.channels();
	switch (channels)&#123;
	case 1:
	&#123;
		//MatIterator_&lt;uchar&gt; it;
		//for (it = dst.begin&lt;uchar&gt;(); it != dst.end&lt;uchar&gt;(); it++)
		//	*it = lut[(*it)];
		for (int j = 0; j &lt; dst.rows; j++)&#123;
			for (int i = 0; i &lt; dst.cols; i++)&#123;
				unsigned char val = dst.at&lt;uchar&gt;(j, i);
				dst.at&lt;uchar&gt;(j, i) = lut[val];
			&#125;
		&#125;
		break;
	&#125;
	case 3:
	&#123;
		MatIterator_&lt;Vec3b&gt; it;
		for (it = dst.begin&lt;Vec3b&gt;(); it != dst.end&lt;Vec3b&gt;(); it++)&#123;
			(*it)[0] = lut[((*it)[0])];
			(*it)[1] = lut[((*it)[1])];
			(*it)[2] = lut[((*it)[2])];
		&#125;
		break;
	&#125;
	&#125;
&#125;
</code></pre>
<p>注：saturate_cast&lt;&gt;的使用（防止颜色溢出）参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15698613/article/details/84557588?spm=1001.2014.3001.5506" title="【OpenCV】中saturate_cast&lt;uchar&gt;的含义和用法是什么？_人工智能博士的博客-CSDN博客">【OpenCV】中saturate_cast<uchar>的含义和用法是什么？_人工智能博士的博客-<br>CSDN博客</a></p>
<h6 id="2-直方图（概率直方图）绘制函数"><a href="#2-直方图（概率直方图）绘制函数" class="headerlink" title="2.直方图（概率直方图）绘制函数"></a>2.直方图（概率直方图）绘制函数</h6><p>①灰度直方图</p>
<pre><code>//灰度直方图
void DrawGrayImgHist(const Mat &amp;srcImg)
&#123;
	if (1 != srcImg.channels())&#123;
		return;
	&#125;
	int channels = 0;
	Mat dstHist;
	int histSize[] = &#123; 256 &#125;;    
	float midRanges[] = &#123; 0, 256 &#125;;
	const float *ranges[] = &#123; midRanges &#125;;
	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \
		1, histSize, ranges, true, true);
	//最终绘制的直方图图像，大小是256×256
	Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);
	double dblHistMaxValue;
	//求得直方图的最大值
	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);
	//将像素的个数整合到图像的最大范围内  
	for (int i = 0; i &lt;= 255; i++)&#123;
		int value = cvRound(dstHist.at&lt;float&gt;(i)\
			* 255 / dblHistMaxValue);
		line(histImage, Point(i, histImage.rows - 1), \
			Point(i, histImage.rows - 1 - value), Scalar(255));
	&#125;
	imshow(&quot;直方图&quot;, histImage);
	imwrite(&quot;desert_hist_规定化之后.bmp&quot;, histImage);
&#125;
</code></pre>
<p>注：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12386274.html" title="minMaxLoc 寻找图像全局最大最小值">minMaxLoc 寻找图像全局最大最小值</a></p>
<p>②RGB彩色直方图</p>
<pre><code>//RGB彩色直方图
void DrawRGBImgHist(const Mat &amp;srcImg)
&#123;
	if (srcImg.empty() || srcImg.channels() != 3)&#123;
		return;
	&#125;
	//分割成3个单通道图像 ( R, G 和 B )
	vector&lt;Mat&gt; rgb_planes;
	split(srcImg, rgb_planes);
	// 设定bin数目
	int histSize = 256;
	// 设定取值范围 ( R,G,B) )
	float range[] = &#123; 0, 256 &#125;;
	const float* histRange = &#123; range &#125;;

	bool uniform = true;
	bool accumulate = true;

	Mat r_hist, g_hist, b_hist;

	//计算直方图:
	calcHist(&amp;rgb_planes[0], 1, 0, Mat(), r_hist, 1, \
		&amp;histSize, &amp;histRange, uniform, accumulate);
	calcHist(&amp;rgb_planes[1], 1, 0, Mat(), g_hist, 1, \
		&amp;histSize, &amp;histRange, uniform, accumulate);
	calcHist(&amp;rgb_planes[2], 1, 0, Mat(), b_hist, 1,\
		&amp;histSize, &amp;histRange, uniform, accumulate);

	// 创建直方图画布
	int hist_w = 256; int hist_h = 200;
	int bin_w = cvRound((double)hist_w / histSize);

	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

	// 将直方图归一化到范围 [ 0, histImage.rows ]
	normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX);

	// 在直方图画布上画出直方图，3个直方图叠加在一起，用不同的颜色表示
	for (int i = 1; i &lt; histSize; i++)
	&#123;
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(r_hist.at&lt;float&gt;(i))),
			Scalar(0, 0, 255), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(g_hist.at&lt;float&gt;(i))),
			Scalar(0, 255, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(b_hist.at&lt;float&gt;(i))),
			Scalar(255, 0, 0), 2, 8, 0);
	&#125;

	// 显示直方图
	imshow(&quot;RGB彩色图像直方图&quot;, histImage);
	imwrite(&quot;./colorhist_for_beatuty_after_qualization.bmp&quot;, histImage);
	waitKey(0);
&#125;
</code></pre>
<p>③累计直方图</p>
<pre><code>//画累积直方图
void DrawAccumulateImgHist(const Mat &amp;srcImg)
&#123;
	if (1 != srcImg.channels())&#123;
		return;
	&#125;
	int channels = 0;
	Mat dstHist;
	int histSize[] = &#123; 256 &#125;;
	float midRanges[] = &#123; 0, 256 &#125;;
	const float *ranges[] = &#123; midRanges &#125;;
	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \
		1, histSize, ranges, true, true);
	//对直方图进行累积
	for (int i = 1; i &lt; dstHist.rows; i++)&#123;
		dstHist.at&lt;float&gt;(i) += dstHist.at&lt;float&gt;(i-1);
	&#125;
	//最终绘制的直方图图像，大小是256×256
	Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);
	double dblHistMaxValue;
	//求得直方图的最大值
	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);
	//将像素的个数整合到图像的最大范围内  
	for (int i = 0; i &lt; 256; i++)&#123;
		int value = cvRound(dstHist.at&lt;float&gt;(i)\
			* 255 / dblHistMaxValue);
		line(histImage, Point(i, histImage.rows - 1), \
			Point(i, histImage.rows - 1 - value), Scalar(255));
	&#125;
	imshow(&quot;累积直方图&quot;, histImage);
	imwrite(&quot;./accumlate.bmp&quot;, histImage);
&#125;
</code></pre>
<h2 id="七-图像分割"><a href="#七-图像分割" class="headerlink" title="七.图像分割"></a>七.图像分割</h2><h5 id="（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）"><a href="#（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）" class="headerlink" title="&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）"></a>&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</h5><h5 id="（几何形状检测【霍夫变换】：直线、圆）"><a href="#（几何形状检测【霍夫变换】：直线、圆）" class="headerlink" title="（几何形状检测【霍夫变换】：直线、圆）"></a>（几何形状检测【霍夫变换】：直线、圆）</h5><h5 id="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"><a href="#（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）" class="headerlink" title="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"></a>（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42061b3c66f846c840087275d00ada91.jpeg"></p>
<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e731b3257fee71a5ec24342e7b18efb.jpeg"><br>&lt;2&gt;示例代码</p>
<h6 id="1-霍夫直线变换和霍夫圆检测"><a href="#1-霍夫直线变换和霍夫圆检测" class="headerlink" title="1.霍夫直线变换和霍夫圆检测"></a>1.霍夫直线变换和霍夫圆检测</h6><pre><code>void DetectLines()
&#123;
	Mat matSrc = imread(&quot;Hough_src_clr.png&quot;, IMREAD_GRAYSCALE);
	Mat matEdge;
	//Canny算子计算图像边缘
	Canny(matSrc, matEdge, 250, 200, 3, false);
	imshow(&quot;原图像&quot;, matSrc);
	imshow(&quot;Canny边缘&quot;, matEdge);
	imwrite(&quot;hough_src_gray.bmp&quot;, matSrc);
	imwrite(&quot;hough_src_canny.bmp&quot;, matEdge);
	std::vector&lt;Vec2f&gt; linesSHT;
	//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300
	HoughLines(matEdge, linesSHT, 1, CV_PI / 180, 280);
	Mat matSHT = matSrc.clone();
	for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
		//直线的rho和theta值
		float rho = linesSHT[i][0], theta = linesSHT[i][1];
		//pt1和pt2是直线的两个端点
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a * rho, y0 = b * rho;
		pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
		pt1.y = cvRound(y0 + 2000 * (a));
		pt2.x = cvRound(x0 - 2000 * (-b));
		pt2.y = cvRound(y0 - 2000 * (a));
		line(matSHT, pt1, pt2, Scalar(255), 4);
	&#125;
	imshow(&quot;SHT直线检测结果&quot;, matSHT);
	imwrite(&quot;hough_Lines_SHT.bmp&quot;, matSHT);
	Mat matPPHT = matSrc.clone();
	std::vector&lt;Vec4i&gt; linesPPHT;
	//累计概率霍夫变换检测直线，得到的是直线的起止端点
	HoughLinesP(matEdge, linesPPHT, 1, CV_PI / 180, 280, 100, 50);
	for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
		//直接绘制直线
		line(matPPHT, Point(linesPPHT[i][0], linesPPHT[i][1]),
			Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);
	&#125;
	imshow(&quot;PPHT直线检测结果&quot;, matPPHT);
	imwrite(&quot;Hough_lines_PPHT.bmp&quot;, matPPHT);
	waitKey(0);
&#125;


void DetectCircles()
&#123;
	Mat src;
	src = imread(&quot;HoughCircles_src_clr.jpg&quot;, IMREAD_GRAYSCALE);
	//imwrite(&quot;HoughCircles_src_gray.bmp&quot;, src);
	vector&lt;Vec3f&gt; circles;
	HoughCircles(src, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);
	//在原图中画出圆心和圆  
	for (size_t i = 0; i &lt; circles.size(); i++)&#123;
		//提取出圆心坐标  
		Point center(round(circles[i][0]), round(circles[i][1]));
		//提取出圆半径  
		int radius = round(circles[i][2]);
		//圆心  
		circle(src, center, 3, Scalar(255), -1, 4, 0);
		//圆  
		circle(src, center, radius, Scalar(255), 3, 4, 0);
	&#125;
	//imwrite(&quot;HoughCircles_circles.bmp&quot;, src);
	imshow(&quot;Circle&quot;, src);
	waitKey(0);
&#125;
</code></pre>
<h6 id="2-OTSU方法和三角法求全局阈值"><a href="#2-OTSU方法和三角法求全局阈值" class="headerlink" title="2.OTSU方法和三角法求全局阈值"></a>2.OTSU方法和三角法求全局阈值</h6><pre><code>//OTSU方法求阈值
int OtsuBinary(Mat src)
&#123;
	long lPixCnt = src.rows * src.cols;
	long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);
			histogram[nCurVal]++;
		&#125;
	&#125;
	int nThreshold = 0;
	long sum0 = 0, sum1 = 0; //存储前景的灰度总和和背景灰度总和  
	long cnt0 = 0, cnt1 = 0; //前景像素总个数和背景像素总个数  
	double w0 = 0, w1 = 0; //前景和背景所占整幅图像的比例  
	double u0 = 0, u1 = 0;  //前景和背景的平均灰度  
	double variance = 0; //类间方差  
	double maxVariance = 0; //用来存储最大类间方差
	for (int i = 1; i &lt; 256; i++) //遍历所有灰度级别
	&#123;
		sum0 = 0;    cnt0 = 0;  w0 = 0;
		sum1 = 0;    cnt1 = 0;  w1 = 0;
		for (int j = 0; j &lt; i; j++) &#123;
			cnt0 += histogram[j]; //前景像素总和
			sum0 += j * histogram[j]; //前景灰度值总和
		&#125;
		//前景部分灰度均值
		u0 = cnt0 &gt; 0 ? double(sum0) / cnt0 : 0;
		w0 = (double)cnt0 / lPixCnt; //前景部分所占的比例
		for (int j = i; j &lt;= 255; j++) &#123;
			cnt1 += histogram[j]; //背景像素个数
			sum1 += j * histogram[j]; //背景部分灰度值总和
		&#125;
		//背景部分灰度均值
		u1 = cnt1 &gt; 0 ? double(sum1) / cnt1 : 0;
		w1 = 1 - w0;  //背景部分所占的比例
		//分割阈值为i时的类间方差
		variance = w0 * w1 * (u0 - u1) * (u0 - u1);
		if (variance &gt; maxVariance) &#123;
			maxVariance = variance;
			nThreshold = i;
		&#125;
	&#125;

	return nThreshold;
&#125;

//三角法求阈值
int TriangleBinary(Mat src)
&#123;
	long lPixCnt = src.rows * src.cols;
	long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);
			histogram[nCurVal]++;
		&#125;
	&#125;

	//左右边界
	int left_bound = 0, right_bound = 0;
	//直方图最高峰和相应的灰度值
	int max_ind = 0, maxPeak = 0;
	int temp;
	bool isflipped = false;

	// 找到最左边零的位置
	for (int i = 0; i &lt; 256; i++) &#123;
		if (histogram[i] &gt; 0) &#123;
			left_bound = i;
			break;
		&#125;
	&#125;
	//位置再移动一个步长，即为最左侧零位置 
	if (left_bound &gt; 0)
		left_bound--;

	// 找到最右边零点位置
	for (int i = 255; i &gt; 0; i--) &#123;
		if (histogram[i] &gt; 0) &#123;
			right_bound = i;
			break;
		&#125;
	&#125;
	// 位置再移动一个步长，即为最右侧零位置 
	if (right_bound &lt; 255)
		right_bound++;

	// 在直方图上寻找最亮的点Hmax
	for (int i = 0; i &lt; 256; i++) &#123;
		if (histogram[i] &gt; maxPeak) &#123;
			maxPeak = histogram[i];
			max_ind = i;
		&#125;
	&#125;

	// 如果最大值落在靠左侧这样就无法满足三角法求阈值，
	 //所以要检测是否最大值是否靠近左侧
	// 如果靠近左侧则通过翻转到右侧位置。
	if (max_ind - left_bound &lt; right_bound - max_ind) &#123;
		isflipped = true;
		int i = 0;
		int j = 255;
		// 左右交换
		while (i &lt; j) &#123;
			temp = histogram[i]; histogram[i] = histogram[j]; histogram[j] = temp;
			i++; j--;
		&#125;
		left_bound = 255 - right_bound;
		max_ind = 255 - max_ind;
	&#125;

	// 计算求得阈值
	double thresh = left_bound;
	double maxDist = 0, tempDist;
	double peakIdxBound = left_bound - max_ind;
	for (int i = left_bound + 1; i &lt;= max_ind; i++)
	&#123;
		// 计算距离
		tempDist = maxPeak * i + peakIdxBound * histogram[i];
		if (tempDist &gt; maxDist) &#123;
			maxDist = tempDist;
			thresh = i;
		&#125;
	&#125;
	thresh--;
	if (isflipped) &#123;
		thresh = 255 - thresh;
	&#125;

	return thresh;
&#125;

//手动二值化处理
Mat Binbary(Mat src, int nThreshold)
&#123;
	//遍历每个像素，对图像进行二值化
	Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC1);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			if (src.at&lt;uchar&gt;(i, j) &gt; nThreshold)
				dst.at&lt;uchar&gt;(i, j) = 255;
		&#125;
	&#125;
	return dst;
&#125;
</code></pre>
<p>*<strong>注：</strong></p>
<p><strong>①二值化的原图都是灰度图，产生灰度图方法见后</strong></p>
<p><strong>②对于固定场景摄像头读取图像可以先调用以上函数求出全局阈值，之后使用cv::threshold()函数时直接调用该阈值，减少每帧计算阈值时间</strong></p>
<h5 id="练手"><a href="#练手" class="headerlink" title="&lt;3&gt;练手"></a>&lt;3&gt;练手</h5><h6 id="1-边缘检测二阶导数算子使用"><a href="#1-边缘检测二阶导数算子使用" class="headerlink" title="1.边缘检测二阶导数算子使用"></a>1.边缘检测二阶导数算子使用</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

#define IMAGE_TEST

#ifdef IMAGE_TEST
const char* filepath = &quot;./Test.jpg&quot;;
Mat img = imread(filepath, IMREAD_COLOR);
Mat draw_board = img.clone();					//图片拷贝以实现清除
#endif
#ifdef CAMERA_TEST
VideoCapture capture(0);
Mat image;
#endif // CAMERA_TEST


int main()
&#123;
	void changing(void);
	changing();
&#125;

//拉普拉斯高通滤波
void changing(void)
&#123;
	Mat LoG_Image(const Mat &amp; image, int kervalue = 3, double sigma = 1.0f);

#ifdef IMAGE_TEST
	Mat image = imread(filepath, IMREAD_COLOR);
	if (image.empty()) &#123;
		std::cout &lt;&lt; &quot;打开图片失败,请检查&quot; &lt;&lt; std::endl;
		return;
	&#125;
	imshow(&quot;原图像&quot;, image);
	Mat matDst;
//	Laplacian(image, matDst, image.depth(), 5);     //拉普拉斯算子
//	matDst = LoG_Image(image, 3, 1.0f);				//LOG算子
	Canny(image, matDst, 80, 150, 3, false);		//canny算子
	imwrite(&quot;changing.bmp&quot;, matDst);
	imshow(&quot;变换效果&quot;, matDst);
	waitKey(0);
#endif
#ifdef CAMERA_TEST
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matDst;
//		Laplacian(image, matDst, image.depth(), 5);		//拉普拉斯算子
//		matDst = LoG_Image(image, 3, 1.0f);				//LOG算子
		Canny(image, matDst, 100, 500, 3, false);		//canny算子
		imshow(&quot;变换效果&quot;, matDst);
		if (waitKey(1) == 27)break;
	&#125;
#endif
&#125;

//图像LoG算子运算
Mat LoG_Image(const Mat&amp; image, int kervalue = 3, double sigma = 1.0f)
&#123;
	//首先对图像做高斯平滑
	Mat matTemp;
	GaussianBlur(image, matTemp, Size(kervalue, kervalue), sigma, sigma, BORDER_DEFAULT);
	//通过拉普拉斯算子做边缘检测
	Mat laplacian = Mat::zeros(image.rows, image.cols, CV_32FC1);
	Laplacian(matTemp, laplacian, CV_32FC1, 3);
	//求得最大边缘值
	double dblMaxVal = 0;
	minMaxLoc(laplacian, NULL, &amp;dblMaxVal);
	Mat dstImg;
	convertScaleAbs(laplacian, dstImg);
	imwrite(&quot;edge.bmp&quot;, dstImg);
	Mat result = Mat::zeros(image.rows, image.cols, CV_8UC1);
	//过零点交叉，寻找边缘像素
	for (int i = 1; i &lt; result.rows - 1; i++) &#123;
		for (int j = 1; j &lt; result.cols - 1; j++) &#123;
			if (laplacian.at&lt;float&gt;(i, j) &lt; 0.1 * dblMaxVal) &#123;
				continue;
			&#125;
			//水平、垂直、45度方向，135度4个方向过零点判定
			if (laplacian.at&lt;float&gt;(i - 1, j) \
				* laplacian.at&lt;float&gt;(i + 1, j) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i, j + 1) \
				* laplacian.at&lt;float&gt;(i, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i + 1, j + 1) \
				* laplacian.at&lt;float&gt;(i - 1, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i - 1, j + 1) \
				* laplacian.at&lt;float&gt;(i + 1, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
		&#125;
	&#125;
	return result;
&#125;

//Canny算子计算图像的梯度和方向
void CannyEdgeAndDirection(const Mat&amp; src)
&#123;
	Mat magX = Mat(src.rows, src.cols, CV_32FC1);
	Mat magY = Mat(src.rows, src.cols, CV_32FC1);
	Mat slopes = Mat(src.rows, src.cols, CV_32FC1);
	Sobel(src, magX, CV_32FC1, 1, 0, 3);//水平梯度
	Sobel(src, magY, CV_32FC1, 1, 0, 3);//垂直梯度
	//梯度方向
	divide(magY, magX, slopes);
	//梯度幅值
	Mat magnitude;
	sqrt(magX * magX + magY * magY, magnitude);
&#125;
</code></pre>
<h6 id="2-霍夫直线变换及霍夫圆的检测"><a href="#2-霍夫直线变换及霍夫圆的检测" class="headerlink" title="2.霍夫直线变换及霍夫圆的检测"></a>2.霍夫直线变换及霍夫圆的检测</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

VideoCapture capture(0);
Mat image;

//#define SHT	//SHT检测直线
//#define PPHT	//PPHT检测直线
#define HCD		//霍夫圆检测

int main()
&#123;
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matCanny;
		Mat matDst;
		Canny(image, matCanny, 100, 300, 3, false);		//canny算子

#ifdef SHT
		std::vector&lt;Vec2f&gt; linesSHT;
		//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300
		HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 280);
		//直线在原图上绘制
		matDst = image.clone();
		for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
			//直线的rho和theta值
			float rho = linesSHT[i][0], theta = linesSHT[i][1];
			//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）
			Point pt1, pt2;
			double a = cos(theta), b = sin(theta);
			double x0 = a * rho, y0 = b * rho;
			pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
			pt1.y = cvRound(y0 + 2000 * (a));
			pt2.x = cvRound(x0 - 2000 * (-b));
			pt2.y = cvRound(y0 - 2000 * (a));
			line(matDst, pt1, pt2, Scalar(255), 4);
		&#125;
#endif // SHT标准霍夫变换

#ifdef PPHT
		matDst = image.clone();
		std::vector&lt;Vec4i&gt; linesPPHT;
		//累计概率霍夫变换检测直线，得到的是直线的起止端点
		HoughLinesP(matCanny, linesPPHT, 1, CV_PI / 180, 220, 100, 50);
		for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
			//直接绘制直线
			line(matDst, Point(linesPPHT[i][0], linesPPHT[i][1]),
				Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);
		&#125;
#endif // PPHT累计概率霍夫变换

#ifdef HCD
		cvtColor(image, matDst, COLOR_BGR2GRAY);
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matDst, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(matDst, center, 3, Scalar(255), -1, 4, 0);
			//圆  
			circle(matDst, center, radius, Scalar(255), 3, 4, 0);
		&#125;
#endif // HCD霍夫圆检测


		imshow(&quot;检测结果&quot;, matDst);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<h6 id="3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"><a href="#3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）" class="headerlink" title="3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"></a>3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</h6><p>参数见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12333022.html" title="opencv ——
HoughCircles 霍夫圆变换原理及圆检测">opencv —— HoughCircles<br>霍夫圆变换原理及圆检测</a></p>
<p>二值化函数threshold参数：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012566751/article/details/77046445" title="OpenCV基础——threshold函数的使用">OpenCV基础——threshold函数的使用</a></p>
<pre><code>#include &quot;opencv2/opencv.hpp&quot;
#include &quot;opencv2/highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;

VideoCapture capture(0);
Mat image;

const char* windowname=&quot;win&quot;;
int max_r=100;
int min_r=60;
int min_d=80;
int t_hold=45;
int param1=100;
int param2=10;
const int t_max=255;
const int r_max=1000;
const int d_max=100;
const int p1_max=200;
const int p2_max=200;

int main()
&#123;

    void on_Trackbar_1(int, void*);
    void on_Trackbar_2(int, void*);
    void on_Trackbar_3(int, void*);
    void on_Trackbar_4(int, void*);
    void on_Trackbar_5(int, void*);
    void on_Trackbar_6(int, void*);
    namedWindow(windowname,0);
    setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
    resizeWindow(windowname, 400, 300);
    moveWindow(windowname, 0, 0);
    createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);
    createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);
    createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);
    createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);
    createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);
    createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);

	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matCanny;
        Mat BinImg;
        Mat matDst;
        cvtColor(image, matDst, COLOR_BGR2GRAY);
		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV);
        Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
        
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

        imshow(&quot;matCanny&quot;, matCanny);
        imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;
&#125;


void on_Trackbar_1(int, void*)
&#123;
    ;
&#125;


void on_Trackbar_2(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_3(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_4(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_5(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_6(int, void*)
&#123;
    ;
&#125;
</code></pre>
<p>注：OpenCV提供的SHT输出极坐标下直线的rho和theta值，需根据经验值推算该直线上的两点以绘图；而PPHT直接返回线段两端两点坐标</p>
<p>*注：图像灰度化的方法：可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36853469/article/details/106416128" title="OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客">OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客</a></p>
<h6 id="4-阈值分割（OTSU-三角法-自适应阈值）"><a href="#4-阈值分割（OTSU-三角法-自适应阈值）" class="headerlink" title="4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）"></a>4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</h6><pre><code>#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

VideoCapture capture(0);
Mat image;

int main()
&#123;
	int OtsuBinary(Mat src);
	int TriangleBinary(Mat src);
	Mat gray, dst;

	capture &gt;&gt; image;
	cvtColor(image, gray, COLOR_BGR2GRAY);
	int nThreshold = OtsuBinary(gray);
//	int nThreshold = TriangleBinary(gray);
	
	while(capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		cvtColor(image, gray, COLOR_BGR2GRAY);

		//用OTSU方法
//		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);
//		threshold(gray, dst, 0, 255, THRESH_BINARY | THRESH_OTSU);
		//用三角法
//		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);
//		threshold(gray, dst, 0, 255, THRESH_BINARY|THRESH_TRIANGLE);
		//自适应阈值
		adaptiveThreshold(gray, dst, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 7, 5);

		imshow(&quot;BinbaryImage&quot;, dst);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<p>*<strong>注：自适应阈值保留信息更多，注意使用场合</strong></p>
<h6 id="5-识别车道（二值化、边缘检测、霍夫直线变换）"><a href="#5-识别车道（二值化、边缘检测、霍夫直线变换）" class="headerlink" title="5.识别车道（二值化、边缘检测、霍夫直线变换）"></a><strong>5.识别车道（二值化、边缘检测、霍夫直线变换）</strong></h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

int main() &#123;
	Mat image = imread(&quot;car_track.jpg&quot;, IMREAD_GRAYSCALE);
	Mat BinImg;
	threshold(image, BinImg, 150, 255, THRESH_BINARY);
	imwrite(&quot;BinImg.jpg&quot;, BinImg);
	Mat matCanny;
	Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
	imwrite(&quot;CannyImg.jpg&quot;, matCanny);
	Mat matDst = image.clone();

	std::vector&lt;Vec2f&gt; linesSHT;
	//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为100
	HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 100);
	//直线在原图上绘制
	matDst = image.clone();
	for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
		//直线的rho和theta值
		float rho = linesSHT[i][0], theta = linesSHT[i][1];
		//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a * rho, y0 = b * rho;
		pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
		pt1.y = cvRound(y0 + 2000 * (a));
		pt2.x = cvRound(x0 - 2000 * (-b));
		pt2.y = cvRound(y0 - 2000 * (a));
		line(matDst, pt1, pt2, Scalar(255), 8);
	&#125;

	imshow(&quot;car_track&quot;, matDst);
	waitKey(0);
	imwrite(&quot;car_track_show.jpg&quot;, matDst);
&#125;
</code></pre>
<p>处理结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f19fbe807f911ee210017b64ea64ea.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/699cf9a73e9c5db8f5837d0018fe3604.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/4fa8e85338396b037d05b85d40503c9d.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/a35992394ee154df3670b102dfe9543c.jpeg"></p>
<h2 id="九-特征提取和目标检测"><a href="#九-特征提取和目标检测" class="headerlink" title="九.特征提取和目标检测"></a>九.特征提取和目标检测</h2><h5 id="（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）"><a href="#（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）" class="headerlink" title="&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）"></a>&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd37be7931389615cbb559ae52a7a7ff.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/70661001c310f47939567a8a92d0512d.jpeg"></p>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-HOG特征提取-SVM"><a href="#1-HOG特征提取-SVM" class="headerlink" title="1.HOG特征提取+SVM"></a>1.HOG特征提取+SVM</h6><pre><code>//SVM参考代码

#include &quot;pch.h&quot;
#include &lt;iostream&gt;	
#include &lt;fstream&gt;
#include &lt;windows.h&gt;
//#include &lt;afxwin.h&gt;

#include &lt;stack&gt;
#include &quot;opencv.hpp&quot;
using namespace cv;
using namespace std;
using namespace cv::ml;

#ifdef _DEBUG
#pragma comment(lib, &quot;opencv_world480d.lib&quot;)
#else
#pragma comment(lib, &quot;opencv_world480.lib&quot;)
#endif

//************************************
const char* file_path = &quot;E:/测试视频数据/Video_2016_8_26__10_10_48.mp4&quot;;
//************************************

vector&lt; float &gt; get_svm_detector(const Ptr&lt; SVM &gt;&amp; svm)
&#123;
	//得到支持向量
	Mat sv = svm-&gt;getSupportVectors();
	const int sv_total = sv.rows;
	//得到支持向量对应的系数值
	Mat alpha, svidx;
	double rho = svm-&gt;getDecisionFunction(0, alpha, svidx);

	CV_Assert(alpha.total() == 1 &amp;&amp; svidx.total() == 1 &amp;&amp; sv_total == 1);
	CV_Assert((alpha.type() == CV_64F &amp;&amp; alpha.at&lt;double&gt;(0) == 1.) ||
		(alpha.type() == CV_32F &amp;&amp; alpha.at&lt;float&gt;(0) == 1.f));
	CV_Assert(sv.type() == CV_32F);
	//将支持向量的值写入一个vector返回
	vector&lt; float &gt; hog_detector(sv.cols + 1);
	memcpy(&amp;hog_detector[0], sv.ptr(), sv.cols * sizeof(hog_detector[0]));
	hog_detector[sv.cols] = (float)-rho;
	return hog_detector;
&#125;

//sampleMat是采样矩阵,labelMat是类别矩阵,nCurRows当前是矩阵的行数
//提取正样本HOG特征
void PosData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;pos_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat imgSrc = imread(files[i], IMREAD_GRAYSCALE); //加载图像
		if (imgSrc.empty()) &#123;
			cout &lt;&lt; files[i] &lt;&lt; &quot; is invalid!&quot; &lt;&lt; endl;
			continue;
		&#125;
		Mat imgDst;
		resize(imgSrc, imgDst, hog.winSize); //将正例缩放到检测窗口大小
		vector&lt;float&gt; featureVec;
		hog.compute(imgDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(+1); //正样本类别为+1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

//提取负样本HOG特征
void NegData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;neg_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	Rect box;
	box.width = hog.winSize.width;
	box.height = hog.winSize.height;
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat img = imread(files[i], IMREAD_GRAYSCALE);
		if (img.empty()) &#123;
			continue;
		&#125;
		Mat matDst;
		if (img.cols &lt;= hog.winSize.width + 1 || img.rows &lt;= hog.winSize.height + 1) &#123;
			//cout &lt;&lt; &quot;image too small&quot; &lt;&lt; endl;
			resize(img, matDst, hog.winSize);
		&#125;
		else &#123;
			//随机选择窗口位置
			box.x = rand() % (img.cols - box.width);
			box.y = rand() % (img.rows - box.height);
			matDst = img(box);
		&#125;

		vector&lt;float&gt; featureVec;
		hog.compute(matDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(-1);//负样本类别为-1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

void TrainSVMModel()
&#123;
	//车牌检测window大小为128X48,block大小为16X16,cell大小为8X8，滑动窗口大小为8X8
	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), cv::Size(8, 8), 9);
	int nVecLen = hog.getDescriptorSize();
	//样本的特征向量，行数等于正负样本个数，列数等于HOG特征向量长度
	Mat sampleFeatureMat = Mat::zeros(9689, nVecLen, CV_32FC1);
	//样本的类别向量，行数等于所有样本的个数，列数等于1；1表示正样本，-1表示负样本
	vector&lt;int&gt; Labels;
	int nRowIdx = 0;
	PosData(hog, sampleFeatureMat, Labels, nRowIdx);
	NegData(hog, sampleFeatureMat, Labels, nRowIdx);


	Ptr&lt;SVM&gt; svm = SVM::create(); //创建一个SVM分类器
	svm-&gt;setCoef0(0.0);
	svm-&gt;setDegree(3);
	svm-&gt;setGamma(0);
	svm-&gt;setKernel(SVM::LINEAR);
	svm-&gt;setNu(0.5);
	svm-&gt;setP(0.1);
	svm-&gt;setC(0.01);
	svm-&gt;setType(SVM::EPS_SVR); //分类器类型为EPS_SVR
	//************************************
	//训练结束条件：要么达到1000次，要么两次误差小于1e-3
	svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 1e-3));
	//************************************
	svm-&gt;train(sampleFeatureMat, ROW_SAMPLE, Labels);

	//svm-&gt;trainAuto();
	//直接将支持向量系数写入文本文件，以方便在检测器的头文件中导入
	vector&lt;float&gt; vecHogCof = get_svm_detector(svm);
	//************************************
	//支持向量结果保存
	ofstream file(&quot;dector.txt&quot;);	
	//************************************
	for (int i = 0; i &lt; vecHogCof.size(); i++) &#123;
		file &lt;&lt; vecHogCof[i] &lt;&lt; &quot;,&quot;;
	&#125;
	file.close();
&#125;


void TestSVMModel()
&#123;
	//************************************
	//SVM检测器系数向量都放在hogCof数组中(detect.txt中内容，模型建立好后可直接调用)
	float hogCof[] = &#123;......&#125;;
	//************************************
	
	//创建HOG检测器，参数与训练时的参数相同
	//在这里特别注意将nLevels参数从默认64修改为4，可以加快检测速度
	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), \
		cv::Size(8, 8), 9, 1, -1.0, HOGDescriptor::L2Hys, 0.2, false, 4);
	const int vecLen = sizeof(hogCof) / sizeof(float);
	vector&lt;float&gt; vecHogCof(hogCof, hogCof + vecLen);
	hog.setSVMDetector(vecHogCof); //设置HOG检测器的系数

	//打开一个视频文件
	VideoCapture cap;
	cap.open(file_path);
	if (!cap.isOpened()) &#123;
		return;
	&#125;
	Mat frame;
	int nFrmIdx = 0;
	while (true) &#123;
		cap &gt;&gt; frame;
		if (frame.empty()) &#123;
			break;
		&#125;
		vector&lt;Rect&gt; detections; //检测到目标矩形位置
		vector&lt;double&gt; foundWeights; //检测到的权重
		hog.detectMultiScale(frame, detections, foundWeights, 0.5, Size(8, 8), Size(0, 0), 1.1, 3.0, false);
		for (int i = 0; i &lt; detections.size(); i++) &#123;
			if (frame.rows - detections[i].y &lt; 200)
				continue;
			rectangle(frame, detections[i], Scalar(0, 0, 255), 4);
		&#125;
		imshow(&quot;LP HOG Detection&quot;, frame);
		if (detections.size() &gt; 0) &#123;
			char szFileName[100] = &#123; 0 &#125;;
			sprintf_s(szFileName, &quot;%03d.jpg&quot;, nFrmIdx++);
			imwrite(szFileName, frame);
		&#125;

		waitKey(40);
	&#125;
&#125;

int mian()
&#123;
	TestSVMModel();
&#125;
</code></pre>
<p>注：</p>
<p>①.&#x2F;&#x2F;*…*之间的是copy代码时要修改的地方</p>
<p>②.void TrainSVMModel()求出支持向量系数，保存在文件中，之后可以直接复制其中数值以调用</p>
<h6 id="2-获取LBP-MB-LBP特征函数"><a href="#2-获取LBP-MB-LBP特征函数" class="headerlink" title="2.获取LBP&#x2F;MB-LBP特征函数"></a>2.获取LBP&#x2F;MB-LBP特征函数</h6><pre><code>//使用函数模板，保证函数对所有类型图像都适用
//_tp参数可以是uchar,float等
template &lt;typename _tp&gt;
//原始LBP特征
void getOriginLBPFeature(InputArray _src, OutputArray _dst)
&#123;
	Mat src = _src.getMat();
	Mat srcExtented;
	//对图像边界进行扩充，边界像素采用复制的形式
	copyMakeBorder(src, srcExtented, 1, 1, 1, 1, BORDER_REPLICATE);
	//输出图像与原图像大小相同
	_dst.create(src.rows, src.cols, CV_8UC1);
	Mat dst = _dst.getMat();
	dst.setTo(0);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			//中心像素的值
			_tp center = srcExtented.at&lt;_tp&gt;(i + 1, j + 1);
			unsigned char lbpCode = 0; //LBP编码值
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j) &gt; center) &lt;&lt; 7; //左上角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 1) &gt; center) &lt;&lt; 6; //上边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 2) &gt; center) &lt;&lt; 5; //右上角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j + 2) &gt; center) &lt;&lt; 4; //右边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 2) &gt; center) &lt;&lt; 3; //右下角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 1) &gt; center) &lt;&lt; 2; //下边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j) &gt; center) &lt;&lt; 1; //左下角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j) &gt; center) &lt;&lt; 0; //左边
			dst.at&lt;uchar&gt;(i, j) = lbpCode;
		&#125;
	&#125;
&#125;

//MB-LBP特征
void getMultiScaleBlockLBPFeature(InputArray _src, OutputArray _dst, int scale)
&#123;
	Mat src = _src.getMat();
	int cellSize = scale / 3;
	int offset = cellSize / 2;
	Mat srcExtented;
	//图像扩大一圈
	copyMakeBorder(src, srcExtented, offset, offset, offset, offset, BORDER_REFLECT);
	//以当前点为中心，计算每个cell的像素均值
	Mat cellImage(src.rows, src.cols, CV_8UC1);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			int temp = 0;
			for (int m = -offset; m &lt; offset + 1; m++) &#123;
				for (int n = -offset; n &lt; offset + 1; n++) &#123;
					temp += srcExtented.at&lt;uchar&gt;(i + n + offset, j + m + offset);
				&#125;
			&#125;
			temp /= (cellSize * cellSize);
			cellImage.at&lt;uchar&gt;(i, j) = uchar(temp);
		&#125;
	&#125;
	getOriginLBPFeature&lt;uchar&gt;(cellImage, _dst);
&#125;
</code></pre>
<h6 id="3-cascade级联分类器使用"><a href="#3-cascade级联分类器使用" class="headerlink" title="3.cascade级联分类器使用"></a>3.cascade级联分类器使用</h6><pre><code>//级联分类器实现人脸检测
void DetectFaces()
&#123;
	//创建一个级联分类器对象，并加载分类器文件
	//CascadeClassifier faceDetector(&quot;haarcascade_frontalface_alt2.xml&quot;);
	CascadeClassifier faceDetector(&quot;cascade.xml&quot;);
	if (faceDetector.empty()) &#123;
		return;
	&#125;
	VideoCapture cap(0); //打开USB摄像头
	if (!cap.isOpened()) &#123;
		return;
	&#125;
	Mat frame;
	while (true) &#123;
		cap &gt;&gt; frame; //从摄像头获取一帧图像
		if (frame.empty())
			break;
		std::vector&lt;cv::Rect&gt; objects;
		//使用级联分类器检测人脸
		faceDetector.detectMultiScale(frame, objects);
		//对人脸图像进行标记
		for (int i = 0; i &lt; objects.size(); i++) &#123;
			static int nIdx = 0;
			char szFileName[100] = &#123; 0 &#125;;
			sprintf_s(szFileName, &quot;detectedHeadShoulder/%03d.jpg&quot;, nIdx++);
			//sprintf_s(szFileName, &quot;DetetecdFaces/%03d.jpg&quot;, nIdx++);
			cv::rectangle(frame, objects[i], Scalar(0, 0, 255), 4);
			imwrite(szFileName, frame);
		&#125;
		imshow(&quot;人脸检测结果&quot;, frame); //显示人脸检测结果

		if (waitKey(25) == 27) //暂停25ms，如果按ESC键则退出
			break;
	&#125;
	cap.release(); //释放摄像头对象
	return;
&#125;
</code></pre>
<p>注：分类器文件生成使用opencv_traincacade.exe；创建正样本.vec文件使用opencv_creatsamples.exe；可视化过程使用opencv_visualisation.exe</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797">https://blog.csdn.net/qq_32971095/article/details/131609797</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/HDL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:34" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>542</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E6%A6%82%E8%BF%B0">一.Verilog概述</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%85%B7%E4%BD%93%E8%AF%AD%E6%B3%95">二.Verilog具体语法</a></p>
<p><a href="about:blank#1.%E6%A0%87%E8%AF%86">1.标识</a></p>
<p><a href="about:blank#2.%E9%80%BB%E8%BE%91%E5%80%BC">2.逻辑值</a></p>
<p><a href="about:blank#3.%E5%B8%B8%E9%87%8F">3.常量</a></p>
<p><a href="about:blank#4.%E5%8F%98%E9%87%8F">4.变量</a></p>
<p><a href="about:blank#5.%E5%8F%82%E6%95%B0">5.参数</a></p>
<p><a href="about:blank#6.%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">6.赋值语句</a></p>
<p><a href="about:blank#7.%E8%BF%90%E7%AE%97%E7%AC%A6">7.运算符</a></p>
<p><a href="about:blank#8.%E8%AF%AD%E5%8F%A5">8.语句</a></p>
<p><a href="about:blank#9.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">9.系统函数</a></p>
<hr>
<p>参考书目：《野火FPGA Verilog 开发实战指南》</p>
<h2 id="一-Verilog概述"><a href="#一-Verilog概述" class="headerlink" title="一.Verilog概述"></a>一.Verilog概述</h2><p>1.IEEE定义标准Verilog语法参考文档</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/1620780" title="IEEE Standard for Verilog Hardware Description
Language">IEEE Standard for Verilog Hardware Description Language<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://ieeexplore.ieee.org/document/1620780</a><img src="https://i-blog.csdnimg.cn/blog_migrate/f28180bb6ad7d5e7cf2d0be08bed5b87.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42b3b557654abe4183f82a59a0ba6d84.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/83f261e770d0298d5b3c99ef2a82a1af.png"></p>
<h2 id="二-Verilog具体语法"><a href="#二-Verilog具体语法" class="headerlink" title="二.Verilog具体语法"></a>二.Verilog具体语法</h2><p>**  KEY WORD：标识符、逻辑值、常量、变量、参数、赋值语句、注释、运算符、语句、系统函数**</p>
<h3 id="1-标识"><a href="#1-标识" class="headerlink" title="1.标识"></a>1.标识</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5faa8d75ee441d53d178a116fc8754d8.png"></p>
<h3 id="2-逻辑值"><a href="#2-逻辑值" class="headerlink" title="2.逻辑值"></a>2.逻辑值</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90dc5515dae6c757c524019fa8383c66.png"></p>
<h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcf1e8adfc490d537036a7ab48c212e7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/019cf81e0945052440e899cf52edd6cb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d078c9fd4a40ce4295d4b0744c878321.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18d269aa4707511f0473895823444f06.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb92bfc53bec3fd438009b3ae9a773f.png"></p>
<h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d098bdb00c939fa2dcf3efe1100fb3b.png"></p>
<h3 id="5-参数"><a href="#5-参数" class="headerlink" title="5.参数"></a>5.参数</h3><p>有parameter和localparam两种，前者可以通过实例化在model外部改变</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bf3c357e7436845ff568400d9196dc4e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3be814a053d3080ca8ca49ad54ab5a65.png"></p>
<h3 id="6-赋值语句"><a href="#6-赋值语句" class="headerlink" title="6.赋值语句"></a>6.赋值语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39d62da1b54d44b352732de96396a766.png"></p>
<h3 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edd387a12d3e04f5571e0679c848aebb.png"></p>
<p> 注:^异或运算</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3c0a5e86253afeb65e89f7f4e001e28c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/908f2d529d157eac38981769103cf85a.png"></p>
<h3 id="8-语句"><a href="#8-语句" class="headerlink" title="8.语句"></a>8.语句</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/efec5da318903ecd4b9ebe1870d3c8db.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2fbf03e1dc5171c9a448486ed7563340.png"></p>
<h3 id="9-系统函数"><a href="#9-系统函数" class="headerlink" title="9.系统函数"></a>9.系统函数</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1b041ff1b50feb52ba7288198de8082.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca2d1eaf85929c7ff512190c9a77271.png"></p>
<p> wirte与display区别：不自动换行</p>
<p>strobe：最后执行<img src="https://i-blog.csdnimg.cn/blog_migrate/fac806b50bdd1a8089f129b7e824e507.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4be67eab72d8fffa966896974f67a64.png"></p>
<p>monitor：当变量变化时打印</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb492cf19fd7d3df4ad2a237caf4ee09.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87b31817095385274983dbecfcaab5d1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/71bdc0b1d1cd629da73bac8834b0c764.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4b45c51ab3699a795f370bf588fd3e7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/367dd47eb20337132f7bf1dd5641e3f1.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6e281793195ce7abdddbcbc97812adb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21be8673f8f0217c17967439be42ccdd.png"></p>
<p>注：a是位宽为8bit，深度为20的存储器；reg [7:0]是一个变量类型</p>
<p>三.VHDL概述</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209">https://blog.csdn.net/qq_32971095/article/details/132308209</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fab fa-csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">698k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
