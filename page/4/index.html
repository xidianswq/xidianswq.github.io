<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:50" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><strong>FreeRTOS学习笔记</strong></strong></p>
<p><strong><strong>第一天摘要：</strong></strong></p>
<p>Key：</p>
<p>移植方法，TCB的结构及创建,任务栈，列表和列表项定义及相关函数</p>
<p>实践：rtos移植执行led闪烁</p>
<p>注意点：keil下载device要正确；内存不够删去不需要的heap.c及其他内 核等多余文件（MemMang,RVDS）</p>
<p>代码风格：</p>
<p>FreeRTOS 中详细的数据类型重定义在 portmacro.h 这个头文件中实现，具体 如下</p>
<p>1.2.4.2 变量名 在 FreeRTOS 中，定义变量的时候往往会把变量的类型当作前缀加在变量上，<br>这样的好处是让用户一看到这个变量就知道该变量的类型。比如 char 型变量的 10 前缀是 c，short 型变量的前缀是 s，long 型变量的前缀是<br>l，portBASE_TYPE 类 型变量的前缀是 x。还有其他的数据类型，比如数据结构，任务句柄，队列句柄 等定义的变量名的前缀也是 x。<br>如果一个变量是无符号型的那么会有一个前缀 u，如果是一个指针变量则会 有一个前缀 p。因此，当我们定义一个无符号的 char 型变量的时候会加一个 uc<br>前缀，当定义一个 char 型的指针变量的时候会有一个 pc 前缀。 1.2.4.3 函数名<br>函数名包含了函数返回值的类型、函数所在的文件名和函数的功能，如果是 私有的函数则会加一个 prv（private）的前缀。特别的，在函数名中加入了函<br>数所在的文件名，这极大的帮助了用户提高寻找函数定义的效率和了解函数作用 的目的，具体的举例如下： ①vTaskPrioritySet()函数的返回值为<br>void 型，在 task.c 这个文件中定 义。 ②xQueueReceive()函数的返回值为 portBASE_TYPE 型，在 queue.c 这个<br>文件中定义。 ③vSemaphoreCreateBinary()函数的返回值为 void 型，在 semphr.h 这个 文件中定义。</p>
<p><strong><strong>移植：</strong></strong></p>
<p>FreeRTOSConfig.h 是直接从 demo 文件夹下面拷贝过来的，该头文件对裁 剪整个 FreeRTOS<br>所需的功能的宏均做了定义，有些宏定义被使能，有些宏定义 被失能，一开始我们只需要配置最简单的功能即可。要想随心所欲的配置 FreeRTOS<br>的功能，我们必须对这些宏定义的功能有所掌握，下面我们先简单的 介绍下这些宏定义的含义，然后再对这些宏定义进行修改。 注意：此<br>FreeRTOSConfig.h 文件内容与我们从 demo 移植过来的 FreeRTOSConfig.h 文件不一样，因为这是我们修改过的<br>FreeRTOSConfig.h 文 件，并不会影响 FreeRTOS 的功能，我们只是添加了一些中文注释，并且把相关<br>的头文件进行分类，方便查找宏定义以及阅读，仅此而已。强烈建议使用我们修 加工过的 FreeRTOSConfig.h 文件。若你在移植时直接使用我们工程中<br>FreeRTOSConfig.h 文件，编译会出现报错，因为里面 PendSV_Handler 和 SVC_Handler 函数重定义，需在<br>stm32f10x_it.c 文件中注释掉这两个函数方可， 后面会有讲解，此处先略过</p>
<p>还需要注意的是：中断优先级 0（具有最高的逻辑优先级）不能被 basepri<br>寄存器屏蔽，因此，configMAX_SYSCALL_INTERRUPT_PRIORITY 绝不可以设置成 0。</p>
<p>修改 stm32f10x_it.c 文件 SysTick 中断服务函数是一个非常重要的函数，FreeRTOS 所有跟时间相关的<br>事情都在里面处理，SysTick 就是 FreeRTOS 的一个心跳时钟，驱动着 FreeRTOS 的运行</p>
<p>FreeRTOS 帮 我们实现了 SysTick 的启动的配置：在 port.c 文件中已经实现<br>vPortSetupTimerInterrupt()函数，并且 FreeRTOS 通用的 SysTick 中断服务 函数也实现了：在 port.c<br>文件中已经实现 xPortSysTickHandler()函数，所以 移植的时候只需要我们在 stm32f10x_it.c<br>文件中实现我们对应（STM32）平台 上的 SysTick_Handler()函数即可</p>
<p><strong><strong>延时函数实现：</strong></strong></p>
<p>&#x2F;&#x2F;reload 为 24 位寄存器,最大 值:16777216,在 72M 下,约合 0.233s 左右</p>
<p>void delay_us(u32 nus) {</p>
<p>u32 ticks;</p>
<p> u32 told,tnow,tcnt&#x3D;0;</p>
<p>u32 reload&#x3D;SysTick-&gt;LOAD; &#x2F;&#x2F;LOAD 的值</p>
<p>ticks&#x3D;nus*fac_us; &#x2F;&#x2F;需要的节拍数</p>
<p>told&#x3D;SysTick-&gt;VAL; &#x2F;&#x2F;刚进入时的计数器值</p>
<p>while(1) {</p>
<p>tnow&#x3D;SysTick-&gt;VAL;</p>
<p>if(tnow!&#x3D;told) {</p>
<p>if(tnow&lt;told)tcnt+&#x3D;told-tnow; &#x2F;&#x2F;这里注意一下 SYSTICK 是一个递 减的计数器就可以了.</p>
<p>else tcnt+&#x3D;reload-tnow+told;</p>
<p>told&#x3D;tnow;</p>
<p>if(tcnt&gt;&#x3D;ticks)break; &#x2F;&#x2F;时间超过&#x2F;等于要延迟的时间,则 退出. } }; }</p>
<p>delay_us()是 us 级延时函数，delay_ms 和 delay_xms()都是 ms 级的延 时函数，delay_us()和<br>delay_xms()不会导致任务切换。delay_ms()其实就是对 FreeRTOS 中的延时函数 vTaskDelay()的简单封装，所以在使用<br>delay_ms()的 时候就会导致任务切换</p>
<p>任务栈其实就是一个预先定义好的全局数组，数据类型为 StackType_t，大小由 TASK1_STACK_SIZE 这个宏来定义，默认为 128，单位为<br>字，即 512 字节，这也是 FreeRTOS 推荐的最小的任务栈。在 FreeRTOS 中， 凡是涉及到数据类型的地方，FreeRTOS 都会将标准的 C<br>数据类型用 typedef 重新取一个类型名。这些经过重定义的数据类型放在 portmacro.h 这个头文件。</p>
<p>正如我们所说的那样，任务是一个独立的、无限循环且不能返回的函数</p>
<p><strong><strong>3.2.3 定义任务控制块</strong></strong><strong><strong>：</strong></strong></p>
<p>typedef struct tskTaskControlBlock {</p>
<p>volatile StackType_t <em>pxTopOfStack; &#x2F;</em> 栈顶 *&#x2F; (1)</p>
<p>ListItem_t xStateListItem; &#x2F;* 任务节点 *&#x2F; (2)</p>
<p>StackType_t <em>pxStack; &#x2F;</em> 任务栈起始地址 *&#x2F; (3)</p>
<p>&#x2F;* 任务名称，字符串形式 *&#x2F;(4)</p>
<p>char pcTaskName[ configMAX_TASK_NAME_LEN ];</p>
<p>} tskTCB; typedef</p>
<p><strong><strong>3.2.4 列表和列表项</strong></strong>  :</p>
<p>要想看懂 FreeRTOS 源码并学习其原理，有一个东西需要理解，那就是 FreeRTOS 的列表和列表项。列表和列表项是 FreeRTOS<br>的一个数据结构， FreeRTOS 大量使用到了列表和列表项，它是 FreeRTOS 的基石。要想深入学习 并理解<br>FreeRTOS，那么列表和列表项就必须首先掌握，否则后面根本就没法进 行</p>
<p>列表项就是存放在列表中的项目，FreeRTOS 提供了两种列表项：列表项和 迷你列表项。这两个都在文件 list.h 中有定义</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18f990da82a5f9f6eb5a94ff344eb171.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/0de18e0f75c2b0b544e7ae7f4a1ed981.png"></p>
<p>3.2.4.2.1 列表初始化 新创建或者定义的列表需要对其做初始化处理，列表的初始化其实就是初始 化列表结构体 List_t<br>中的各个成员变量，列表的初始化通过函数 vListInitialise()来完成，此函数在 list.c 中有定义（<strong><strong>P58</strong></strong> ）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/76ca02bd0d186b50e841cd1a219d975d.png"></p>
<p>3.2.4.3.1 列表项插入函数 列表项的插入操作通过函数 vListInsert()来完成，函数原型如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be08fad541f38dea7f1d9a44896cd77f.png"></p>
<p>通过图可以看出，列表是一个环形的，即环形列表</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2048995ef80bb90a1f07f009b28c3884.png"></p>
<p>vListInsertEnd()插入列表的顺序问题（<strong><strong>P66</strong></strong> ）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/300cd190948f1391a19e5ae37f8638bd.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b7d15078dd210766f248d74c83c7ffd.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/130351060">https://blog.csdn.net/qq_32971095/article/details/130351060</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:06" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">一.Ubuntu<br>系统入门</a></p>
<p><a href="about:blank#1.VMware%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%81%E7%A8%8B">1.VMware<br>创建虚拟机流程</a></p>
<p><a href="about:blank#2.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">2.Ubuntu 系统入门</a></p>
<p><a href="about:blank#%3C1%3EShell%20%E5%91%BD%E4%BB%A4">&lt;1&gt;Shell 命令</a></p>
<p><a href="about:blank#1%E3%80%81%E7%9B%AE%E5%BD%95%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20ls">1、目录信息查看命令<br>ls</a></p>
<p><a href="about:blank#2%E3%80%81%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E5%91%BD%E4%BB%A4%20cd">2、目录切换命令<br>cd</a></p>
<p><a href="about:blank#3%E3%80%81%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%20pwd">3、当前路径显示命令<br>pwd</a></p>
<p><a href="about:blank#4%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20uname">4、系统信息查看命令<br>uname</a></p>
<p><a href="about:blank#5%E3%80%81%E6%B8%85%E5%B1%8F%E5%91%BD%E4%BB%A4%20clear">5、清屏命令<br>clear</a></p>
<p><a href="about:blank#6%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%BA%AB%E4%BB%BD%E5%91%BD%E4%BB%A4%20sudo">6、切换用户执行身份命令<br>sudo</a></p>
<p><a href="about:blank#7%E3%80%81%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20adduser">7、添加用户命令<br>adduser</a></p>
<p><a href="about:blank#8%E3%80%81%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20deluser">8、删除用户命令<br>deluser</a></p>
<p><a href="about:blank#9%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20su">9、切换用户命令<br>su</a></p>
<p><a href="about:blank#10%E3%80%81%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%91%BD%E4%BB%A4%20cat">10、显示文件内容命令<br>cat</a></p>
<p><a href="about:blank#11%E3%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4%20ifconfig">11、显示和配置网络属性命令<br>ifconfig</a></p>
<p><a href="about:blank#12%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%20man">12、系统帮助命令<br>man</a></p>
<p><a href="about:blank#13%E3%80%81%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%20reboot">13、 系统重启命令<br>reboot</a></p>
<p><a href="about:blank#14%E3%80%81%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%97%AD%E5%91%BD%E4%BB%A4%20poweroff">14、系统关闭命令<br>poweroff</a></p>
<p><a href="about:blank#15%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%20install">15、软件安装命令<br>install</a></p>
<p><a href="about:blank#%3C2%3EAPT%20%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7">&lt;2&gt;APT 下载工具</a></p>
<p><a href="about:blank#1%E3%80%81%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93">1、更新本地数据库</a></p>
<p><a href="about:blank#2%E3%80%81%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">2、检查依赖关系</a></p>
<p><a href="about:blank#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">3、软件安装</a></p>
<p><a href="about:blank#4%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0">4、软件更新</a></p>
<p><a href="about:blank#5%E3%80%81%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6">5、卸载软件</a></p>
<p><a href="about:blank#%3C3%3EUbuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91">&lt;3&gt;Ubuntu<br>下文本编辑</a></p>
<p><a href="about:blank#%3C4%3E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">&lt;4&gt;文件系统</a></p>
<p><a href="about:blank#1.Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">1.Linux<br>文件系统结构</a></p>
<p><a href="about:blank#2.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">2.文件操作命令</a></p>
<p><a href="about:blank#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E2%80%94touch">1、创建新文件命令—touch</a></p>
<p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir">2、文件夹创建命令—mkdir</a></p>
<p><a href="about:blank#3%E3%80%81%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rm">3、文件及目录删除命令—rm</a></p>
<p><a href="about:blank#4%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%28%E7%9B%AE%E5%BD%95%29%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rmdir">4、文件夹(目录)删除命令—rmdir</a></p>
<p><a href="about:blank#5%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4%E2%80%94cp">5、文件复制命令—cp</a></p>
<p><a href="about:blank#6%E3%80%81%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%91%BD%E4%BB%A4%E2%80%94mv">6、文件移动命令—mv</a></p>
<p><a href="about:blank#3.%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">3.文件压缩和解压缩</a></p>
<p><a href="about:blank#1%E3%80%81%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">1、图形化压缩和解压缩</a></p>
<p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">2、命令行进行文件的压缩和解压缩</a></p>
<p><a href="about:blank#%E2%91%A0%E5%91%BD%E4%BB%A4%20zip">①命令 zip</a></p>
<p><a href="about:blank#%E2%91%A1%E5%91%BD%E4%BB%A4%20unzip">②命令 unzip</a></p>
<p><a href="about:blank#%E2%91%A2%E5%91%BD%E4%BB%A4%20tar">③命令 tar</a></p>
<p><a href="about:blank#4.%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2">4.文件查询和搜索</a></p>
<p><a href="about:blank#1%E3%80%81%E5%91%BD%E4%BB%A4%20find">1、命令 find</a></p>
<p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%20grep">2、命令 grep</a></p>
<p><a href="about:blank#5.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">5.文件类型</a></p>
<p><a href="about:blank#%3C5%3ELinux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">&lt;5&gt;Linux<br>用户权限管理</a></p>
<p><a href="about:blank#1.Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F">1.Ubuntu 用户系统</a></p>
<p><a href="about:blank#2.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">2.权限管理</a></p>
<p><a href="about:blank#3.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">3.权限管理命令</a></p>
<p><a href="about:blank#1%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chmod">1、权限修改命令<br>chmod</a></p>
<p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%BD%92%E5%B1%9E%E8%80%85%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chown">2、文件归属者修改命令<br>chown</a></p>
<p><a href="about:blank#%3C6%3ELinux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86">&lt;6&gt;Linux<br>磁盘管理</a></p>
<p><a href="about:blank#1.Linux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.Linux<br>磁盘管理基本概念</a></p>
<p><a href="about:blank#2.%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2.磁盘管理命令</a></p>
<p><a href="about:blank#1%E3%80%81%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20fdisk">1、磁盘分区命令<br>fdisk</a></p>
<p><a href="about:blank#2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%91%BD%E4%BB%A4%20mkfs">2、格式化命令<br>mkfs</a></p>
<p><a href="about:blank#3%E3%80%81%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20mount">3、挂载分区命令<br>mount</a></p>
<p><a href="about:blank#4%E3%80%81%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4%20umount">4、卸载命令<br>umount</a></p>
<p><a href="about:blank#3.Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8">3.Linux C<br>编程入门</a></p>
<p><a href="about:blank#%3C1%3E%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">&lt;1&gt;编写代码</a></p>
<p><a href="about:blank#%3C2%3E%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">&lt;2&gt;编译代码</a></p>
<p><a href="about:blank#%3C3%3EGCC%20%E7%BC%96%E8%AF%91%E5%99%A8">&lt;3&gt;GCC 编译器</a></p>
<p><a href="about:blank#1%E3%80%81gcc%20%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">1、gcc<br>命令格式如下：</a></p>
<p><a href="about:blank#2%E3%80%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B">2、编译流程</a></p>
<p><a href="about:blank#%3C4%3EMakefile%20%E5%9F%BA%E7%A1%80">&lt;4&gt;Makefile 基础</a></p>
<p><a href="about:blank#1%E3%80%81Makefile%20%E7%AE%80%E4%BB%8B">1、Makefile 简介</a></p>
<p><a href="about:blank#2%E3%80%81Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5">2、Makefile 的引入</a></p>
<p><a href="about:blank#3%E3%80%81Makefile%20%E8%AF%AD%E6%B3%95">3、Makefile 语法</a></p>
<p><a href="about:blank#%E2%91%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F">①Makefile<br>规则格式</a></p>
<p><a href="about:blank#%E2%91%A1Makefile%20%E5%8F%98%E9%87%8F">②Makefile 变量</a></p>
<p><a href="about:blank#%E2%91%A2Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">③Makefile<br>模式规则</a></p>
<p><a href="about:blank#%E2%91%A3Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F">④Makefile<br>自动化变量</a></p>
<p><a href="about:blank#%E2%91%A4Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87">⑤Makefile 伪目标</a></p>
<p><a href="about:blank#%E2%91%A5Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">⑥Makefile<br>条件判断</a></p>
<p><a href="about:blank#%E2%91%A6Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">⑦Makefile<br>函数使用</a></p>
<hr>
<p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p>
<h2 id="一-Ubuntu-系统入门"><a href="#一-Ubuntu-系统入门" class="headerlink" title="一.Ubuntu 系统入门"></a>一.Ubuntu 系统入门</h2><pre><code>    在虚拟机上安装 Ubuntu 操作系统，安装好以后 Ubuntu 的设置、基本操作。想详细的学习 Ubuntu 系统的话可以参考《鸟哥的 linux 私房菜》这本书使用的 CentOS 操作系统，但是 Ubuntu 下完全可以使用。当 Ubuntu 系统入门以后，我们重点要学的就是如何在 Linux 下进行 C 语言开发，如何 使用 gcc 编译器、如何编写 Makefile 文件等等。如果此前已经使用过 Ubuntu 操作系统，并且从事过 Linux C 编程工作的话本篇就不需要看了。
</code></pre>
<h3 id="1-VMware-创建虚拟机流程"><a href="#1-VMware-创建虚拟机流程" class="headerlink" title="1.VMware 创建虚拟机流程"></a>1.VMware 创建虚拟机流程</h3><h3 id="2-Ubuntu-系统入门"><a href="#2-Ubuntu-系统入门" class="headerlink" title="2.Ubuntu 系统入门"></a>2.Ubuntu 系统入门</h3><pre><code>    本章的主要目的是教会读者掌握后续嵌入式开发所需的 Ubuntu 基本技能，比如**系统的基本设置、常用的 shell 命令、vim 编辑器的基本操作** 等等，如果想详 细的学习 Ubuntu 操作系统请参考其它更为详细的书籍，本章参考了《Ubuntu Linux 从入门到 精通》
</code></pre>
<h4 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="&lt;1&gt;Shell 命令"></a>&lt;1&gt;Shell 命令</h4><pre><code>    将多个 Shell 命令按照一定的格式放到一个文本中，那么这个文本就叫做 Shell 脚本。严格意义上来讲，Shell 是一个应用程序，它负责接收用户输入的命令，然后根据命令做出相应的动作，**Shell 负责将应用层或者用户输入的命令传递给系统内核，由操作系统内核来完成相应的工作，然后将结果反馈给应用层或者用户。**
</code></pre>
<p><strong>Shell 命令的格式</strong> 如下：</p>
<pre><code>command -options [argument]
</code></pre>
<p><strong>command</strong> : Shell 命令名称。</p>
<p><strong>options</strong> ：选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。</p>
<p><strong>argument</strong> ：Shell 命令是可以带参数的，也可以不带参数运行。</p>
<pre><code>    Shell 命令是**支持自动补全功能** 的，因为 Shell 命令非常多，如果不作自动补全的话就需要用户去记忆这些命令的全部字母。使用自动补全功能以后我们只需要输入命令的前面一部分字母，然后按下 **TAB 键** ，如果只有一个命令匹配的话就会自动补全这个命令剩下的字母。
</code></pre>
<p><strong>常用 Shell 命令：</strong></p>
<h5 id="1、目录信息查看命令-ls"><a href="#1、目录信息查看命令-ls" class="headerlink" title="1、目录信息查看命令 ls"></a><strong>1、目录信息查看命令 ls</strong></h5><pre><code>ls [选项] [路径]
主要参数有：
-a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。
-l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。
-t 将文件按照创建时间排序列出。
-A 和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。
-R 递归列出所有文件，包括子目录中的文件。

    Shell 命令里面的参数是可以组合在一起用的，比如组合“-al”就是显示所有文件的详细 信息，包括以“.”开头的隐藏文件。
</code></pre>
<h5 id="2、目录切换命令-cd"><a href="#2、目录切换命令-cd" class="headerlink" title="2、目录切换命令 cd"></a><strong>2、目录切换命令 cd</strong></h5><pre><code>cd [路径]
示例：
cd / //进入到根目录“/”下，Linux 系统的根目录为“/”,
cd /usr //进入到目录“/usr”里面。
cd .. //进入到上一级目录。
cd ~ //切换到当前用户主目录
</code></pre>
<h5 id="3、当前路径显示命令-pwd"><a href="#3、当前路径显示命令-pwd" class="headerlink" title="3、当前路径显示命令 pwd"></a><strong>3、当前路径显示命令 pwd</strong></h5><h5 id="4、系统信息查看命令-uname"><a href="#4、系统信息查看命令-uname" class="headerlink" title="4、系统信息查看命令 uname"></a><strong>4、系统信息查看命令 uname</strong></h5><pre><code>uname [选项]
可选的选项参数如下：
-r 列出当前系统的具体内核版本号。
-s 列出系统内核名称。
-o 列出系统信息。
</code></pre>
<h5 id="5、清屏命令-clear"><a href="#5、清屏命令-clear" class="headerlink" title="5、清屏命令 clear"></a><strong>5、清屏命令 clear</strong></h5><h5 id="6、切换用户执行身份命令-sudo"><a href="#6、切换用户执行身份命令-sudo" class="headerlink" title="6、切换用户执行身份命令 sudo"></a><strong>6、切换用户执行身份命令 sudo</strong></h5><pre><code>    Ubuntu(Linux)是一个允许多用户的操作系统，其中权限最大的就是**超级用户 root** ，有时候 我们执行一些操作的时候是需要用 root 用户身份才能执行，比如安装软件。通过 sudo 命令可以使我们暂时将身份切换到 root 用户。当使用 sudo 命令的时候是需要输入密码的，这里要注 意输入密码的时候是没有任何提示的！命令格式如下：


sudo [选项] [命令]
选项主要参数如下：
-h 显示帮助信息。
-l 列出当前用户可执行与不可执行的命令
-p 改变询问密码的提示符。

    假如我们现在要**创建一个新的用户 test** ，创建新用户的命令为“**adduser** ”，创建新用户的权限只有 root 用户才有，我们在装系统的时候创建的那个用户是没有这个权限的，比如我的 “zuozhongkai”用户。所以创建新用户的话需要使用“sudo”命令以 root 用户执行“adduser” 这个命令，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c242489236851475c5f139aaf39a0d35.png"></p>
<h5 id="7、添加用户命令-adduser"><a href="#7、添加用户命令-adduser" class="headerlink" title="7、添加用户命令 adduser"></a><strong>7、添加用户命令 adduser</strong></h5><pre><code>adduser [参数] [用户名]
常用的参数如下：
-system 添加一个系统用户
-home DIR DIR 表示用户的主目录路径
-uid ID ID 表示用户的 uid。
-ingroup GRP 表示用户所属的组名。
</code></pre>
<h5 id="8、删除用户命令-deluser"><a href="#8、删除用户命令-deluser" class="headerlink" title="8、删除用户命令 deluser"></a><strong>8、删除用户命令 deluser</strong></h5><pre><code>deluser [参数] [用户名]
主要参数有：
-system 当用户是一个系统用户的时候才能删除。
-remove-home 删除用户的主目录
-remove-all-files 删除与用户有关的所有文件。
-backup 备份用户信息
</code></pre>
<h5 id="9、切换用户命令-su"><a href="#9、切换用户命令-su" class="headerlink" title="9、切换用户命令 su"></a><strong>9、切换用户命令 su</strong></h5><pre><code>    **命令“su” 可以直接将当前用户切换为 root 用户** ，切换到 root 用户以后获得系统最高权限，在 root 用户下，所有的命令都可以无障碍执行，不需要在 前面加上“sudo”，“su”命令格式如下：


su [选项] [用户名]
常用选项参数如下：
-c –command 执行指定的命令，执行完毕以后回复原用户身份。
-login 改变用户身份，同时改变工作目录和 PATH 环境变量。
-m 改变用户身份的时候不改变环境变量
-h 显示帮助信息
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/06fd80a8ca5c2c4e5ad67b6fd8deac4c.png"></p>
<pre><code>    使用命令“sudo su”切换到 root 用户，su 命令不写明用户名的话默认 切换到 root 用户。然后输入密码，密码正确的话就会切换到 root 用户，可以看到切换到 root 用户以后提示符的“@”符号前面的用户名变成了“root”，表示当前的用户是 root 用户。并 且以“#”结束。

    注意！！由于 **root 用户权限太大，稍微不注意就可能删除掉系统文件，导致系统奔溃** ， 因此强烈建议大家，**不要以 root 用户运行 Ubuntu** 。当要用到 root 身份执行某些命令的时候使用“sudo”命令即可。

    要**切换回原来的用户** ，使用命令“**sudo su 用户名** ”即可。
</code></pre>
<h5 id="10、显示文件内容命令-cat"><a href="#10、显示文件内容命令-cat" class="headerlink" title="10、显示文件内容命令 cat"></a><strong>10、显示文件内容命令 cat</strong></h5><pre><code>cat [选项] [文件]
选项主要参数如下：
-n 由 1 开始对所有输出的行进行编号。
-b 和-n 类似，但是不对空白行编号。
-s 当遇到连续两个行以上空白行的话就合并为一个行空白行。
</code></pre>
<h5 id="11、显示和配置网络属性命令-ifconfig"><a href="#11、显示和配置网络属性命令-ifconfig" class="headerlink" title="11、显示和配置网络属性命令 ifconfig"></a><strong>11、显示和配置网络属性命令 ifconfig</strong></h5><pre><code>ifconfig interface options | address
主要参数如下：
interface 网络接口名称，比如 eth0 等。
up 开启网络设备。
down 关闭网络设备。
add IP 地址，设置网络 IP 地址。
netmask add 子网掩码。


    在图中有两个网卡：ens33 和 lo，ens33 是我的电脑实际使用的网卡，lo 是回测网 卡。可以看出网卡 ens33 的 IP 地址为 192.168.31.235，我们使用命令“ifconfig”将网卡 ens33 的 IP 地址改为 192.168.31.20，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7f7e119e714d7803c899b06b145c47c7.png"></p>
<h5 id="12、系统帮助命令-man"><a href="#12、系统帮助命令-man" class="headerlink" title="12、系统帮助命令 man"></a><strong>12、系统帮助命令 man</strong></h5><pre><code>man [命令名]
</code></pre>
<p>按“q”键退出到终端。</p>
<h5 id="13、-系统重启命令-reboot"><a href="#13、-系统重启命令-reboot" class="headerlink" title="13、 系统重启命令 reboot"></a><strong>13、 系统重启命令 reboot</strong></h5><h5 id="14、系统关闭命令-poweroff"><a href="#14、系统关闭命令-poweroff" class="headerlink" title="14、系统关闭命令 poweroff"></a><strong>14、系统关闭命令 poweroff</strong></h5><h5 id="15、软件安装命令-install"><a href="#15、软件安装命令-install" class="headerlink" title="15、软件安装命令 install"></a><strong>15、软件安装命令 install</strong></h5><pre><code>格式如下：
install [选项]... [-T] 源文件 目标文件
或：install [选项]... 源文件... 目录
或：install [选项]... -t 目录 源文件...
或：install [选项]... -d 目录...

    截至目前，我们都没有讲过 Ubuntu 下如何安装软件，因为 Ubuntu 安装软件不像 Windows 下那样，直接双击.exe 文件就开始安装了。Ubuntu 下很多软件是需要**先自行下载源码** ，下载源码以后**自行编译** ，**编译完成以后使用命令“intsall”来安装** 。当然 Ubuntu 下也有其它的软件安装方法，但是用的最多的就是自行编译源码然后安装，尤其是嵌入式Linux开发。

    “install”命令是将文件(通常是编译后的文件)**复制到目的位置** ，在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录中同时设置其所有权和权限模式。在第四种形式会创建指定的目录。命令“install”通常和命令“apt-get”组合在一起使用的。
</code></pre>
<h4 id="APT-下载工具"><a href="#APT-下载工具" class="headerlink" title="&lt;2&gt;APT 下载工具"></a>&lt;2&gt;APT 下载工具</h4><pre><code>    对于长时间使用 Windows 的我们，下载安装软件非常容易，Windows 下有很多的下载软 件，Ubuntu 同样有不少的下载软件，本节我们讲解 Ubuntu 下我们用的最多的下载工具：APT 下载工具，APT 下载工具可以实现软件**自动下载、配置、安装二进制或者源码** 的功能。APT 下载工具和我们前面讲解的“install”命令结合在一起构成了 Ubuntu 下最常用的下载和安装软件方法。它解决了 Linux 平台下一安装软件的一个缺陷，即**软件之间相互依赖** 。

    APT 采用的 **C/S 模式** ，也就是**客户端/服务器模式** ，我们的 PC 机作为客户端，当需要下载软件的时候就向服务器请求，因此我们需要知道服务器的地址，也叫做安装源或者更新源。
</code></pre>
<p>打开“软件和更新”设置，打开方式如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/523881d52264434de75ee6b79f8c8361.png"></p>
<pre><code>    在上图中的“Ubuntu 软件”选项卡下面的“下载自”就是 **APT 工具的安装源** ，因为我们是在中国，所以需要选择中国的服务器，否则的话可能会导致下载失败！这个也就是网上说的 Ubuntu 安装成功以后要更新源。

    在我们使用 APT 工具下载安装或者更新软件的时候，首先会在下载列表中**与本机软件对比** ，看一下需要下载哪些软件，或者升级哪些软件，默认情况下 APT 会下载最新的软件包， 被安装的软件包**所依赖的其它软件也会被下载安装** 。说了这么多，APT 下载工具究竟怎么用呢？APT 工具常用的命令如下：
</code></pre>
<h5 id="1、更新本地数据库"><a href="#1、更新本地数据库" class="headerlink" title="1、更新本地数据库"></a><strong>1、更新本地数据库</strong></h5><pre><code>sudo apt-get update
</code></pre>
<p>这个命令会<strong>访问源地址，并且获取软件列表</strong> 并保存在本电脑上。如果想查看<strong>本地哪些软件可以更新</strong> 的话可以使用如下命令。</p>
<h5 id="2、检查依赖关系"><a href="#2、检查依赖关系" class="headerlink" title="2、检查依赖关系"></a><strong>2、检查依赖关系</strong></h5><pre><code>sudo apt-get check

    有时候本地某些软件可能存在依赖关系，所谓依赖关系就是 A 软件依赖于 B 软件。通过 如下命令可以查看依赖关系，如果存在依赖关系的话 APT 会提出解决方案。
</code></pre>
<h5 id="3、软件安装"><a href="#3、软件安装" class="headerlink" title="3、软件安装"></a><strong>3、软件安装</strong></h5><pre><code>sudo apt-get install package-name
</code></pre>
<p>注：<strong>推荐使用 apt 替代 apt-get</strong></p>
<h5 id="4、软件更新"><a href="#4、软件更新" class="headerlink" title="4、软件更新"></a><strong>4、软件更新</strong></h5><pre><code>sudo apt-get upgrade package-name
</code></pre>
<h5 id="5、卸载软件"><a href="#5、卸载软件" class="headerlink" title="5、卸载软件"></a><strong>5、卸载软件</strong></h5><pre><code>sudo apt-get remove package-name
</code></pre>
<h4 id="Ubuntu-下文本编辑"><a href="#Ubuntu-下文本编辑" class="headerlink" title="&lt;3&gt;Ubuntu 下文本编辑"></a>&lt;3&gt;Ubuntu 下文本编辑</h4><pre><code>    Ubuut 下有一个自带的文本编辑器，那就是 Gedit。Gedit 是一个窗口式的编辑器，本节我们重点讲解的是另外一 个编辑器：VI/VIM 编辑器。

    我们如果要在**终端模式下进行文本编辑** 或者修改文件就可以使用 VI/VIM 编辑器，Ubuntu 自带了 VI 编辑器。VIM 编辑 器是 VI 编辑器升级版本，VI/VIM 编辑器都是一种**基于指令式的编辑器** ，不需要鼠标，也没有菜单，仅仅**使用键盘来完成所有的编辑** 工作。
</code></pre>
<p>安装 VIM 编辑器，命令如下：</p>
<pre><code>sudo apt-get install vim

    VIM 编辑器有 3 中工作模式：**输入模式、指令 模式和底行模式** ，通过切换不同的模式可以完成不同的功能。

    打开终端，输入命令：vi test.txt 。在终端中输入上图中所示的命令以后就会创建一个 test.txt 文档，并且用 VIM 打开了。VIM **默认是以只读模式打开的文档** ，因此我们要**切换到输入模式** ，切换到输入模式的命令如下：


i 在当前光标所在字符的前面，转为输入模式
I 在当前光标所在行的行首转换为输入模式
a 在当前光标所在字符的后面，转为输入模式
A 在光标所在行的行尾，转换为输入模式
o 在当前光标所在行的下方，新建一行，并转为输入模式
O 在当前光标所在行的上方，新建一行，并转为输入模式
s 删除光标所在字符。 r 替换光标处字符

    但是不能使用快捷键 Ctrl+S 来保存，这是因为在 Ubuntu 下 Ctrl+S 快捷 键不是用来完成保存的功能的，而是暂停该终端！所以你一旦在使用终端的时候按下 Ctrl+S 快捷键，那么你的终端肯定不会再有任何反应，如果你按下 **Ctrl+S 关闭了当前终端可以 按下 Ctrl+Q 来重新打开终端** 。

    我们需要从 VIM 现在的**输入模式切换到指令模式** ，方式就是按下键盘的 **ESC** 键

    指令模式顾名思义就是输入指令的模式，这些 指令是控制文本的指令，我们将这些指令进行分类，如下所示：


1、移动光标指令：
h(或左方向键) 光标左移一个字符。
l(或右方向键) 光标右移一个字符。
j(或下方向键) 光标下移一行。
k(或上方向键) 光标上移一行。
nG 光标移动到第 n 行首。
n+ 光标下移 n 行。
n- 光标上移 n 行。

2、屏幕翻滚指令
Ctrl+f 屏幕向下翻一页，相当于下一页。
Ctrl+b 屏幕向上翻一页，相当于上一页。

3、复制、删除和粘贴指令
cc 删除整行，并且修改整行内容。
dd 删除改行，不提供修改功能。
ndd 删除当前行向下 n 行。
x 删除光标所在的字符。
X 删除光标前面的一个字符。
nyy 复制当前行及其下面 n 行。
p 粘贴最近复制的内容。

    保存文档的命令是在**底行模式** 中，我们要先进入到指令模式，进入底行模式的方式是**先进入指令模式 下，然后在指令模式下输入“：”进入底行模式**
</code></pre>
<p>常用的命令如下：</p>
<pre><code>x 保存当前文档并且退出。
q 退出。
w 保存文档。
q! 退出 VI/VIM，不保存文档。
</code></pre>
<p>如果我们要退出并保存文本的话需要在“：”底行模式下输入“wq”</p>
<pre><code>    还可以 在指令模式下**输入“/”进入底行模式** ，在“/”后面输入要**搜索** 的内容，然后按下回车键就会找到与字符串匹配的部分
</code></pre>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="&lt;4&gt;文件系统"></a>&lt;4&gt;文件系统</h4><pre><code>    Linux 有多种文件系统，不同的文件系统支持不同的体系。文件系统是管理数 据的，而可以存储数据的物理设备有硬盘、U 盘、SD 卡、NAND FLASH、NOR FLASH、网 络存储设备等。不同的存储设备其物理结构不同，不同的物理结构就需要不同的文件系统去管 理，比如管理 NAND FLASH 的话使用 YAFFS 文件系统，管理硬盘、SD 卡的话就是 ext 文件 系统等等。

    Windows 下一般有 FAT、NTFS 和 exFAT 这些文件系统。同样的，在 Linux 下我们使用 fdisk 创建好分区以后也是要先在创建好的分区 上面创建文件系统，也就是格式化。 在 Windows 下有磁盘分区的概念，比如 C，D，E 盘等，在 Linux 下没有这个概念，因此 Linux 下你找不到像 C、D、E 盘这样的东西。前面我们说了 Linux 下可以给磁盘分割，在 Linux 下创建一个分区并且格式化好以后我们要将 其“挂载”到一个目录下才能访问这个分区。Windows 的文件系统挂载过程是其内部完成的， 用户是看不到的，Linux 下我们使用 mount 命令来挂载磁盘。挂载磁盘的时候是需要确定挂载 点的，也就是你的这个磁盘要挂载到哪个目录下。

    Linux 下的文件系统主要有 ext2、ext3、ext4 等文件系统。Linux 还支持其 他的 UNIX 文件系统，比如 XFS、JFS、UFS 等，也支持 Windows 的 FAT 文件系统和网络文 件系统 NFS 等。这里我们主要讲一下 Linux 自带的 ext2、ext3 和 ext4 文件系统。
</code></pre>
<p>在终端中输入如下命令来查询当前磁盘挂载的是什么文件系统：</p>
<pre><code>df -T –h
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5e5c67fe02fe10eb124ecd486b2765bb.png"></p>
<h5 id="1-Linux-文件系统结构"><a href="#1-Linux-文件系统结构" class="headerlink" title="1.Linux 文件系统结构"></a>1.Linux 文件系统结构</h5><pre><code>    Linux 只有一个根目录“/”。Ubuntu 是支持多用户的，Ubuntu 为每个用户创建了一个根目录，只要你创建了一个用户，那么系统就会在/home 这个目录下创建一个以这个用户名命名的文件 夹，这个文件夹就是这个用户的根目录。
</code></pre>
<p>我们来看一下根目录“&#x2F;”中的 一些重要的文件夹：</p>
<pre><code>/bin 存储一些二进制可执行命令文件，/usr/bin 也存放了一些基于用户的命令文件。
/sbin 存储了很多系统命令，/usr/sbin 也存储了许多系统命令。
/root 超级用户 root 的根目录文件。
/home 普通用户默认目录，在该目录下，每个用户都有一个以本用户名命名的文件夹。
/boot 存放 Ubuntu 系统内核和系统启动文件。
/mnt 通常包括系统引导后被挂载的文件系统的挂载点。
/dev 存放设备文件，我们后面学习 Linux 驱动主要是跟这个文件夹打交道的。
/etc 保存系统管理所需的配置文件和目录。
/lib 保存系统程序运行所需的库文件，/usr/lib 下存放了一些用于普通用户的库文件。
/lost+found 一般为空，当系统非正常关机以后，此文件夹会保存一些零散文件。
/var 存储一些不断变化的文件，比如日志文件
/usr 包括与系统用户直接有关的文件和目录，比如应用程序和所需的库文件。
/media 存放 Ubuntu 系统自动挂载的设备文件。
/proc 虚拟目录，不实际存储在磁盘上，通常用来保存系统信息和进程信息。
/tmp 存储系统和用户的临时文件，该文件夹对所有的用户都提供读写权限。
/opt 可选文件和程序的存放目录。
/sys 系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。
</code></pre>
<h5 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h5><h6 id="1、创建新文件命令—touch"><a href="#1、创建新文件命令—touch" class="headerlink" title="1、创建新文件命令—touch"></a><strong>1、创建新文件命令—touch</strong></h6><pre><code>touch [参数] [文件名]
使用 touch 创建文件的时候，如果[文件名]的文件不存在，那就直接创建一个以[文件名]
命名的文件，如果[文件名]文件存在的话就仅仅修改一下此文件的最后修改日期，常用的命令
参数如下：
-a 只更改存取时间。
-c 不建立任何文件。
-d&lt;日期&gt; 使用指定的日期，而并非现在日期。
-t&lt;时间&gt; 使用指定的时间，而并非现在时间。
</code></pre>
<h6 id="2、文件夹创建命令—mkdir"><a href="#2、文件夹创建命令—mkdir" class="headerlink" title="2、文件夹创建命令—mkdir"></a>2、文件夹创建命令—mkdir</h6><pre><code>mkdir [参数] [文件夹名目录名]
主要参数如下：
-p 如所要创建的目录其上层目录目前还未创建，那么会一起创建上层目录。
</code></pre>
<h6 id="3、文件及目录删除命令—rm"><a href="#3、文件及目录删除命令—rm" class="headerlink" title="3、文件及目录删除命令—rm"></a>3、文件及目录删除命令—rm</h6><pre><code>    要删除一个文件或者文件夹可以使用 命令“rm”，此命令可以完成删除一个文件或者多个文件及文件夹，它可以实现递归删除。 对于链接文件，只删除链接，原文件保持不变，所谓的链接文件，其实就是 Windows 下的快 捷方式文件，此命令格式如下：


rm [参数] [目的文件或文件夹目录名]
命令主要参数如下：
-d 直接把要删除的目录的硬连接数据删成 0，删除该目录。
-f 强制删除文件和文件夹(目录)。
-i 删除文件或者文件夹(目录)之前先询问用户.
-r 递归删除，指定文件夹(目录)下的所有文件和子文件夹全部删除掉。
-v 显示删除过程。

    直接使用命令“rm”是无法删除文件夹(目录)的，我们需要加上 参数“-rf”，也就是强制递归删除文件夹(目录)
</code></pre>
<h6 id="4、文件夹-目录-删除命令—rmdir"><a href="#4、文件夹-目录-删除命令—rmdir" class="headerlink" title="4、文件夹(目录)删除命令—rmdir"></a>4、文件夹(目录)删除命令—rmdir</h6><p>它可以不加任何参数的删除掉指定的文件夹(目 录)，命令格式如下：</p>
<pre><code>rmdir [参数] [文件夹(目录)]
命令主要参数如下：
-p 删除指定的文件夹(目录)以后，若上层文件夹(目录)为空文件夹(目录)的话就将其一起
删除。
</code></pre>
<h6 id="5、文件复制命令—cp"><a href="#5、文件复制命令—cp" class="headerlink" title="5、文件复制命令—cp"></a>5、文件复制命令—cp</h6><pre><code>cp [参数] [源地址] [目的地址]
主要参数描述如下：
-a 此参数和同时指定“-dpR”参数相同
-d 在复制有符号连接的文件时，保留原始的连接。
-f 强行复制文件，不管要复制的文件是否已经存在于目标目录。
-I 覆盖现有文件之前询问用户。
-p 保留源文件或者目录的属性。
-r 或-R递归处理，将指定目录下的文件及子目录一并处理
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fdd2b97a66de0166f090b556b64996c4.png"></p>
<pre><code>    通配符“*”，“*.c”就表示 test1 下的所有以“.c”结尾的文件，也就是 a.c 和 b.c。“../test2”中的“../”表示上级目录，因此“../test2”就是上级目录下的 test2 文件夹。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9edd7298f52909aee3caad55eb8418d.png"></p>
<h6 id="6、文件移动命令—mv"><a href="#6、文件移动命令—mv" class="headerlink" title="6、文件移动命令—mv"></a>6、文件移动命令—mv</h6><pre><code>mv [参数] [源地址] [目的地址]
主要参数描述如下：
-b 如果要覆盖文件的话覆盖前先进行备份。
-f 若目标文件或目录与现在的文件重复，直接覆盖目标文件或目录。
-I 在覆盖之前询问用户。
</code></pre>
<h5 id="3-文件压缩和解压缩"><a href="#3-文件压缩和解压缩" class="headerlink" title="3.文件压缩和解压缩"></a>3.文件压缩和解压缩</h5><p>Ubuntu 下图形化以及命 令行这两种压缩和解压缩操作:</p>
<h6 id="1、图形化压缩和解压缩"><a href="#1、图形化压缩和解压缩" class="headerlink" title="1、图形化压缩和解压缩"></a>1、图形化压缩和解压缩</h6><p>在要压缩或者解压的文件上点击鼠标右键， 然后选择要进行的操作——压缩&#x2F;提取</p>
<h6 id="2、命令行进行文件的压缩和解压缩"><a href="#2、命令行进行文件的压缩和解压缩" class="headerlink" title="2、命令行进行文件的压缩和解压缩"></a>2、命令行进行文件的压缩和解压缩</h6><p>命令行下进行压缩和解压缩常用的命令有三个：zip、unzip 和 tar：</p>
<h6 id="①命令-zip"><a href="#①命令-zip" class="headerlink" title="①命令 zip"></a>①命令 zip</h6><p>zip 命令是针对.zip 文件的，用于将一个或者多个文件压缩成一个.zip 结尾的文件，格式如下：</p>
<pre><code>zip [参数] [压缩文件名.zip] [被压缩的文件]
主要参数函数如下：
-b&lt;工作目录&gt; 指定暂时存放文件的目录。
-d 从 zip 文件中删除一个文件。
-F 尝试修复已经损毁的压缩文件。
-g 将文件压缩入现有的压缩文件中，不需要新建压缩文件。
-h 帮助。
-j 只保存文件的名，不保存目录。
-m 压缩完成以后删除源文件。
-n&lt;字尾符号&gt; 不压缩特定扩展名的文件。
-q 不显示压缩命令执行过程。
-r 递归压缩，将指定目录下的所有文件和子目录一起压缩。
-v 显示指令执行过程。
-num 压缩率，为 1~9 的数值。
</code></pre>
<p>使用 zip 命令进行 test2 文件夹的压缩，我们使用的命令如下： zip -rv test2.zip test2</p>
<h6 id="②命令-unzip"><a href="#②命令-unzip" class="headerlink" title="②命令 unzip"></a>②命令 unzip</h6><pre><code>unzip [参数] [压缩文件名.zip]
主要参数如下：
-l 显示压缩文件内所包含的文件。
-t 检查压缩文件是否损坏，但不解压。
-v 显示命令显示的执行过程。
-Z 只显示压缩文件的注解。
-C 压缩文件中的文件名称区分大小写。
-j 不处理压缩文件中的原有目录路径。
-L 将压缩文件中的全部文件名改为小写。
-n 解压缩时不要覆盖原有文件。
-P&lt;密码&gt; 解压密码。
-q 静默执行，不显示任何信息。
-x&lt;文件列表&gt; 指定不要处理.zip 中的哪些文件。
-d&lt;目录&gt; 把压缩文件解到指定目录下。
</code></pre>
<h6 id="③命令-tar"><a href="#③命令-tar" class="headerlink" title="③命令 tar"></a>③命令 tar</h6><pre><code>    Linux 下最常用的.bz2 和.gz 这两种压缩格式。其它格式的压缩和解压使用 命令 tar，tar 将压缩和解压缩集合在一起，使用不同的参数即可，命令格式如下：


tar [参数] [压缩文件名] [被压缩文件名]
常用参数如下：
-c 创建新的压缩文件。
-C&lt;目的目录&gt; 切换到指定的目录。
-f&lt;备份文件&gt; 指定压缩文件。
-j 用 tar 生成压缩文件，然后用 bzip2 进行压缩。
-k 解开备份文件时，不覆盖已有的文件。
-m 还原文件时，不变更文件的更改时间。
-r 新增文件到已存在的备份文件的结尾部分。
-t 列出备份文件内容。
-v 显示指令执行过程。
-w 遭遇问题时先询问用户。
-x 从备份文件中释放文件，也就是解压缩文件。
-z 用 tar 生成压缩文件，用 gzip 压缩。
-Z 用 tar 生成压缩文件，用 compress 压缩。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e5e7cf4b3d0a2d1d46d57f90bd86a38.png"></p>
<p>在上面命令中，-vcjf 表示创建 bz2 格式的压缩文件，-vczf 表示创建.gz 格式的压缩文 件。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cac42b4dab88584feb7f441772bd694.png"></p>
<pre><code>    上述两行命令中，-vxjf 用来完成.bz2 格式压缩文件的解压，-vxzf 用来完成.gz 格式压缩文 件的解压。要熟练掌握使用 tar 命令来完成.bz2 和.gz 格式的文件压缩和解压缩。
</code></pre>
<h5 id="4-文件查询和搜索"><a href="#4-文件查询和搜索" class="headerlink" title="4.文件查询和搜索"></a>4.文件查询和搜索</h5><pre><code>    在嵌入式 Linux 开发中常常需要在 Linux 源码文件中查询某个**文件是否存在** ，或者搜索哪些文件都**调用了某个函数** 等等。本节我们就讲解两个最 常用的文件查询和搜索命令：**find** 和 **grep** 。
</code></pre>
<h6 id="1、命令-find"><a href="#1、命令-find" class="headerlink" title="1、命令 find"></a>1、命令 find</h6><p>find 命令用于在目录结构中查找文件，其命令格式如下：</p>
<pre><code>find [路径] [参数] [关键字]
路径是要查找的目录路径，如果不写的话表示在当前目录下查找，关键字是文件名的一部
分，主要参数如下：
-name&lt;filename&gt; 按照文件名称查找，查找与 filename 匹配的文件，可使用通配符。
-depth 从指定目录下的最深层的子目录开始查找。
-gid&lt;群组识别码&gt; 查找符合指定的群组识别码的文件或目录。
-group&lt;群组名称&gt; 查找符合指定的群组名称的文件或目录。
-size&lt;文件大小&gt; 查找符合指定文件大小的文件。
-type&lt;文件类型&gt; 查找符合指定文件类型的文件。
-user&lt;拥有者名称&gt;查找符合指定的拥有者名称的文件或目录。
find 命令的参数有很多，常用的就这些，关于其它的参数大家可以自行上网查找
</code></pre>
<h6 id="2、命令-grep"><a href="#2、命令-grep" class="headerlink" title="2、命令 grep"></a>2、命令 grep</h6><pre><code>    **在文件中搜索一串关键字** ，grep 就是完 成这个功能的，grep 命令用于查找包含指定关键字的文件，如果发现某个文件的内容包含所指 定的关键字，grep 命令就会把包含指定关键字的这一行标记出来，grep 命令格式如下：


grep [参数] 关键字 文件列表
grep 命令一次只能查一个关键字，主要参数如下：
-b 在显示符合关键字的那一列前，标记处该列第 1 个字符的位编号。
-c 计算符合关键字的列数。
-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用此参数！否则 grep 指令将回
报信息并停止搜索。
-i 忽略字符大小写。
-v 反转查找，只显示不匹配的行。
-r 在指定目录中递归查找。
</code></pre>
<h5 id="5-文件类型"><a href="#5-文件类型" class="headerlink" title="5.文件类型"></a>5.文件类型</h5><p>使用命令“ls -l”来查看用户根目录下所有文件的详细信息</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9775c00441c48eb60dac4172e8a138aa.png"></p>
<p>在上图中，每个文件的详细信息占一行，每行最前面都是一个符号就标记了当前文件类型， 比如 test1 的第一个字符是“d”，test1.tar.bz2<br>文件第一个字符是“-”。这些字符表示的文件类型如下：</p>
<pre><code>- 普通文件，一些应用程序创建的，比如文档、图片、音乐等等。
d 目录文件。
c 字符设备文件，Linux 驱动里面的字符设备驱动，比如串口设备，音频设备等。
b 块设备文件，存储设备驱动，比如硬盘，U 盘等。
l 符号连接文件，相当于 Windwos 下的快捷方式。
s 套接字文件。
p 管道文件，主要指 FIFO 文件。
</code></pre>
<p>后面学习 <strong>Linux 驱动开发</strong> 的时候基本是在和<strong>字符设备文件</strong> 和<strong>块设备文件</strong> 打交道。</p>
<h4 id="Linux-用户权限管理"><a href="#Linux-用户权限管理" class="headerlink" title="&lt;5&gt;Linux 用户权限管理"></a>&lt;5&gt;Linux 用户权限管理</h4><h6 id="1-Ubuntu-用户系统"><a href="#1-Ubuntu-用户系统" class="headerlink" title="1.Ubuntu 用户系统"></a>1.Ubuntu 用户系统</h6><pre><code>    装系统的时候创建的用户其权限比后面创建的用户大一点，但是没有 root 用户权限大， Ubuntu 下用户类型分为以下 3 类：
</code></pre>
<p>● 初次创建的用户，此用户可以完成比普通用户更多的功能。</p>
<p>● root 用户，系统管理员，拥有所有权利。</p>
<p>● 普通用户，安装完操作系统以后被创建的用户。</p>
<pre><code>    以上三种用户，每个用户都有一个 ID 号，称为 UID，操作系统通过 UID 来识别是哪个用 户，用户相关信息可以在文件/etc/passwd 中查看到
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/771a5136f3710899083fa41699d937ad.png"></p>
<pre><code>    从配置文件 passwd 中可以看到，每个用户名后面都有两个数字，比如用户“zuozhongkai” 后面“1000:1000”，第一个数字是用户的 ID，另一个是用户的 GID，也就是用户组 ID。Ubuntu 里面每个用户都属于一个用户组里面，用户组就是一组有相同属性的用户集合。
</code></pre>
<h6 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h6><pre><code>    对于嵌入式开发一般不关注**用户的权限问题** ，因为嵌入式基本是单用户，做嵌入式开发重点关注的是**文件的权限问题** 。 对于一个文件通常有三种权限：**读(r)、写(w)和执行(x)** ，使用命令“**ls -l** ”可以查看某个目 录下所有文件的权限信息，如：


-rw-rw-r-- 1 zuozhongkai zuozhongkai 0 12 月 25 20:44 test.c

    其中“-rw-rw-r--”表示**文件权限与用户和用户组之间的关系** ，第一位表示文件类型，上一 小节已经说了。剩下的 9 位**以 3 位为一组** ，**分别表示文件拥有者的权限，文件拥有者所在用户组的权限以及其它用户权限** 。后面的**“zuozhongkai zuozhongkai”分别代表文件拥有者(用户) 和该用户所在的用户组** ，因此文件 test.c 的权限情况如下：

    ①、文件 test.c 的拥有者是用户 zuozhongkai，其对文件 tesst.c 的权限是“rw-”，也就是 对该文件拥有读和写两种权限。

    ②、用户 zuozhongkai 所在的用户组也叫做 zuozhongkai，其组内用户对于文件 test.c 的权 限是“rw-”，也是拥有读和写这两种权限。         

    ③、其它用户对于文件 test.c 的权限是“r--”，也就是只读权限。 对于文件，可读权限表示可以打开查看文件内容，可写权限表示可以对文件进行修改，可执行权限就是可以运行此文件(如果是软件的话)。对于文件夹，拥有可读权限才可以使用命令 ls 查看文件夹中的内容，**拥有可执行权限才能进入到文件夹内部** 。

    除了用 r、w 和 x 表示以外， 我们也可以使用二进制数表示，三种权限就可以使用 3 位二进制数来表示，一种权限对应一个 二进制位，如果该位为 1 就表示具备此权限，如果该位为 0 就表示没不具备此权限，如下表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f81b8eae64f7d2e4f654d3232de0e342.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/15a31e64d77cb241198b539487d3ea6c.png"></p>
<pre><code>    前面的文件 test.c 其权限为“rw-rw-r--”，因此其十进制表示就是：664。

    另外我们也开始使用 a、u、g 和 o 表示文件的归属关系，用=、+和-表示文件权限的变化， 如下表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3ca28a83c1229c2b850b18f568c0c362.png"></p>
<pre><code>    对于文件 test.c，我们想要修改其归属用户(zuozhongkai)对其拥有可执行权限，那么就可以 使用：u+x。如果希望设置归属用户及其所在的用户组都对其拥有可执行权限就可以使用：gu+x。
</code></pre>
<h6 id="3-权限管理命令"><a href="#3-权限管理命令" class="headerlink" title="3.权限管理命令"></a>3.权限管理命令</h6><pre><code>    可以使用 Shell 来操作文件的权限管理，主要用到“chmod”和“chown”这两个命令：
</code></pre>
<h6 id="1、权限修改命令-chmod"><a href="#1、权限修改命令-chmod" class="headerlink" title="1、权限修改命令 chmod"></a>1、权限修改命令 chmod</h6><pre><code>    命令“chmod”用于修改**文件或者文件夹的权限** ，权限可以使用前面讲的数字表示也可以 使用字母表示，命令格式如下：


chmod [参数] [文件名/目录名]
主要参数如下：
-c 效果类似“-v”参数，但仅回显更改的部分。
-f 不显示错误信息。
-R 递归处理，指定目录下的所有文件及其子文件目录一起处理。
-v 显示指令的执行过程。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3045966479f706fd2acc5cde644c1850.png"></p>
<pre><code>    在上图中，我们修改文件 test 的权限为 766，修改完成以后的 test 文件权限为“rwxrw-rw-”， 和我们设置的一样，说明权限修改成功。上面我们是通过数字来修改权限的，我们接下来使用字母来修改权限，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bd35ca1b6e1e1629e108c746630441f.png"></p>
<pre><code>    上面两个例子都是修改文件的权限，接下来我们修改文件夹的权限，新建一个 test 文件夹， 在文件夹 test 里面创建 a.c、b.c 和 c.c 三个文件，test 文件夹下的文件 a.c、b.c 和 c.c 的权限均为“rw-rw-r--”，我们将 test 文件夹 下的所有文件权限都改为“rwxrwxrwx”，也就是数字 777，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f7b16b3540313a758a86add48c277a8.png"></p>
<h6 id="2、文件归属者修改命令-chown"><a href="#2、文件归属者修改命令-chown" class="headerlink" title="2、文件归属者修改命令 chown"></a>2、文件归属者修改命令 chown</h6><p>命令 chown 用来修改某个文件或者目录的归属者用户或者用户组，命令格式如下：</p>
<pre><code>chown [参数] [用户名.&lt;组名&gt;] [文件名/目录]
其中[用户名.&lt;组名&gt;]表示要将文件或者目录改为哪一个用户或者用户组，用户名和组名用
“.”隔开，其中用户名和组名中的任何一个都可以省略，命令主要参数如下：
-c 效果同-v 类似，但仅回显更改的部分。
-f 不显示错误信息。
-h 只对符号连接的文件做修改，不改动其它任何相关的文件。
-R 递归处理，将指定的目录下的所有文件和子目录一起处理。
-v 显示处理过程。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7241a6cc8931d0f72cc27bb10effe8c.png"></p>
<h4 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="&lt;6&gt;Linux 磁盘管理"></a>&lt;6&gt;Linux 磁盘管理</h4><h5 id="1-Linux-磁盘管理基本概念"><a href="#1-Linux-磁盘管理基本概念" class="headerlink" title="1.Linux 磁盘管理基本概念"></a>1.Linux 磁盘管理基本概念</h5><pre><code>    Linux 的磁盘管理体系和 Windows 有很大的区别，在 Windows 下经常会遇到“分区”这个概念，在 Linux 中一般不叫“分区”而叫**“挂载点”** 。 “挂载点”就是将一个硬盘的一部 分做成文件夹的形式，这个文件夹的名字就是“挂载点”，不管在哪个发行版的 Linux 中，用 户是绝对看到不到 C 盘、D 盘这样的概念的，只能看到以文件夹形式存在的“挂载点”。
</code></pre>
<p>文件&#x2F;etc&#x2F;fstab 详细的记录了 Ubuntu 中硬盘分区的情况：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a3bc3e97a3d219def7e1c541dbed467.png"></p>
<pre><code>    “/ was on /dev/sda1 during installation”，意思是根目录“/”是在/dev/sda1 上的，其中“/”是挂载点，**“/dev/sda1”就是我们装 Ubuntu 系统的硬盘** 。由于我们的系统是安装在虚拟机中的，因此图 中没有出现实际的硬盘。可以通过如下命令查看当前系统中的磁盘：


ls /dev/sd*
</code></pre>
<p>上述命令就是打印出所有以&#x2F;dev&#x2F;sd 开头的设备文件</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cec4bbd0cada4073445feeeb68007f2f.png"></p>
<pre><code>    在图中有四个磁盘设备文件，其中**sd 表示是 SATA 硬盘或者其它外部设备** ，最后面的数字表示该**硬盘上的第 n 个分区** ，比如/dev/sda1 就表示磁盘 sda 上的第一个分区。图中都是以/dev/sda 开头的，说明当前只有一个硬盘。如果再插上 U 盘、SD 卡啥的就可能会出 现/dev/sdb，/dev/sdc 等等。如果你的 U 盘有两个分区那么可能就会出现/dev/sdb1、dev/sdb2 这 样的设备文件。比如我现在插入我的 U 盘，插入 U 盘会提示 U 盘是接到主机还是虚拟机
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7293b9ea5d13716ed4cf99bf1a73f2a0.png"></p>
<h5 id="2-磁盘管理命令"><a href="#2-磁盘管理命令" class="headerlink" title="2.磁盘管理命令"></a>2.磁盘管理命令</h5><h6 id="1、磁盘分区命令-fdisk"><a href="#1、磁盘分区命令-fdisk" class="headerlink" title="1、磁盘分区命令 fdisk"></a>1、磁盘分区命令 fdisk</h6><p>如果要对某个磁盘进行分区，可以使用命令 fdisk，命令格如下：</p>
<pre><code>fdisk [参数]
主要参数如下：
-b&lt;分区大小&gt; 指定每个分区的大小。
-l 列出指定设备的分区表。
-s&lt;分区编号&gt; 将指定的分区大小输出到标准的输出上，单位为块。
-u 搭配“-l”参数，会用分区数目取代柱面数目，来表示每个分区的起始地址。

    比如我要对 U 盘进行分区，**千万不要对自己装 Ubuntu 系统进行分区！！！** 可以使用如下命令：


sudo fdisk /dev/sdb
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b79740fbfb552d056496462ceab27102.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42ca5bc370ae284b9d794f1b74a1eff.png"></p>
<p>p 显示现有的分区</p>
<p>n 建立新分区</p>
<p>t 更改分区类型</p>
<p>d 删除现有的分区</p>
<p>a 更改分区启动标志</p>
<p>w 对分区的更改写入到硬盘或者存储器中</p>
<p>q 不保存退出</p>
<h6 id="2、格式化命令-mkfs"><a href="#2、格式化命令-mkfs" class="headerlink" title="2、格式化命令 mkfs"></a>2、格式化命令 mkfs</h6><pre><code>    使用命令 fdisk 创建好一个分区以后，我们需要对其格式化，也就是在这个分区上创建一 个文件系统，Linux 下的格式化命令为 mkfs，命令格式如下：


mkfs [参数] [-t 文件系统类型] [分区名称]
主要参数如下：
fs 指定建立文件系统时的参数
-V 显示版本信息和简要的使用方法。
-v 显示版本信息和详细的使用方法。
</code></pre>
<p>比如我们要格式化 U 盘的分区&#x2F;dev&#x2F;sdb1 为 FAT 格式，那么就可以使用如下命令：</p>
<pre><code>mkfs –t vfat /dev/sdb1
</code></pre>
<h6 id="3、挂载分区命令-mount"><a href="#3、挂载分区命令-mount" class="headerlink" title="3、挂载分区命令 mount"></a>3、挂载分区命令 mount</h6><pre><code>    我们需要将/dev/sdb1 这个**分区挂载到一个文件夹中，然后通过这个文件访问 U 盘** ， 磁盘挂载命令为 mount，命令格式如下：


mount [参数] -t [类型] [设备名称] [目的文件夹]
命令主要参数有：
-V 显示程序版本。
-h 显示辅助信息。
-v 显示执行过程详细信息。
-o ro 只读模式挂载。
-o rw 读写模式挂载。
-s-r 等于-o ro。
-w 等于-o rw。


    一般我们把挂载点放到“/mnt” 目录下，在“/mnt”下创建一个 tmp 文件夹，然后将 U 盘的/dev/sdb1 分区挂载到/mnt/tmp 文 件夹里面，操作如图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07d3a057fe42131964d315015bc0a845.png"></p>
<h6 id="4、卸载命令-umount"><a href="#4、卸载命令-umount" class="headerlink" title="4、卸载命令 umount"></a>4、卸载命令 umount</h6><pre><code>    当我们不在需要访问已经挂载的 U 盘，可以通过 umount 将其从卸载点卸除，命令格式如下：


umount [参数] -t [文件系统类型] [设备名称]
-a 卸载/etc/mtab 中的所有文件系统。
-h 显示帮助。
-n 卸载时不要将信息存入到/etc/mtab 文件中
-r 如果无法成功卸载，则尝试以只读的方式重新挂载。
-t &lt;文件系统类型&gt; 仅卸载选项中指定的文件系统。
-v 显示执行过程。

    上面我们将 U 盘挂载到了文件夹/mnt/tmp 里面，这里我们使用命令 umount 将其卸载掉， 操作如图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4d8dc86df68eec73b0027777819655.png"></p>
<h3 id="3-Linux-C-编程入门"><a href="#3-Linux-C-编程入门" class="headerlink" title="3.Linux C 编程入门"></a>3.Linux C 编程入门</h3><pre><code>    Ubuntu 下也有一些可以进行编程的工具，但是大多都只是编辑 器，也就是只能进行代码编辑，如果要编译的话就需要用到 **GCC 编译器** ，使用 GCC 编译器 肯定就要接触到 **Makefile** 。本章就讲解如何在 Ubuntu 下进行 C 语言的编辑和编译、GCC 和 Makefile 的使用和编写。

    代码编写工具很多，比如 VIM 编辑器、Emacs 编辑器、VScode 编辑器等等，本教程使用 Ubuntu 自带的 VIM 编辑器。
</code></pre>
<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="&lt;1&gt;编写代码"></a>&lt;1&gt;编写代码</h4><p>首先设置 TAB 键为 4 字节</p>
<pre><code>    VI 编辑器默认 TAB 键为 8 空格，我们改成 4 空格，用 vi 打开文件/etc/vim/vimrc，在此文件最后面输入如下代码：


set ts=4
</code></pre>
<p>接着设置 VIM 编辑器显示行号：</p>
<pre><code>set nu
</code></pre>
<p>然后使用vim编写代码保存。</p>
<h4 id="编译代码"><a href="#编译代码" class="headerlink" title="&lt;2&gt;编译代码"></a>&lt;2&gt;编译代码</h4><p>Ubuntu 下的 C 语言编译器是 GCC，GCC 编译器在我们安装 Ubuntu 的时候就已经默认安 装好了，可以通过如下命令查看 GCC<br>编译器的版本号：</p>
<pre><code>gcc -v

    如果输入命令“gcc -v”命令以后，你的终端输出信息，那么说明你 的电脑已经有 GCC 编译器了。最后下面的“gcc version 5.4.0”说明本机的 GCC 编译器版本为 5.4.0 的。注意观察在图 3.1.2.1 中有**“Target: x86_64-linux-gnu”** 一行，这说明 Ubuntu 自带的 GCC 编译器是针对 X86 架构的，因此只能编译在 X86 架构 CPU 上运行的程序。如果想要编译在 ARM 上运行的程序就需要针对 ARM 架构的 GCC 编译器，也就是**交叉编译器** ！我们进行 ARM 开发，因此肯定要安装**针对 ARM 架构的 GCC 交叉编译器** ，当然了，这是后面的事， 现在我们不用管这些，只要知道不同的目标架构，其 GCC 编译器是不同的。

    如何使用 GCC 编译器来编译 main.c 文件呢？GCC 编译器是命令模式的，因此需要输入命 令来使用 gcc 编译器来编译文件，输入如下命令：


gcc main.c -o main

    我们使用“gcc main.c –o main”来编译 main.c 文件，使用参数“-o”来指 定编译生成的可执行文件名字。
</code></pre>
<h4 id="GCC-编译器"><a href="#GCC-编译器" class="headerlink" title="&lt;3&gt;GCC 编译器"></a>&lt;3&gt;GCC 编译器</h4><h5 id="1、gcc-命令格式如下："><a href="#1、gcc-命令格式如下：" class="headerlink" title="1、gcc 命令格式如下："></a>1、gcc 命令格式如下：</h5><pre><code>gcc [选项] [文件名字]
主要选项如下：
-c 只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。
-o&lt;输出文件名&gt; 用来指定编译结束以后的输出文件名，如果不使用这个选项的话 GCC
默认编译出来的可执行文件名字为 a.out。
-g 添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编
译的时候生成调试所需的符号信息。
-O 对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进
行优化，这样产生的可执行文件执行效率就高。
-O2 比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。
</code></pre>
<h5 id="2、编译流程"><a href="#2、编译流程" class="headerlink" title="2、编译流程"></a>2、编译流程</h5><pre><code>    GCC 编译器的编译流程是：**预处理、汇编、编译和链接** 。预处理就是对程序中的宏定义等相关的内容先进行前期的处理。汇编是先将 C 文件转换为汇编文件。当 C 文件转换为汇编文件以后就是文件编译了，**编译过程就是将 C 源文件编译成.o 结尾的目标文件** 。编译生成的.o 文件不能直接执行，而是需要最后的链接，如果你的工程有很多个 c 源文件的话最终就会有很多.o 文件，将这些**.o 文件链接在一起形成完整的一个可执行文件** 。
</code></pre>
<h4 id="Makefile-基础"><a href="#Makefile-基础" class="headerlink" title="&lt;4&gt;Makefile 基础"></a>&lt;4&gt;Makefile 基础</h4><h6 id="1、Makefile-简介"><a href="#1、Makefile-简介" class="headerlink" title="1、Makefile 简介"></a>1、Makefile 简介</h6><pre><code>    当文件数量很多时用终端输入 GCC 命令的方法显然是不现实的。编写一个文件，这个文件描述了编译哪些源码文件、如何编译，每次需要编译工程的时只需要使用这个文件就行了，为此提出了一个 解决**大工程编译的工具** ：**Make** ，**描述哪些文件需要编译、哪些需要重新编译的文件** 就叫做 **Makefile** ，Makefile 就跟脚本文件一样，Makefile 里面还可以执行系统命令。使用的时候只需要一个 make 命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。如果大家以 前一直使用 IDE 来编写 C 语言的话肯定没有听说过 Makefile 这个东西，其实这些 IDE 是有的， 只不过这些 **IDE 对其进行了封装** ，提供给大家的是已经经过封装后的图形界面了，我们在 IDE 中添加要编译的 C 文件，然后点击按钮就完成了编译。在 Linux 下用的最多的是 GCC 编译器， 这是个没有 UI 的编译器，因此 Makefile 就需要我们自己来编写了。作为一个专业的程序员， 是一定要懂得 Makefile 的，一是因为在 Linux 下你不得不懂 Makefile，再就是通过 Makefile 你就能了解整个工程的处理过程。如果想详细的研究 Makefile，推荐阅读《跟我一起写 Makefile》这份文档。
</code></pre>
<h6 id="2、Makefile-的引入"><a href="#2、Makefile-的引入" class="headerlink" title="2、Makefile 的引入"></a>2、Makefile 的引入</h6><pre><code>    我们完成这样一个小工程，在这个工程中我们有 main.c、input.c 和 calcu.c 这三个 C 文件和 input.h、calcu.h 这两个头文件。其中 main.c 是主体。接下来使用 gcc 的方法来对其进行编译， 在终端输入如下命令：


gcc main.c calcu.c input.c -o main

   如果有一个文件被修改了，使用上面的命令编译的时候所有的文件都会重新编译。最好的办法肯定是哪个文件被修改了，只编译这个修改的文件即可，其它没有修改的文件就不需要再次重新编译了，为此我们改变我们的编译方法，如果第一次编译工程，我们先将工程中的文件都编译一遍，然后后面修改了哪个文件就编译哪个文件， 命令如下：


gcc -c main.c
gcc -c input.c
gcc -c calcu.c
gcc main.o input.o calcu.o -o main

    上述命令前三行分别是将 main.c、input.c 和 calcu.c 编译成对应的.o 文件，所以使用了“-c” 选项，**“-c”选项我们上面说了，是只编译不链接** 。最后一行命令是将编译出来的所有.o 文件链接成可执行文件 main。假如我们现在修改了 calcu.c 这个文件，**只需要将 caclue.c 这一个文 件重新编译成.o 文件，然后再将所有的.o 文件链接成可执行文件** ，只需要下面两条命令即可：


gcc -c calcu.c
gcc main.o input.o calcu.o -o main

    但是这样就又有一个问题，如果修改的文件一多，会非常麻烦，为此我们需要这样一个工具：
</code></pre>
<p>1、如果工程没有编译过，那么工程中的所有.c 文件都要被编译并且链接成可执行程序。</p>
<p>2、如果工程中只有个别 C 文件<strong>被修改</strong> 了，那么<strong>只编译这些被修改的 C 文件即可</strong> 。</p>
<p>3、如果工程的<strong>头文件被修改了，那么我们需要编译所有引用这个头文件的 C 文件</strong> ，并且 链接成可执行文件。</p>
<pre><code>    很明显，能够完成这个功能的就是 Makefile 了，在工程目录下创建名为“Makefile”的文件， 文件名**一定要叫做“Makefile”！！！区分大小写** ！

    Makefile 和 C 文件可以处于同一个目录的，在 Makefile 文件中输入如下代码：


main: main.o input.o calcu.o
    gcc -o main main.o input.o calcu.o
main.o: main.c
    gcc -c main.c
input.o: input.c
    gcc -c input.c
calcu.o: calcu.c
    gcc -c calcu.c

clean:
    rm *.o
    rm main

    上述代码中所有行首需要空出来的地方一定要**使用“TAB”键！不要使用空格键！** 这是 Makefile 的语法要求。**（可以看出这里的Makefile文件类似于脚本，把所有文件编译指令集合）**

    Makefile 编写好以后我们就可以使用 Make 命令来编译我们的工程了，直接在命令行中输 入“make”即可，Make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在 的话就会按照 Makefile 里面定义的编译方式进行编译。

    使用命令“Make”编译完成以后就会在当前工程目录下生成各种.o 和可执行文件，说明我们编译成功了。使用 make 命令编译工程的时候可能会提示如图所示错误:
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/272c8273e54202132793b1944a9cab74.png"></p>
<p>错误来源一般有两点:</p>
<p>1、Makefile 中命令缩进没有使用 TAB 键！</p>
<p>2、VI&#x2F;VIM 编辑器使用空格代替了 TAB 键，修改文件&#x2F;etc&#x2F;vim&#x2F;vimrc，在文件最后面加上 如下所示代码：</p>
<pre><code>set noexpandtab

    之后再输入make指令只会重新编译被修改的文件和最后的可执行文件，其它没有修改过的文件就没有编译。
</code></pre>
<h6 id="3、Makefile-语法"><a href="#3、Makefile-语法" class="headerlink" title="3、Makefile 语法"></a>3、Makefile 语法</h6><h6 id="①Makefile-规则格式"><a href="#①Makefile-规则格式" class="headerlink" title="①Makefile 规则格式"></a>①Makefile 规则格式</h6><p>Makefile 里面是由一系列的<strong>规则</strong> 组成的，这些规则格式如下：</p>
<pre><code>目标…... : 依赖文件集合……
    命令 1
    命令 2
    ……
</code></pre>
<p>比如下面这条规则：</p>
<pre><code>main : main.o input.o calcu.o
    gcc -o main main.o input.o calcu.o


    这条规则的**目标** 是 main，main.o、input.o 和 calcu.o 是生成 main 的**依赖文件** ，如果要更新 目标 main，就必须要先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目 标也必须更新，“更新”就是执行一遍规则中的**命令列表** 。

    命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ make 命令会为 Makefile 中的每个**以 TAB 开始的命令创建一个 Shell 进程去执行** 。

    在之前的代码中一共有 5 条规则，1~2 行为第一条规则，3~4 行为第二条规则，5~6 行为第三 条规则，7~8 行为第四条规则，10~12 为第五条规则，make 命令在执行这个 Makefile 的时候其执行步骤如下：

   **  首先更新第一条规则中的 main**，第一条规则的目标成为**默认目标** ，**只要默认目标更新了那么就完成了 Makefile 的工作** ，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行。

    第一条规则依赖于文件 main.o、input.o 和 calcu.o 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make 会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为**“gcc –c main.c”** ，这行命令很熟悉了 吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。

    最后一个规则目标是 clean， 它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令**“make clean”** ，**执行以后就会删除当前目录下所有的.o 文件以及 main** ，因此 clean 的功能就是完成**工程的清理** 。
</code></pre>
<p>我们在来总结一下 Make 的执行过程：</p>
<ol>
<li><p>make 命令会在当前目录下查找以 Makefile(makefile 其实也可以)命名的文件。</p>
</li>
<li><p>当找到 Makefile 文件以后就会<strong>按照 Makefile 中定义的规则去编译</strong> 生成最终的目标文件。</p>
</li>
<li><p>当发现目标文件<strong>不存在</strong> ，或者目标<strong>所依赖的文件比目标文件新</strong>(也就是最后修改时间比目标文件晚)的话就会<strong>执行后面的命令来更新目标</strong> 。</p>
<pre><code> **除了 Makefile 的“终极目标”所在的规则以外，其它规则的顺序在 Makefile 中是没有意义的** ，“终极目标”就是指在使用 make 命令的时候没有指定具体的目标时，make 默认的那个目标，它是 Makefile 文件中**第一个规则** 的目标，如果 Makefile 中的第一个规则有多个目标， 那么这些目标中的**第一个目标** 就是 make 的“终极目标”。
</code></pre>
</li>
</ol>
<h6 id="②Makefile-变量"><a href="#②Makefile-变量" class="headerlink" title="②Makefile 变量"></a>②Makefile 变量</h6><p>跟 C 语言一样 Makefile 也支持变量的，先看一下前面的例子：</p>
<pre><code> main: main.o input.o calcu.o
     gcc -o main main.o input.o calcu.o

    上述 Makefile 语句中，main.o input.o 和 calcue.o 这三个依赖文件，我们输入了两遍，我们 这个 Makefile 比较小，如果 Makefile 复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile 加入了**变量支持** 。Makefile 中的变量都是**字符串** ！**类似 C 语言中的宏** 。使用变量将上面的代码修改，修改以后如下所示：


#Makefile 变量的使用
objects = main.o input.o calcu.o
main: $(objects)
    gcc -o main $(objects)

    第 1 行是注释，Makefile 中可以写注释，**注释开头要用符号“#”** ，第 2 行我们定义了一个变量 objects， 并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行使用到了变 量 objects，Makefile 中**变量的引用方法是“$(变量名)”** ，比如本例中的“$(objects)”就是使用 变量 objects。

    在“示例代码中我们在定义变量 objects 的时候使用**“=”** 对其进行了赋值，Makefile 变量的赋值符还有其它两个**“:=”和“?=”** ，我们来看一下这三种赋值符的区别：
</code></pre>
<p><strong>1、赋值符“&#x3D;”</strong></p>
<pre><code>    使用“=”在给变量的赋值的时候，**不一定要用已经定义好的值，也可以使用后面定义的值** ，比如如下代码：


name = zzk
curname = $(name)
name = zuozhongkai

print:
	@echo curname: $(curname)

    我们来分析一下上述代码，第 1 行定义了一个变量 name，变量值为“zzk”，第 2 行也定义了一个变量 curname，curname 的变量值引用了变量 name，按照我们 C 写语言的经验此时 curname 的值就是“zzk”。第 3 行将变量 name 的值改为了“zuozhongkai”，第 5、6 行是输 出变量 curname 的值。在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf” 一样，第 6 行中的“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，**在命令前面加上“@”的话就不会输出命令执行过程** ，大家可以测试一下不加“@” 的效果。使用命令**“make print”** 来执行上述代码。借助另外一个变量，可以将变量的真实值推到后面去定义。也就是**变量的真实值取决于它所引用的变量的最后一次有效值** 。
</code></pre>
<p><strong>2、赋值符“:&#x3D;”</strong></p>
<pre><code>    修改上述代码第 2 行，将 其中的“=”改为“:=”。此时的 curname 是 zzk，不是 zuozhongkai 了。这是因为**赋值符“:=” 不会使用后面定义的变量** ，只能使用前面已经定义好的，这就是“=”和“:=”两个的区别。
</code></pre>
<p><strong>3、赋值符“?&#x3D;”</strong></p>
<pre><code>    **如果变量 curname 前面没有被赋值，那么此变量就是“zuozhongkai”** ， **如果前面已经赋过值了，那么就使用前面赋的值** 。
</code></pre>
<p><strong>4、变量追加“+&#x3D;”</strong></p>
<pre><code>    Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量**添加一些字符串进 去** ，此时就要使用到符号“+=”，比如如下所示代码：


    objects = main.o inpiut.o
    objects += calcu.o
</code></pre>
<p>一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此 变量 objects<br>变成了“main.o input.o calcu.o”，这个就是变量的追加。</p>
<h6 id="③Makefile-模式规则"><a href="#③Makefile-模式规则" class="headerlink" title="③Makefile 模式规则"></a>③Makefile 模式规则</h6><pre><code>    上述 Makefile 中第 3~8 行是将对应的.c 源文件编译为.o 文件，每一个 C 文件都要写一个对应的规则，如果工程中 C 文件很多的话显然不能这么做。为此，我们可以使用 Makefile 中的**模式规则** ，通过模式规则我们就可以**使用一条规则来将所有的.c 文件编译为对应的.o 文件** 。

    模式规则中，**至少在规则的目标定定义中要包涵“%”，否则就是一般规则** ，目标中的**“%” 表示对 文件名的匹配**，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾 的文件，**类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件** 。

    当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值，使用 方法如下：


%.o : %.c
    命令


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)

%.o : %.c
	#命令

clean:
	rm *.o 
	rm main

    修改以后的 Makefile 还不能运行，因为第 6 行的命令还没写，第 6 行的命令我们需要借助另外一种强大的变量—**自动化变量** 。
</code></pre>
<h6 id="④Makefile-自动化变量"><a href="#④Makefile-自动化变量" class="headerlink" title="④Makefile 自动化变量"></a>④Makefile 自动化变量</h6><pre><code>    上面讲的模式规则中，**目标和依赖都是一系列的文件** ，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而命令只有一行，如何通过一行命令来从不同的依赖文件中生成对应的目标呢？自动化变量就是完成这个功能的！所谓自动化变量就是这种变量会**把模式中所定义的一系列的文件自动的挨个取出** ，**直至所有的符合模式的文件都取完** ，自动化变量**只应该出现在规则的命令中** ，常用的自动化变量如表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdafd022717f6cc1113bf86481167cbf.png"></p>
<pre><code>    表中的 7 个自动化变量中，常用的三种：**$@、$ &lt;和$^**，我们使用自动化变量来完 成“示例代码中的 Makefile，最终的完整代码如下所示：


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)

%.o : %.c
	gcc -c $&lt;
	
clean:
	rm *.o 
	rm main
</code></pre>
<h6 id="⑤Makefile-伪目标"><a href="#⑤Makefile-伪目标" class="headerlink" title="⑤Makefile 伪目标"></a>⑤Makefile 伪目标</h6><pre><code>    Makefile 有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而**伪目标不代表真正的目标名** ，在执行 make 命令的时候通过**指定这个伪目标来执行其所在规则的定义的命令** 。

    使用伪目标的主要是为了避免 Makefile 中定义的只**执行命令的目标 和工作目录下的实际文件出现名字冲突**，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面代码规则“clean”代码用来完成清理工程的功能。

    上述规则中并没有创建文件 clean 的命令，因此工作目录下永远都**不会存在文件 clean** ，当 我们输入**“make clean”** 以后，后面的“rm *.o”和“rm main”总是会执行。可是如果我们“手贱”，在工作目录下**创建一个名为“clean”的文件** ，那就不一样了，当执行“make clean”的 时候，**规则因为没有依赖文件，所以目标被认为是最新的，因此后面的 rm 命令也就不会执行** ， 我们预先设想的清理工程的功能也就无法完成。为了避免这个问题，我们可以将 clean 声明为 伪目标，声明方式如下：


.PHONY : clean


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)
	
.PHONY : clean

%.o : %.c
	gcc -c $&lt;
	
clean:
	rm *.o 
	rm main

    上述代码第 5 行声明 clean 为伪目标，声明 clean 为伪目标以后不管当前目录下是否存在名为“clean”的文件，**输入 “make clean”的话规则后面的 rm 命令都会执行**。
</code></pre>
<h6 id="⑥Makefile-条件判断"><a href="#⑥Makefile-条件判断" class="headerlink" title="⑥Makefile 条件判断"></a>⑥Makefile 条件判断</h6><p>语法有两种如下：</p>
<pre><code>&lt;条件关键字&gt;
    &lt;条件为真时执行的语句&gt;
endif
以及：
&lt;条件关键字&gt;
    &lt;条件为真时执行的语句&gt;
else
    &lt;条件为假时执行的语句&gt;
endif

    其中条件关键字有 4 个：**ifeq、ifneq、ifdef 和 ifndef** ，这四个关键字其实分为两对、ifeq 与 ifneq、ifdef 与 ifndef，先来看一下 ifeq 和 ifneq，ifeq 用来判断是否相等，ifneq 就是判断是 否不相等，ifeq 用法如下：


ifeq (&lt;参数 1&gt;, &lt;参数 2&gt;)
ifeq ‘&lt;参数 1 &gt;’，‘&lt;参数 2&gt;’ 
ifeq “&lt;参数 1&gt;”，“&lt;参数 2&gt;”
ifeq “&lt;参数 1&gt;”，‘&lt;参数 2&gt;’
ifeq ‘&lt;参数 1&gt;’, “&lt;参数 2&gt;”

    上述用法中都是用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1” 和“参数 2”可以为函数返回值。ifneq 的用法类似，只不过 ifneq 是用来了比较“参数 1”和 “参数 2”是否不相等，如果不相等的话就为真。

    ifdef 和 ifndef 的用法如下：


ifndef &lt;变量名&gt;

    如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以 是一个函数的返回值。ifndef 用法类似，但是含义与 ifdef 相反。
</code></pre>
<h6 id="⑦Makefile-函数使用"><a href="#⑦Makefile-函数使用" class="headerlink" title="⑦Makefile 函数使用"></a>⑦Makefile 函数使用</h6><pre><code>    Makefile 支持函数，类似 C 语言一样，Makefile 中的函数是已经定义好的，我们直接使用， 不支持我们自定义函数。make 所支持的函数不多，但是绝对够我们使用了，函数的用法如下：


$(函数名 参数集合)
或者
$&#123;函数名 参数集合&#125;

    可以看出，**调用 函数和调用普通变量一样，使用符号“$”来标识**。参数集合是函数的多个参数，**参数之间以逗号“,”隔开** ，**函数名和参数之间以“空格”分隔开** ，函数的调用以“$” 开头。接下来我们介绍几个常用的函数，其它的函数大家可以参考《跟我一起写 Makefile》这份文档。
</code></pre>
<p><strong>1、函数 subst</strong></p>
<p>函数 subst 用来完成<strong>字符串替换</strong> ，调用形式如下：</p>
<pre><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)
</code></pre>
<p><strong>2、函数 patsubst</strong></p>
<p>函数 patsubst 用来完成<strong>模式字符串替换</strong> ，使用方法如下：</p>
<pre><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)


    此函数查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来  
</code></pre>
<p>替换掉，<pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换<br>后的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern><br>中的那个“%”所代表的字符串，比如：</p>
<pre><code>$(patsubst %.c,%.o,a.c b.c c.c)

    将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的 字符串为“a.o b.o c.o”。
</code></pre>
<p><strong>3、函数 dir</strong></p>
<p>函数 dir 用来获取目录，使用方法如下：</p>
<pre><code>$(dir &lt;names…&gt;

    此函数用来从文件名序列中提取出目录部分，返回值是文件名序列的目 录部分，比如：


$(dir &lt;/src/a.c&gt;)

    提取文件“/src/a.c”的目录部分，也就是“/src”。
</code></pre>
<p><strong>4、函数 notdir</strong></p>
<p>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：</p>
<pre><code>$(notdir &lt;names…&gt;)

    上个例子“dir”改成“notdir”结果是文件名“a.c”。
</code></pre>
<p><strong>5、函数 foreach</strong></p>
<p>foreach 函数用来完成循环，用法如下：</p>
<pre><code>$(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)

    此函数的意思就是把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;  
</code></pre>
<p>所包含的表达式。每次<text>都会返回一个字符串，循环的过程中，<text>中所包含的每个字<br>符串会以空格隔开，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串<br>将会是函数 foreach 函数的返回值。</p>
<p><strong>6、函数 wildcard</strong></p>
<pre><code>    通配符“%”只能用在规则中，只有在规则中它才会展开，**如果 在变量定义和函数使用时， 通配符不会自动展开，这个时候就要用到函数 wildcard**，使用方法如下：


$(wildcard PATTERN…)
</code></pre>
<p>比如：</p>
<pre><code>$(wildcard *.c)

    上面的代码是用来获取当前目录下所有的.c 文件，类似“%”。
</code></pre>
<h3 id="4-其他资料"><a href="#4-其他资料" class="headerlink" title="4.其他资料"></a>4.其他资料</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29235669" title="9个Linux系统常用监控命令">9个Linux系统常用监控命令<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://zhuanlan.zhihu.com/p/29235669</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/renfufei/article/details/105851728" title="Linux系统命令 - 查看内存使用情况">Linux系统命令 - 查看内存使用情况<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/renfufei/article/details/105851728</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）">图像识别小车（jetson nano部分）——电赛学习笔记（3）<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;131511658</a></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133484963">https://blog.csdn.net/qq_32971095/article/details/133484963</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/FPGA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C0%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:31:36" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p>
<p><a href="about:blank#%E4%B8%80.FPGA%C2%A0">一.FPGA </a></p>
<p><a href="about:blank#%E4%BA%8C.FPGA%2BAI">二.FPGA+AI</a></p>
<p><a href="about:blank#%E4%B8%89.HDL">三.HDL</a></p>
<p><a href="about:blank#%E5%9B%9B.XILINX">四.XILINX</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">五.学习资源</a></p>
<p><a href="about:blank#%E5%85%AD.%E5%85%B6%E4%BB%96">六.硬件命名规则</a></p>
<p><a href="about:blank#%E4%B8%83.vivado%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">七.vivado使用介绍</a></p>
<p>[八.FPGA Arm-Cortex-M1软核配置](about:blank#%E5%85%AB.FPGA%20Arm-<br>Cortex-M1%E8%BD%AF%E6%A0%B8%E9%85%8D%E7%BD%AE)</p>
<p><a href="about:blank#%E4%B9%9D.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">九.xilinx Zynq UltraScale+ MPSoC
</a></p>
<p><a href="about:blank#%E5%8D%81.%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E6%B1%87%E6%80%BB">十.学习实践汇总</a></p>
<hr>
<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><p>作者的“FPGA学习笔记”系列将采用野火 XILINX-Artix7-FPGA 升腾开发板作为学习平台进行学习，总结学习过程中的收获。</p>
<p><strong>学习实践汇总</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132308209?spm=1001.2014.3001.5502" title="​​​​​​verilog语法——FPGA学习笔记＜1＞">​​​​​​verilog语法——FPGA学习笔记＜1＞<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132308209?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132314807?spm=1001.2014.3001.5502" title="基础设计一——FPGA学习笔记＜2＞">基础设计一——FPGA学习笔记＜2＞xilinx FPGA<br>verilog工程设计流程<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132314807?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132779996?spm=1001.2014.3001.5502" title="基础设计二（IP核）——FPGA学习笔记＜3＞">基础设计二（IP核）——FPGA学习笔记＜3＞xilinx fpga<br>基础设计学习笔记，学习资料来自野火<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132779996?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132818565?spm=1001.2014.3001.5502" title="基础设计三（RS232、I2C）——FPGA学习笔记＜4＞">基础设计三（RS232、I2C）——FPGA学习笔记＜4＞参考书目：《野火FPGA Verilog<br>开发实战指南》<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132818565?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132993678?spm=1001.2014.3001.5502" title="基础设计四（信号采集、发生）——FPGA学习笔记＜5＞">基础设计四（信号采集、发生）——FPGA学习笔记＜5＞频率测量法：在时间 t 内对被测时钟信号的时钟周期 N<br>进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率。周期测量法：先测量出被测时钟信号的时钟周期 T，然后根据频率 f &#x3D; 1／T<br>求出被测时钟信号的频率。但是上述两种方法都会产生±1<br>个被测时钟周期的误差，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量，但二者都不能兼顾高低频率同样精度的测量要求。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;132993678?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133174030?spm=1001.2014.3001.5502" title="基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞">基础设计五（LCD液晶屏）——FPGA学习笔记＜6＞液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态，<br>但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会<br>改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率<br>的作用，再配合彩色滤光片，改变加给液晶电压大小，就能改变某一颜色透光量的多少。​。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133174030?spm&#x3D;1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133233092?spm=1001.2014.3001.5502" title="Zynq简介——FPGA学习笔记＜7＞">Zynq简介——FPGA学习笔记＜7＞Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on<br>Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和<br>Virtex 系列。每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和<br>UltraScale+（16nm），以提供不同的性能和功耗比。<img src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;133233092?spm&#x3D;1001.2014.3001.5502</a></p>
<h2 id="一-FPGA"><a href="#一-FPGA" class="headerlink" title="一.FPGA"></a>一.FPGA</h2><p>1.FPGA——可编程逻辑器件，大家都知道。大家可能之前还做过电子线路实验，用过Quartus II，但是当看到各种各样的型号比如Xilinx<br>Artix-7 XC7A35T、Altera Cyclone IV<br>EP4CE10时完全不知道这是什么，推荐看一下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117974989" title="FPGA最全科普总结">FPGA最全科普总结</a></p>
<p>大家还会看到Soc这个词，实际上就像是以前学的mcu：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lqingqing/article/details/51566841" title="MCU, SOC 区别">MCU, SOC<br>区别</a></p>
<p>2.关键名词：</p>
<p>可编程逻辑器件(PLD,Programmable Logic Device)</p>
<p>可编程整列逻辑(PAL,Progarmmable Array Logic)</p>
<p>CPLD(Complex Progarmmable Logic Device)</p>
<p>FPGA(Field Programmable Gate Array)</p>
<p>FPGA配置模式：并行主模式为一片FPGA加一片EPROM的方式；主从模式可以支持一片PROM编程多块FPGA；串行模式可以采用串行PROM编程FPGA；外设模式可以将FPGA作为微处理器的外设，由微处理器对其进行编程</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/efb548d7fce00591ae02781195aab027.png" alt="da0a19b036704759be5eef2f40178dcd.png"></p>
<p>详细硬件介绍：参考图书或</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EE411475Z/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="从零开始系统学FPGA">从零开始系统学FPGA</a></p>
<h2 id="二-FPGA-AI"><a href="#二-FPGA-AI" class="headerlink" title="二.FPGA+AI"></a>二.FPGA+AI</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/89259418a2a5dcdcc118aea94879ed42.png" alt="0b2255268293419fa2598d8863ca129f.png"><br>用FPGA来干什么？方向FPGA+AI：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428224002" title="Xilinx助力FPGA+AI时代">Xilinx助力FPGA+AI时代</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/152167194?source_id=1005" title="两大FPGA公司的“AI技术路线">两大FPGA公司的“AI技术路线</a></p>
<p>FPGA在AI领域的优势：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv13109378/?spm_id_from=333.999.collection.opus.click" title="FPGA图像处理的前景如何？">FPGA图像处理的前景如何？</a></p>
<h2 id="三-HDL"><a href="#三-HDL" class="headerlink" title="三.HDL"></a>三.HDL</h2><p>1.FPGA使用硬件描述语言，可参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617299598" title="《Verilog》·第2章·硬件描述语言基础">《Verilog》·第2章·硬件描述语言基础</a></p>
<p>可能会用到的知识：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337168442583105536&__biz=MzIyMDc2NTQ0Mw==#wechat_redirect" title="基于Verilog的图像处理实现">基于Verilog的图像处理实现</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e33ffc8e402126dade14098a34c12b84.png" alt="01fbbd3b3ead49f68bc9187966e35cf5.png"><br>2.VHDL(VHSIC[Very-High-Speed Integrated Circuit] hardware Description<br>Language)</p>
<p>VHDL支持多层次抽象描述： <strong><strong>行为层次（Behavioral）关注模块功能描述和仿真验证；寄存器传输层次（RTL，Register Transfer<br>Level）关注模块的可综合电路的实现；逻辑门层次（Logic）考虑如何用门级电路实现给定功能；布图层次（Lay<br>Out）考虑如何将电路适配到FPGA的资源中。</strong></strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcec777e5ea768a2abd0eb8059465495.jpeg" alt="a66a88467432488caf83079131890d3d.jpeg"></p>
<p>VHDL基本设计单元：实体（Entity）、构造体（Architecture）、配置（Configuration）；包集合（Package）；库（Library）</p>
<p>3.Verilog HDL</p>
<h2 id="四-XILINX"><a href="#四-XILINX" class="headerlink" title="四.XILINX"></a>四.XILINX</h2><p>xilinx公司的产品系列：<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-devices/fpga.html" title="FPGA 和 3D IC (xilinx.com)">FPGA 和 3D IC<br>(xilinx.com)</a></p>
<p>文档搜索库：<a target="_blank" rel="noopener" href="https://docs.xilinx.com/" title="Homepage • AMD Adaptive Computing
Documentation Portal (xilinx.com)">Homepage • AMD Adaptive Computing Documentation Portal<br>(xilinx.com)</a></p>
<p>Artix-7官方文档：[搜索结果 • AMD 自适应计算文档门户<br>(xilinx.com)](<a target="_blank" rel="noopener" href="https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&content-">https://docs.xilinx.com/search/all?filters=Product_custom~%2522Boards+and+Kits%257CVirtex+7%2522&amp;content-</a><br>lang&#x3D;en-US “搜索结果 • AMD 自适应计算文档门户 (xilinx.com)“)</p>
<p>设计软件平台：</p>
<p>xilinx开发工具有哪些：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv17335988/?spm_id_from=333.999.collection.opus.click" title="Vitis AI 系列视频 QA&amp;目录（待续）">Vitis AI 系列视频<br>QA&amp;目录（待续）</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e0feb3e8280ba4e06a7efb6f968a73b.png" alt="b6db89dc700f40f7bcd5b85b40226fe7.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/477090c37771b370ac8383bca92b9df3.png" alt="2b70623234004a648a9341940d8cc42d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a884e13a6ae351570f5d5a459a8e6615.png" alt="8bf4e434fdf24062be63b880cc577862.png"></p>
<p> Vitis-AI：[Vitis AI (xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/design-">https://china.xilinx.com/products/design-</a><br>tools&#x2F;vitis&#x2F;vitis-<br>ai.html#:~:text&#x3D;Vitis%E2%84%A2%20AI%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%20Xilinx%20%E7%9A%84%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%9C%A8%20Xilinx%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%8C%85%E6%8B%AC%E8%BE%B9%E7%BC%98%E5%99%A8%E4%BB%B6%E5%92%8C%20Alveo,Vitis%20AI%20%E4%BB%A5%E9%AB%98%E6%95%88%E6%98%93%E7%94%A8%E4%B8%BA%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E5%8F%AF%E5%9C%A8%20Xilinx%20FPGA%20%E5%92%8C%20ACAP%20%E4%B8%8A%E5%85%85%E5%88%86%E5%8F%91%E6%8C%A5%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8A%A0%E9%80%9F%E7%9A%84%E6%BD%9C%E5%8A%9B%E3%80%82.<br>“Vitis AI (xilinx.com)“)</p>
<p>Vitis-AI官方支持：<a target="_blank" rel="noopener" href="https://china.xilinx.com/developer/products/vitis-ai.html" title="Vitis
AI 快速上手 (xilinx.com)">Vitis AI 快速上手<br>(xilinx.com)</a></p>
<p>视频：[Vitis AI 全流程讲解<br>(xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-">https://china.xilinx.com/video/events/cns-D1-03-Vitis-AI-Start-</a><br>to-finish_FanZhang_region.html “Vitis AI 全流程讲解 (xilinx.com)“)</p>
<p>Vitis下载：<a target="_blank" rel="noopener" href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vitis.html" title="下载 (xilinx.com)">下载<br>(xilinx.com)</a></p>
<p>注：Vitis是为无FPGA设计经验的人设计的软件开发平台；Vitis-AI是面向算法开发者进行深度学习开发的高级加速库和设计工具；频繁出现的DPU：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145142691" title="科普 | 什么是DPU？">科普 | 什么是DPU？</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4c07fd2ab54f220e025e0ba093c633b.png" alt="7a9ddd30cbdf4a63b7835c9b544bbe84.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/715135ad31ba1890ad0059989b959629.png" alt="96dccbd6cf2047299a08800ca75c7427.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/28c6afc7b5621b2c4ef9da58d3121937.png"></p>
<p>Model Zoo：使用公共数据集训练良好的Caffe、pytorch、TensorFlow框架模型</p>
<p>处理流程：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f36b2ab3b83d541a095d93b84af4e6c3.png" alt="2504e79b6665483da00848b8f78ee776.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/09e7b9fd2103db6fbce09719a58a1d52.png" alt="4a08eebc031e484090a0653b6b345ce2.png"></p>
<p>相关问题对话ChatGPT：<a target="_blank" rel="noopener" href="https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f">https://chat.openai.com/share/2206fea6-39c7-4ec7-9567-d5d14513250f</a></p>
<p>xilinx社区：<a target="_blank" rel="noopener" href="https://xilinx.eetrend.com/" title="电子创新网赛灵思社区 | 电子创新网 (eetrend.com)">电子创新网赛灵思社区 | 电子创新网 (eetrend.com)</a></p>
<p>xilinx技术支持社区：<a target="_blank" rel="noopener" href="https://support.xilinx.com/s/?language=zh_CN" title="主页 (xilinx.com)">主页 (xilinx.com)</a></p>
<h2 id="五-学习资源"><a href="#五-学习资源" class="headerlink" title="五.学习资源"></a>五.学习资源</h2><p>1.竞赛平台提供</p>
<p>FPGA创新大赛：<a target="_blank" rel="noopener" href="http://fpga.icisc.cn/video?value=4" title="培训视频_全国大学生fpga创新设计竞赛官网">培训视频_全国大学生fpga创新设计竞赛官网</a></p>
<p>龙芯杯：[LoongsonEdu&#x2F;nscscc-wiki (gitee.com)](<a target="_blank" rel="noopener" href="https://gitee.com/loongson-">https://gitee.com/loongson-</a><br>edu&#x2F;nscscc-wiki “LoongsonEdu&#x2F;nscscc-wiki (gitee.com)“)</p>
<p>英特尔杯：[英特尔杯在线培训中心](<a href="https://www.xn--48sz67d.xn--">https://www.xn--48sz67d.xn--</a><br>fiqs8s&#x2F;p&#x2F;t_pc&#x2F;course_pc_detail&#x2F;big_column&#x2F;p_624f9a63e4b04e8d902ce9ce<br>“英特尔杯在线培训中心”)</p>
<p>2.野火资源</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="FPGA系列Xilinx Artix7教学视频">FPGA系列Xilinx<br>Artix7教学视频</a></p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/products/link/zh/latest/index.html" title="野火产品资料下载中心">野火产品资料下载中心</a></p>
<p>3.图书资源</p>
<p>《XILINX FPGA设计基础》《XILINX FPGA权威设计指南》《野火FPGAVerilog开发实战指南》</p>
<p>4.b站资源</p>
<p>推荐up主视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dg4y1v7P8/?vd_source=01cde8042a76495bf513aa4407a56cd6" title="第0期 - 介绍与规划 -基于FPGA的数字信号处理系统开发笔记">第0期 - 介绍与规划<br>-基于FPGA的数字信号处理系统开发笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/505234/channel/collectiondetail?sid=308669" title="Vitis&#x2F;Vitis AI开发笔记">Vitis&#x2F;Vitis<br>AI开发笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/473639301/channel/collectiondetail?sid=852953" title="ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis HLS开发">ALINX Zynq MPSoC XILINX FPGA视频教程——Vitis<br>HLS开发</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/2139404925/channel/collectiondetail?sid=197586" title="FPGA图像处理">FPGA图像处理</a></p>
<p>5.正点原子资料</p>
<p>[MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档](<a target="_blank" rel="noopener" href="http://www.openedv.com/docs/boards/fpga/zdyz-">http://www.openedv.com/docs/boards/fpga/zdyz-</a><br>MPSOC.html “MPSoC开发板 — 正点原子资料下载中心 1.0.0 文档”)</p>
<h2 id="六-硬件命名规则"><a href="#六-硬件命名规则" class="headerlink" title="六.硬件命名规则"></a>六.硬件命名规则</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9226e376971648da400fbec74c13e90.png" alt="3e62452446cd4e6db0ddeefee5a67020.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/31c9c122639646bdec9d69319b9313b3.png" alt="b3c7340adb9443c79cae1972129a00b7.png"><br>芯片资源</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/03842299e0ad76ca983e82f57289b07c.png" alt="1efa2f0f7686467791b576d34bc3d035.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/798af551557b2512a1d100f95fed5b77.png" alt="445d93be180549c688a0fe8c5617979b.png"></p>
<h2 id="七-vivado使用介绍"><a href="#七-vivado使用介绍" class="headerlink" title="七.vivado使用介绍"></a>七.vivado使用介绍</h2><p>参考《xilinx fpga权威设计指南》</p>
<p>1.首先书目介绍了新一代UltraScale结构，介绍了其CLB，包含LUT、触发器、查找表什么的，以此构成多路复用器、进位逻辑、存储等基本结构。（粗略浅看未看完）</p>
<p>2.vivado以前的版本是个IDE，现在出现了GUI，前后者的关系类似Windows的shell和图形界面的关系。而在之前所使用的是 **XDC  **语言，由标准约束语言 **Tcl  **演变而来，二者相似。vivado工程目录下的 .Journal 文件和 .Log 文件则可以记录Tcl命令和执行反馈，据此可在工程调试中导出.Journal文件制成Tcl命令脚本，实现快速自动化处理。<a target="_blank" rel="noopener" href="https://xilinx.eetrend.com/content/2019/100046350.html#:~:text=XDC%20%E6%98%AF%20Xilinx%20Design%20Constraints%20%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%8C%E4%BD%86%E5%85%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%9D%A5%E6%BA%90%E4%BA%8E%E4%B8%9A%E7%95%8C%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BA%A6%E6%9D%9F%E8%A7%84%E8%8C%83SDC%E3%80%82%20XDC%20%E5%9C%A8%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF,I%2FO%20%E7%AD%89%E8%AF%AD%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%9C%A8%20Vivado%20%E4%B8%AD%20source%20%E4%B8%80%E4%B8%AA%20Tcl%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%A1%A5%E5%85%85%E3%80%82" title="XDC时钟约束 | 电子创新网赛灵思社区">XDC时钟约束 | 电子创新网赛灵思社区</a></p>
<p>3.接下来介绍vivado集成开发界面：</p>
<p>打开主界面三栏：快速开始（包含打开&#x2F;创建工程、<strong>打开示例工程</strong><br>）、Task（IP核操作、硬件管理器【要连接板子，下载步骤时也要打开】、Tcl商店）、资料中心（文档、<strong>视频</strong> 、注释向导）</p>
<p>任意打开一个工程，主界面左侧<strong>FlowNavigator（流程向导）</strong> ，包含：工程管理器（添加原文件、IP目录）、IP<br>集成器（设计用户IP核）、仿真、<strong>RTL分析（RTL ANALYSIS【<a target="_blank" rel="noopener" href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513" title="RTL
闪退解决">RTL<br>闪退解决</a>】，生成网表图、硬件引脚连接，生成.XDC文件）、综合（SYNTHESIS）、实现（IMPLEMENTATION）</strong>、编程和调试（生成比特流、打开硬件管理器）</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhikaidetb/article/details/128295529" title="Vivado的RTL分析（RTL analysis）、综合（synthesis）和实现（implementation）的区别？">Vivado的RTL分析（RTL<br>analysis）、综合（synthesis）和实现（implementation）的区别？</a></p>
<p><strong>源窗口Source</strong> ，用于管理工程源文件，Hierarchy（层次）将工程按层次分组展示，Compile<br>order可设置工程文件编译顺序，文件右键点击set as top可设置为顶层文件。</p>
<p>4.然后是高层次综合工具Vidado HLS</p>
<p>原理即<strong>将高级语言如c&#x2F;c++转换成RTL级实现，还支持OpenCV函数</strong></p>
<h2 id="八-FPGA-Arm-Cortex-M1软核配置"><a href="#八-FPGA-Arm-Cortex-M1软核配置" class="headerlink" title="八.FPGA Arm-Cortex-M1软核配置"></a>八.FPGA Arm-Cortex-M1软核配置</h2><pre><code>    打开vivado IP manager，搜索 arm 显示可使用的 arm 核——Arm-Cortex-M1，若未安装可点击链接下载。Arm 官网下载 IP 核需要提前一周注册，提供免费使用的 IP 核有 M1 和 M3。
</code></pre>
<h2 id="九-xilinx-Zynq-UltraScale-MPSoC"><a href="#九-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="九.xilinx Zynq UltraScale+ MPSoC"></a>九.xilinx Zynq UltraScale+ MPSoC</h2><p>[Zynq UltraScale+ MPSoC](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivity
for ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p>
<p><a target="_blank" rel="noopener" href="http://www.pynq.io/" title="PYNQ -
Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p>
<pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。

    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132220627">https://blog.csdn.net/qq_32971095/article/details/132220627</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:30:46" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一.问题描述"></a>一.问题描述</h2><p>求该函数的最优解：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b72b9e9aec3b2c8f64d8b9f4e22efa21.png"></p>
<p>解题思路：</p>
<p>变量编码-&gt;生成种群-&gt;交叉-&gt;变异-&gt;选择-&gt;迭代</p>
<pre><code>    对x1和x2在变量范围内的值按照给定精度计算编码成二进制码的位数；随机生成一定规模的种群，其二进制编码随机； 随机对种群内个体的编码进行交叉；随机对种群内个体的编码进行按位变异；对二进制码进行解码、求解适应度函数值、保留一定数量的精英、采用轮盘赌随机选取其余个体最终组成新的种群；迭代，重复 交叉-&gt;变异-&gt;选择 至最优适应度基本不变或迭代一定次数。
</code></pre>
<h2 id="二-代码解析"><a href="#二-代码解析" class="headerlink" title="二.代码解析"></a>二.代码解析</h2><h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h3><pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define POPULATION_SIZE 100	//种群规模
#define RESERVE_NUM 3		//每代精英保留数 
#define VARI_NUM 2			//变量个数 
#define ITERATION 1000		//迭代次数
#define END_TIMES 100		//稳定终止次数 
#define PC 0.6				//交叉概率 
#define CROSS_LEN 8			//交叉长度 
#define PM 0.1				//变异概率 

//种群结构体 
typedef struct v&#123;
	bool encode[50];		//二进制编码 
	double value[VARI_NUM];	//解码数值 
	bool change;			//标记是否发生交叉或变异  
	double fitness;			//适应度
	double fit_rate;		//适应度占比 
&#125;v;

double lower[VARI_NUM],upper[VARI_NUM],accur;	//x1,x2上下界和精度 
int encode_num,encode_number[VARI_NUM];			//二进制编码位数 
double real_accur[VARI_NUM];					//实际精度 
v optimization_popu;							//最优个体 

//函数声明 
v Get_Optimization(void);
void Init_Population(v* group);
void Cross(v* group);
void Mutation(v* group);
v* Select(v**group);
double Fitness(double x1,double x2); 
void Output_Result(v* optimization);
void Free_space(v** group);

//************************************************************************************************************
int main()&#123;

	int i;
	v temp;
	
	//输入样例：-3.0 12.1 4.1 5.8 0.0001 
	printf(&quot;输入变量x1和x2的上下界和精度(x1_lower,x1_upper,x2_lower,x2_upper,accur):&quot;);
	scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;lower[0],&amp;upper[0],&amp;lower[1],&amp;upper[1],&amp;accur);
	
	//可以多次进行实验
	for(i=0;i&lt;1;i++)&#123;
		temp=Get_Optimization();
		if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;
	&#125;
	Output_Result(&amp;optimization_popu);
	
	return 0;	
&#125;

//************************************************************************************************************
v Get_Optimization(void)&#123;
	
	srand((unsigned)time(NULL));
	int i,j;
	double temp;
	v** group=(v**)malloc(3*sizeof(v*));	//原始、交叉、变异种群
	for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	v* optimization=group[0],opt_tmep;				//最优种群 
	
	//初始化种群 
	Init_Population(group[0]);
	memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); 
	memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);
	
	//迭代 
	for(i=j=0;i&lt;ITERATION;i++)&#123;
		
		//交叉
		Cross(group[1]); 
		//变异
		Mutation(group[2]);
		//选择 
		temp=optimization-&gt;fitness;
		optimization=Select(group); 
		if((optimization-&gt;fitness-temp)&lt;accur)&#123;
			j++;
			if(j&gt;=END_TIMES)break;		//结果保持稳定则退出 
		&#125;
	 	
	&#125;
	
	//输出结果
	Output_Result(optimization); 
	
	opt_tmep=*optimization;
	Free_space(group);
	return opt_tmep;
	
&#125;

//计算变量二进制编码位数 
int Encode_Num(double lower,double upper,double accur)&#123;
	
	int num,i,j;
	num=(upper-lower)/accur+1;
	for(i=0,j=1;j&lt;num;j*=2,i++);
	return i;
	
&#125;

void Init_Population(v* group)&#123;
	
	int i,j;	
	
	for(i=encode_num=0;i&lt;VARI_NUM;i++)encode_num+=(encode_number[i]=Encode_Num(lower[i],upper[i],accur));		//计算编码位数
	for(i=0;i&lt;VARI_NUM;i++)real_accur[i]=(upper[i]-lower[i])/(pow(2,encode_number[i])-1);						//计算实际精度
	
	//初始化种群 
	for(i=0;i&lt;POPULATION_SIZE;i++)&#123;
		//随机生成二进制编码 
		for(j=0;j&lt;encode_num;j++)&#123;
			group[i].encode[j]=rand()%2;
//			printf(&quot;%d %d:%d\n&quot;,i,j,group[i].encode[j]);
		&#125;
		group[i].change=true;
	&#125;

&#125;

//交叉lower和upper之间的编码 
void Cross(v* group)&#123;
	
	double p;
	int i,j,lower,upper;
	bool temp;
	
	//随机选取交叉片段
	lower=rand()%(encode_num-CROSS_LEN-1);
	upper=lower+CROSS_LEN; 

	for(i=0;i&lt;POPULATION_SIZE/2-1;i++)&#123;
		p=1.0*rand()/RAND_MAX;	//***随机数*** 
		if(p&lt;PC)&#123; 
			//交叉 
			for(j=lower;j&lt;upper;j++)&#123;
				temp=group[i].encode[j];
				group[i].encode[j]=group[POPULATION_SIZE-1-i].encode[j];
				group[POPULATION_SIZE-1-i].encode[j]=temp;
			&#125;
		&#125;
		//标记未交叉 
		else group[i].change=group[POPULATION_SIZE-1-i].change=false;
	&#125;
	
&#125; 

//按位变异  
void Mutation(v* group)&#123;

	double p;
	int i,j;
	for(i=0;i&lt;POPULATION_SIZE/2;i++)&#123;
		for(j=0;j&lt;encode_num;j++)&#123;
			p=1.0*rand()/RAND_MAX;	//***随机数*** 
			if(p&lt;PM)group[i].encode[j]=!group[i].encode[j];
			else group[i].change=false;
		&#125;
	&#125;
	
&#125;

//选择
v* Select(v**group)&#123;
	
	v* fitist[RESERVE_NUM],*group_temp=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	int i,j,k,l,m,n;
	int vaild_num;	//有效个数 
	double fit_sum;	//适应度总大小
	for(i=0;i&lt;RESERVE_NUM;i++)fitist[i]=&amp;group[0][0]; 
		
	//解码并计算适应度函数 
	for(vaild_num=fit_sum=i=0;i&lt;3;i++)&#123;
		for(j=0;j&lt;POPULATION_SIZE;j++)&#123;
			if(!group[i][j].change)continue; 
			for(m=n=0;m&lt;VARI_NUM;n+=encode_number[m],m++)&#123;
				for(k=l=0;k&lt;encode_number[m];k++)l+=group[i][j].encode[k+n]*pow(2,k);
				//解码 
				group[i][j].value[m]=lower[m]+l*real_accur[m];
//				printf(&quot;%d %d--value[%d]:%lf\n&quot;,i,j,m,group[i][j].value[m]);
			&#125;
			
			//计算适应度 
			group[i][j].fitness=Fitness(group[i][j].value[0],group[i][j].value[1]);
			//保存适应度大的个体
			for(k=0;k&lt;RESERVE_NUM;k++)&#123;
				if(group[i][j].fitness&gt;fitist[k]-&gt;fitness)&#123;
					for(l=k;l&lt;RESERVE_NUM-1;l++)fitist[l+1]=fitist[l];
					fitist[k]=&amp;group[i][j];
				&#125;	
			&#125;
			vaild_num++;fit_sum+=group[i][j].fitness;						//适应度总和计算 
//			printf(&quot;%d %d--fitness:%lf\n&quot;,i,j,group[i][j].fitness);			
		&#125;
	&#125; 
	
	//***保留优秀个体***
	for(i=0;i&lt;RESERVE_NUM;i++)group_temp[i]=*fitist[i];
	
	//计算比率 
	for(i=0;i&lt;3;i++)&#123;
		for(j=0;j&lt;POPULATION_SIZE;j++)&#123;
			if(!group[i][j].change)continue;
			group[i][j].fit_rate=group[i][j].fitness/fit_sum;
//			printf(&quot;%d %d--fit_rate:%lf\n&quot;,i,j,group[i][j].fit_rate);	
		&#125;
	&#125;
	
	//轮盘赌选择
	for(i=RESERVE_NUM;i&lt;POPULATION_SIZE;i++)&#123;
		double p=1.0*rand()/RAND_MAX;
		//寻找所处区间
		double temp;
		for(temp=0,j=0;j&lt;3;j++)&#123;
			for(k=0;k&lt;POPULATION_SIZE;k++)&#123;
				if(!group[j][k].change)continue;
				temp+=group[j][k].fit_rate;
				if(p&lt;temp)break;
			&#125;
			if(p&lt;temp)break;
		&#125;
		//复制 
		if(j!=3&amp;&amp;k!=POPULATION_SIZE)group_temp[i]=group[j][k];
		else group_temp[i]=group[j-1][k-1];
//		printf(&quot;select %3d from %3d %3d--fitness:%lf	--p:%lf\n&quot;,i,j,k,group_temp[i].fitness,p);
	&#125; 
	 
	memcpy(group[0],group_temp,sizeof(v)*POPULATION_SIZE);
	free(group_temp);
	
	return fitist[0]; 
	
&#125;

//适应度函数 
double Fitness(double x1,double x2)&#123;
	return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);
&#125;

void Output_Result(v* optimization)&#123;
	int i;
	printf(&quot;最优解为:x1=%9lf x2=%9lf f(x1,x2)=%9lf 二进制编码为:&quot;,optimization-&gt;value[0],optimization-&gt;value[1],optimization-&gt;fitness); 
	for(i=0;i&lt;encode_num;i++)printf(&quot;%d&quot;,optimization-&gt;encode[i]);
	printf(&quot;\n&quot;);
&#125;

//释放空间 
void Free_space(v** group)&#123;
	int i;
	for(i=0;i&lt;3;i++)free(group[i]);
	free(group);
&#125;
</code></pre>
<h3 id="2-算法关键参数"><a href="#2-算法关键参数" class="headerlink" title="2.算法关键参数"></a>2.算法关键参数</h3><pre><code>#define POPULATION_SIZE 100	//种群规模
#define RESERVE_NUM 3		//每代精英保留数 
#define VARI_NUM 2			//变量个数 
#define ITERATION 1000		//迭代次数
#define END_TIMES 100		//稳定终止次数 
#define PC 0.6				//交叉概率 
#define CROSS_LEN 8			//交叉长度 
#define PM 0.1				//变异概率 
</code></pre>
<h3 id="3-定义种群结构体、相关变量及函数"><a href="#3-定义种群结构体、相关变量及函数" class="headerlink" title="3.定义种群结构体、相关变量及函数"></a>3.定义种群结构体、相关变量及函数</h3><pre><code>//种群结构体 
typedef struct v&#123;
	bool encode[50];		//二进制编码 
	double value[VARI_NUM];	//解码数值 
	bool change;			//标记是否发生交叉或变异  
	double fitness;			//适应度
	double fit_rate;		//适应度占比 
&#125;v;

double lower[VARI_NUM],upper[VARI_NUM],accur;	//x1,x2上下界和精度 
int encode_num,encode_number[VARI_NUM];			//二进制编码位数 
double real_accur[VARI_NUM];					//实际精度 
v optimization_popu;							//最优个体 

//函数声明 
v Get_Optimization(void);
void Init_Population(v* group);
void Cross(v* group);
void Mutation(v* group);
v* Select(v**group);
double Fitness(double x1,double x2); 
void Output_Result(v* optimization);
void Free_space(v** group);
</code></pre>
<h3 id="4-求解流程"><a href="#4-求解流程" class="headerlink" title="4.求解流程"></a>4.求解流程</h3><pre><code>v Get_Optimization(void)&#123;
	
	srand((unsigned)time(NULL));
	int i,j;
	double temp;
	v** group=(v**)malloc(3*sizeof(v*));	//原始、交叉、变异种群
	for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	v* optimization=group[0],opt_tmep;				//最优种群 
	
	//初始化种群 
	Init_Population(group[0]);
	memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); 
	memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);
	
	//迭代 
	for(i=j=0;i&lt;ITERATION;i++)&#123;
		
		//交叉
		Cross(group[1]); 
		//变异
		Mutation(group[2]);
		//选择 
		temp=optimization-&gt;fitness;
		optimization=Select(group); 
		if((optimization-&gt;fitness-temp)&lt;accur)&#123;
			j++;
			if(j&gt;=END_TIMES)break;		//结果保持稳定则退出 
		&#125;
	 	
	&#125;
	
	//输出结果
	Output_Result(optimization); 
	
	opt_tmep=*optimization;
	Free_space(group);
	return opt_tmep;
	
&#125;
</code></pre>
<h2 id="三-求解结果"><a href="#三-求解结果" class="headerlink" title="三.求解结果"></a>三.求解结果</h2><pre><code>    改变算法关键参数会导致求解结果不同，不同的时间下的结果也不同。可以改变主函数中for循环的结束条件多次进行实验：


    //可以多次进行实验
	for(i=0;i&lt;1;i++)&#123;
		temp=Get_Optimization();
		if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;
	&#125;

    笔者在一定的参数下得到了最优解：


最优解为:
x1=11.625358
x2=5.725031
f(x1,x2)=38.850261
二进制编码为:
111100111111101111010110100101111

    对于问题二，修改适应度函数：


//适应度函数 
double Fitness(double x1,double x2)&#123;
//	return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);
	return 100*pow((x2-x1*x1),2)+pow((1-x1),2);
&#125;

    再输入变量范围及精度 ：


输入样例2：-2.048 2.048 -2.048 2.048 0.0001
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ede4e3460860a1737bc72b9a592cb66.png"></p>
<pre><code>最优解为:x1=-2.047875 x2=-2.037187 f(x1,x2)=3891.799899 
二进制编码为:01000000000000001011010100000000
</code></pre>
<h2 id="四-相关思考"><a href="#四-相关思考" class="headerlink" title="四.相关思考"></a>四.相关思考</h2><p>1.增加精度可以增加编码长度，减少交叉变异的影响，增加搜索精度，结果可能更加靠近最优解</p>
<p>2.增加变异概率以产生更多新的性状（<strong>变异的概率可采用自适应概率，如果最优种个体适应度值长时间未变化，可增加变异概率</strong><br>），以及采用更复杂的交叉、变异算法</p>
<p>3.交叉、变异过于随机会使求解趋于“遍历”，并且算法的“朝最优解的驱动力”不足</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136715239">https://blog.csdn.net/qq_32971095/article/details/136715239</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 11:46:35 / 修改时间：09:30:32" itemprop="dateCreated datePublished" datetime="2025-02-08T11:46:35+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1">一.2023年E题完整设计</a></p>
<p><a href="about:blank#%3C1%3E%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88">&lt;1&gt;选择方案</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务一：实现按键按下复位（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务二：实现激光点绕边框一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务三：实现激光点绕A4纸边缘一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89">任务四：实现绿色激光追踪红色激光（发挥部分）</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D">&lt;2&gt;任务分配</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">&lt;3&gt;代码分析</a></p>
<p><a href="about:blank#1.stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.stm32上关键源码分析</a></p>
<p><a href="about:blank#I.%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86">I.基本部分</a></p>
<p><a href="about:blank#II.%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81">II.模块代码</a></p>
<p><a href="about:blank#%281%29Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97">(1)Timer——定时器延时函数模块</a></p>
<p><a href="about:blank#%282%29servo_motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">(2)servo_motor——云台舵机控制模块</a></p>
<p><a href="about:blank#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC">①控制舵机的旋转</a></p>
<p><a href="about:blank#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9">②控制激光点到达某一像素点</a></p>
<p><a href="about:blank#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson%20nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87">③与上位机jetson<br>nano通讯接收点坐标</a></p>
<p><a href="about:blank#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC">④得到一点坐标对应的舵机pwm波OC值</a></p>
<p><a href="about:blank#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF">⑤控制激光点沿四边形巡线</a></p>
<p><a href="about:blank#III.%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86">III.主函数与中断函数部分</a></p>
<p><a href="about:blank#%281%29%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(1)红色激光云台</a></p>
<p><a href="about:blank#%282%29%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(2)绿色激光云台</a></p>
<p><a href="about:blank#2.jetson%20nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2.jetson<br>nano上关键源码分析</a></p>
<p><a href="about:blank#I.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4">I.相机参数的调整</a></p>
<p><a href="about:blank#II.%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95">II.关键识别算法</a></p>
<p><a href="about:blank#%281%29%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(1)铅笔线识别及顶点的计算</a></p>
<p><a href="about:blank#%282%29A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(2)A4纸顶点识别及巡线顶点的计算</a></p>
<p><a href="about:blank#%283%29%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89">(3)区分红绿激光</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">二.学习资料分享</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A">&lt;1&gt;学习笔记</a></p>
<p><a href="about:blank#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99%EF%BC%9A">&lt;2&gt;其他资料</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95">三.备赛阶段记录</a></p>
<p><a href="about:blank#%E5%9B%9B.%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD">四.电赛总结及经验教训</a></p>
<p><a href="about:blank#%3C1%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84%EF%BC%9A">&lt;1&gt;本次比赛作品的不足、改进之处</a></p>
<p><a href="about:blank#%3C2%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%EF%BC%9A">&lt;2&gt;本次比赛的经验教训</a></p>
<hr>
<p>“愿大家都少走弯路，在迷茫时看到希望！”</p>
<h3 id="一-2023年E题完整设计"><a href="#一-2023年E题完整设计" class="headerlink" title="一.2023年E题完整设计"></a>一.2023年E题完整设计</h3><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="&lt;1&gt;选择方案"></a>&lt;1&gt;选择方案</h3><h4 id="任务一：实现按键按下复位（基础部分）"><a href="#任务一：实现按键按下复位（基础部分）" class="headerlink" title="任务一：实现按键按下复位（基础部分）"></a>任务一：实现按键按下复位（基础部分）</h4><p>方法①：识别四顶点位置-&gt;连接对角线得到中心点-&gt;PID调节使激光点与中心点重合</p>
<p>方法②：识别四顶点位置-&gt;对角顶点坐标求平均值得中心点位置-&gt;PID调节使重合</p>
<p>方法③：固定所有器件位置，保证各点PWM值不变，得到中心点PWM固定值，开环设定</p>
<h4 id="任务二：实现激光点绕边框一周（基础部分）"><a href="#任务二：实现激光点绕边框一周（基础部分）" class="headerlink" title="任务二：实现激光点绕边框一周（基础部分）"></a>任务二：实现激光点绕边框一周（基础部分）</h4><p>步骤I：激光点由中心点到达边线左上角</p>
<p>步骤II：顺时针绕一圈</p>
<pre><code>    方法①：两点定线，先确定两点坐标，连线确定等分点，使用PID算法在等分点间移动

    方法②：不使用PID，利用与目标点坐标差计算移动方向，每次移动距离为舵机最小精度值

    方法③：求PWM和坐标(x,y)的函数关系（近似线性），直接设定PWM值到达指定点
</code></pre>
<h4 id="任务三：实现激光点绕A4纸边缘一周（基础部分）"><a href="#任务三：实现激光点绕A4纸边缘一周（基础部分）" class="headerlink" title="任务三：实现激光点绕A4纸边缘一周（基础部分）"></a>任务三：实现激光点绕A4纸边缘一周（基础部分）</h4><p>（与任务二区别：矩形放置角度可以倾斜；要区分两矩形宽度以识别A4纸）</p>
<h4 id="任务四：实现绿色激光追踪红色激光（发挥部分）"><a href="#任务四：实现绿色激光追踪红色激光（发挥部分）" class="headerlink" title="任务四：实现绿色激光追踪红色激光（发挥部分）"></a>任务四：实现绿色激光追踪红色激光（发挥部分）</h4><p>方法①：区分红绿色激光并得到坐标-&gt;PID直接跟踪</p>
<h3 id="任务分配"><a href="#任务分配" class="headerlink" title="&lt;2&gt;任务分配"></a>&lt;2&gt;任务分配</h3><p>将上述任务分解成多个要完成的技术，以便分工：</p>
<p>1.硬件平台搭建</p>
<p>2.stm32控制算法：</p>
<p>①PID控制激光点移动到目标点算法（核心）</p>
<p>②舵机以最小分度值移动算法（细微调节）</p>
<p>③给定两点以及等分数计算所有等分点算法（线上移动减少偏差）</p>
<p>④在PID寻点时获取基本点（矩形顶点及中心）PWM值算法</p>
<p>⑤stm32和jetson nano的通信规则设计与数据互传</p>
<p>3.OpenCV识别算法</p>
<p>①识别铅笔线边框：灰度图转换-&gt;阈值分割成二值图-&gt;霍夫直线变换得到直线上两点（非端点）-&gt;从得到的多条直线中筛选去重-&gt;编写“已知两直线上两点求直线交点”算法-&gt;求得四端点</p>
<p>②识别A4纸边框：阈值分割后利用Harris角点检测出A4框的8个顶点-&gt;编写“从8个顶点中识别两两相邻顶点”算法-&gt;求得框中心线4顶点</p>
<p>③区分红绿激光点算法：转换到Hsv色彩空间-&gt;分别设置阈值，在Hsv空间中二值化图像提取红绿色区域以得到激光点坐标  </p>
<p>4.主函数（程序流程）设计</p>
<p>5.电赛报告书写</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="&lt;3&gt;代码分析"></a>&lt;3&gt;代码分析</h3><h4 id="1-stm32上关键源码分析"><a href="#1-stm32上关键源码分析" class="headerlink" title="1.stm32上关键源码分析"></a>1.stm32上关键源码分析</h4><h5 id="I-基本部分"><a href="#I-基本部分" class="headerlink" title="I.基本部分"></a>I.基本部分</h5><p>(1)引脚使用说明</p>
<pre><code>//*************************引脚使用说明*************************
/*
oled.h				GPIOA PIN0/1
bluetooth.h			GPIOA PIN2/3
joystick.h			GPIOA PIN4/5 ADC1_CH4/5 GPIOB PIN11/12/13 EXTI12/13
Pwm.h				GPIOA PIN8/11 TIM1_CH1/4 50hz
usart.h				GPIOA PIN9/10 TX/RX Black/White
beep.h				GPIOB PIN14
led.h				GPIOB PIN15
Timer.h				TIM2/3
*/
</code></pre>
<p>(2)头文件声明</p>
<pre><code>//************************头文件声明************************
#include &quot;public.h&quot;				//公用引用函数封装
//#include &quot;bluetooth.h&quot;		//蓝牙模块
#include &quot;oled.h&quot;				//OLED显示屏模块
#include &quot;Pwm.h&quot;				//PWM波生成模块
#include &quot;servo_motor.h&quot;		//云台控制函数模块
#include &quot;joystick.h&quot;			//摇杆控制模块
#include &quot;string.h&quot;				
#include &quot;Delay.h&quot;				
#include &quot;Timer.h&quot;				//定时器模块
#include &quot;usart.h&quot;				//uart通信模块
#include &quot;beep.h&quot;				//蜂鸣器模块
#include &quot;led.h&quot;				//led灯模块
#include &quot;dma.h&quot;				//dma数据转存模块
</code></pre>
<p>(3)全局变量和宏定义声明</p>
<pre><code>//************************全局变量和宏定义声明************************
//#define OpenLoop_OL		//开环实现功能执行
#define CloseLoop_CL		//闭环实现功能执行

extern float Voltage[2];	//ad测量电压值[0.3.3]			//ad.c
extern char  USART_RX_INFO[USART_REC_LEN];	//uart接收数据	//usart.c
extern int x,y;				//激光当前坐标					//servo_motor.c
extern int Vertex[4][2];	//四顶点位置						//servo_motor.c
extern int Vertex_Peak_Pos[4][2];
extern int Vertex_A4[4][2];
extern Pwm Center_Pwm;
extern Pwm Peak_Pwm[4];
extern Pwm A4_Pwm[4];

int Programme_Progress=0;					//比赛程序进度
int order=0;								//蓝牙接收到的命令
int Main_Wait_Stop_Sign =1;					//主程序等待标志位
extern int JoyStick_Control_Stop_Sign;		//摇杆控制程序结束标志位
int Get_Depend_Point_Pos_Stop_Sign=1;
int Get_A4_Point_Pos_Stop_Sign=1;
extern int Follow_Track_Stop_Sign;			//矩形寻迹结束标志位
extern int Follow_Point_Stop_Sign;			//绿激光跟随红激光结束标志位
</code></pre>
<h5 id="II-模块代码"><a href="#II-模块代码" class="headerlink" title="II.模块代码"></a>II.模块代码</h5><h6 id="1-Timer——定时器延时函数模块"><a href="#1-Timer——定时器延时函数模块" class="headerlink" title="(1)Timer——定时器延时函数模块"></a>(1)Timer——定时器延时函数模块</h6><pre><code>#include &quot;Timer.h&quot;

//TIM2/3

void Timer_Init(void)
&#123;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	
	TIM_InternalClockConfig(TIM2);
	TIM_InternalClockConfig(TIM3);
	
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = 60000 - 1;	//分辨率1us,最大60ms
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);
	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);
	
&#125;

void Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM2,ENABLE); //启动定时器
	while(TIM2-&gt;CNT &lt; xus);
	TIM2-&gt;CNT = 0;
	TIM_Cmd(TIM2,DISABLE); //关闭定时器
&#125;

void Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)Timer_delay_us(1000);
&#125;

//外部中断专用延时函数
void EXIT_LINE_Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM3,ENABLE); //启动定时器
	while(TIM3-&gt;CNT &lt; xus);
	TIM3-&gt;CNT = 0;
	TIM_Cmd(TIM3,DISABLE); //关闭定时器
&#125;

void EXIT_LINE_Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)EXIT_LINE_Timer_delay_us(1000);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>在Timer_Init()中开启了两个定时器TIM1&#x2F;2，由Timer_delay_us()和EXIT_LINE_Timer_delay_us()分别使用，分别在中断函数内外使用，<strong>避免重复调用冲突</strong></p>
<h6 id="2-servo-motor——云台舵机控制模块"><a href="#2-servo-motor——云台舵机控制模块" class="headerlink" title="(2)servo_motor——云台舵机控制模块"></a>(2)servo_motor——云台舵机控制模块</h6><h6 id="①控制舵机的旋转"><a href="#①控制舵机的旋转" class="headerlink" title="①控制舵机的旋转"></a>①控制舵机的旋转</h6><pre><code>int Oc_Lp[4]=&#123;750,750,750,750&#125;;
int Oc_Vp[4]=&#123;763,763,763,763&#125;;
/*********************************************************
函数功能：云台水平方向旋转
*********************************************************/
void Spinnig_Level(int diff)
&#123;
	if(diff&lt;0)
	&#123;
		Oc_Lp[0]=Oc_L=(Oc_L+diff)&lt;660?660:(Oc_L+diff);
	&#125;
	else if(diff&gt;0)
	&#123;
		Oc_Lp[0]=Oc_L=(Oc_L+diff)&gt;840?840:(Oc_L+diff);	
	&#125;
	TIM_SetCompare1(TIM1,Oc_L);	
	int i;
	for(i=3;i&gt;0;i--)Oc_Lp[i]=Oc_Lp[i-1];
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>这里的Oc_Lp存储的是控制舵机的pwm波参数中的OC寄存器中的值，作为舵机运动最基本的函数，<br><em><strong>舵机的控制通过改变pwm波参数中的OC寄存器中的值实现</strong></em><br>。这里定义数组实现记忆功能，可存储前三次的OC值。并通过三元运算符设定上下限，将最终的OC值通过TIM_SetCompare1()设定。</p>
<h6 id="②控制激光点到达某一像素点"><a href="#②控制激光点到达某一像素点" class="headerlink" title="②控制激光点到达某一像素点"></a>②控制激光点到达某一像素点</h6><pre><code>/*********************************************************
函数功能：云台控制激光点到达某一点
函数参数：目标点的坐标
*********************************************************/
int x=360,y=360;		//跟随点当前坐标
int Reach_Pos_CL_Stop_Sign=1;
//云台水平方向旋转PID值
float Level_Kp=0.06;
float Level_Ki=0.02;
float Level_Kd=0.01;
//云台竖直方向旋转PID值
float Vert_Kp=0.06;
float Vert_Ki=0.02;
float Vert_Kd=0.01;
void Reach_Pos_CL(int Target_X,int Target_Y,int Reach_Pos_CL_MODE)
&#123;
	int Sign(int num);
	void Get_Point_Pos(void);
	int near(int Target_X,int Target_Y);
	
	int diff_x,diff_y;
	while(Reach_Pos_CL_Stop_Sign)
	&#123;
		Timer_delay_ms(30);
		Get_Point_Pos();
		if(near(Target_X,Target_Y)&lt;=6)
		&#123;
			Beep_Times(10,1,NORMAL_MODE);
			break;
		&#125;
		if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&gt;60)					//用pid计算舵机单位数
		&#123;
			diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,Target_X,x,PID_REALIZE);
			diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,Target_Y,y,PID_REALIZE);
		&#125;
		else if(Reach_Pos_CL_MODE==MINMIZE_MODE)		//以舵机最小分辨率为单位
		&#123;
			diff_x=-Sign(x-Target_X);
			diff_y=-Sign(y-Target_Y);
		&#125;
		else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; near(Target_X,Target_Y)&lt;=60)					//用pid计算舵机单位数
		&#123;
			diff_x=-Sign(x-Target_X);
			diff_y=-Sign(y-Target_Y);
			Timer_delay_ms(30);
		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;

int Sign(int num)
&#123;
	if(num&gt;5)return 1;
	else if(num&lt;-5)return -1;
	else return 0;
&#125;

int my_abs(int a,int b)
&#123;
	return a-b&gt;0?a-b:b-a;
&#125;

int near(int Target_X,int Target_Y)
&#123;
	return my_abs(Target_X,x)+my_abs(Target_Y,y);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：目标点像素坐标；追踪模式（PID【PID与最小精度混合】模式和最小精度值模式）</p>
<p><strong>追踪过程：</strong></p>
<p>——得到当前激光点坐标：Get_Point_Pos()</p>
<p>——如果接近目标点则蜂鸣器鸣叫并退出【near(Target_X,Target_Y)&lt;&#x3D;6，说明当前坐标与目标横纵坐标差之和{“距离”}小于6个像素】</p>
<p>——如果使用PID模式：</p>
<pre><code>    ——“距离”大于60时采用PID算法快速靠近，计算出OC变化值diff_x、diff_y

    ——“距离”小于60时使用最小精度模式缓慢靠近，利用“符号函数sign()”计算diff
</code></pre>
<p>——调用Spinnig_Level()、Spinnig_Level()进行水平和垂直舵机的旋转</p>
<h6 id="③与上位机jetson-nano通讯接收点坐标"><a href="#③与上位机jetson-nano通讯接收点坐标" class="headerlink" title="③与上位机jetson nano通讯接收点坐标"></a>③与上位机jetson nano通讯接收点坐标</h6><p><strong>a.激光点坐标的实时接收</strong></p>
<pre><code>/*********************************************************
函数功能：stm32获取当前激光坐标
*********************************************************/
void Get_Point_Pos(void)
&#123;
	if(USART_RX_INFO[0]==&#39;x&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
	&#125;
	if(USART_RX_INFO[4]==&#39;y&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>规定上位机每次发送数据格式为：以#开头，以$结尾；stm32usart模块对接收数据进行解析</p>
<p>上位机坐标数据格式为：x123y456；123、456代表三位坐标值，字符’x’、’y’起定位作用</p>
<p>stm32对接收到的字符坐标进行解析如上</p>
<p><strong>b.特殊坐标接收</strong></p>
<pre><code>//********************************************************高级控制函数(CloseLoop--CL)********************************************************
int Vertex_Peak_Pos[4][2];
int Center_Pos[2];
Pwm Center_Pwm;
Pwm Peak_Pwm[4];
Pwm A4_Pwm[4]; 
//获取重要点坐标
void Get_Point_5(void)
&#123;
	int i,j;
	while(1)
	&#123;
		for(i=0;i&lt;8;i++)
		&#123;
			if(USART_RX_INFO[4*i]==&#39;a&#39;+i)continue;
			else break;
		&#125;
		if(i==8)
		&#123;
			for(i=0;i&lt;4;i++)
			&#123;
				for(j=0;j&lt;2;j++)Vertex_Peak_Pos[i][j]=(USART_RX_INFO[4*(2*i+j)+1]-&#39;0&#39;)*100+(USART_RX_INFO[4*(2*i+j)+2]-&#39;0&#39;)*10+(USART_RX_INFO[4*(2*i+j)+3]-&#39;0&#39;);
			&#125;
			break;
		&#125;
	&#125;
	
	while(!(USART_RX_INFO[0]==&#39;i&#39;&amp;&amp;USART_RX_INFO[4]==&#39;j&#39;));
	
	Center_Pos[0]=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
	Center_Pos[1]=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
	Beep_Times(50,5,NORMAL_MODE);
	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>这里接收的是铅笔线框四个顶点的坐标和中心点坐标，但是一次发送的数据长度不能太长，这里拆分成两部分接收（数据格式为：axxxbxxxcxxx…hxxx共8组值四个坐标），<br><em><strong>关键在于两部分的衔接</strong></em></p>
<p>while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<em><strong>确保收到四个顶点坐标后持续等待中心点坐标的发送</strong></em></p>
<h6 id="④得到一点坐标对应的舵机pwm波OC值"><a href="#④得到一点坐标对应的舵机pwm波OC值" class="headerlink" title="④得到一点坐标对应的舵机pwm波OC值"></a>④得到一点坐标对应的舵机pwm波OC值</h6><pre><code>int sum_num(int *num,int n)
&#123;
	int i,sum;
	for(i=sum=0;i&lt;n;i++)sum+=num[i];
	return sum;
&#125;	
//获取目标点pwm值
void Get_Pwm(int px,int py,Pwm *target_pwm,int n)
&#123;
	Reach_Pos_CL(px,py,PID_MODE);
	target_pwm-&gt;level=sum_num(Oc_Lp,n)/n;
	target_pwm-&gt;vert=sum_num(Oc_Vp,n)/n;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>通过②控制函数控制激光点到达指定点后记录目标点pwm值并返回；Pwm结构体定义如下</p>
<pre><code>typedef struct Pwm&#123;
	int level;
	int vert;
&#125;Pwm;
</code></pre>
<p>可以通过改变参数n的值选择是否滤波，4&gt;n&gt;1时进行滤波，取前几次OC值的平均值，不建议滤波</p>
<h6 id="⑤控制激光点沿四边形巡线"><a href="#⑤控制激光点沿四边形巡线" class="headerlink" title="⑤控制激光点沿四边形巡线"></a>⑤控制激光点沿四边形巡线</h6><pre><code>//巡线
void Follow_Track(int Vertex[4][2],int divide_num)
&#123;
	int i,j;
	float sub_l,sub_v;
	Pwm Vertex_Pwm[4];
	for(i=0;i&lt;4;i++)Get_Pwm(Vertex[i][0],Vertex[i][1],&amp;Vertex_Pwm[i],1);
	
	for(i=0;i&lt;4;i++)
	&#123;
		sub_l=(Vertex_Pwm[(i+1)%4].level-Vertex_Pwm[i].level);	//下一个顶点与当前顶点pwm之差
		sub_v=(Vertex_Pwm[(i+1)%4].vert-Vertex_Pwm[i].vert);	//下一个顶点与当前顶点纵坐标之差
		for(j=0;j&lt;divide_num;j++)
		&#123;
			Reach_Pos_OL(Vertex_Pwm[i].level+j*sub_l/divide_num,Vertex_Pwm[i].vert+j*sub_v/divide_num);
			Timer_delay_ms(200);
		&#125;
		Reach_Pos_OL(Vertex_Pwm[(i+1)%4].level,Vertex_Pwm[(i+1)%4].vert);
		Timer_delay_ms(300);
	&#125;
	
	Beep_Times(50,5,NORMAL_MODE);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：四边形顺时针顺序顶点坐标、每段等分数divide_num</p>
<p><strong>巡线过程：</strong></p>
<p>——得到四个顶点坐标对应的水平、数值舵机OC值</p>
<p>——在for循环内依次经过四个顶点，视作四个大任务</p>
<pre><code>    ——内部使用for循环分解小任务，根据等分段数divide_num计算等分点横纵pwm值并移动至
</code></pre>
<p>——任务结束鸣叫示意</p>
<h5 id="III-主函数与中断函数部分"><a href="#III-主函数与中断函数部分" class="headerlink" title="III.主函数与中断函数部分"></a>III.主函数与中断函数部分</h5><h6 id="1-红色激光云台"><a href="#1-红色激光云台" class="headerlink" title="(1)红色激光云台"></a>(1)红色激光云台</h6><pre><code>//*************************主函数部分*************************
//重新重启初值还原设置
void Programme_Reset(void)
&#123;
	Beep_Times(1000,1,NORMAL_MODE);
	Led_Times(1000,1,NORMAL_MODE);
	Programme_Progress=0;
	
	Main_Wait_Stop_Sign=1;
	JoyStick_Control_Stop_Sign=1;
	Follow_Track_Stop_Sign=1;
	
	Get_A4_Point_Pos_Stop_Sign=1;
	Get_Depend_Point_Pos_Stop_Sign=1;
&#125;

int main(void)
&#123;	
	//********************初始化程序********************
	Timer_Init();				//定时器初始化
//	BlueToothInit(9600,USART_Parity_No,USART_StopBits_1,USART_WordLength_8b);	//蓝牙初始化
	OLED_Init();				//oled初始化
	Beep_Init();				//蜂鸣器初始化
	Led_Init();					//led灯初始化
	TIM1_PWM_Init(9999,143);	//一周期20ms，分辨率20ms/10000）
	TIM_SetCompare1(TIM1,750);	//对齐角度为90度(1.5ms)
	TIM_SetCompare4(TIM1,763);	//对齐角度为90度(1.5ms)
	uart_init(115200);			//uart1初始化
	JoyStick_Init();			//JoyStick摇杆初始化
			
	//*************************比赛程序部分*************************
	while(1)
	&#123;
		int i;
		//重新重启初值还原设置
		Programme_Reset();
//		Reach_Pos_CL(50,50,PID_MODE);
		
		Axes_Init();
		
//		Follow_Track(Vertex_Peak_Pos,1);
		
		while(Main_Wait_Stop_Sign);
		//摇杆控制
		JoyStick_Control();
	
		
//#ifdef OpenLoop_OL
//			Follow_Track_OL();
//#endif			
//#ifdef CloseLoop_CL
//		//等待上位机发送初始坐标
//		Get_Depend_Point_Pos();
//		//环绕正方形顺时针旋转一周
//		while(Get_Depend_Point_Pos_Stop_Sign);

		//Follow_Track_CL(Vertex_Peak_Pos,2,PID_MODE);
		
//#endif

		Pwm_Track(Peak_Pwm,1);
		while(Follow_Track_Stop_Sign);
				
		Get_A4_Point_Pos();
		Timer_delay_ms(2000);
//		Follow_Track_CL(Vertex_A4,4,MINMIZE_MODE);
//		Follow_Track(Vertex_A4,4);
		for(i=0;i&lt;4;i++)Get_Pwm(Vertex_A4[i][0],Vertex_A4[i][1],&amp;A4_Pwm[i],1);
		Pwm_Track(A4_Pwm,6);
		while(Get_A4_Point_Pos_Stop_Sign);
		
	&#125;
&#125;


//*********************************************中断函数部分*********************************************
//按键中断函数
void EXTI15_10_IRQHandler()
&#123;
	if (EXTI_GetITStatus(EXTI_Line11) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0)		//软件防抖
		&#123;
			Beep_Times(50,2,EXIT_LINE_MODE);
			Reach_Pos_OL(Oc_L,Oc_V);						//保持激光当前指向位置
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0); 	//等待按键松开

			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11==1)); 	//等待按键松开
			Beep_Times(50,2,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line11);
		&#125;
	&#125;
	
	else if (EXTI_GetITStatus(EXTI_Line12) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0)		//软件防抖
		&#123;
			Programme_Progress++;
			Beep_Times(500,1,EXIT_LINE_MODE);
			if(Programme_Progress==1)
			&#123;
				Main_Wait_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==2)
			&#123;
				JoyStick_Control_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==3)
			&#123;
//				Get_Depend_Point_Pos_Stop_Sign=0;
				Follow_Track_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==4)
			&#123;
				Get_A4_Point_Pos_Stop_Sign=0;
//				Follow_Track_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==5)
			&#123;
//				Get_A4_Point_Pos_Stop_Sign=0;
			&#125;
			else if(Programme_Progress==6)
			&#123;
				;
			&#125;
			else if(Programme_Progress==7)
			&#123;
				;
			&#125;
			else
			&#123;
				Programme_Reset();
			&#125;
			
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)==0); 	//等待按键松开
			EXTI_ClearITPendingBit(EXTI_Line12);
		&#125;
		
	&#125;
	
	else if (EXTI_GetITStatus(EXTI_Line13) == SET)
	&#123;
		EXIT_LINE_Timer_delay_ms(10);										
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0)		//软件防抖
		&#123;
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			Reach_Pos_OL(Center_Pwm.level,Center_Pwm.vert);
			
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0); 	//等待按键松开

			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13==1)); 	//等待按键松开
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line13);
		&#125;
	&#125;	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>主函数与中断函数相辅相成，程序整体使用外部中断推进以及实现一些特殊功能（立即复位）；</p>
<p>由于主函数内小功能函数都借助while()循环实现，设置循环标志位Stop_Sign和程序阶段标志位Programme_Progress来推进主函数；</p>
<p>按下GPIOB,GPIO_Pin_12的按键触发中断，Programme_Progress++以及相应的Stop_Sign&#x3D;0，以控制目前运行小功能停止并进入下一阶段；</p>
<p>在程序开始和结束处执行Programme_Reset()函数，重置各标志位实现程序重新运行；</p>
<p><strong>注意：</strong></p>
<p>在中断函数内部涉及到的延时函数统统使用EXIT_LINE_Timer_delay_ms()函数，区别外部使用的Timer_delay_ms()函数，防止调用冲突程序卡死</p>
<h6 id="2-绿色激光云台"><a href="#2-绿色激光云台" class="headerlink" title="(2)绿色激光云台"></a>(2)绿色激光云台</h6><pre><code>//绿车
int r_x=0,r_y=0;
void Get_RaG_Point_Pos(void)
&#123;
	if(USART_RX_INFO[0]==&#39;g&#39;&amp;&amp; USART_RX_INFO[8]==&#39;r&#39;&amp;&amp; USART_RX_INFO[4]==&#39;y&#39;&amp;&amp; USART_RX_INFO[12]==&#39;y&#39;)				//检查数据定位是否正确(上位机发送信息为：x123y456)
	&#123;
		x=(USART_RX_INFO[1]-&#39;0&#39;)*100+(USART_RX_INFO[2]-&#39;0&#39;)*10+USART_RX_INFO[3]-&#39;0&#39;;
		y=(USART_RX_INFO[5]-&#39;0&#39;)*100+(USART_RX_INFO[6]-&#39;0&#39;)*10+USART_RX_INFO[7]-&#39;0&#39;;
		r_x=(USART_RX_INFO[9]-&#39;0&#39;)*100+(USART_RX_INFO[10]-&#39;0&#39;)*10+USART_RX_INFO[11]-&#39;0&#39;;
		r_y=(USART_RX_INFO[13]-&#39;0&#39;)*100+(USART_RX_INFO[14]-&#39;0&#39;)*10+USART_RX_INFO[15]-&#39;0&#39;;
	&#125;
&#125;

void G_Follow_R(int Reach_Pos_CL_MODE)
&#123;
	int Sign(int num);
	void Get_RaG_Point_Pos(void);
	int near(int r_x,int Target_Y);
	
	int diff_x,diff_y,dis;
	while(Reach_Pos_CL_Stop_Sign)
	&#123;
		if(x==0&amp;&amp;y==0)Reach_Pos_OL(750,750);
		Get_RaG_Point_Pos();
		dis=near(r_x,r_y);
		if(dis&lt;=20)
		&#123;
			Beep_Times(300,1,NORMAL_MODE);
			Led_Times(300,1,NORMAL_MODE);
			continue;
		&#125;
		if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&gt;60)					//用pid计算舵机单位数
		&#123;
			Get_RaG_Point_Pos();
			diff_x=Pid_Control(Level_Kp,Level_Ki,Level_Kd,r_x,x,PID_REALIZE);
			diff_y=Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,r_y,y,PID_REALIZE);
		&#125;
		else if(Reach_Pos_CL_MODE==MINMIZE_MODE)		//以舵机最小分辨率为单位
		&#123;
			Get_RaG_Point_Pos();
			diff_x=-0.5*Sign(x-r_x);
			diff_y=-0.5*Sign(y-r_y);
		&#125;
		else if(Reach_Pos_CL_MODE==PID_MODE &amp;&amp; dis&lt;=60)					//用pid计算舵机单位数
		&#123;
			Get_RaG_Point_Pos();
			diff_x=-0.4*Sign(x-r_x);
			diff_y=-0.4*Sign(y-r_y);

		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>上位机数据格式为：g123y123r123y123，实时传输红绿激光点两个坐标；</p>
<p>执行点到点的跟踪即可，在主函数中不断重复即可，即while(1)G_Follow_R(PID_MODE);</p>
<h4 id="2-jetson-nano上关键源码分析"><a href="#2-jetson-nano上关键源码分析" class="headerlink" title="2.jetson nano上关键源码分析"></a>2.jetson nano上关键源码分析</h4><p><strong>文件说明：</strong></p>
<p>mian_10、main_11、mian_12是测试函数，分别测试<strong>铅笔线识别效果</strong> 、<strong>A4纸识别效果</strong> 、<strong>红绿激光分别识别效果</strong><br>。设置了滑动条供<strong>调参</strong> 使用，确定好参数</p>
<p>q_1、q_2、q_3即为三个问题对应的程序，分别实现<strong>发送铅笔线顶点和中心坐标后实时传输红色激光点坐标</strong><br>、<strong>发送A4纸顶点坐标后实时传输红色激光点坐标</strong> 、<strong>实时传输红色和绿色激光点坐标</strong></p>
<h5 id="I-相机参数的调整"><a href="#I-相机参数的调整" class="headerlink" title="I.相机参数的调整"></a>I.相机参数的调整</h5><pre><code>string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
&#123;
   return &quot;nvarguscamerasrc exposurecompensation=1 ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +
       to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +
       &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +
       to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;
&#125;
</code></pre>
<p>这里设置好管道参数，主要调整曝光和饱和度，方便之后线条的检测以及红绿激光的区分</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h5 id="II-关键识别算法"><a href="#II-关键识别算法" class="headerlink" title="II.关键识别算法"></a>II.关键识别算法</h5><h6 id="1-铅笔线识别及顶点的计算"><a href="#1-铅笔线识别及顶点的计算" class="headerlink" title="(1)铅笔线识别及顶点的计算"></a>(1)铅笔线识别及顶点的计算</h6><p><strong>变量解析：</strong></p>
<pre><code>int Find = 0, l_x = 0, l_y = 0, r_x = 0, r_y = 0;
int l[2][2],r[2][2],u[2][2],d[2][2];
int ul[2],ur[2],dl[2],dr[2],ce[2];
</code></pre>
<p>Find有效个数标志位，表示找到了几组有效的边上两点；</p>
<p>l_x、l_y、r_x、r_y寻找标志位，为1则分别表示上下左右边未找到有效值的两点值</p>
<p>l[2][2]、r[2][2]、u[2][2]、d[2][2]分别存储上下左右边上两点坐标</p>
<p>ul[2]、ur[2]、dl[2]、dr[2]、ce[2]分别存储最终的顶点和中心点坐标</p>
<p><strong>过程：</strong></p>
<p>——转换成灰度图-&gt;阈值划分成二制图-&gt;霍夫直线检测得到直线并输出直线上两点坐标</p>
<pre><code>    ——设计算法过滤筛选重复直线并存储两点坐标


for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
                x1 = linesPPHT[i][0], y1 = linesPPHT[i][1], x2 = linesPPHT[i][2], y2 = linesPPHT[i][3];
                line(image, Point(x1, y1), Point(x2, y2), Scalar(0), 1, 8);

                if (x1 &lt; 150 &amp;&amp; x2 &lt; 150 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !l_x)&#123;Find++;l_x = (x2 + x1) / 2;l[0][0]=x1;l[0][1]=y1;l[1][0]=x2;l[1][1]=y2;&#125;
                else if (y1 &lt; 150 &amp;&amp; y2 &lt; 150 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !l_y)&#123;Find++;l_y = (y1 + y2) / 2;u[0][0]=x1;u[0][1]=y1;u[1][0]=x2;u[1][1]=y2;&#125;
                else if (x1 &gt; 570 &amp;&amp; x2 &gt; 570 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !r_x)&#123;Find++;r_x = (x2 + x1) / 2;r[0][0]=x1;r[0][1]=y1;r[1][0]=x2;r[1][1]=y2;&#125;
                else if (y1 &gt; 570 &amp;&amp; y2 &gt; 570 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !r_y)&#123;Find++;r_y = (y1 + y2) / 2;d[0][0]=x1;d[0][1]=y1;d[1][0]=x2;d[1][1]=y2;&#125;
            &#125;
</code></pre>
<p>linesPPHT是霍夫直线检测函数的输出，linesPPHT.size()表示检测到直线的条数；这里根据直线上两点坐标值大小判断属于四条边的那一条；属于其中一条且之前未存储（标志位为1）（见if语句中的判断）则存储并将找点标志位Find+1；Find&#x3D;&#x3D;4时即寻找结束</p>
<p>——由于霍夫直线检测算法得到的并非顶点而是直线上两点，设计求两直线交点函数</p>
<pre><code>void crossline(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int cross[2])
&#123;
    cross[0]=(y3*x4*x2-y4*x3*x2-y3*x4*x1+y4*x3*x1-y1*x2*x4+y2*x1*x4+y1*x2*x3-y2*x1*x3)/(x4*y2-x4*y1-x3*y2+x3*y1-x2*y4+x2*y3+x1*y4-x1*y3);
    cross[1]=(-y3*x4*y2+y4*x3*y2+y3*x4*y1-y4*x3*y1+y1*x2*y4-y1*x2*y3-y2*x1*y4+y2*x1*y3)/(y4*x2-y4*x1-y3*x2+x1*y3-y2*x4+y2*x3+y1*x4-y1*x3);
&#125;
</code></pre>
<p>输入的(x1,y1)~(x4,y4)是两条直线上四点坐标，输出交点坐标并赋值给cross；</p>
<pre><code>crossline(l[0][0],l[0][1],l[1][0],l[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ul);
crossline(r[0][0],r[0][1],r[1][0],r[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ur);
crossline(l[0][0],l[0][1],l[1][0],l[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dl);
crossline(r[0][0],r[0][1],r[1][0],r[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dr);

crossline(ul[0],ul[1],dr[0],dr[1],ur[0],ur[1],dl[0],dl[1],ce);
</code></pre>
<p>输入之前得到的坐标计算四个顶点值和中心坐标</p>
<p>——向下位机stm32输出坐标</p>
<pre><code>sprintf(m,&quot;#a%03db%03dc%03dd%03de%03df%03dg%03dh%03d$\n&quot;,ul[0],ul[1],ur[0],ur[1],dr[0],dr[1],dl[0],dl[1]);
uart.sendUart(m);
usleep(50000);
sprintf(m,&quot;#i%03dj%03d$\n&quot;,ce[0],ce[1]);
uart.sendUart(m);
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png"></p>
<h6 id="2-A4纸顶点识别及巡线顶点的计算"><a href="#2-A4纸顶点识别及巡线顶点的计算" class="headerlink" title="(2)A4纸顶点识别及巡线顶点的计算"></a>(2)A4纸顶点识别及巡线顶点的计算</h6><p>过程：</p>
<p>——灰度图-&gt;二值化-&gt;角点检测得到角点坐标CornerImg</p>
<pre><code>    ——设计算法过滤筛选得到八个顶点P[8][2]（绝缘胶布内外边形成两个矩形）


#define MAX_DIS 20
int Is_Exit(int i, int j)
&#123;
    int k = 0;
    for (k = 0; k &lt; Find; k++) 
    &#123;
        if (myabs(P[k][0]-i)+ myabs(P[k][1]-j)&lt;MAX_DIS)return 1;
    &#125;
    return 0;
&#125;


int P[8][2] = &#123; 0 &#125;;
int Find = 0;

for (int j = 0; j &lt; CornerImg.rows; j++) &#123;
    for (int i = 0; i &lt; CornerImg.cols; i++) &#123;
        if (CornerImg.at&lt;float&gt;(j, i) &gt; 150.0f) &#123;
            if (!Is_Exit(i, j))
            &#123;                            
                P[Find][0] = i;
                P[Find][1] = j;
                Find++;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>Is_Exit()函数遍历已经视作有效的点，如果与当前坐标(i,j)接近则不存储；找到八个有效点退出</p>
<p>——设计根据八个顶点P[8][2]求得巡线四边形的顶点Vertex[4][2]（同一个角的内外顶点的中点）</p>
<pre><code>int Vertex[4][2] = &#123; 0 &#125;;
int sign[8] = &#123; 0 &#125;;
int i,j,k,dis,min = 1000;
int temp1, temp2;
for (k=0,i = 0; i &lt; 8; i++)
&#123;
    if (sign[i])continue;
    min = 2000;
    for (j = 0; j &lt; 8; j++)
    &#123;
        if (i == j||sign[j])continue;
        dis = myabs(P[i][0] - P[j][0]) + myabs(P[i][1] - P[j][1]);
        if (dis&lt; min)
        &#123;
            min = dis;
            temp1 = i;
            temp2 = j;
        &#125;
    &#125;
    sign[temp1] = 1;
    sign[temp2] = 1;
    Vertex[k][0] = (P[temp1][0] + P[temp2][0])/2;
    Vertex[k][1] = (P[temp1][1] + P[temp2][1])/2;
    k++;
&#125;
</code></pre>
<p>这里使用for循环遍历P[8][2]中顶点，将距离最近的两点视为A4纸一个角内外两边的两个顶点，求其中点存储在Vertex[4][2]中</p>
<p>——设计算法使巡线的四个端点按照顺时针传输给下位机，否则巡线顺序错误</p>
<pre><code>int temp;
//先整体按y值大小排序
for(i=0;i&lt;4;i++)
&#123;
    for(min=Vertex[i][1],j=k=i;j&lt;4;j++)
    &#123;
        if(Vertex[j][1]&lt;=min)k=j;
    &#125;
    temp=Vertex[k][0];
    Vertex[k][0]=Vertex[i][0];
    Vertex[i][0]=temp;
    temp=Vertex[k][1];
    Vertex[k][1]=Vertex[i][1];
    Vertex[i][1]=temp;
&#125;
//y值中等的两点按x值排序
if(Vertex[1][0]&lt;Vertex[2][0])
&#123;
    temp=Vertex[1][0];
    Vertex[1][0]=Vertex[2][0];
    Vertex[2][0]=temp;
    temp=Vertex[2][1];
    Vertex[2][1]=Vertex[1][1];
    Vertex[1][1]=temp;
&#125;


if(Vertex[0][0]&amp;&amp; Vertex[0][1]&amp;&amp;Vertex[1][0]&amp;&amp;Vertex[1][1]&amp;&amp;Vertex[3][0]&amp;&amp; Vertex[3][1]&amp;&amp;Vertex[2][0]&amp;&amp; Vertex[2][1])
&#123;
    sprintf(m,&quot;#k%03dl%03dm%03dn%03do%03dp%03dq%03dr%03d$\n&quot;, Vertex[0][0], Vertex[0][1],Vertex[1][0], Vertex[1][1],Vertex[3][0], Vertex[3][1],Vertex[2][0], Vertex[2][1]);
    u.sendUart(m);
&#125;
</code></pre>
<p><strong>观察任意矩形顶点坐标规律，要顺时针发送，可将y值最小的作为第一个发送，y值最大的第三个发送，介于中间的两点按x值大小判断，x小的最后发送，大的第二个发送</strong></p>
<p>即先整体按y值大小排序，y值中等的两点按x值排序-&gt;排序后按<strong>0<del>1</del>3~2的顺序</strong> 发送坐标</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png"></p>
<h6 id="3-区分红绿激光"><a href="#3-区分红绿激光" class="headerlink" title="(3)区分红绿激光"></a>(3)区分红绿激光</h6><p><strong>过程如下：</strong></p>
<pre><code>Point color_recognite(Mat image, Scalar Low, Scalar High)
&#123;

    vector&lt;vector&lt;Point&gt;&gt; g_vContours;
    vector&lt;Vec4i&gt; g_vHierarchy;
    vector&lt;Mat&gt; hsvSplit;
    double maxarea = 0;
    int maxAreaIdx = 0;
    Mat g_grayImage, hsv, g_cannyMat_output;

    cvtColor(image, hsv, COLOR_BGR2HSV);
    split(hsv, hsvSplit);
    equalizeHist(hsvSplit[2], hsvSplit[2]);
    merge(hsvSplit, hsv);
    inRange(hsv, Low, High, g_grayImage);//二值化识别颜色

    //开操作 (去除一些噪点)
    Mat element = getStructuringElement(MORPH_RECT, Size(2, 2));
    morphologyEx(g_grayImage, g_grayImage, MORPH_OPEN, element);

    //闭操作 (连接一些连通域)
    morphologyEx(g_grayImage, g_grayImage, MORPH_CLOSE, element);
    //  Canny(g_grayImage, g_cannyMat_output, 80, 80 * 2, 3);

    // 寻找轮廓
    findContours(g_grayImage, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));

    //假设contours是用findContours函数所得出的边缘点集
    RotatedRect box;
    Point centre;

    if (g_vContours.size() != 0)
    &#123;
        for (int index = 0; index &lt; g_vContours.size(); index++)
        &#123;
            double tmparea = fabs(contourArea(g_vContours[index]));
            if (tmparea &gt; maxarea)
            &#123;
                maxarea = tmparea;
                maxAreaIdx = index;//记录最大轮廓的索引号
            &#125;
        &#125;

        box = minAreaRect(g_vContours[maxAreaIdx]);
        rectangle(image, box.boundingRect(), Scalar(0, 0, 255), 2);
        centre = box.center;
    &#125;
    return centre;
&#125;
</code></pre>
<p>关键是调用inRange()函数HSV色彩空间二值化的阈值上下限设置</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Home_Wood/article/details/88613977" title="OpenCV学习笔记-inRange()阈值操作函数怎么用_cv.inrange函数">OpenCV学习笔记-<br>inRange()阈值操作函数怎么用_cv.inrange函数</a></p>
<p>并设置滑动条调整参数获得经验值</p>
<p><strong>最终评判标准：</strong></p>
<p>激光在绝缘胶布上是能否识别（黑色胶布吸光；通过提高曝光，调参，增大激光功率等可以解决）</p>
<p>红绿激光靠近时能否区分（红绿在HSC空间互斥，更亮的会掩盖另一个；调inRange()参数解决）</p>
<h2 id="二-学习资料分享"><a href="#二-学习资料分享" class="headerlink" title="二.学习资料分享"></a>二.学习资料分享</h2><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="&lt;1&gt;学习笔记"></a>&lt;1&gt;学习笔记</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797?spm=1001.2014.3001.5501" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697?spm=1001.2014.3001.5501" title="图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-CSDN博客">图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991?spm=1001.2014.3001.5501" title="图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-CSDN博客">图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?spm=1001.2014.3001.5501" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-CSDN博客">图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041?spm=1001.2014.3001.5501" title="图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-CSDN博客">图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399?spm=1001.2014.3001.5501" title="PID控制算法理解_switch_swq的博客-CSDN博客">PID控制算法理解_switch_swq的博客-<br>CSDN博客</a></p>
<h3 id="其他资料"><a href="#其他资料" class="headerlink" title="&lt;2&gt;其他资料"></a>&lt;2&gt;其他资料</h3><p>1.<a target="_blank" rel="noopener" href="https://space.bilibili.com/28143041/?spm_id_from=333.999.0.0" title="唐老师讲电赛的个人空间-唐老师讲电赛个人主页-哔哩哔哩视频">唐老师讲电赛的个人空间-唐老师讲电赛个人主页-<br>哔哩哔哩视频</a></p>
<p>2.电赛资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ehPdgMU8T16tcQXeLU1xaQ?pwd=1234#list/path=%2F" title="电赛资料_免费高速下载|百度网盘-分享无限制 (baidu.com)">电赛资料_免费高速下载|百度网盘-分享无限制<br>(baidu.com)</a>提取码：1234</p>
<p>3.我的“电赛”、“VS Studio”、“cmake”、“opencv”、“makefile”、“linux、操作系统”、“stm32”收藏夹</p>
<p>3.以及上面笔记中所包含信息</p>
<h2 id="三-备赛阶段记录"><a href="#三-备赛阶段记录" class="headerlink" title="三.备赛阶段记录"></a><strong>三.备赛阶段记录</strong></h2><p>7.2.2023</p>
<ul>
<li>问题 <ol>
<li>Nano板子供电5v4A，需求电流较大</li>
<li>实验室现有开关电源模块似乎调不了5v，需自己设计电源模块</li>
<li>作为底层主要负责，如何为项目打下坚实基础</li>
<li>硬件使用有明确目标，如何学习</li>
</ol>
</li>
<li>解决 <ol>
<li>先不考虑电源模块，用适配器及直流电源供电</li>
<li>先把电机控制写好，提供友善接口</li>
<li>先用简单硬件过度，后期转高级的。如电机先用直流后用伺服。先拼起来，再细化雕琢</li>
</ol>
</li>
<li>收获 <ol>
<li>用vscode远程开发jetson，下载remote-ssh插件，ssh jetson@IP地址；快捷键ctrl+o调出要打开页面</li>
</ol>
</li>
</ul>
<p>7.3.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32很多知识忘记，如定时器和A&#x2F;D、D&#x2F;A；是否需要复习，因复习耗时且不一定需要stm32</li>
<li>目前目标尚不明确</li>
</ol>
</li>
<li>解决 <ol>
<li>先将stm32相关知识看完，stm32作为保底</li>
<li>先搭一个蓝牙遥控小车！</li>
</ol>
</li>
<li>收获 <ol>
<li>修好了学长的小车，看到了PID实现双轮平衡小车的现象</li>
<li>学会了MG995型号舵机控制（控制脉冲占空比实现角度控制）</li>
<li>搭建了测试平台（OLED屏、蓝牙、i2c通讯）</li>
<li>搭建了简单的两轮遥控小车，采用直流电机控制，未加入PWM波调速，实现简单的前进、倒退、转弯。</li>
</ol>
</li>
</ul>
<p>7.4.2023</p>
<ul>
<li>问题 <ol>
<li>昨天做的小车电源直接冒烟，因为电源采用两节3.7V锂电池供电，buck升压到12V以匹配LM298N，电流过大</li>
</ol>
</li>
<li>解决 <ol>
<li>暂时给l298n提供5V电压，驱动能力下降，但系统可以运行。以后电源模块之后重新设计或使用小功率电机</li>
</ol>
</li>
<li>收获 <ol>
<li>主要将昨天搭好的小车完善，并加入了测压模块（利用STM32的ADC外设）</li>
<li>复习了stm32相关知识（外部中断，定制器TIM设置，定时器比较OC产生PWM波）</li>
<li>打开了jetson nano的摄像头，它睁开了眼</li>
</ol>
</li>
</ul>
<p>7.5.2023</p>
<ul>
<li>问题 <ol>
<li>编码器旋转无响应，电机也不动了</li>
<li>烧了一个stm32板子，当时接的自制稳压模块，之前都是好的，不知道什么原因</li>
</ol>
</li>
<li>解决 <ol>
<li>重新测试电机是否能正常工作</li>
<li>在小车到达前有时间学习MPU6050，相关姿态轨迹传输算法</li>
</ol>
</li>
<li>收获 <ol>
<li>在jetson nano上跑了例程及自己上传的几张图片</li>
<li>学会了linux的vim的使用</li>
<li>复习了stm32相关知识（定时器IC输入捕获模式）</li>
<li>学会了超声波测距CS100A模块和红外传感模块以及电机编码器部分</li>
</ol>
</li>
</ul>
<p>7.6.2023</p>
<ul>
<li>问题 <ol>
<li>如何解决电机编码器输出波形峰值小，stm32无法接收</li>
<li>Pwm波和电源需供电，不然波形失真</li>
</ol>
</li>
<li>解决 <ol>
<li>昨天电机不转是因为接线不紧，编码器不行是因为输出电压太小，只有0.5v左右</li>
<li>考虑IO口输出模式，不行加电压比较器，ref&#x3D;0.33V</li>
<li>要重新系统性设计电源了，所有信号共地！</li>
</ol>
</li>
<li>收获 <ol>
<li>拼好了大车，发现了诸多问题，舵机控制程序完成</li>
<li>浅浅学了PCB绘制流程</li>
</ol>
</li>
</ul>
<p>7.7.2023</p>
<ul>
<li>问题 <ol>
<li>控制函数太过简陋，后续仍需不断升级</li>
<li>图像识别进度为零</li>
</ol>
</li>
<li>解决 <ol>
<li>《基于opencv的数字图像处理技术》</li>
</ol>
</li>
<li>收获 <ol>
<li>用洞洞板搭建好了电源系统（12V-5V-3.7V），系统完全移植到大车</li>
<li>新车编码器输出足够大，无需放大器，编码器计数正常</li>
</ol>
</li>
</ul>
<p>7.8.2023</p>
<ul>
<li>收获 <ol>
<li>学会在Windows配置OpenCV环境，掌握OpenCV图像视频基本操作以及一些基础知识</li>
<li>PCB绘制进展</li>
</ol>
</li>
</ul>
<p>7.9.2023</p>
<ul>
<li>收获 <ol>
<li>学会在linux中运行调用OpenCV的c++文件（cmake的使用）</li>
<li>学习OpenCV基本数据结构和类的使用</li>
<li>进一步了解VS studio上编译选项配置以及debug和release的区别</li>
</ol>
</li>
</ul>
<p>7.10.2023</p>
<ul>
<li>收获 <ol>
<li>学会OpenCV灰度变换、直方图、边缘检测、霍夫检测直线和圆</li>
</ol>
</li>
</ul>
<p>7.11.2023</p>
<ul>
<li>问题 <ol>
<li>源码在linux上无法运行（OpenCV调用摄像头出问题，采用CMake方法编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>今天下午加晚上未解决</li>
</ol>
</li>
<li>收获 <ol>
<li>学会阈值分割（图像二值化方法）</li>
</ol>
</li>
</ul>
<p>7.12.2023</p>
<ul>
<li>问题 <ol>
<li>C++无法编译成功，Mat类未定义引用（QT上编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>使用python编写运行成功</li>
</ol>
</li>
<li>收获 <ol>
<li>看完特征提取和目标检测（HOG特征+SVM基本流程；LBP特征+级联分类器）</li>
</ol>
</li>
</ul>
<p>7.13.2023</p>
<ul>
<li>问题 <ol>
<li>依旧无法运行以C++运行OpenCV代码</li>
<li>可以运行的OpenCV代码不能直接以videocapture capture(0)的方法获取视频流</li>
</ol>
</li>
<li>解决 <ol>
<li>重新系统性安装OpenCV库并重走CMake流程</li>
<li>将视频流通过管道gstreamer传输</li>
</ol>
</li>
<li>收获 <ol>
<li>学会CMake以及基本编译链接流程</li>
<li>重新安装配置OpenCV4.8.0，成功在jetson nano上运行OpenCV代码</li>
</ol>
</li>
</ul>
<p>7.14.2023</p>
<ul>
<li>问题 <ol>
<li>但运行自己编写的直线检测程序过于卡顿，一秒一帧</li>
<li>蓝牙模块无法正常工作</li>
</ol>
</li>
<li>解决 <ol>
<li>霍夫直线检测运算量大，不使用该算法</li>
<li>调整视频大小及帧率</li>
<li>经检测应是蓝牙模块问题，重新购买</li>
</ol>
</li>
<li>收获 <ol>
<li>使用画好的pcb搭建小车，将全部器件搭载在小车上</li>
</ol>
</li>
</ul>
<p>7.15.2023</p>
<ul>
<li>问题 <ol>
<li>电机控制出错，一边电机不受控制</li>
<li>目前控制算法学的太少，但图像识别进展不够</li>
</ol>
</li>
<li>解决 <ol>
<li>GPIO口选到了下载口JTDI&#x2F;O，换GPIO口控制</li>
<li>先用超声波模块、MPU6050、红外传感等模块写避障、路径记录、寻迹等功能</li>
</ol>
</li>
<li>收获 <ol>
<li>学会jetson nano上的GPIO使用（基本和树莓派一样）</li>
<li>解决了电机的基本控制问题并将电机的四控制线改成了两根</li>
<li>jetson使用电池供电（器件全供地）；实现stm32与jetson nano的usart通信（照搬蓝牙）</li>
</ol>
</li>
</ul>
<p>7.16.2023</p>
<ul>
<li>问题 <ol>
<li>超声波测距模块中断代码写的不好，拔下模块进入while循环等待，系统卡住</li>
<li>拉肚子</li>
</ol>
</li>
<li>解决 <ol>
<li>使用static变量，进入中断模式改为EXTI_Trigger_Rising_Falling…</li>
<li>休息一天（今日中午至明天中午）</li>
</ol>
</li>
</ul>
<p>7.17.2023</p>
<ul>
<li>问题 <ol>
<li>欲添加mpu6050模块，但其与oled、蓝牙、超声波模块冲突（非引脚分配问题）</li>
</ol>
</li>
<li>解决 <ol>
<li>更改方案，debug试试。仍不行</li>
</ol>
</li>
</ul>
<p>7.18.2023</p>
<ul>
<li>问题 <ol>
<li>昨天问题仍然存在</li>
<li>多个中断之间不协调，影响超声波测距精度。以及测角度过于耗时</li>
</ol>
</li>
<li>解决 <ol>
<li>使用江科大自动化的例程代码，简洁明了，解决冲突</li>
<li>更改各个中断优先级，控制mpu6050的使用</li>
</ol>
</li>
<li>收获</li>
</ul>
<p>7.19.2023</p>
<ul>
<li>收获 <ol>
<li>学会PID算法</li>
<li>重新绘制PCB，解决若干问题</li>
</ol>
</li>
</ul>
<p>7.20.2023</p>
<ul>
<li>问题 <ol>
<li>SysTick定时器冲突问题（外部和中断同时调用delay_us函数会卡死）</li>
</ol>
</li>
<li>解决 <ol>
<li>避免了0.1s定时器中断（数据刷新）的SysTick定时函数</li>
</ol>
</li>
<li>收获 <ol>
<li>使用编码器利用PID编写行驶给定长度函数及测速</li>
</ol>
</li>
</ul>
<p>7.21.2023</p>
<ul>
<li>问题 <ol>
<li>后退时编码器反向计数，上限不明确，速度测算出现问题</li>
</ol>
</li>
<li>解决 <ol>
<li>通过TIM_EncoderInterfaceConfig设置编码器反转依旧向上计数</li>
</ol>
</li>
<li>收获 <ol>
<li>编写小车倒车定长距离</li>
</ol>
</li>
</ul>
<p>7.22.2023</p>
<ul>
<li>收获 <ol>
<li>编写小车以恒定速度行驶和拐弯90度算法</li>
</ol>
</li>
</ul>
<p>7.23.2023</p>
<ul>
<li>收获 <ol>
<li>焊好新到的板子</li>
</ol>
</li>
</ul>
<p>7.24.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson配置难，yolo难跑通</li>
<li>要求设计完整程序，在jetson开机时自动执行</li>
</ol>
</li>
<li>解决 <ol>
<li>学习OpenCV备用</li>
<li>学习python或c++可执行文件Linux开机自动执行方法</li>
</ol>
</li>
</ul>
<p>7.25.2023</p>
<ul>
<li>问题 <ol>
<li>采用硬盘直接克隆方式克隆SD卡依旧无法启动jetson nano系统</li>
</ol>
</li>
<li>解决 <ol>
<li>烧录官方镜像文件，成功还原系统。并发现python和C++环境已经配好，之前不会用。解决yolov5摄像头实时检测问题，方案参考亚博论坛。C++也是，g++编译时加上一个参数就行</li>
</ol>
</li>
</ul>
<p>7.26.2023</p>
<ul>
<li>收获 <ol>
<li>看今年电赛器件清单，简单编写完云台代码，购买K210等器材</li>
</ol>
</li>
</ul>
<p>7.27.2023</p>
<ul>
<li>收获 <ol>
<li>简单编写完红外寻迹功能</li>
<li>解决nano开机启动python文件</li>
</ol>
</li>
</ul>
<p>7.28.2023</p>
<ul>
<li>问题 <ol>
<li>分析电赛清单，云台摄像头加激光笔应该涉及到动态物体追踪</li>
</ol>
</li>
<li>解决 <ol>
<li>学习视频目标跟踪</li>
</ol>
</li>
</ul>
<p>7.29.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32定时器资源有限无法满足云台的加入</li>
</ol>
</li>
<li>解决 <ol>
<li>使用pca9685驱动</li>
</ol>
</li>
<li>收获 <ol>
<li>采用stm32管脚重定义解决pca9685驱动的使用问题</li>
</ol>
</li>
</ul>
<p>7.30.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson nano的C++库不包含串口uart相关内容</li>
</ol>
</li>
<li>解决 <ol>
<li>使用其设备&#x2F;dev&#x2F;tthTSH1，研究网上代码</li>
</ol>
</li>
<li>收获 <ol>
<li>编写以及pca9685控制云台函数</li>
</ol>
</li>
</ul>
<p>7.31.2023</p>
<ul>
<li>问题 <ol>
<li>霍夫圆检测一定也不稳定</li>
</ol>
</li>
<li>解决 <ol>
<li>调整参数或使用深度学习识别物体的方法</li>
</ol>
</li>
<li>收获 <ol>
<li>终于解决串口通信问题，实现C++语言的nano和电脑以及stm32通信</li>
<li>完善霍夫圆检测代码，加入uart传输圆心坐标</li>
<li>学会nano开机自启动程序方法</li>
<li>编写stm32的PID点跟踪函数，实现点跟踪</li>
</ol>
</li>
</ul>
<p>8.1.2023</p>
<ul>
<li>问题 <ol>
<li>走定长不精确，大约是设定5cm行驶6cm这个比例</li>
</ol>
</li>
<li>收获 <ol>
<li>编写摇杆控制云台程序</li>
<li>发现之前使用的pid算法全犯了低级错误，本应用float定义PID值结果用了int，修改后大范围应用，各个控制加入PID平稳精确了很多</li>
</ol>
</li>
</ul>
<h2 id="四-电赛总结及经验教训"><a href="#四-电赛总结及经验教训" class="headerlink" title="四.电赛总结及经验教训"></a>四.电赛总结及经验教训</h2><h3 id="本次比赛作品的不足、改进之处"><a href="#本次比赛作品的不足、改进之处" class="headerlink" title="&lt;1&gt;本次比赛作品的不足、改进之处"></a>&lt;1&gt;本次比赛作品的不足、改进之处</h3><p>1.stm32和jetson<br>nano通讯不稳定（可能原因：杜邦线传输能力差、波特率可能设置高了【但低了影响系统处理速度】）（实际原因：while写成了if，导致时机很难对上，通信规则设计失误！）</p>
<p>2.stm32主函数设计不行，没花时间改进，想要重复运行某个程序只能重启，人机交互也不友好</p>
<p>3.比赛报告没有在头脑风暴之后就开始写，导致后期书写太急，不够规范</p>
<p>4.linux操作不熟，开机自启动程序出现问题，且jetson nano上的程序设计缺乏系统性结构性（每问都写了一个程序，而不是整合成一个大的测试程序）</p>
<p>5.所有任务完成太晚，没有留下时间仔细调试调参找问题。而且全流程过一遍后立马就要封箱了，急急忙忙乱改代码导致出现了<strong>意想不到的错误！再给一天就刚好了啊！！！</strong></p>
<h3 id="本次比赛的经验教训"><a href="#本次比赛的经验教训" class="headerlink" title="&lt;2&gt;本次比赛的经验教训"></a>&lt;2&gt;本次比赛的经验教训</h3><p>1.器件准备很重要：比赛发布器件清单后要备齐，最好每个器件都多买几个。以满足比赛器件需求并防止比赛时器件损坏！（本次比赛oled屏、舵机都反复坏过）</p>
<p>2.器件精度很重要：比赛前统计自己所有器件清单，并实测是否可以使用？精度如何？硬件精度不足会直接导致结果无法满足！（本次比赛刚开始使用的舵机为20kg大扭矩低精度，调了一晚PID参数舵机仍然运动不准，最后才发现是精度问题）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132150694">https://blog.csdn.net/qq_32971095/article/details/132150694</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-08 00:33:48" itemprop="dateCreated datePublished" datetime="2025-02-08T00:33:48+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>367</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fab fa-csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">698k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
