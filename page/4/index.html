<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Switch">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SWQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="Switch" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">PID控制算法理解</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-25 22:44:50" itemprop="dateCreated datePublished" datetime="2023-07-25T22:44:50+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="PID控制算法理解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-简要回顾PID"><a href="#一-简要回顾PID" class="headerlink" title="一.简要回顾PID"></a>一.简要回顾PID</h2><p>*代码：</p>
<pre><code>//**********pid.h**********
#ifndef _PID_H
#define _PID_H
#include &quot;public.h&quot;

#define PID_REALIZE	0	//位置式PID
#define PID_INCREASE 1	//增量式PID

int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode);

#endif



//**********pid.c**********
#include &quot;pid.h&quot;

//速度环控制
int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode)
&#123;
	int Pid_Num=0;		//返回的控制值
	
	static float Error_k=0;
	static float Error_k1=0;
	static float Error_k2=0;
	
	Error_k=Target_Num-Current_Num;
	Error_k1=Error_k-Error_k1;
	
	if(PID_Mode==PID_INCREASE)
	&#123;
		Error_k2=Error_k-2*Error_k1+Error_k2;
		Pid_Num=kp*Error_k+ki*Error_k2+kd*Error_k1;
	&#125;
	
	else if(PID_Mode==PID_REALIZE)
	&#123;
		Pid_Num=kp*Error_k+kd*Error_k1;
	&#125;

	Error_k2=Error_k1;
	Error_k1=Error_k;

	return Pid_Num;
&#125;
</code></pre>
<p>*所需参数：KP&#x2F;KI&#x2F;KD&#x2F;当前值Curr_Num</p>
<p>*返回值：Pid_Num（根据实际情境确定其物理意义，比如可以是增量：如控制电机转速，Pid_Num为增量，可代表增加的电压值等；也可以是直接确定值：如控制小车行进距离，Pid_Num代表当前小车速度）</p>
<p>*位置式PID和增量式PID区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/89508034" title="位置式PID与增量式PID区别浅析">位置式PID与增量式PID区别浅析</a></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二-PID参数意义"><a href="#二-PID参数意义" class="headerlink" title="二.PID参数意义"></a>二.PID参数意义</h2><p>评估指标：最大超调量、上升时间、静差（稳定、准确、快速）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f816706c1aa1692d006fa201b2e511c2.png"></p>
<p> PID三参数：P用于提高响应速度，I减小静差、D减小静差</p>
<p>在实践生产工程中，不同的控制系统对控制器效果的要求不一样。比如平衡车、倒立摆对系统的快速性要求很高,响应太慢会导致系统失控。智能家居里面的门窗自动开合系统,对快速性要求就不高,但是对稳定性和准确性的要求就很高,所以需要严格控制系统的超调量和静差。</p>
<p>所以PID参数在不同的控制系统中是不一样的。只要我们理解了每个PID参数的作用,我们就可以应对工程中的各种项目的PID参数整定了。</p>
<p> 位置控制的调节经验可以总结为：先只使用P控制，增大P系数至系统震荡之后加入微分控制以增大阻尼,消除震荡之后再根据系统对响应和静差等的具体要求，调节P 和<br>I 参数。</p>
<p>一般而言,一个控制系统的控制难度,一般取决于系统的转动惯量和对响应的速度要求等。转动惯量越小、对响应速度要求越低, PID参数就越不敏感。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399">https://blog.csdn.net/qq_32971095/article/details/131927399</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（PCB设计）——电赛学习笔记（4）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-25 22:01:44" itemprop="dateCreated datePublished" datetime="2023-07-25T22:01:44+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（PCB设计）——电赛学习笔记（4）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>540</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习来源：B站唐老师讲电赛——PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zg41127BV/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0_哔哩哔哩_bilibili">PCB设计极速入门，立创EDA+ALTIUM<br>DESIGNER<br>10.0_哔哩哔哩_bilibili</a></p>
<p>一.设计过程</p>
<p>使用嘉立创EDA加Altium Designer联合设计</p>
<p>1.嘉立创EDA：原理图绘制；器件选型；PCB生成；</p>
<p>ICEDA操作：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f20d7d97b76a22bfbc89dc11ba4cd542.png"></p>
<p>生成的pcd文件和原理图-导出-Altium Designer文件；转至 Altium Designer操作</p>
<p>2.Altium Designer：基础操作；使用规则（右键-设计-规则-desgin rules右键-导入规则-类型全选-<br>寻找规则文件）；字体大小调节（任意字右键-查找相似对象-text height-same-应用-修改text height）；shift s-DSD-<br>shift s-清除（右下角）；注意各个板层（顶层、底层；顶层走不通打过孔底层走；过孔尽量不经过焊盘）</p>
<p>调整好后新建PCB工程-右键添加现有文件-保存工程</p>
<p>走线（TAB键调出参数）</p>
<p>覆铜（放置多边形平面）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42fa1ac446e75661bc31d493a6a28d3c.png"></p>
<p> 打过孔</p>
<p>注意事项：芯片电源引脚加电容滤纹波</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c5d70666df4ea8e0417e843702022b96.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041">https://blog.csdn.net/qq_32971095/article/details/131583041</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" class="post-title-link" itemprop="url">OpenCV学习笔记——《基于OpenCV的数字图像处理》</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-08 23:25:36" itemprop="dateCreated datePublished" datetime="2023-07-08T23:25:36+08:00">2023-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="OpenCV学习笔记——《基于OpenCV的数字图像处理》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/08/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>源码下载：<a target="_blank" rel="noopener" href="https://29.s.bookln.cn/q?c=120EL4LP111&sh=sh&vt_=1688811733923#1688811735786" title="下载资源包 (bookln.cn)">下载资源包<br>(bookln.cn)</a></strong></p>
<p><strong>常用函数库：</strong></p>
<p>**         英文：**<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/" title="OpenCV:
OpenCV modules">OpenCV: OpenCV modules</a></p>
<p>**         中文：**<a target="_blank" rel="noopener" href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/index.html" title="Welcome to opencv documentation! — OpenCV 2.3.2 documentation">Welcome to opencv documentation! — OpenCV 2.3.2<br>documentation</a></p>
<p><strong>jetson nano上的OpenCV使用：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</p>
<p><strong>学习OpenCV的推荐网站和文章：</strong></p>
<p><a target="_blank" rel="noopener" href="https://learnopencv.com/getting-started-with-opencv/" title="Getting Started with OpenCV | LearnOpenCV">Getting Started with OpenCV | LearnOpenCV</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spmallick/learnopencv" title="spmallick&#x2F;learnopencv:
Learn OpenCV : C++ and Python Examples (github.com)">spmallick&#x2F;learnopencv: Learn OpenCV : C++ and Python Examples<br>(github.com)</a></p>
<p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">一.图像相关知识</a></p>
<p><a href="about:blank#%E4%BA%8C.opencv%E7%AE%80%E4%BB%8B">二.opencv简介</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%EF%BC%88VS2019%EF%BC%89%E3%80%81%E6%BA%90%E7%A0%81%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%EF%BC%88CMake%EF%BC%89%E3%80%81%E8%B0%83%E7%94%A8%E5%8A%A8%2F%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81cv%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81OpenCV%20API%E7%89%B9%E7%82%B9%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3InputArray%2FOutputArray%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81OpenCV%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81HighGui%E6%A8%A1%E5%9D%97%EF%BC%89">&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV<br>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">&lt;2&gt;示例代码：</a></p>
<p><a href="about:blank#1.%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%9A">1.展示图片：</a></p>
<p><a href="about:blank#2.%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91">2.播放视频</a></p>
<p><a href="about:blank#3.%E6%BB%91%E5%8A%A8%E6%9D%A1%E4%BD%BF%E7%94%A8%EF%BC%9A">3.滑动条使用：</a></p>
<p><a href="about:blank#4.%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%EF%BC%9A">4.鼠标事件响应：</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B%EF%BC%9A">&lt;3&gt;练手：</a></p>
<p><a href="about:blank#1.%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4">1.打开摄像头</a></p>
<p><a href="about:blank#2.%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%8C%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%9A%82%E5%81%9C%2F%E6%92%AD%E6%94%BE">2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</a></p>
<p><a href="about:blank#%3C4%3Elinux%E4%B8%8A%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%EF%BC%9A%E5%8F%82%E8%80%83%EF%BC%9ALinux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8CC%2B%2B%20OpenCV%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3_linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%A5%BDopencv%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%A0%E8%BD%BD_Adenialzz%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2">&lt;4&gt;linux上编译运行：参考：Linux下编译、链接、加载运行C++<br>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客</a></p>
<p><a href="about:blank#%E4%B8%89.OpenCV%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">三.OpenCV基本数据结构和基本组件</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%83%8F%E5%AE%B9%E5%99%A8Mat%E7%B1%BB%EF%BC%9B%E7%82%B9Point%E7%B1%BB%EF%BC%9B%E9%A2%9C%E8%89%B2Scalar%E7%B1%BB%EF%BC%9B%E5%B0%BA%E5%AF%B8Size%E7%B1%BB%EF%BC%9B%E7%9F%A9%E5%BD%A2Rect%E7%B1%BB%EF%BC%9B%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2RotatedRect%E7%B1%BB%EF%BC%9B%E5%9B%BA%E5%AE%9A%E5%90%91%E9%87%8FVec%E7%B1%BB%EF%BC%9B%E5%A4%8D%E6%95%B0%E7%B1%BBcomplexf%EF%BC%89">&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</a></p>
<p><a href="about:blank#%C2%A0%3C2%3E%E7%BB%83%E6%89%8B%E4%BB%A3%E7%A0%81"> &lt;2&gt;练手代码</a></p>
<p><a href="about:blank#1.Mat%E7%B1%BB%E6%93%8D%E4%BD%9C">1.Mat类操作</a></p>
<p><a href="about:blank#2.%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E6%B5%81%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2">2.摄像头图像流极坐标变换</a></p>
<p><a href="about:blank#3.%E8%AF%BB%E5%8F%96%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0RGB%E5%80%BC%EF%BC%88%E5%B7%A6%E9%94%AE%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%B8%85%E7%A9%BA%EF%BC%89">3.读取图像像素RGB值（左键显示，右键清空）</a></p>
<p><a href="about:blank#4.%E5%88%9B%E5%BB%BA%E4%B8%80%E5%AE%9A%E5%B0%BA%E5%AF%B83%E9%80%9A%E9%81%93RGB%E5%9B%BE%E5%83%8F%EF%BC%8C%E5%B9%B6%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE%E5%85%B6%E5%83%8F%E7%B4%A0%E5%80%BC%EF%BC%8C%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%80%E7%BB%BF%E8%89%B2%E5%B9%B3%E9%9D%A2">4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">四.数字图像灰度变换与空间滤波</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%EF%BC%9A%E7%BA%BF%E6%80%A7%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%EF%BC%9B%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9A%E6%A6%82%E7%8E%87%E3%80%81%E7%B4%AF%E8%AE%A1%EF%BC%89">&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">1.灰度变换函数</a></p>
<p><a href="about:blank#2.%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88%E6%A6%82%E7%8E%87%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%89%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0">2.直方图（概率直方图）绘制函数</a></p>
<p><a href="about:blank#%E4%B8%83.%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2">七.图像分割</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%EF%BC%9A%E7%AE%97%E5%AD%90%EF%BC%9A%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%EF%BC%88Sobel%2FPrewitt%2FRoberts%EF%BC%89%E3%80%81%E4%BA%8C%E9%98%B6%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%2FLOG%2FCanny%EF%BC%89%E3%80%81%E6%B7%B7%E5%90%88%EF%BC%9B%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%EF%BC%88%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%EF%BC%89%EF%BC%9A%E7%9B%B4%E7%BA%BF%EF%BC%89">&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</a></p>
<p><a href="about:blank#%EF%BC%88%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%E3%80%90%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E3%80%91%EF%BC%9A%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%EF%BC%89">（几何形状检测【霍夫变换】：直线、圆）</a></p>
<p><a href="about:blank#%EF%BC%88%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E3%80%90%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%91%EF%BC%9A%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E3%80%90OTSU%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%95%E3%80%91%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</a></p>
<p><a href="about:blank#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">​编辑<br>&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%92%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B">1.霍夫直线变换和霍夫圆检测</a></p>
<p><a href="about:blank#2.OTSU%E6%96%B9%E6%B3%95%E5%92%8C%E4%B8%89%E8%A7%92%E6%B3%95%E6%B1%82%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC">2.OTSU方法和三角法求全局阈值</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B">&lt;3&gt;练手</a></p>
<p><a href="about:blank#1.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8">1.边缘检测二阶导数算子使用</a></p>
<p><a href="about:blank#2.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%8F%8A%E9%9C%8D%E5%A4%AB%E5%9C%86%E7%9A%84%E6%A3%80%E6%B5%8B">2.霍夫直线变换及霍夫圆的检测</a></p>
<p><a href="about:blank#3.linux%EF%BC%88ubuntu18%EF%BC%89%E4%B8%8A%E5%AE%9E%E7%8E%B0%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%EF%BC%88%E5%8F%AF%E8%B0%83%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89">3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</a></p>
<p><a href="about:blank#4.%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%EF%BC%88OTSU%2F%E4%B8%89%E8%A7%92%E6%B3%95%2F%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</a></p>
<p><a href="about:blank#5.%E8%AF%86%E5%88%AB%E8%BD%A6%E9%81%93%EF%BC%88%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%81%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%EF%BC%89">5.识别车道（二值化、边缘检测、霍夫直线变换）</a></p>
<p><a href="about:blank#%E4%B9%9D.%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%92%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">九.特征提取和目标检测</a></p>
<p>[&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-<br>LIKE）（分类：SVM&#x2F;级联分类器）](about:blank#%3C1%3E%EF%BC%88%E7%89%B9%E5%BE%81%EF%BC%9AHOG%2FLBP%2FHAAR-<br>LIKE%EF%BC%89%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%9ASVM%2F%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%89)</p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.HOG%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%2BSVM">1.HOG特征提取+SVM</a></p>
<p>[2.获取LBP&#x2F;MB-LBP特征函数](about:blank#2.%E8%8E%B7%E5%8F%96LBP%2FMB-<br>LBP%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0)</p>
<p><a href="about:blank#3.cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E4%BD%BF%E7%94%A8">3.cascade级联分类器使用</a></p>
<hr>
<h2 id="一-图像相关知识"><a href="#一-图像相关知识" class="headerlink" title="一.图像相关知识"></a>一.图像相关知识</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb52f259aeff1a793a7899f7f1678e8e.jpeg"></p>
<h2 id="二-opencv简介"><a href="#二-opencv简介" class="headerlink" title="二.opencv简介"></a>二.opencv简介</h2><h5 id="（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV"><a href="#（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV" class="headerlink" title="&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV"></a>&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV</h5><p>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be8b3f267f375a33f3365797cbf719bd.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7637aa7bab9d022a85a835b6b07b0818.jpeg"></p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="&lt;2&gt;示例代码："></a>&lt;2&gt;示例代码：</h5><h6 id="1-展示图片："><a href="#1-展示图片：" class="headerlink" title="1.展示图片："></a>1.展示图片：</h6><pre><code>int main()
&#123;
	namedWindow(&quot;lena&quot;, WINDOW_NORMAL);
	//setWindowProperty(&quot;lena&quot;, WND_PROP_FULLSCREEN, WINDOW_FULLSCREEN);
	setWindowTitle(&quot;lena&quot;, &quot;Lena经典图像窗口&quot;);
	//resizeWindow(&quot;lena&quot;, 400, 300);
	//moveWindow(&quot;lena&quot;, 0, 0);
	createTrackbar(&quot;t1&quot;, &quot;lena&quot;, NULL, 10, NULL, NULL);
	Mat img = imread(&quot;lena512color.tiff&quot;); //读取图像
	if (img.empty()) &#123;
		return -1; //如果读取图像失败，则返回
	&#125;
	imshow(&quot;lena&quot;, img); //显示图像
	waitKey(0); //等待用户输入
    std::cout &lt;&lt; &quot;Hello World!\n&quot;; 
&#125;
</code></pre>
<h6 id="2-播放视频"><a href="#2-播放视频" class="headerlink" title="2.播放视频"></a>2.播放视频</h6><pre><code>void PlayVideo()
&#123;
	cv::VideoCapture capture(&quot;D:/files/picture and video/C0056.MP4&quot;);
	int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
	int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
	double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率
	double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数
	double dblStartFrames = dblFrameCnt / 2; //播放起始帧数
	capture.set(CAP_PROP_POS_FRAMES, dblStartFrames); //从视频中间开始播放

	cv::namedWindow(&quot;video&quot;,0 );
	resizeWindow(&quot;video&quot;, 800, 600);

	while (capture.isOpened()) &#123;
		Mat frame;
		capture &gt;&gt; frame;
		if (frame.empty()) &#123;
			break;
		&#125;
		imshow(&quot;video&quot;, frame);
		waitKey(10);
	&#125;
&#125;
</code></pre>
<h6 id="3-滑动条使用："><a href="#3-滑动条使用：" class="headerlink" title="3.滑动条使用："></a>3.滑动条使用：</h6><pre><code>滑动条的使用实例
const int g_nMaxAlphaValue = 100; //Alpha值的最大值
int g_nCurAlphaValue;   //当前滑动条对应的值
Mat g_srcImg1; //第1张图像
Mat g_srcImg2; //第2张图像
Mat g_mixImg;  //混合图像
const char cszWindowName[] = &quot;mix&quot;;
//拖动滑动条的响应函数
void on_Trackbar(int, void *)
&#123;
	//求出当前alpha值相对于最大值的比例
	double dblAlphaValue = double(g_nCurAlphaValue)/double(g_nMaxAlphaValue);
	//则beta值为1减去alpha值
	double dblBetaValue = 1.0 - dblAlphaValue;
	//根据alpha和beta的值，对两张图像进行线性混合
	addWeighted(g_srcImg1, dblAlphaValue, g_srcImg2, dblBetaValue, 0.0, g_mixImg);
	//显示混合图像的效果
	imshow(cszWindowName, g_mixImg);
	if (0 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix0.jpg&quot;, g_mixImg);
	&#125;
	if (50 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix50.jpg&quot;, g_mixImg);
	&#125;
	if (100 == g_nCurAlphaValue) &#123;
		imwrite(&quot;mix100.jpg&quot;, g_mixImg);
	&#125;
&#125;

int main(int argc, char ** argv)
&#123;
	//加载图像 (两图像的尺寸需相同)
	g_srcImg1 = imread(&quot;lenna.bmp&quot;, IMREAD_COLOR);
	if (g_srcImg1.empty()) &#123;
		std::cout &lt;&lt; &quot;读取第1张图像失败&quot; &lt;&lt; std::endl;
		return -1;
	&#125;
	g_srcImg2 = imread(&quot;tiffany.bmp&quot;, IMREAD_COLOR);
	if (g_srcImg2.empty())&#123;
		std::cout &lt;&lt; &quot;读取第2张图像失败&quot; &lt;&lt; std::endl;
		return -1;
	&#125;
	// 设置滑动条的初值为70
	g_nCurAlphaValue = 0;

	//创建窗口，自动调整大小
	namedWindow(&quot;mix&quot;, WINDOW_AUTOSIZE);
	//在创建的窗体中创建一个滑动条控件
	char TrackbarName[50];
	sprintf_s(TrackbarName, &quot;透明度 %d&quot;, g_nMaxAlphaValue);
	createTrackbar(TrackbarName, cszWindowName, &amp;g_nCurAlphaValue, g_nMaxAlphaValue, on_Trackbar);
	//调用一次回调函数，以显示图像
	on_Trackbar(g_nCurAlphaValue, 0);
	waitKey(0);
	return 0;
&#125;
</code></pre>
<h6 id="4-鼠标事件响应："><a href="#4-鼠标事件响应：" class="headerlink" title="4.鼠标事件响应："></a>4.鼠标事件响应：</h6><pre><code>Rect g_rectangle; //记录要绘制的矩形位置
bool g_bDrawingBox = false;//是否进行绘制
RNG g_rng(12345);  //随机数对象
const String strWndName = &quot;MouseWnd&quot;;
void DrawRactangle(Mat &amp; img, Rect rect)
&#123;
	//每次绘制矩形的颜色都是随机产生的
	rectangle(img, rect, Scalar(g_rng.uniform(0, 255), \
		g_rng.uniform(0, 255), g_rng.uniform(0, 255)), 4);
&#125;
void onMouseCallback(int event, int x, int y, int flags, void * param)
&#123;
	//将画矩形的图像作为参数传入回调函数
	Mat &amp;image = *(Mat*)param;
	switch (event)
	&#123;
		//鼠标移动时改变窗口的大小
	case EVENT_MOUSEMOVE:
		//如果g_bDrawingBox为真，则记录矩形信息到g_rectangle中
		if (g_bDrawingBox) &#123;
			g_rectangle.width = x - g_rectangle.x;
			g_rectangle.height = y - g_rectangle.y;
		&#125;
		break;
		//左键按下时记录窗口的起始位置
	case EVENT_LBUTTONDOWN:
		g_bDrawingBox = true;
		//记录g_rectangle的起点
		g_rectangle = Rect(x, y, 0, 0); 
		break;
		//左键抬起时将当前绘制的矩形信息写入到图像中
	case EVENT_LBUTTONUP:
		// 标识符为false
		g_bDrawingBox = false;
		//向起点左边绘制
		if (g_rectangle.width &lt; 0) &#123;
			g_rectangle.x += g_rectangle.width;
			g_rectangle.width *= -1;
		&#125;
		//向起点上边绘制
		if (g_rectangle.height &lt; 0) &#123;
			g_rectangle.y += g_rectangle.height;
			g_rectangle.height *= -1;
		&#125;
		//调用函数进行绘制
		DrawRactangle(image, g_rectangle);
		break;
	&#125;
&#125;
int main(int argc, char ** argv)
&#123;
	//准备参数
	g_rectangle = Rect(-1, -1, 0, 0);
	Mat srcImage(600, 800, CV_8UC3, Scalar(255,255,255)), tempImage;
	srcImage.copyTo(tempImage);
	g_rectangle = Rect(-1, -1, 0, 0);
	// 设置鼠标操作回调函数
	namedWindow(strWndName);
	setMouseCallback(strWndName, onMouseCallback, (void *)&amp;srcImage);
	// 程序主循环，当进行绘制的标识符为真的时候进行绘制
	while (true)
	&#123;
		//复制原图到临时变量，这样可以清除上一次的鼠标拖动结果
		srcImage.copyTo(tempImage); 
		if (g_bDrawingBox)&#123;
			//在鼠标拖动时，每次都对图像进行临时绘制
			Rect rectCur = g_rectangle;
			//鼠标向上或向左移动时，需要对坐标进行处理
			if (rectCur.width &lt; 0) &#123;
				rectCur.x += rectCur.width;
				rectCur.width *= -1;
			&#125;
			if (rectCur.height &lt; 0) &#123;
				rectCur.y += rectCur.height;
				rectCur.height *= -1;
			&#125;
			DrawRactangle(tempImage, rectCur);
		&#125;
		imshow(strWndName, tempImage);
		if (waitKey(10) == 27) // 按下ESC键，程序退出
			break;
	&#125;

	return 0;
&#125;
</code></pre>
<h5 id="练手："><a href="#练手：" class="headerlink" title="&lt;3&gt;练手："></a>&lt;3&gt;练手：</h5><h6 id="1-打开摄像头"><a href="#1-打开摄像头" class="headerlink" title="1.打开摄像头"></a>1.打开摄像头</h6><pre><code>#include &quot;pch.h&quot;                //viscalC++预编译头文件
#include &lt;iostream&gt;             //C++标准输入、输出流
#include &lt;opencv.hpp&gt;           //OpenCV头文件
#include &lt;highgui.hpp&gt;          //GUI界面头文件
using namespace cv;             //打开cv的名词空间

#pragma comment(lib, &quot;opencv_world480d.lib&quot;)//打开动态库

int main()
&#123;
	cv::namedWindow(&quot;camera&quot;, 0);    //新建名为“camera”的窗口
	VideoCapture capture(0);         //打开ID为0的摄像头
	Mat frame;                       //新建Mat变量（矩阵）
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; frame;            //用重载运算符方式获取视频帧
		if (frame.empty())break;
		imshow(&quot;camera&quot;, frame);     //在名为“camera”的窗口显示捕获帧
		waitKey(10);                 //刷新图像，否则无法正常显示
	&#125;
&#125;
</code></pre>
<h6 id="2-视频播放器，滑动条控制进度，双击暂停-播放"><a href="#2-视频播放器，滑动条控制进度，双击暂停-播放" class="headerlink" title="2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放"></a>2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</h6><pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;opencv.hpp&gt;
#include &lt;highgui.hpp&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* trackname = &quot;progress&quot;;
const char* windowname = &quot;videoplayer&quot;;
const char* filepath = &quot;D:/files/picture and video/C0056.MP4&quot;;
cv::VideoCapture capture(filepath, CAP_ANY);
int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
double dblFrameRate = capture.get(CAP_PROP_FPS); //视频帧率
double dblFrameCnt = capture.get(CAP_PROP_FRAME_COUNT); //视频总帧数

const int g_nMaxProgressValue = 100;			//Alpha值的最大值
int g_nCurProgressValue;						//当前滑动条对应的值
int Cur_Frame;								//记录暂停时的帧数

Mat frame;
int sign = 0;

int main()
&#123;
	void on_Trackbar(int, void*);
	void onMouseCallback(int event, int x, int y, int flags, void* param);
	cv::namedWindow(windowname,0);
	setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
	resizeWindow(windowname, 400, 300);
	moveWindow(windowname, 0, 0);

	createTrackbar(trackname, windowname, &amp;g_nCurProgressValue, g_nMaxProgressValue, on_Trackbar);
	setMouseCallback(windowname, onMouseCallback, (void*)NULL);

	while(capture.isOpened())&#123;
		Cur_Frame = capture.get(CAP_PROP_POS_FRAMES);	//获取当前播放帧数
		//判断是否双击，双击则暂停播放
		if (sign)
		&#123;
			capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);
		&#125;

		capture &gt;&gt; frame;

		//如果播放完毕，等待按键，直接退出
		if (Cur_Frame == dblFrameCnt)
		&#123;
			waitKey(0);
			break;
		&#125;

		imshow(windowname, frame);

		//中途按		ESC可以直接退出
		if (waitKey(1) == 27)break;
	&#125;

&#125;

//滑动条回调函数
void on_Trackbar(int, void*)
&#123;
	capture.set(CAP_PROP_POS_FRAMES, g_nCurProgressValue * dblFrameCnt / g_nMaxProgressValue); //从视频中间开始播放
	capture &gt;&gt; frame;
&#125;

//鼠标回调函数
void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if(event==EVENT_LBUTTONDBLCLK)sign = (sign + 1) % 2;
&#125;
</code></pre>
<p>注意控制输出暂停的方法：</p>
<p>1.waitKey等待：键盘控制，可参考其他博主</p>
<p>2.一直输出上一帧：即本人使用方法</p>
<pre><code>capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);
</code></pre>
<p>3.直接用system（“pause”）  </p>
<h5 id="4-linux上编译运行：参考：-Linux下编译、链接、加载运行C"><a href="#4-linux上编译运行：参考：-Linux下编译、链接、加载运行C" class="headerlink" title="**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++"></a>**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++</h5><p>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506</a><br>“Linux下编译、链接、加载运行C++ OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客”)**</p>
<p><strong>CMakeLists.txt编辑：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuliuheng/p/9431275.html" title="[CMAKE]
详解CMakeLists.txt文件 - VictoKu - 博客园 (cnblogs.com)">[CMAKE] 详解CMakeLists.txt文件 - VictoKu - 博客园<br>(cnblogs.com)</a></strong></p>
<p><strong>或参考：jetson nano上的OpenCV使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</strong></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="三-OpenCV基本数据结构和基本组件"><a href="#三-OpenCV基本数据结构和基本组件" class="headerlink" title="三.OpenCV基本数据结构和基本组件"></a>三.OpenCV基本数据结构和基本组件</h2><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p>&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</p>
<p>（辅助对象：迭代参数TermCriteria类；范围range类；指针Ptr类）</p>
<p>（工具和系统函数：数学、内存管理、性能优化、异常处理函数）</p>
<p>（图像绘制图形函数：线、矩形、圆、折线）</p>
<p>（图像保存函数；图像几何操作函数：均匀调整（尺寸）、仿射变换、对数极坐标变换）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1811f91ca180329611fd9be36e5e02b.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c2fcbc408c51032f372737fcdbc6a410.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4891ab8394f175c44875a74ca770271d.jpeg"></p>
<h5 id="练手代码"><a href="#练手代码" class="headerlink" title="&lt;2&gt;练手代码"></a>&lt;2&gt;练手代码</h5><h6 id="1-Mat类操作"><a href="#1-Mat类操作" class="headerlink" title="1.Mat类操作"></a>1.Mat类操作</h6><pre><code>int main()
&#123;
	namedWindow(&quot;image&quot;, WINDOW_NORMAL);
	setWindowTitle(&quot;image&quot;, &quot;image:&quot;);
	Mat img(Size(200, 100), CV_8UC3, Scalar(80, 160, 240));
	imshow(&quot;image&quot;, img);
	waitKey(0);
	return -1;
&#125;
</code></pre>
<h6 id="2-摄像头图像流极坐标变换"><a href="#2-摄像头图像流极坐标变换" class="headerlink" title="2.摄像头图像流极坐标变换"></a>2.摄像头图像流极坐标变换</h6><pre><code>const int g_nMaxValue = 100; //滑条值的最大值
int g_nCurValue = 0;   //当前滑动条对应的值

int main()
&#123;
	void on_Trackbar(int, void*);
	namedWindow(&quot;Polor&quot;, WINDOW_NORMAL);

	Mat frame;
	VideoCapture capture(0);
	int nWidth = capture.get(CAP_PROP_FRAME_WIDTH); //视频图像宽度
	int nHeight = capture.get(CAP_PROP_FRAME_HEIGHT); //视频图像高度
	createTrackbar(&quot;zoom factor&quot;, &quot;Polor&quot;, &amp;g_nCurValue, g_nMaxValue, on_Trackbar);
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; frame;
		if (frame.empty())break;
		logPolar(frame, frame, Point2i(nWidth / 2, nHeight / 2), g_nCurValue, WARP_FILL_OUTLIERS);
		imshow(&quot;Polor&quot;, frame);
		waitKey(1);
	&#125;

&#125;

void on_Trackbar(int, void*)
&#123;
	;
&#125;
</code></pre>
<h5 id="3-读取图像像素RGB值（左键显示，右键清空）"><a href="#3-读取图像像素RGB值（左键显示，右键清空）" class="headerlink" title="3.读取图像像素RGB值（左键显示，右键清空）"></a>3.读取图像像素RGB值（左键显示，右键清空）</h5><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* filepath = &quot;/test2.png&quot;;
const char* windowname = &quot;window&quot;;
const char* windowtitle = &quot;image&quot;;
const char* trackname = &quot;fontscale&quot;;	
int fontscale = 1;·								//字体大小及线条粗细
const int max_fontscale = 100;
Mat img = imread(filepath, IMREAD_COLOR);
Mat draw_board = img.clone();					//图片拷贝以实现清除
char string[5];

int main()
&#123;
	void on_Trackbar(int, void*);
	void onMouseCallback(int event, int x, int y, int flags, void* param);
	namedWindow(windowname, WINDOW_NORMAL);
	createTrackbar(trackname, windowname, &amp;fontscale, max_fontscale, on_Trackbar);
	setMouseCallback(windowname, onMouseCallback, (void*)NULL);
	if (draw_board.empty())return -1;
	while (!draw_board.empty())
	&#123;
		imshow(windowname, draw_board);
		if (waitKey(1) == 27)break;
	&#125;
	return 0;
&#125;

void on_Trackbar(int, void*)
&#123;
	;
&#125;

void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if (event == EVENT_LBUTTONDOWN)
	&#123;
		//读取鼠标所指像素的值
		int rgb[3] = &#123; img.at&lt;cv::Vec3b&gt;(x, y)[2],img.at&lt;cv::Vec3b&gt;(x, y)[1], img.at&lt;cv::Vec3b&gt;(x, y)[0] &#125;;
		//putText不支持\n换行，只能手动计算间隔：y + fontscale * 10 * i
		for (int i = 0; i &lt; 3; i++) &#123;
			sprintf_s(string, &quot;%d&quot;, rgb[i]);
			//文字写入图像
			putText(draw_board, string, Point(x, y + fontscale * 10 * i), FONT_HERSHEY_PLAIN, fontscale, Scalar(rgb[2], rgb[1], rgb[0]), fontscale, 8, false);
		&#125;
	&#125;
	if (event == EVENT_RBUTTONDOWN)
	&#123;
		//使显示图像为原始图像，即清零
		draw_board = img.clone();
	&#125;
&#125;
</code></pre>
<p>注：</p>
<p>①.at()函数访问多通道Mat数据元素时为只能用at()函数，且注意at&lt;&gt;内为 Vec3b</p>
<pre><code>at&lt;cv::Vec3b&gt;(x, y)[i]
</code></pre>
<p>②.putText()函数无法实现换行，需手动计算</p>
<h6 id="4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"><a href="#4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面" class="headerlink" title="4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"></a>4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

const char* filepath = &quot;test2.png&quot;;
const char* windowname = &quot;window&quot;;
const char* windowtitle = &quot;image&quot;;
const char* trackname = &quot;fontscale&quot;;

#define WIDTH 800
#define HEIGHT 600

int main()
&#123;
	namedWindow(windowname, WINDOW_NORMAL);
	Mat img(WIDTH, HEIGHT, CV_8UC3, Scalar(0, 0, 0));
	for (int i = 0; i &lt; WIDTH; i++) &#123;
		for (int j = 0; j &lt; HEIGHT; j++) &#123;
			for (int k = 0; k &lt; 3; k++) &#123;
				img.at&lt;Vec3b&gt;(i, j)[k] = (i * j * k) % 256;
			&#125;
		&#125;
	&#125;
	Point p1(200, 50), p2(400, 200);
	rectangle(img,p1,p2,Scalar(0,255,0),8,8,0);
	imshow(windowname, img);
	//imwrite(&quot;C:/Users/user/Desktop/1.png&quot;, img);
	waitKey(0);
	
&#125;
</code></pre>
<h2 id="四-数字图像灰度变换与空间滤波"><a href="#四-数字图像灰度变换与空间滤波" class="headerlink" title="四.数字图像灰度变换与空间滤波"></a>四.数字图像灰度变换与空间滤波</h2><h5 id="（灰度变换：线性、非线性；直方图：概率、累计）"><a href="#（灰度变换：线性、非线性；直方图：概率、累计）" class="headerlink" title="&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）"></a>&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/10f1536c594c088a66be8508027e04c3.jpeg"></p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-灰度变换函数"><a href="#1-灰度变换函数" class="headerlink" title="1.灰度变换函数"></a>1.灰度变换函数</h6><p>①对数变换</p>
<pre><code>//对数变换
void LogTransform(Mat srcImg, Mat &amp;dstImg, const float c=1.0f)
&#123;
	if (srcImg.empty())&#123;
		cout &lt;&lt; &quot;No data&quot; &lt;&lt; endl;
		return;
	&#125;
	//Mat dstMat = Mat::zeros(srcImg.size(), srcImg.type());
	add(srcImg, Scalar(1.0), srcImg);  //计算 s+1
	srcImg.convertTo(srcImg, CV_32F);  //转化为32位浮点型
	cv::log(srcImg, dstImg); //计算log(1+s)
	dstImg = c*dstImg;
	//归一化处理
	normalize(dstImg, dstImg, 0, 255, NORM_MINMAX);
	//cout &lt;&lt; dstImg &lt;&lt; endl;
	cout &lt;&lt; dstImg.elemSize() &lt;&lt; endl;
	//将dstImg转换到CV_8U类型
	convertScaleAbs(dstImg, dstImg);
	return;
&#125;
</code></pre>
<p><strong>②*伽马变换</strong></p>
<pre><code>//伽马校正
void MyGammaCorrection(const Mat&amp; src, Mat&amp; dst, float fGamma)
&#123;
	//CV_Assert(src.data);
	if (src.empty())&#123;
		return;
	&#125;
	//只处理位深度为8位的图像
	CV_Assert(src.depth() != sizeof(uchar));
	//创建查找表
	unsigned char lut[256];
	for (int i = 0; i &lt; 256; i++)&#123;
		lut[i] = saturate_cast&lt;uchar&gt;(pow((float)(i / 255.0),\
			fGamma) * 255.0f);
	&#125;

	dst = src.clone();
	const int channels = dst.channels();
	switch (channels)&#123;
	case 1:
	&#123;
		//MatIterator_&lt;uchar&gt; it;
		//for (it = dst.begin&lt;uchar&gt;(); it != dst.end&lt;uchar&gt;(); it++)
		//	*it = lut[(*it)];
		for (int j = 0; j &lt; dst.rows; j++)&#123;
			for (int i = 0; i &lt; dst.cols; i++)&#123;
				unsigned char val = dst.at&lt;uchar&gt;(j, i);
				dst.at&lt;uchar&gt;(j, i) = lut[val];
			&#125;
		&#125;
		break;
	&#125;
	case 3:
	&#123;
		MatIterator_&lt;Vec3b&gt; it;
		for (it = dst.begin&lt;Vec3b&gt;(); it != dst.end&lt;Vec3b&gt;(); it++)&#123;
			(*it)[0] = lut[((*it)[0])];
			(*it)[1] = lut[((*it)[1])];
			(*it)[2] = lut[((*it)[2])];
		&#125;
		break;
	&#125;
	&#125;
&#125;
</code></pre>
<p>注：saturate_cast&lt;&gt;的使用（防止颜色溢出）参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15698613/article/details/84557588?spm=1001.2014.3001.5506" title="【OpenCV】中saturate_cast&lt;uchar&gt;的含义和用法是什么？_人工智能博士的博客-CSDN博客">【OpenCV】中saturate_cast<uchar>的含义和用法是什么？_人工智能博士的博客-<br>CSDN博客</uchar></a></p>
<h6 id="2-直方图（概率直方图）绘制函数"><a href="#2-直方图（概率直方图）绘制函数" class="headerlink" title="2.直方图（概率直方图）绘制函数"></a>2.直方图（概率直方图）绘制函数</h6><p>①灰度直方图</p>
<pre><code>//灰度直方图
void DrawGrayImgHist(const Mat &amp;srcImg)
&#123;
	if (1 != srcImg.channels())&#123;
		return;
	&#125;
	int channels = 0;
	Mat dstHist;
	int histSize[] = &#123; 256 &#125;;    
	float midRanges[] = &#123; 0, 256 &#125;;
	const float *ranges[] = &#123; midRanges &#125;;
	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \
		1, histSize, ranges, true, true);
	//最终绘制的直方图图像，大小是256×256
	Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);
	double dblHistMaxValue;
	//求得直方图的最大值
	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);
	//将像素的个数整合到图像的最大范围内  
	for (int i = 0; i &lt;= 255; i++)&#123;
		int value = cvRound(dstHist.at&lt;float&gt;(i)\
			* 255 / dblHistMaxValue);
		line(histImage, Point(i, histImage.rows - 1), \
			Point(i, histImage.rows - 1 - value), Scalar(255));
	&#125;
	imshow(&quot;直方图&quot;, histImage);
	imwrite(&quot;desert_hist_规定化之后.bmp&quot;, histImage);
&#125;
</code></pre>
<p>注：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12386274.html" title="minMaxLoc 寻找图像全局最大最小值">minMaxLoc 寻找图像全局最大最小值</a></p>
<p>②RGB彩色直方图</p>
<pre><code>//RGB彩色直方图
void DrawRGBImgHist(const Mat &amp;srcImg)
&#123;
	if (srcImg.empty() || srcImg.channels() != 3)&#123;
		return;
	&#125;
	//分割成3个单通道图像 ( R, G 和 B )
	vector&lt;Mat&gt; rgb_planes;
	split(srcImg, rgb_planes);
	// 设定bin数目
	int histSize = 256;
	// 设定取值范围 ( R,G,B) )
	float range[] = &#123; 0, 256 &#125;;
	const float* histRange = &#123; range &#125;;

	bool uniform = true;
	bool accumulate = true;

	Mat r_hist, g_hist, b_hist;

	//计算直方图:
	calcHist(&amp;rgb_planes[0], 1, 0, Mat(), r_hist, 1, \
		&amp;histSize, &amp;histRange, uniform, accumulate);
	calcHist(&amp;rgb_planes[1], 1, 0, Mat(), g_hist, 1, \
		&amp;histSize, &amp;histRange, uniform, accumulate);
	calcHist(&amp;rgb_planes[2], 1, 0, Mat(), b_hist, 1,\
		&amp;histSize, &amp;histRange, uniform, accumulate);

	// 创建直方图画布
	int hist_w = 256; int hist_h = 200;
	int bin_w = cvRound((double)hist_w / histSize);

	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

	// 将直方图归一化到范围 [ 0, histImage.rows ]
	normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX);

	// 在直方图画布上画出直方图，3个直方图叠加在一起，用不同的颜色表示
	for (int i = 1; i &lt; histSize; i++)
	&#123;
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(r_hist.at&lt;float&gt;(i))),
			Scalar(0, 0, 255), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(g_hist.at&lt;float&gt;(i))),
			Scalar(0, 255, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(b_hist.at&lt;float&gt;(i))),
			Scalar(255, 0, 0), 2, 8, 0);
	&#125;

	// 显示直方图
	imshow(&quot;RGB彩色图像直方图&quot;, histImage);
	imwrite(&quot;./colorhist_for_beatuty_after_qualization.bmp&quot;, histImage);
	waitKey(0);
&#125;
</code></pre>
<p>③累计直方图</p>
<pre><code>//画累积直方图
void DrawAccumulateImgHist(const Mat &amp;srcImg)
&#123;
	if (1 != srcImg.channels())&#123;
		return;
	&#125;
	int channels = 0;
	Mat dstHist;
	int histSize[] = &#123; 256 &#125;;
	float midRanges[] = &#123; 0, 256 &#125;;
	const float *ranges[] = &#123; midRanges &#125;;
	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, \
		1, histSize, ranges, true, true);
	//对直方图进行累积
	for (int i = 1; i &lt; dstHist.rows; i++)&#123;
		dstHist.at&lt;float&gt;(i) += dstHist.at&lt;float&gt;(i-1);
	&#125;
	//最终绘制的直方图图像，大小是256×256
	Mat histImage = Mat::zeros(Size(256, 256), CV_8UC1);
	double dblHistMaxValue;
	//求得直方图的最大值
	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);
	//将像素的个数整合到图像的最大范围内  
	for (int i = 0; i &lt; 256; i++)&#123;
		int value = cvRound(dstHist.at&lt;float&gt;(i)\
			* 255 / dblHistMaxValue);
		line(histImage, Point(i, histImage.rows - 1), \
			Point(i, histImage.rows - 1 - value), Scalar(255));
	&#125;
	imshow(&quot;累积直方图&quot;, histImage);
	imwrite(&quot;./accumlate.bmp&quot;, histImage);
&#125;
</code></pre>
<h2 id="七-图像分割"><a href="#七-图像分割" class="headerlink" title="七.图像分割"></a>七.图像分割</h2><h5 id="（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）"><a href="#（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）" class="headerlink" title="&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）"></a>&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</h5><h5 id="（几何形状检测【霍夫变换】：直线、圆）"><a href="#（几何形状检测【霍夫变换】：直线、圆）" class="headerlink" title="（几何形状检测【霍夫变换】：直线、圆）"></a>（几何形状检测【霍夫变换】：直线、圆）</h5><h5 id="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"><a href="#（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）" class="headerlink" title="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"></a>（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42061b3c66f846c840087275d00ada91.jpeg"></p>
<h5 id="-2"><a href="#-2" class="headerlink" title></a></h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e731b3257fee71a5ec24342e7b18efb.jpeg"><br>&lt;2&gt;示例代码</p>
<h6 id="1-霍夫直线变换和霍夫圆检测"><a href="#1-霍夫直线变换和霍夫圆检测" class="headerlink" title="1.霍夫直线变换和霍夫圆检测"></a>1.霍夫直线变换和霍夫圆检测</h6><pre><code>void DetectLines()
&#123;
	Mat matSrc = imread(&quot;Hough_src_clr.png&quot;, IMREAD_GRAYSCALE);
	Mat matEdge;
	//Canny算子计算图像边缘
	Canny(matSrc, matEdge, 250, 200, 3, false);
	imshow(&quot;原图像&quot;, matSrc);
	imshow(&quot;Canny边缘&quot;, matEdge);
	imwrite(&quot;hough_src_gray.bmp&quot;, matSrc);
	imwrite(&quot;hough_src_canny.bmp&quot;, matEdge);
	std::vector&lt;Vec2f&gt; linesSHT;
	//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300
	HoughLines(matEdge, linesSHT, 1, CV_PI / 180, 280);
	Mat matSHT = matSrc.clone();
	for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
		//直线的rho和theta值
		float rho = linesSHT[i][0], theta = linesSHT[i][1];
		//pt1和pt2是直线的两个端点
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a * rho, y0 = b * rho;
		pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
		pt1.y = cvRound(y0 + 2000 * (a));
		pt2.x = cvRound(x0 - 2000 * (-b));
		pt2.y = cvRound(y0 - 2000 * (a));
		line(matSHT, pt1, pt2, Scalar(255), 4);
	&#125;
	imshow(&quot;SHT直线检测结果&quot;, matSHT);
	imwrite(&quot;hough_Lines_SHT.bmp&quot;, matSHT);
	Mat matPPHT = matSrc.clone();
	std::vector&lt;Vec4i&gt; linesPPHT;
	//累计概率霍夫变换检测直线，得到的是直线的起止端点
	HoughLinesP(matEdge, linesPPHT, 1, CV_PI / 180, 280, 100, 50);
	for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
		//直接绘制直线
		line(matPPHT, Point(linesPPHT[i][0], linesPPHT[i][1]),
			Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);
	&#125;
	imshow(&quot;PPHT直线检测结果&quot;, matPPHT);
	imwrite(&quot;Hough_lines_PPHT.bmp&quot;, matPPHT);
	waitKey(0);
&#125;


void DetectCircles()
&#123;
	Mat src;
	src = imread(&quot;HoughCircles_src_clr.jpg&quot;, IMREAD_GRAYSCALE);
	//imwrite(&quot;HoughCircles_src_gray.bmp&quot;, src);
	vector&lt;Vec3f&gt; circles;
	HoughCircles(src, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);
	//在原图中画出圆心和圆  
	for (size_t i = 0; i &lt; circles.size(); i++)&#123;
		//提取出圆心坐标  
		Point center(round(circles[i][0]), round(circles[i][1]));
		//提取出圆半径  
		int radius = round(circles[i][2]);
		//圆心  
		circle(src, center, 3, Scalar(255), -1, 4, 0);
		//圆  
		circle(src, center, radius, Scalar(255), 3, 4, 0);
	&#125;
	//imwrite(&quot;HoughCircles_circles.bmp&quot;, src);
	imshow(&quot;Circle&quot;, src);
	waitKey(0);
&#125;
</code></pre>
<h6 id="2-OTSU方法和三角法求全局阈值"><a href="#2-OTSU方法和三角法求全局阈值" class="headerlink" title="2.OTSU方法和三角法求全局阈值"></a>2.OTSU方法和三角法求全局阈值</h6><pre><code>//OTSU方法求阈值
int OtsuBinary(Mat src)
&#123;
	long lPixCnt = src.rows * src.cols;
	long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);
			histogram[nCurVal]++;
		&#125;
	&#125;
	int nThreshold = 0;
	long sum0 = 0, sum1 = 0; //存储前景的灰度总和和背景灰度总和  
	long cnt0 = 0, cnt1 = 0; //前景像素总个数和背景像素总个数  
	double w0 = 0, w1 = 0; //前景和背景所占整幅图像的比例  
	double u0 = 0, u1 = 0;  //前景和背景的平均灰度  
	double variance = 0; //类间方差  
	double maxVariance = 0; //用来存储最大类间方差
	for (int i = 1; i &lt; 256; i++) //遍历所有灰度级别
	&#123;
		sum0 = 0;    cnt0 = 0;  w0 = 0;
		sum1 = 0;    cnt1 = 0;  w1 = 0;
		for (int j = 0; j &lt; i; j++) &#123;
			cnt0 += histogram[j]; //前景像素总和
			sum0 += j * histogram[j]; //前景灰度值总和
		&#125;
		//前景部分灰度均值
		u0 = cnt0 &gt; 0 ? double(sum0) / cnt0 : 0;
		w0 = (double)cnt0 / lPixCnt; //前景部分所占的比例
		for (int j = i; j &lt;= 255; j++) &#123;
			cnt1 += histogram[j]; //背景像素个数
			sum1 += j * histogram[j]; //背景部分灰度值总和
		&#125;
		//背景部分灰度均值
		u1 = cnt1 &gt; 0 ? double(sum1) / cnt1 : 0;
		w1 = 1 - w0;  //背景部分所占的比例
		//分割阈值为i时的类间方差
		variance = w0 * w1 * (u0 - u1) * (u0 - u1);
		if (variance &gt; maxVariance) &#123;
			maxVariance = variance;
			nThreshold = i;
		&#125;
	&#125;

	return nThreshold;
&#125;

//三角法求阈值
int TriangleBinary(Mat src)
&#123;
	long lPixCnt = src.rows * src.cols;
	long histogram[256] = &#123; 0 &#125;; //histogram是灰度直方图
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			unsigned char nCurVal = src.at&lt;uchar&gt;(i, j);
			histogram[nCurVal]++;
		&#125;
	&#125;

	//左右边界
	int left_bound = 0, right_bound = 0;
	//直方图最高峰和相应的灰度值
	int max_ind = 0, maxPeak = 0;
	int temp;
	bool isflipped = false;

	// 找到最左边零的位置
	for (int i = 0; i &lt; 256; i++) &#123;
		if (histogram[i] &gt; 0) &#123;
			left_bound = i;
			break;
		&#125;
	&#125;
	//位置再移动一个步长，即为最左侧零位置 
	if (left_bound &gt; 0)
		left_bound--;

	// 找到最右边零点位置
	for (int i = 255; i &gt; 0; i--) &#123;
		if (histogram[i] &gt; 0) &#123;
			right_bound = i;
			break;
		&#125;
	&#125;
	// 位置再移动一个步长，即为最右侧零位置 
	if (right_bound &lt; 255)
		right_bound++;

	// 在直方图上寻找最亮的点Hmax
	for (int i = 0; i &lt; 256; i++) &#123;
		if (histogram[i] &gt; maxPeak) &#123;
			maxPeak = histogram[i];
			max_ind = i;
		&#125;
	&#125;

	// 如果最大值落在靠左侧这样就无法满足三角法求阈值，
	 //所以要检测是否最大值是否靠近左侧
	// 如果靠近左侧则通过翻转到右侧位置。
	if (max_ind - left_bound &lt; right_bound - max_ind) &#123;
		isflipped = true;
		int i = 0;
		int j = 255;
		// 左右交换
		while (i &lt; j) &#123;
			temp = histogram[i]; histogram[i] = histogram[j]; histogram[j] = temp;
			i++; j--;
		&#125;
		left_bound = 255 - right_bound;
		max_ind = 255 - max_ind;
	&#125;

	// 计算求得阈值
	double thresh = left_bound;
	double maxDist = 0, tempDist;
	double peakIdxBound = left_bound - max_ind;
	for (int i = left_bound + 1; i &lt;= max_ind; i++)
	&#123;
		// 计算距离
		tempDist = maxPeak * i + peakIdxBound * histogram[i];
		if (tempDist &gt; maxDist) &#123;
			maxDist = tempDist;
			thresh = i;
		&#125;
	&#125;
	thresh--;
	if (isflipped) &#123;
		thresh = 255 - thresh;
	&#125;

	return thresh;
&#125;

//手动二值化处理
Mat Binbary(Mat src, int nThreshold)
&#123;
	//遍历每个像素，对图像进行二值化
	Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC1);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			if (src.at&lt;uchar&gt;(i, j) &gt; nThreshold)
				dst.at&lt;uchar&gt;(i, j) = 255;
		&#125;
	&#125;
	return dst;
&#125;
</code></pre>
<p>*<strong>注：</strong></p>
<p><strong>①二值化的原图都是灰度图，产生灰度图方法见后</strong></p>
<p><strong>②对于固定场景摄像头读取图像可以先调用以上函数求出全局阈值，之后使用cv::threshold()函数时直接调用该阈值，减少每帧计算阈值时间</strong></p>
<h5 id="练手"><a href="#练手" class="headerlink" title="&lt;3&gt;练手"></a>&lt;3&gt;练手</h5><h6 id="1-边缘检测二阶导数算子使用"><a href="#1-边缘检测二阶导数算子使用" class="headerlink" title="1.边缘检测二阶导数算子使用"></a>1.边缘检测二阶导数算子使用</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

#define IMAGE_TEST

#ifdef IMAGE_TEST
const char* filepath = &quot;./Test.jpg&quot;;
Mat img = imread(filepath, IMREAD_COLOR);
Mat draw_board = img.clone();					//图片拷贝以实现清除
#endif
#ifdef CAMERA_TEST
VideoCapture capture(0);
Mat image;
#endif // CAMERA_TEST


int main()
&#123;
	void changing(void);
	changing();
&#125;

//拉普拉斯高通滤波
void changing(void)
&#123;
	Mat LoG_Image(const Mat &amp; image, int kervalue = 3, double sigma = 1.0f);

#ifdef IMAGE_TEST
	Mat image = imread(filepath, IMREAD_COLOR);
	if (image.empty()) &#123;
		std::cout &lt;&lt; &quot;打开图片失败,请检查&quot; &lt;&lt; std::endl;
		return;
	&#125;
	imshow(&quot;原图像&quot;, image);
	Mat matDst;
//	Laplacian(image, matDst, image.depth(), 5);     //拉普拉斯算子
//	matDst = LoG_Image(image, 3, 1.0f);				//LOG算子
	Canny(image, matDst, 80, 150, 3, false);		//canny算子
	imwrite(&quot;changing.bmp&quot;, matDst);
	imshow(&quot;变换效果&quot;, matDst);
	waitKey(0);
#endif
#ifdef CAMERA_TEST
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matDst;
//		Laplacian(image, matDst, image.depth(), 5);		//拉普拉斯算子
//		matDst = LoG_Image(image, 3, 1.0f);				//LOG算子
		Canny(image, matDst, 100, 500, 3, false);		//canny算子
		imshow(&quot;变换效果&quot;, matDst);
		if (waitKey(1) == 27)break;
	&#125;
#endif
&#125;

//图像LoG算子运算
Mat LoG_Image(const Mat&amp; image, int kervalue = 3, double sigma = 1.0f)
&#123;
	//首先对图像做高斯平滑
	Mat matTemp;
	GaussianBlur(image, matTemp, Size(kervalue, kervalue), sigma, sigma, BORDER_DEFAULT);
	//通过拉普拉斯算子做边缘检测
	Mat laplacian = Mat::zeros(image.rows, image.cols, CV_32FC1);
	Laplacian(matTemp, laplacian, CV_32FC1, 3);
	//求得最大边缘值
	double dblMaxVal = 0;
	minMaxLoc(laplacian, NULL, &amp;dblMaxVal);
	Mat dstImg;
	convertScaleAbs(laplacian, dstImg);
	imwrite(&quot;edge.bmp&quot;, dstImg);
	Mat result = Mat::zeros(image.rows, image.cols, CV_8UC1);
	//过零点交叉，寻找边缘像素
	for (int i = 1; i &lt; result.rows - 1; i++) &#123;
		for (int j = 1; j &lt; result.cols - 1; j++) &#123;
			if (laplacian.at&lt;float&gt;(i, j) &lt; 0.1 * dblMaxVal) &#123;
				continue;
			&#125;
			//水平、垂直、45度方向，135度4个方向过零点判定
			if (laplacian.at&lt;float&gt;(i - 1, j) \
				* laplacian.at&lt;float&gt;(i + 1, j) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i, j + 1) \
				* laplacian.at&lt;float&gt;(i, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i + 1, j + 1) \
				* laplacian.at&lt;float&gt;(i - 1, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
			if (laplacian.at&lt;float&gt;(i - 1, j + 1) \
				* laplacian.at&lt;float&gt;(i + 1, j - 1) &lt; 0)
				result.at&lt;uchar&gt;(i, j) = 255;
		&#125;
	&#125;
	return result;
&#125;

//Canny算子计算图像的梯度和方向
void CannyEdgeAndDirection(const Mat&amp; src)
&#123;
	Mat magX = Mat(src.rows, src.cols, CV_32FC1);
	Mat magY = Mat(src.rows, src.cols, CV_32FC1);
	Mat slopes = Mat(src.rows, src.cols, CV_32FC1);
	Sobel(src, magX, CV_32FC1, 1, 0, 3);//水平梯度
	Sobel(src, magY, CV_32FC1, 1, 0, 3);//垂直梯度
	//梯度方向
	divide(magY, magX, slopes);
	//梯度幅值
	Mat magnitude;
	sqrt(magX * magX + magY * magY, magnitude);
&#125;
</code></pre>
<h6 id="2-霍夫直线变换及霍夫圆的检测"><a href="#2-霍夫直线变换及霍夫圆的检测" class="headerlink" title="2.霍夫直线变换及霍夫圆的检测"></a>2.霍夫直线变换及霍夫圆的检测</h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

VideoCapture capture(0);
Mat image;

//#define SHT	//SHT检测直线
//#define PPHT	//PPHT检测直线
#define HCD		//霍夫圆检测

int main()
&#123;
	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matCanny;
		Mat matDst;
		Canny(image, matCanny, 100, 300, 3, false);		//canny算子

#ifdef SHT
		std::vector&lt;Vec2f&gt; linesSHT;
		//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300
		HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 280);
		//直线在原图上绘制
		matDst = image.clone();
		for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
			//直线的rho和theta值
			float rho = linesSHT[i][0], theta = linesSHT[i][1];
			//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）
			Point pt1, pt2;
			double a = cos(theta), b = sin(theta);
			double x0 = a * rho, y0 = b * rho;
			pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
			pt1.y = cvRound(y0 + 2000 * (a));
			pt2.x = cvRound(x0 - 2000 * (-b));
			pt2.y = cvRound(y0 - 2000 * (a));
			line(matDst, pt1, pt2, Scalar(255), 4);
		&#125;
#endif // SHT标准霍夫变换

#ifdef PPHT
		matDst = image.clone();
		std::vector&lt;Vec4i&gt; linesPPHT;
		//累计概率霍夫变换检测直线，得到的是直线的起止端点
		HoughLinesP(matCanny, linesPPHT, 1, CV_PI / 180, 220, 100, 50);
		for (size_t i = 0; i &lt; linesPPHT.size(); i++) &#123;
			//直接绘制直线
			line(matDst, Point(linesPPHT[i][0], linesPPHT[i][1]),
				Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);
		&#125;
#endif // PPHT累计概率霍夫变换

#ifdef HCD
		cvtColor(image, matDst, COLOR_BGR2GRAY);
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matDst, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(matDst, center, 3, Scalar(255), -1, 4, 0);
			//圆  
			circle(matDst, center, radius, Scalar(255), 3, 4, 0);
		&#125;
#endif // HCD霍夫圆检测


		imshow(&quot;检测结果&quot;, matDst);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<h6 id="3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"><a href="#3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）" class="headerlink" title="3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"></a>3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</h6><p>参数见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12333022.html" title="opencv ——
HoughCircles 霍夫圆变换原理及圆检测">opencv —— HoughCircles<br>霍夫圆变换原理及圆检测</a></p>
<p>二值化函数threshold参数：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012566751/article/details/77046445" title="OpenCV基础——threshold函数的使用">OpenCV基础——threshold函数的使用</a></p>
<pre><code>#include &quot;opencv2/opencv.hpp&quot;
#include &quot;opencv2/highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;

VideoCapture capture(0);
Mat image;

const char* windowname=&quot;win&quot;;
int max_r=100;
int min_r=60;
int min_d=80;
int t_hold=45;
int param1=100;
int param2=10;
const int t_max=255;
const int r_max=1000;
const int d_max=100;
const int p1_max=200;
const int p2_max=200;

int main()
&#123;

    void on_Trackbar_1(int, void*);
    void on_Trackbar_2(int, void*);
    void on_Trackbar_3(int, void*);
    void on_Trackbar_4(int, void*);
    void on_Trackbar_5(int, void*);
    void on_Trackbar_6(int, void*);
    namedWindow(windowname,0);
    setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
    resizeWindow(windowname, 400, 300);
    moveWindow(windowname, 0, 0);
    createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);
    createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);
    createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);
    createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);
    createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);
    createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);

	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		Mat matCanny;
        Mat BinImg;
        Mat matDst;
        cvtColor(image, matDst, COLOR_BGR2GRAY);
		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV);
        Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
        
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

        imshow(&quot;matCanny&quot;, matCanny);
        imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;
&#125;


void on_Trackbar_1(int, void*)
&#123;
    ;
&#125;


void on_Trackbar_2(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_3(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_4(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_5(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_6(int, void*)
&#123;
    ;
&#125;
</code></pre>
<p>注：OpenCV提供的SHT输出极坐标下直线的rho和theta值，需根据经验值推算该直线上的两点以绘图；而PPHT直接返回线段两端两点坐标</p>
<p>*注：图像灰度化的方法：可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36853469/article/details/106416128" title="OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客">OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客</a></p>
<h6 id="4-阈值分割（OTSU-三角法-自适应阈值）"><a href="#4-阈值分割（OTSU-三角法-自适应阈值）" class="headerlink" title="4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）"></a>4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</h6><pre><code>#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

VideoCapture capture(0);
Mat image;

int main()
&#123;
	int OtsuBinary(Mat src);
	int TriangleBinary(Mat src);
	Mat gray, dst;

	capture &gt;&gt; image;
	cvtColor(image, gray, COLOR_BGR2GRAY);
	int nThreshold = OtsuBinary(gray);
//	int nThreshold = TriangleBinary(gray);
	
	while(capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
		cvtColor(image, gray, COLOR_BGR2GRAY);

		//用OTSU方法
//		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);
//		threshold(gray, dst, 0, 255, THRESH_BINARY | THRESH_OTSU);
		//用三角法
//		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);
//		threshold(gray, dst, 0, 255, THRESH_BINARY|THRESH_TRIANGLE);
		//自适应阈值
		adaptiveThreshold(gray, dst, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 7, 5);

		imshow(&quot;BinbaryImage&quot;, dst);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<p>*<strong>注：自适应阈值保留信息更多，注意使用场合</strong></p>
<h6 id="5-识别车道（二值化、边缘检测、霍夫直线变换）"><a href="#5-识别车道（二值化、边缘检测、霍夫直线变换）" class="headerlink" title="5.识别车道（二值化、边缘检测、霍夫直线变换）"></a><strong>5.识别车道（二值化、边缘检测、霍夫直线变换）</strong></h6><pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

int main() &#123;
	Mat image = imread(&quot;car_track.jpg&quot;, IMREAD_GRAYSCALE);
	Mat BinImg;
	threshold(image, BinImg, 150, 255, THRESH_BINARY);
	imwrite(&quot;BinImg.jpg&quot;, BinImg);
	Mat matCanny;
	Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
	imwrite(&quot;CannyImg.jpg&quot;, matCanny);
	Mat matDst = image.clone();

	std::vector&lt;Vec2f&gt; linesSHT;
	//标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为100
	HoughLines(matCanny, linesSHT, 1, CV_PI / 180, 100);
	//直线在原图上绘制
	matDst = image.clone();
	for (size_t i = 0; i &lt; linesSHT.size(); i++) &#123;
		//直线的rho和theta值
		float rho = linesSHT[i][0], theta = linesSHT[i][1];
		//pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a * rho, y0 = b * rho;
		pt1.x = cvRound(x0 + 2000 * (-b)); //把浮点数转化成整数
		pt1.y = cvRound(y0 + 2000 * (a));
		pt2.x = cvRound(x0 - 2000 * (-b));
		pt2.y = cvRound(y0 - 2000 * (a));
		line(matDst, pt1, pt2, Scalar(255), 8);
	&#125;

	imshow(&quot;car_track&quot;, matDst);
	waitKey(0);
	imwrite(&quot;car_track_show.jpg&quot;, matDst);
&#125;
</code></pre>
<p>处理结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f19fbe807f911ee210017b64ea64ea.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/699cf9a73e9c5db8f5837d0018fe3604.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/4fa8e85338396b037d05b85d40503c9d.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/a35992394ee154df3670b102dfe9543c.jpeg"></p>
<h2 id="九-特征提取和目标检测"><a href="#九-特征提取和目标检测" class="headerlink" title="九.特征提取和目标检测"></a>九.特征提取和目标检测</h2><h5 id="（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）"><a href="#（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）" class="headerlink" title="&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）"></a>&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd37be7931389615cbb559ae52a7a7ff.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/70661001c310f47939567a8a92d0512d.jpeg"></p>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-HOG特征提取-SVM"><a href="#1-HOG特征提取-SVM" class="headerlink" title="1.HOG特征提取+SVM"></a>1.HOG特征提取+SVM</h6><pre><code>//SVM参考代码

#include &quot;pch.h&quot;
#include &lt;iostream&gt;	
#include &lt;fstream&gt;
#include &lt;windows.h&gt;
//#include &lt;afxwin.h&gt;

#include &lt;stack&gt;
#include &quot;opencv.hpp&quot;
using namespace cv;
using namespace std;
using namespace cv::ml;

#ifdef _DEBUG
#pragma comment(lib, &quot;opencv_world480d.lib&quot;)
#else
#pragma comment(lib, &quot;opencv_world480.lib&quot;)
#endif

//************************************
const char* file_path = &quot;E:/测试视频数据/Video_2016_8_26__10_10_48.mp4&quot;;
//************************************

vector&lt; float &gt; get_svm_detector(const Ptr&lt; SVM &gt;&amp; svm)
&#123;
	//得到支持向量
	Mat sv = svm-&gt;getSupportVectors();
	const int sv_total = sv.rows;
	//得到支持向量对应的系数值
	Mat alpha, svidx;
	double rho = svm-&gt;getDecisionFunction(0, alpha, svidx);

	CV_Assert(alpha.total() == 1 &amp;&amp; svidx.total() == 1 &amp;&amp; sv_total == 1);
	CV_Assert((alpha.type() == CV_64F &amp;&amp; alpha.at&lt;double&gt;(0) == 1.) ||
		(alpha.type() == CV_32F &amp;&amp; alpha.at&lt;float&gt;(0) == 1.f));
	CV_Assert(sv.type() == CV_32F);
	//将支持向量的值写入一个vector返回
	vector&lt; float &gt; hog_detector(sv.cols + 1);
	memcpy(&amp;hog_detector[0], sv.ptr(), sv.cols * sizeof(hog_detector[0]));
	hog_detector[sv.cols] = (float)-rho;
	return hog_detector;
&#125;

//sampleMat是采样矩阵,labelMat是类别矩阵,nCurRows当前是矩阵的行数
//提取正样本HOG特征
void PosData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;pos_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat imgSrc = imread(files[i], IMREAD_GRAYSCALE); //加载图像
		if (imgSrc.empty()) &#123;
			cout &lt;&lt; files[i] &lt;&lt; &quot; is invalid!&quot; &lt;&lt; endl;
			continue;
		&#125;
		Mat imgDst;
		resize(imgSrc, imgDst, hog.winSize); //将正例缩放到检测窗口大小
		vector&lt;float&gt; featureVec;
		hog.compute(imgDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(+1); //正样本类别为+1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

//提取负样本HOG特征
void NegData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;neg_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	Rect box;
	box.width = hog.winSize.width;
	box.height = hog.winSize.height;
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat img = imread(files[i], IMREAD_GRAYSCALE);
		if (img.empty()) &#123;
			continue;
		&#125;
		Mat matDst;
		if (img.cols &lt;= hog.winSize.width + 1 || img.rows &lt;= hog.winSize.height + 1) &#123;
			//cout &lt;&lt; &quot;image too small&quot; &lt;&lt; endl;
			resize(img, matDst, hog.winSize);
		&#125;
		else &#123;
			//随机选择窗口位置
			box.x = rand() % (img.cols - box.width);
			box.y = rand() % (img.rows - box.height);
			matDst = img(box);
		&#125;

		vector&lt;float&gt; featureVec;
		hog.compute(matDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(-1);//负样本类别为-1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

void TrainSVMModel()
&#123;
	//车牌检测window大小为128X48,block大小为16X16,cell大小为8X8，滑动窗口大小为8X8
	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), cv::Size(8, 8), 9);
	int nVecLen = hog.getDescriptorSize();
	//样本的特征向量，行数等于正负样本个数，列数等于HOG特征向量长度
	Mat sampleFeatureMat = Mat::zeros(9689, nVecLen, CV_32FC1);
	//样本的类别向量，行数等于所有样本的个数，列数等于1；1表示正样本，-1表示负样本
	vector&lt;int&gt; Labels;
	int nRowIdx = 0;
	PosData(hog, sampleFeatureMat, Labels, nRowIdx);
	NegData(hog, sampleFeatureMat, Labels, nRowIdx);


	Ptr&lt;SVM&gt; svm = SVM::create(); //创建一个SVM分类器
	svm-&gt;setCoef0(0.0);
	svm-&gt;setDegree(3);
	svm-&gt;setGamma(0);
	svm-&gt;setKernel(SVM::LINEAR);
	svm-&gt;setNu(0.5);
	svm-&gt;setP(0.1);
	svm-&gt;setC(0.01);
	svm-&gt;setType(SVM::EPS_SVR); //分类器类型为EPS_SVR
	//************************************
	//训练结束条件：要么达到1000次，要么两次误差小于1e-3
	svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 1e-3));
	//************************************
	svm-&gt;train(sampleFeatureMat, ROW_SAMPLE, Labels);

	//svm-&gt;trainAuto();
	//直接将支持向量系数写入文本文件，以方便在检测器的头文件中导入
	vector&lt;float&gt; vecHogCof = get_svm_detector(svm);
	//************************************
	//支持向量结果保存
	ofstream file(&quot;dector.txt&quot;);	
	//************************************
	for (int i = 0; i &lt; vecHogCof.size(); i++) &#123;
		file &lt;&lt; vecHogCof[i] &lt;&lt; &quot;,&quot;;
	&#125;
	file.close();
&#125;


void TestSVMModel()
&#123;
	//************************************
	//SVM检测器系数向量都放在hogCof数组中(detect.txt中内容，模型建立好后可直接调用)
	float hogCof[] = &#123;......&#125;;
	//************************************
	
	//创建HOG检测器，参数与训练时的参数相同
	//在这里特别注意将nLevels参数从默认64修改为4，可以加快检测速度
	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), \
		cv::Size(8, 8), 9, 1, -1.0, HOGDescriptor::L2Hys, 0.2, false, 4);
	const int vecLen = sizeof(hogCof) / sizeof(float);
	vector&lt;float&gt; vecHogCof(hogCof, hogCof + vecLen);
	hog.setSVMDetector(vecHogCof); //设置HOG检测器的系数

	//打开一个视频文件
	VideoCapture cap;
	cap.open(file_path);
	if (!cap.isOpened()) &#123;
		return;
	&#125;
	Mat frame;
	int nFrmIdx = 0;
	while (true) &#123;
		cap &gt;&gt; frame;
		if (frame.empty()) &#123;
			break;
		&#125;
		vector&lt;Rect&gt; detections; //检测到目标矩形位置
		vector&lt;double&gt; foundWeights; //检测到的权重
		hog.detectMultiScale(frame, detections, foundWeights, 0.5, Size(8, 8), Size(0, 0), 1.1, 3.0, false);
		for (int i = 0; i &lt; detections.size(); i++) &#123;
			if (frame.rows - detections[i].y &lt; 200)
				continue;
			rectangle(frame, detections[i], Scalar(0, 0, 255), 4);
		&#125;
		imshow(&quot;LP HOG Detection&quot;, frame);
		if (detections.size() &gt; 0) &#123;
			char szFileName[100] = &#123; 0 &#125;;
			sprintf_s(szFileName, &quot;%03d.jpg&quot;, nFrmIdx++);
			imwrite(szFileName, frame);
		&#125;

		waitKey(40);
	&#125;
&#125;

int mian()
&#123;
	TestSVMModel();
&#125;
</code></pre>
<p>注：</p>
<p>①.&#x2F;&#x2F;*…*之间的是copy代码时要修改的地方</p>
<p>②.void TrainSVMModel()求出支持向量系数，保存在文件中，之后可以直接复制其中数值以调用</p>
<h6 id="2-获取LBP-MB-LBP特征函数"><a href="#2-获取LBP-MB-LBP特征函数" class="headerlink" title="2.获取LBP&#x2F;MB-LBP特征函数"></a>2.获取LBP&#x2F;MB-LBP特征函数</h6><pre><code>//使用函数模板，保证函数对所有类型图像都适用
//_tp参数可以是uchar,float等
template &lt;typename _tp&gt;
//原始LBP特征
void getOriginLBPFeature(InputArray _src, OutputArray _dst)
&#123;
	Mat src = _src.getMat();
	Mat srcExtented;
	//对图像边界进行扩充，边界像素采用复制的形式
	copyMakeBorder(src, srcExtented, 1, 1, 1, 1, BORDER_REPLICATE);
	//输出图像与原图像大小相同
	_dst.create(src.rows, src.cols, CV_8UC1);
	Mat dst = _dst.getMat();
	dst.setTo(0);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			//中心像素的值
			_tp center = srcExtented.at&lt;_tp&gt;(i + 1, j + 1);
			unsigned char lbpCode = 0; //LBP编码值
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j) &gt; center) &lt;&lt; 7; //左上角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 1) &gt; center) &lt;&lt; 6; //上边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i, j + 2) &gt; center) &lt;&lt; 5; //右上角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j + 2) &gt; center) &lt;&lt; 4; //右边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 2) &gt; center) &lt;&lt; 3; //右下角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j + 1) &gt; center) &lt;&lt; 2; //下边
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 2, j) &gt; center) &lt;&lt; 1; //左下角
			lbpCode |= (srcExtented.at&lt;_tp&gt;(i + 1, j) &gt; center) &lt;&lt; 0; //左边
			dst.at&lt;uchar&gt;(i, j) = lbpCode;
		&#125;
	&#125;
&#125;

//MB-LBP特征
void getMultiScaleBlockLBPFeature(InputArray _src, OutputArray _dst, int scale)
&#123;
	Mat src = _src.getMat();
	int cellSize = scale / 3;
	int offset = cellSize / 2;
	Mat srcExtented;
	//图像扩大一圈
	copyMakeBorder(src, srcExtented, offset, offset, offset, offset, BORDER_REFLECT);
	//以当前点为中心，计算每个cell的像素均值
	Mat cellImage(src.rows, src.cols, CV_8UC1);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			int temp = 0;
			for (int m = -offset; m &lt; offset + 1; m++) &#123;
				for (int n = -offset; n &lt; offset + 1; n++) &#123;
					temp += srcExtented.at&lt;uchar&gt;(i + n + offset, j + m + offset);
				&#125;
			&#125;
			temp /= (cellSize * cellSize);
			cellImage.at&lt;uchar&gt;(i, j) = uchar(temp);
		&#125;
	&#125;
	getOriginLBPFeature&lt;uchar&gt;(cellImage, _dst);
&#125;
</code></pre>
<h6 id="3-cascade级联分类器使用"><a href="#3-cascade级联分类器使用" class="headerlink" title="3.cascade级联分类器使用"></a>3.cascade级联分类器使用</h6><pre><code>//级联分类器实现人脸检测
void DetectFaces()
&#123;
	//创建一个级联分类器对象，并加载分类器文件
	//CascadeClassifier faceDetector(&quot;haarcascade_frontalface_alt2.xml&quot;);
	CascadeClassifier faceDetector(&quot;cascade.xml&quot;);
	if (faceDetector.empty()) &#123;
		return;
	&#125;
	VideoCapture cap(0); //打开USB摄像头
	if (!cap.isOpened()) &#123;
		return;
	&#125;
	Mat frame;
	while (true) &#123;
		cap &gt;&gt; frame; //从摄像头获取一帧图像
		if (frame.empty())
			break;
		std::vector&lt;cv::Rect&gt; objects;
		//使用级联分类器检测人脸
		faceDetector.detectMultiScale(frame, objects);
		//对人脸图像进行标记
		for (int i = 0; i &lt; objects.size(); i++) &#123;
			static int nIdx = 0;
			char szFileName[100] = &#123; 0 &#125;;
			sprintf_s(szFileName, &quot;detectedHeadShoulder/%03d.jpg&quot;, nIdx++);
			//sprintf_s(szFileName, &quot;DetetecdFaces/%03d.jpg&quot;, nIdx++);
			cv::rectangle(frame, objects[i], Scalar(0, 0, 255), 4);
			imwrite(szFileName, frame);
		&#125;
		imshow(&quot;人脸检测结果&quot;, frame); //显示人脸检测结果

		if (waitKey(25) == 27) //暂停25ms，如果按ESC键则退出
			break;
	&#125;
	cap.release(); //释放摄像头对象
	return;
&#125;
</code></pre>
<p>注：分类器文件生成使用opencv_traincacade.exe；创建正样本.vec文件使用opencv_creatsamples.exe；可视化过程使用opencv_visualisation.exe</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797">https://blog.csdn.net/qq_32971095/article/details/131609797</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（电机部分）——电赛学习笔记（2）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 22:32:42" itemprop="dateCreated datePublished" datetime="2023-07-04T22:32:42+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（电机部分）——电赛学习笔记（2）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>907</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><hr>
<h2 id="图片来源：B站唐老师讲电赛"><a href="#图片来源：B站唐老师讲电赛" class="headerlink" title="_  图片来源：B站唐老师讲电赛_"></a><strong>_  图片来源：B站唐老师讲电赛_</strong></h2><p><strong>目录</strong></p>
<p><a href="about:blank#%C2%A0%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90%EF%BC%9AB%E7%AB%99%E5%94%90%E8%80%81%E5%B8%88%E8%AE%B2%E7%94%B5%E8%B5%9B"><br>图片来源：B站唐老师讲电赛</a></p>
<p><a href="about:blank#%E4%B8%80.%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84">一.电机部分结构</a></p>
<p><a href="about:blank#%E4%BA%8C.%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">二.步进电机示例</a></p>
<p><a href="about:blank#%E4%B8%89.%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">三.伺服电机示例</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%A1%88">四.我们的方案</a></p>
<hr>
<h2 id="一-电机部分结构"><a href="#一-电机部分结构" class="headerlink" title="一.电机部分结构"></a>一.电机部分结构</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcfec2f6ed3a3e801301c91dfeb4307d.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b68a6432253fb37113bcd87a78d6af13.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/99f4e23df848c63b9a836035426fe043.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5483b488abe59c6b56599034cee91db9.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/36766f56d5dbe1c3b71e1d2f8cc63d56.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f23bb2de689dbeadc754dd5f58a19811.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/f2fe3b27147efcb57b0964d81171b5b5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4547084918f7ca3e14a1a6aaf1c3ea0c.png"></p>
<h2 id="二-步进电机示例"><a href="#二-步进电机示例" class="headerlink" title="二.步进电机示例"></a>二.步进电机示例</h2><p>1.驱动器：L298N（CSDN搜索使用方法）；控制器：stm32；电源暂时用12V直流源</p>
<p>2.控制：全速模式：in1、in2一低一高控制正反转，全低不转。</p>
<p>pwm控制模式：使能端连接单片机IO口，通过产生pwm波占空比控制速度（相当于有效电压控制）</p>
<p>3.编码器：将编码器产生脉冲当做外部时钟传入单片机定时器，定时读取并清零</p>
<p>4.涉及知识：定时器（内部定时器产生pwm波，外部作为编码计数）</p>
<p>5.示例代码：</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_65683639/article/details/130562162" title="直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-CSDN博客">直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-<br>CSDN博客</a></p>
<h2 id="三-伺服电机示例"><a href="#三-伺服电机示例" class="headerlink" title="三.伺服电机示例"></a>三.伺服电机示例</h2><p>MG995型伺服电机：</p>
<p>1.结构：可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/he__yuan/article/details/79195435?spm=1001.2014.3001.5506" title="MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-CSDN博客">MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-<br>CSDN博客</a></p>
<p>2.控制：通过PWM波占空比控制</p>
<p>固定20ms周期pwm波通过定时器输出  </p>
<p>TIM1_PWM_Init(199,7199);        &#x2F;&#x2F;(7200<em>200)&#x2F;72000000&#x3D;0.02&#x3D;20ms；（分频</em>周期数）</p>
<p>占空比通过函数TIM_SetCompare1（TIM1,num）控制，其中num是低电平占周期数</p>
<p>0.5ms对应195，2.5ms对应175</p>
<p>四.具体器件</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/79abef952376244b07db4ca4c37604b6.png"></p>
<h2 id="四-我们的方案"><a href="#四-我们的方案" class="headerlink" title="四.我们的方案"></a>四.我们的方案</h2><p>后轮电机：MG513直流减速电机（霍尔编码器）</p>
<p>前轮转向电机（采用阿克曼转向结构）：舵机MG995</p>
<p>机械臂电机：舵机MG995</p>
<p>后轮电机驱动：l298n电机驱动模块</p>
<p>舵机驱动：pca9685 PWM伺服驱动器模块</p>
<p>超声波测距：cs100a超声波模块</p>
<p>蓝牙：JDY-31蓝牙模块</p>
<p>显示屏：SSD1306 OLED IIC显示屏</p>
<p>稳压芯片：lm2596可调稳压模块*2（12V-5V-3.3V）</p>
<p>电池：12V3A锂电池（最大电流6A）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991">https://blog.csdn.net/qq_32971095/article/details/131503991</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（jetson nano部分）——电赛学习笔记（3）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 22:30:36" itemprop="dateCreated datePublished" datetime="2023-07-04T22:30:36+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（jetson nano部分）——电赛学习笔记（3）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/04/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p>
<p><a href="about:blank#1.jetson%20nano%E8%B4%AD%E4%B9%B0%E5%95%86%E5%AE%B6%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81">1.jetson<br>nano购买商家及技术支持</a></p>
<p><a href="about:blank#2.%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2.相关环境配置</a></p>
<p><a href="about:blank#3.%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD">3.做好系统备份</a></p>
<p><a href="about:blank#%E4%B8%80.vscode%E8%BF%9C%E7%A8%8Bssh%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5%EF%BC%89">一.vscode远程ssh操作</a></p>
<p><a href="about:blank#%3C1%3E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5">&lt;1&gt;局域网连接</a></p>
<p><a href="about:blank#%3C2%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E">&lt;2&gt;电脑直连</a></p>
<p><a href="about:blank#%3C3%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E%2BVNC%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">&lt;3&gt;电脑直连+VNC远程桌面</a></p>
<p><a href="about:blank#%E4%BA%8C.%E6%9D%BF%E8%BD%BD%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%99%E7%A8%8B%EF%BC%9A">二.板载摄像头教程：</a></p>
<p><a href="about:blank#%E4%B8%89.%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B">三.运行例程</a></p>
<p><a href="about:blank#%E5%9B%9B.GPIO%E4%BD%BF%E7%94%A8">四.GPIO使用</a></p>
<p><a href="about:blank#GPIO%E5%BA%93%E7%9A%84API%E7%94%A8%E6%B3%95">GPIO库的API用法</a></p>
<p><a href="about:blank#1.%E5%AF%BC%E5%85%A5%E5%BA%93">1.导入库</a></p>
<p><a href="about:blank#2.%E5%BC%95%E8%84%9A%E7%BC%96%E5%8F%B7">2.引脚编号</a></p>
<p><a href="about:blank#3.%E8%AD%A6%E5%91%8A">3.警告</a></p>
<p><a href="about:blank#4.%E8%AE%BE%E7%BD%AE%E9%80%9A%E9%81%93">4.设置通道</a></p>
<p><a href="about:blank#5.%E8%BE%93%E5%85%A5">5.输入</a></p>
<p><a href="about:blank#6.%E8%BE%93%E5%87%BA">6.输出</a></p>
<p><a href="about:blank#set%20first%20channel%20to%20HIGH%20and%20rest%20to%20LOW">set first channel to HIGH and rest to<br>LOW</a></p>
<p><a href="about:blank#7.%E6%B8%85%E7%90%86">7.清理</a></p>
<p><a href="about:blank#8.jetson%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E5%92%8C%E5%BA%93%E7%89%88%E6%9C%AC">8.jetson模块信息和库版本</a></p>
<p><a href="about:blank#9.%E4%B8%AD%E6%96%AD">9.中断</a></p>
<p><a href="about:blank#wait_for_edge%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">wait_for_edge（）函数</a></p>
<p><a href="about:blank#timeout%20is%20in%20milliseconds">timeout is in milliseconds</a></p>
<p><a href="about:blank#event_detected%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">event_detected（）函数</a></p>
<p><a href="about:blank#set%20rising%20edge%20detection%20on%20the%20channel">set rising edge detection on the<br>channel</a></p>
<p><a href="about:blank#%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E8%BE%B9%E7%BC%98%E6%97%B6%E8%BF%90%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">当检测到边缘时运行回调函数</a></p>
<p><a href="about:blank#define%20callback%20function">define callback function</a></p>
<p><a href="about:blank#add%20rising%20edge%20detection">add rising edge detection</a></p>
<p><a href="about:blank#bouncetime%20set%20in%20milliseconds">bouncetime set in<br>milliseconds</a></p>
<p><a href="about:blank#10.%E6%A3%80%E6%9F%A5GPIO%E9%80%9A%E9%81%93%E7%9A%84%E5%8A%9F%E8%83%BD">10.检查GPIO通道的功能</a></p>
<p><a href="about:blank#11.%20PWM">11. PWM</a></p>
<p><a href="about:blank#%E4%BA%94.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1">五.串口通信</a></p>
<p><a href="about:blank#%3C1%3EUART">&lt;1&gt;UART</a></p>
<p><a href="about:blank#1.python%E4%BB%A3%E7%A0%81%EF%BC%9AJetsonHacksNano%2FUARTDemo%3A%20UART%20Demo%20Code%20%28github.com%29">1.python代码：JetsonHacksNano&#x2F;UARTDemo: UART Demo Code<br>(github.com)</a></p>
<p><a href="about:blank#3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点</a></p>
<p><a href="about:blank#2.C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%9AUart%20c%2B%2B%20class%20for%20Nvidia%20Jetson%20Nano">2.C++代码：Uart c++ class for Nvidia Jetson<br>Nano</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%9C%A8jetson%20nano%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV">六.在jetson<br>nano上使用OpenCV</a></p>
<p><a href="about:blank#%E4%B8%83.jetson%20nano%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">七.jetson<br>nano开机自启动程序</a></p>
<p><a href="about:blank#%E5%85%AB.%E5%AE%9E%E6%88%98%E7%A8%8B%E5%BA%8F">八.实战程序</a></p>
<p><a href="about:blank#1.jetson%20nano%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%B0%86%E5%9C%86%E5%BF%83%E5%9D%90%E6%A0%87%E9%80%9A%E8%BF%87uart%E4%BC%A0%E7%BB%99stm32">1.jetson<br>nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</a></p>
<hr>
<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><h5 id="1-jetson-nano购买商家及技术支持"><a href="#1-jetson-nano购买商家及技术支持" class="headerlink" title="1.jetson nano购买商家及技术支持"></a><strong>1.jetson nano购买商家及技术支持</strong></h5><p>***<strong>选购亚博，支持相关开源资料，资料网址：<a target="_blank" rel="noopener" href="https://www.yahboom.com/study/jetson-nano" title="JETSON NANO B01
(yahboom.com)">JETSON NANO B01<br>(yahboom.com)</a></strong></p>
<p>***<strong>常见问题及解答：<a target="_blank" rel="noopener" href="https://www.yuque.com/yahboomtechnology/yahboom_support/kgdd5m#NLt6t" title="Jetson nano A01&#x2F;B01 (yuque.com)">Jetson nano A01&#x2F;B01<br>(yuque.com)</a></strong></p>
<h5 id="2-相关环境配置"><a href="#2-相关环境配置" class="headerlink" title="2.相关环境配置"></a>2.相关环境配置</h5><p>&lt;1&gt;亚博已经在SD卡中将环境配好，插上即可直接使用</p>
<p>&lt;2&gt;***<strong>自行烧录镜像，配置环境</strong> ：</p>
<p>下载之前要格式化SD卡或者U盘，具体操作见“jetson—主板—2.Jetson Nano B01基础教程”，然后烧录镜像文件：</p>
<p>亚博资料里的 “jetson—主板—附录—镜像” 包含**<code>已安装：</code>**</p>
<p><strong><code>CUDA10.2、CUDNNv8、tensorRT、opencv4.1.1、python2、python3、tensorflow2.3、jetpack4.6.1、yolov5、jetson- inference包（包括相关模型）、jetson-gpio库、安装pytorch1.8和torchvesion0.9、安装node v15.0.1、npm7.2.3，jupyter，已开启VNC服务，还有其他课程中所用到的模块。</code></strong></p>
<p>以及Swap空间配置，Jtop安装，只需要TF&#x2F;U盘扩容即可</p>
<p>减少自行配置的麻烦。</p>
<p>如果要从零开始自己配置，“jetson—主板—2.Jetson Nano B01基础教程” 和“4.系统基础设置教程”中包括了大部分操作，甚至包括空环境下载</p>
<h5 id="3-做好系统备份"><a href="#3-做好系统备份" class="headerlink" title="3.做好系统备份"></a>3.做好系统备份</h5><p>如果只是使用亚博官方提供的版本库，可以只用 “jetson—主板—附录—镜像”<br>中的镜像文件作为备份。如果自行配置了其他环境，建议备份系统，可在“jetson—主板—4.系统基础设置教程” 找到具体操作。</p>
<h2 id="一-vscode远程ssh操作"><a href="#一-vscode远程ssh操作" class="headerlink" title="一.vscode远程ssh操作"></a>一.vscode远程ssh操作</h2><h3 id="局域网连接"><a href="#局域网连接" class="headerlink" title="&lt;1&gt;局域网连接"></a>&lt;1&gt;局域网连接</h3><p>1.将jetson连接至路由器——电脑使用该路由wifi——打开VS Code——下载ssh-<br>remote插件——jetson上终端ifconfig查ip——vscode按格式输入：ssh<br>jetson@IP地址——输入密码登录（原始默认用户名为jetson，密码为yahboom）</p>
<p>2.crtl+o选择要打开的文件或侧栏资源管理器选择，文件可在主机写好直接拖入jetson；终端写入代码并操作</p>
<h3 id="电脑直连"><a href="#电脑直连" class="headerlink" title="&lt;2&gt;电脑直连"></a>&lt;2&gt;电脑直连</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15906550/5921556#:~:text=Jetson,Nano%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E6%9C%ACssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9CjetsonnanoSD%E5%8D%A1%E6%88%90%E5%8A%9F%E7%83%A7%E5%BD%95%E5%B9%B6%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B0%86Jetsonnano%E5%92%8C%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%BB%99%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8F%B3%E5%87%BBwlan%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E6%89%BE%E5%88%B0IP%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%89%93%E5%BC%80cmd%EF%BC%9Aarp-a%E8%BF%9E%E6%8E%A5ssh%E5%8D%B3%E5%8F%AF%E3%80%82" title="Jetson Nano——通过网线实现笔记本ssh远程连接">Jetson<br>Nano——通过网线实现笔记本ssh远程连接</a></p>
<h3 id="电脑直连-VNC远程桌面"><a href="#电脑直连-VNC远程桌面" class="headerlink" title="&lt;3&gt;电脑直连+VNC远程桌面"></a>&lt;3&gt;电脑直连+VNC远程桌面</h3><p>jetson nano上设置：[Jetson nano 通过 vnc<br>实现远程桌面控制（已在nano实现）](<a target="_blank" rel="noopener" href="https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171299147716800184169928&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171299147716800184169928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>top_positive~default-1-122121251-null-<br>null.142%5Ev100%5Epc_search_result_base9&amp;utm_term&#x3D;jetson%20nano%20vnc&amp;spm&#x3D;1018.2226.3001.4187<br>“Jetson nano 通过 vnc 实现远程桌面控制（已在nano实现）”)</p>
<p>下载VNC Viewer软件并连接（端口号参考&lt;2&gt;），效果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png"></p>
<p> 如果无法连接检查接口是否插好，如果成功会有一个不同于端口地址的地址：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/938609aaeb57355774c771bab4569295.png"></p>
<p>如果vnc server显示窗口过小，打开终端输入以下命令调整分辨率：</p>
<pre><code>xrandr --fb 1920x1080
</code></pre>
<h2 id="二-板载摄像头教程："><a href="#二-板载摄像头教程：" class="headerlink" title="二.板载摄像头教程："></a>二.板载摄像头教程：</h2><p><strong>获取摄像头相关参数：[linux查看摄像头分辨率参数](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20">https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20</a><br>–list-<br>devices%2F%2F%E9%80%9A%E8%BF%87v4l2%E6%9F%A5%E7%9C%8B%E6%91%84%E5%83%8F%E5%A4%B4%E8%AE%BE%E5%A4%87%20%2F%2F%E5%BD%93%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%91%84%E5%83%8F%E5%A4%B4%E6%97%B6%EF%BC%8C%E6%8C%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95,sudo%20rmmod%20uvcvideo%2F%2F%E7%A7%BB%E9%99%A4%E6%A8%A1%E5%9D%97%20sudo%20modprobe%20uvcvideo%20nodrop%3D1%20timeout%3D5000<br>“linux查看摄像头分辨率参数”)</strong></p>
<pre><code>Driver Info (not using libv4l2):
        Driver name   : tegra-video
        Card type     : vi-output, imx219 8-0010
        Bus info      : platform:54080000.vi:4
        Driver version: 4.9.255
        Capabilities  : 0x84200001
                Video Capture
                Streaming
                Extended Pix Format
                Device Capabilities
        Device Caps   : 0x04200001
                Video Capture
                Streaming
                Extended Pix Format
Priority: 2
Video input : 0 (Camera 4: ok)
Format Video Capture:
        Width/Height      : 3264/2464
        Pixel Format      : &#39;RG10&#39;
        Field             : None
        Bytes per Line    : 6528
        Size Image        : 16084992
        Colorspace        : sRGB
        Transfer Function : Default (maps to sRGB)
        YCbCr/HSV Encoding: Default (maps to ITU-R 601)
        Quantization      : Default (maps to Full Range)
        Flags             : 

Camera Controls

                     group_hold 0x009a2003 (bool)   : default=0 value=0 flags=execute-on-write
                    sensor_mode 0x009a2008 (int64)  : min=0 max=0 step=0 default=0 value=0 flags=slider
                           gain 0x009a2009 (int64)  : min=0 max=0 step=0 default=0 value=16 flags=slider
                       exposure 0x009a200a (int64)  : min=0 max=0 step=0 default=0 value=13 flags=slider
                     frame_rate 0x009a200b (int64)  : min=0 max=0 step=0 default=0 value=2000000 flags=slider
                    bypass_mode 0x009a2064 (intmenu): min=0 max=1 default=0 value=0
                override_enable 0x009a2065 (intmenu): min=0 max=1 default=0 value=0
                   height_align 0x009a2066 (int)    : min=1 max=16 step=1 default=1 value=1
                     size_align 0x009a2067 (intmenu): min=0 max=2 default=0 value=0
               write_isp_format 0x009a2068 (bool)   : default=0 value=0
       sensor_signal_properties 0x009a2069 (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
        sensor_image_properties 0x009a206a (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
      sensor_control_properties 0x009a206b (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
              sensor_dv_timings 0x009a206c (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
               low_latency_mode 0x009a206d (bool)   : default=0 value=0
               preferred_stride 0x009a206e (int)    : min=0 max=65535 step=1 default=0 value=0
                   sensor_modes 0x009a2082 (int)    : min=0 max=30 step=1 default=30 value=6 flags=read-only
</code></pre>
<p><strong>注意jetson nano要连接显示屏</strong></p>
<p>jetson@yahboom:&#x2F;home$ <strong>nvgstcapture-1.0  **                              **<br>&#x2F;&#x2F;打开摄像头命令</strong></p>
<p><strong>响应：</strong><br>Encoder null, cannot set bitrate!<br>Encoder Profile &#x3D; High<br>Supported resolutions in case of ARGUS Camera                      <strong>&#x2F;&#x2F;设置分辨率</strong><br>  (2) : 640x480<br>  (3) : 1280x720<br>  (4) : 1920x1080<br>  (5) : 2104x1560<br>  (6) : 2592x1944<br>  (7) : 2616x1472<br>  (8) : 3840x2160<br>  (9) : 3896x2192<br>  (10): 4208x3120<br>  (11): 5632x3168<br>  (12): 5632x4224</p>
<p>Runtime ARGUS Camera Commands:</p>
<p>  <strong>Help : ‘h’<br>  Quit : ‘q’</strong><br>  Set Capture Mode:<br>      mo:<val><br>          (1): image<br>          (2): video<br>  Get Capture Mode:<br>      gmo<br>  Set sensor orientation:<br>      so:<val><br>          (0): none<br>          (1): Rotate counter-clockwise 90 degrees<br>          (2): Rotate 180 degrees<br>          (3): Rotate clockwise 90 degrees<br>  Get sensor orientation:<br>      gso<br>  Set sensor mode:<br>      smo:<val> e.g., smo:1<br>  Get sensor mode:<br>      gsmo<br>  Set Whitebalance Mode:<br><strong>&#x2F;&#x2F;更改相机参数（曝光、饱和度等等）</strong><br>      wb:<val><br>          (0): off<br>          (1): auto<br>          (2): incandescent<br>          (3): fluorescent<br>          (4): warm-fluorescent<br>          (5): daylight<br>          (6): cloudy-daylight<br>          (7): twilight<br>          (8): shade<br>          (9): manual<br>  Get Whitebalance Mode:<br>      gwb<br>  Set Saturation (0 to 2):<br>      st:<val> e.g., st:1.25<br>  Get Saturation:<br>      gst<br>  Set Exposure Compensation (-2 to 2):<br>      ec:<val> e.g., ec:-2<br>  Get Exposure Compensation:<br>      gec<br>  Set Auto Whitebalance Lock:<br>      awbl:<val> e.g., awbl:0<br>  Get Auto Whitebalance Lock:<br>      awbl<br>  Set Auto Exposure Lock:<br>      ael:<val> e.g., ael:0<br>  Get Auto Exposure Lock:<br>      gael<br>  Set TNR Mode:<br>      tnrm:<val> e.g., tnrm:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get TNR Mode:<br>      gtnrm<br>  Set TNR Strength (-1 to 1):<br>      tnrs:<val> e.g., tnrs:0.5<br>  Get TNR Strength:<br>      gtnrs<br>  Set EE Mode:<br>      eem:<val> e.g., eem:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get EE Mode:<br>      geem<br>  Set EE Strength (-1 to 1):<br>      ees:<val> e.g., ees:0.5<br>  Get EE Strength:<br>      gees<br>  Set Auto Exposure Anti-Banding (0 to 3):<br>      aeab:<val> e.g., aeab:2<br>          (0): OFF<br>          (1): MODE AUTO<br>          (2): MODE 50HZ<br>          (3): MODE 60HZ<br>  Get Auto Exposure Anti-Banding:<br>      gaeab<br>  Set Gain Range:<br>      gr:<val><space><val> e.g., gr:1 16<br>  Get Gain Range:<br>      ggr<br>  Set Exposure Time Range:<br>      etr:<val><space><val> e.g., etr:34000 35000<br>  Get Exposure Time Range:<br>      getr<br>  Set ISP Digital Gain Range:<br>      dgr:<val><space><val> e.g., dgr:2 152<br>  Get ISP Digital Gain Range:<br>      gdgr<br>  <strong>Capture: enter ‘j’ OR<br>           followed by a timer (e.g., jx5000, capture after 5 seconds) OR<br>           followed by multishot count (e.g., j:6, capture 6 images)<br>           timer&#x2F;multihot values are optional, capture defaults to single shot with timer&#x3D;0s<br>  Start Recording : enter ‘1’<br>  Stop Recording  : enter ‘0’</strong><br>  Video <strong>snapshot</strong>  : enter ‘2’ (While recording video)<br>  Get Preview Resolution:<br>      gpcr<br>  Get Image Capture Resolution:<br>      gicr<br>  Get Video Capture Resolution:<br>      gvcr</val></space></val></val></space></val></val></space></val></val></val></val></val></val></val></val></val></val></val></val></val></val></p>
<p>Runtime encoder configuration options:</p>
<p>  Set Encoding Bit-rate(in bytes):<br>      br:<val> e.g., br:4000000<br>  Get Encoding Bit-rate(in bytes):<br>      gbr<br>  Set Encoding Profile(only for H.264):<br>      ep:<val> e.g., ep:1<br>          (0): Baseline<br>          (1): Main<br>          (2): High<br>  Get Encoding Profile(only for H.264):<br>      gep<br>  Force IDR Frame on video Encoder(only for H.264):<br>      Enter ‘f’ </val></val></p>
<p>bitrate &#x3D; 4000000<br>Encoder Profile &#x3D; High<br>Encoder control-rate &#x3D; 1<br>Encoder EnableTwopassCBR &#x3D; 0<br>Opening in BLOCKING MODE</p>
<p>摘自亚博教程：命令</p>
<ol>
<li>--prev_res 预览视屏的分辨率，高度和宽度，用的是CSI摄像头的话范围是 2 to 12 (5632x4224)</li>
</ol>
<p>e.g.,  nvgstcapture-1.0 –prev-res&#x3D;3</p>
<ol>
<li>--cus-prev-res 自定义预览分辨率，宽度和高度，仅支持CSI摄像头</li>
</ol>
<p>e.g., nvgstcapture-1.0 –cus-prev-res&#x3D;1920x1080</p>
<p>多个命令同时使用的话用！隔开</p>
<p>想关掉摄像头的额话，直接在终端输入q再按回车</p>
<p>想捕获图片的话，在终端输入j再按回车，图片将保存当前目录下</p>
<p><strong>关键参数的调整</strong> ：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h2 id="三-运行例程"><a href="#三-运行例程" class="headerlink" title="三.运行例程"></a>三.运行例程</h2><ul>
<li><p>MIPI CSI cameras (<code>csi://0</code>)</p>
</li>
<li><p>V4L2 cameras (<code>/dev/video0</code>)</p>
</li>
<li><p>RTP&#x2F;RTSP streams (<code>rtsp://username:password@ip:port</code>)</p>
<p>在&#x2F;home&#x2F;jetson&#x2F;jetson-inference&#x2F;build&#x2F;aarch64&#x2F;bin 中打开终端</p>
<p>输入示例(c++)(python 加.py即可)<br>.&#x2F;imagenet images&#x2F;orange_0.jpg images&#x2F;test&#x2F;output_0.jpg<br>.&#x2F;imagenet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;图像分类推理<br>.&#x2F;detectnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;目标检测推理<br>.&#x2F;segnet –network&#x3D;<model> csi:&#x2F;&#x2F;0           &#x2F;&#x2F;语义分割<br>.&#x2F;posenet &#x2F;dev&#x2F;video0                        &#x2F;&#x2F;姿态估计<br>.&#x2F;posenet –network&#x3D;resnet18-hand csi:&#x2F;&#x2F;0    &#x2F;&#x2F;手部姿态<br>.&#x2F;actionnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;动作识别<br>.&#x2F;backgroundnet csi:&#x2F;&#x2F;0                      &#x2F;&#x2F;背景去除<br>.&#x2F;depthnet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;单眼深度</model></p>
</li>
</ul>
<h2 id="四-GPIO使用"><a href="#四-GPIO使用" class="headerlink" title="四.GPIO使用"></a>四.GPIO使用</h2><p><strong>Python版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio" title="NVIDIA&#x2F;jetson-gpio: A
Python library that enables the use of Jetson&#39;s GPIOs">NVIDIA&#x2F;jetson-gpio: A Python library that enables the use of<br>Jetson’s GPIOs</a></p>
<p><strong>C++版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/pjueon/JetsonGPIO" title="pjueon&#x2F;JetsonGPIO: A C++
library that enables the use of Jetson&#39;s GPIOs">pjueon&#x2F;JetsonGPIO: A C++ library that enables the use of<br>Jetson’s GPIOs</a></p>
<h4 id="GPIO库的API用法"><a href="#GPIO库的API用法" class="headerlink" title="GPIO库的API用法"></a>GPIO库的API用法</h4><p>Jetson GPIO库提供了RPi.GPIO库提供的所有公共API。下面讨论每种API的用法：</p>
<h5 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h5><p>要导入Jetson.GPIO模块，请使用：</p>
<p>import Jetson.GPIO as GPIO</p>
<p>通过这种方式，您可以在应用程序的其余部分中将该模块称为GPIO。模块也可以使用RPi的名称导入。GPIO代替了Jetson。GPIO用于使用RPi库的现有代码。</p>
<h5 id="2-引脚编号"><a href="#2-引脚编号" class="headerlink" title="2.引脚编号"></a>2.引脚编号</h5><p>Jetson<br>GPIO库提供了四种给IO引脚编号的方法。前两个对应于RPi.GPIO库提供的模式，即BOARD和BCM，分别引用40引脚GPIO接头连接器的引脚号和Broadcom<br>SoC GPIO编号。其余两种模式CVM和TEGRA_SOC使用字符串代替数字，而数字分别对应于CVM CVB连接器和Tegra SoC上的信号名称。</p>
<p>要指定您正在使用哪种模式（强制性），请使用以下函数调用：</p>
<p>GPIO.setmode(GPIO.BOARD)# or</p>
<p>GPIO.setmode(GPIO.BCM)# or</p>
<p>GPIO.setmode(GPIO.CVM)# or</p>
<p>GPIO.setmode(GPIO.TEGRA_SOC)</p>
<p>要检查已设置的模式，可以调用：</p>
<p>mode &#x3D; GPIO.getmode()</p>
<p>该模式必须为GPIO.BOARD，GPIO.BCM，GPIO.CVM，GPIO.TEGRA_SOC或无。</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cynophile/article/details/99310678" title="Jetson Nano GPIO使用、四种模式以及串口解释">Jetson Nano<br>GPIO使用、四种模式以及串口解释</a></p>
<h5 id="3-警告"><a href="#3-警告" class="headerlink" title="3.警告"></a>3.警告</h5><p>您尝试使用的GPIO可能已在当前应用程序外部使用。在这种情况下，如果使用的GPIO配置为除默认方向（输入）以外的任何值，Jetson<br>GPIO库将向您发出警告。如果在设置模式和通道之前尝试清理，它也会警告您。要禁用警告，请使用：</p>
<p>GPIO.setwarnings(False)</p>
<h5 id="4-设置通道"><a href="#4-设置通道" class="headerlink" title="4.设置通道"></a>4.设置通道</h5><p>在用作输入或输出之前，必须先设置GPIO通道。要将通道配置为输入，请调用：</p>
<p>GPIO.setup(channel, GPIO.IN)</p>
<p>要将通道设置为输出，请调用：</p>
<p>GPIO.setup(channel, GPIO.OUT)</p>
<p>也可以为输出通道指定一个初始值：</p>
<p>GPIO.setup(channel, GPIO.OUT, initial&#x3D;GPIO.HIGH)</p>
<p>将一个通道设置为输出时，也可以一次设置多个通道：</p>
<p>channels &#x3D; [18, 12, 13]</p>
<p>GPIO.setup(channels, GPIO.OUT)</p>
<h5 id="5-输入"><a href="#5-输入" class="headerlink" title="5.输入"></a>5.输入</h5><p>要读取通道的值，请使用：</p>
<p>GPIO.input(channel)</p>
<p>这将返回GPIO.LOW或GPIO.HIGH。</p>
<h5 id="6-输出"><a href="#6-输出" class="headerlink" title="6.输出"></a>6.输出</h5><p>要设置配置为输出的引脚的值，请使用：</p>
<p>GPIO.output(channel, state)</p>
<p>状态可以是GPIO.LOW或GPIO.HIGH。</p>
<p>您还可以输出到频道列表或元组：</p>
<p>channels &#x3D; [18, 12, 13] # or use tuples</p>
<p>GPIO.output(channels, GPIO.HIGH) # or GPIO.LOW</p>
<h6 id="set-first-channel-to-HIGH-and-rest-to-LOW"><a href="#set-first-channel-to-HIGH-and-rest-to-LOW" class="headerlink" title="set first channel to HIGH and rest to LOW"></a>set first channel to HIGH and rest to LOW</h6><p>GPIO.output(channel, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH))</p>
<h5 id="7-清理"><a href="#7-清理" class="headerlink" title="7.清理"></a>7.清理</h5><p>在程序结束时，最好清理通道，以便将所有引脚设置为默认状态。要清理所有使用的通道，请使用：</p>
<p>GPIO.cleanup()</p>
<p>如果您不想清除所有通道，也可以清除单个通道或通道列表或元组：</p>
<p>GPIO.cleanup(chan1) # cleanup only chan1</p>
<p>GPIO.cleanup([chan1, chan2]) # cleanup only chan1 and chan2</p>
<p>GPIO.cleanup((chan1, chan2)) # does the same operation as previous statement</p>
<h5 id="8-jetson模块信息和库版本"><a href="#8-jetson模块信息和库版本" class="headerlink" title="8.jetson模块信息和库版本"></a>8.jetson模块信息和库版本</h5><p>要获取有关Jetson模块的信息，请使用&#x2F;阅读：</p>
<p>GPIO.JETSON_INFO</p>
<p>这为Python字典提供了以下键：P1_REVISION，RAM，REVISION，TYPE，MANUFACTURER和PROCESSOR。字典中的所有值都是字符串，但P1_REVISION是整数。</p>
<p>要获取有关库版本的信息，请使用&#x2F;阅读：</p>
<p>GPIO.VERSION</p>
<p>这提供了XYZ版本格式的字符串。</p>
<h5 id="9-中断"><a href="#9-中断" class="headerlink" title="9.中断"></a>9.中断</h5><p>除了繁忙的轮询外，该库还提供了三种监视输入事件的方法：</p>
<h6 id="wait-for-edge（）函数"><a href="#wait-for-edge（）函数" class="headerlink" title="wait_for_edge（）函数"></a>wait_for_edge（）函数</h6><p>该函数阻塞调用线程，直到检测到提供的边缘为止。该函数可以如下调用：</p>
<p>GPIO.wait_for_edge(channel, GPIO.RISING)</p>
<p>第二个参数指定要检测的边缘，可以是GPIO.RISING，GPIO.FALLING或GPIO.BOTH。如果只想将等待时间限制为指定的时间，则可以选择设置超时：</p>
<h6 id="timeout-is-in-milliseconds"><a href="#timeout-is-in-milliseconds" class="headerlink" title="timeout is in milliseconds"></a>timeout is in milliseconds</h6><p>GPIO.wait_for_edge(channel, GPIO.RISING, timeout&#x3D;500)</p>
<p>该函数返回检测到边缘的通道；如果发生超时，则返回无。</p>
<h6 id="event-detected（）函数"><a href="#event-detected（）函数" class="headerlink" title="event_detected（）函数"></a>event_detected（）函数</h6><p>此功能可用于定期检查自上次通话以来是否发生了事件。该函数可以如下设置和调用：</p>
<h6 id="set-rising-edge-detection-on-the-channel"><a href="#set-rising-edge-detection-on-the-channel" class="headerlink" title="set rising edge detection on the channel"></a>set rising edge detection on the channel</h6><p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>run_other_code()</p>
<p>if GPIO.event_detected(channel):</p>
<p>do_something()</p>
<p>和以前一样，您可以检测GPIO.RISING，GPIO.FALLING或GPIO.BOTH的事件。</p>
<h6 id="当检测到边缘时运行回调函数"><a href="#当检测到边缘时运行回调函数" class="headerlink" title="当检测到边缘时运行回调函数"></a>当检测到边缘时运行回调函数</h6><p>此功能可用于为回调函数运行第二个线程。因此，响应边缘，回调函数可以与主程序并发运行。可以按以下方式使用此功能：</p>
<h6 id="define-callback-function"><a href="#define-callback-function" class="headerlink" title="define callback function"></a>define callback function</h6><p>def callback_fn(channel):</p>
<p>print(“Callback called from channel %s” % channel)</p>
<h6 id="add-rising-edge-detection"><a href="#add-rising-edge-detection" class="headerlink" title="add rising edge detection"></a>add rising edge detection</h6><p>GPIO.add_event_detect(channel, GPIO.RISING, callback&#x3D;callback_fn)</p>
<p>如果需要，还可以添加多个回调：</p>
<p>def callback_one(channel):</p>
<p>print(“First Callback”)</p>
<p>def callback_two(channel):</p>
<p>print(“Second Callback”)</p>
<p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>GPIO.add_event_callback(channel, callback_one)</p>
<p>GPIO.add_event_callback(channel, callback_two)</p>
<p>在这种情况下，这两个回调是顺序运行的，而不是同时运行，因为只有线程运行所有回调函数。</p>
<p>为了通过将多个事件折叠为一个事件来防止多次调用回调函数，可以选择设置反跳时间：</p>
<h6 id="bouncetime-set-in-milliseconds"><a href="#bouncetime-set-in-milliseconds" class="headerlink" title="bouncetime set in milliseconds"></a>bouncetime set in milliseconds</h6><p>GPIO.add_event_detect(channel, GPIO.RISING,<br>callback&#x3D;callback_fn,bouncetime&#x3D;200)</p>
<p>如果不再需要边缘检测，可以按以下步骤将其删除：</p>
<p>GPIO.remove_event_detect(channel)</p>
<h5 id="10-检查GPIO通道的功能"><a href="#10-检查GPIO通道的功能" class="headerlink" title="10.检查GPIO通道的功能"></a>10.检查GPIO通道的功能</h5><p>此功能使您可以检查提供的GPIO通道的功能：</p>
<p>GPIO.gpio_function(channel)</p>
<p>该函数返回GPIO.IN或GPIO.OUT。</p>
<h5 id="11-PWM"><a href="#11-PWM" class="headerlink" title="11. PWM"></a>11. PWM</h5><p>请参阅samples&#x2F;simple_pwm.py有关如何使用PWM通道的详细信息。</p>
<p>Jetson.GPIO库仅在附带硬件PWM控制器的引脚上支持PWM。与RPi.GPIO库不同，Jetson.GPIO库不实现软件仿真的PWM。Jetson<br>Nano支持2个PWM通道，而Jetson AGX Xavier支持3个PWM通道。Jetson TX1和TX2不支持任何PWM通道。</p>
<p>系统引脚复用器必须配置为将硬件PWM控制器连接到相关引脚。如果未配置pinmux，则PWM信号将不会到达引脚！Jetson.GPIO库不会动态修改pinmux配置来实现此目的。阅读L4T文档以获取有关如何配置pinmux的详细信息</p>
<p>完整英文版说明见: <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio">https://github.com/NVIDIA/jetson-gpio</a></p>
<h2 id="五-串口通信"><a href="#五-串口通信" class="headerlink" title="五.串口通信"></a>五.串口通信</h2><h5 id="UART"><a href="#UART" class="headerlink" title="&lt;1&gt;UART"></a>&lt;1&gt;UART</h5><h6 id="1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code"><a href="#1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code" class="headerlink" title="1.python代码 ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code"></a><strong>1.python代码</strong> ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code</h6><p>(github.com)](<a target="_blank" rel="noopener" href="https://github.com/JetsonHacksNano/UARTDemo">https://github.com/JetsonHacksNano/UARTDemo</a><br>“JetsonHacksNano&#x2F;UARTDemo: UART Demo Code (github.com)“)</p>
<p>jetson nano的串口的TXD和RXD引脚分别对应物理引脚8,10</p>
<p>开启串口权限，注意这个权限关机后就也被关闭，下次需要重新开启</p>
<pre><code>sudo chmod 777 /dev/ttyTHS1
</code></pre>
<p>如果要永久打开，可参考：<a target="_blank" rel="noopener" href="https://codeleading.com/article/76115811693/" title="永久修改jetson
nano上电启动串口权限">永久修改jetson<br>nano上电启动串口权限</a></p>
<h5 id="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"><a href="#注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点" class="headerlink" title="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"></a>注意事项：<strong>如果使用USB转TTL模块电脑和nano进行通信注意一下几点</strong></h5><pre><code>    1.杜邦线不可太长，太长会乱码

    2.出现只能收不能发的情况是电压不足导致的，把usb转ttl模块的5V口和nano的5V进行连接

    3.如果线合理，但出现乱码，波特率、奇偶校验、停止位检查是否一致

    4.其它情况：[串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据](https://blog.csdn.net/lxj362343/article/details/89646731 &quot;串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据&quot;)
</code></pre>
<h6 id="2-C-代码：-Uart-c-class-for-Nvidia-Jetson"><a href="#2-C-代码：-Uart-c-class-for-Nvidia-Jetson" class="headerlink" title="2.C++代码：[Uart c++ class for Nvidia Jetson"></a>2.C++代码：[Uart c++ class for Nvidia Jetson</h6><p>Nano](<a target="_blank" rel="noopener" href="https://github.com/MathieuBahin/JetsonNanoUart/tree/master">https://github.com/MathieuBahin/JetsonNanoUart/tree/master</a> “Uart c++<br>class for Nvidia Jetson Nano”)</p>
<p>在四中的C++版GPIO库中并未包括uart相关内容，但是利用jetson nano设备中的</p>
<pre><code>/dev/ttyTHS1
</code></pre>
<p>进行系统调用，可实现串口通信。</p>
<p>但github上的C++ uart代码比较复杂，且只适用于特点场景，笔者修改了部分内容如下：</p>
<pre><code>//uart.h
#ifndef _UART_H
#define _UART_H


// Define Constants
const char *uart_target = &quot;/dev/ttyTHS1&quot;;
#define     NSERIAL_CHAR   256
#define     VMINX          1
#define     BAUDRATE       B115200


class Uart &#123;
private:
  /* data */
  int fid;
public:
  char serial_message[NSERIAL_CHAR];


  Uart ();
  void sendUart(char *msg);
  void readUart();
  void closeUart();

&#125;;
#endif



/************************************/
/* @auteur Mathieu Bahin            */
/* @date_création mars 2020         */
/* @version 1.0                     */
/* @email bahin.mathieu@gmail.com   */
/************************************/

#include &quot;uart.h&quot;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;       // Used for UART
#include &lt;sys/fcntl.h&gt;    // Used for UART
#include &lt;termios.h&gt;      // Used for UART
#include &lt;string.h&gt;

using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;

  // SETUP SERIAL WORLD

  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port


  //------------------------------------------------
  //  OPEN THE UART
  //------------------------------------------------
  // The flags (defined in fcntl.h):
  //	Access modes (use 1 of these):
  //		O_RDONLY - Open for reading only.
  //		O_RDWR   - Open for reading and writing.
  //		O_WRONLY - Open for writing only.
  //	    O_NDELAY / O_NONBLOCK (same function)
  //               - Enables nonblocking mode. When set read requests on the file can return immediately with a failure status
  //                 if there is no input immediately available (instead of blocking). Likewise, write requests can also return
  //				   immediately with a failure status if the output can&#39;t be written immediately.
  //                 Caution: VMIN and VTIME flags are ignored if O_NONBLOCK flag is set.
  //	    O_NOCTTY - When set and path identifies a terminal device, open() shall not cause the terminal device to become the controlling terminal for the process.fid = open(&quot;/dev/ttyTHS1&quot;, O_RDWR | O_NOCTTY | O_NDELAY);		//Open in non blocking read/write mode

  fid = open(uart_target, O_RDWR | O_NOCTTY );

  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);

  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;

  //------------------------------------------------
  // CONFIGURE THE UART
  //------------------------------------------------
  // flags defined in /usr/include/termios.h - see http://pubs.opengroup.org/onlinepubs/007908799/xsh/termios.h.html
  //	Baud rate:
  //         - B1200, B2400, B4800, B9600, B19200, B38400, B57600, B115200,
  //           B230400, B460800, B500000, B576000, B921600, B1000000, B1152000,
  //           B1500000, B2000000, B2500000, B3000000, B3500000, B4000000
  //	CSIZE: - CS5, CS6, CS7, CS8
  //	CLOCAL - Ignore modem status lines
  //	CREAD  - Enable receiver
  //	IGNPAR = Ignore characters with parity errors
  //	ICRNL  - Map CR to NL on input (Use for ASCII comms where you want to auto correct end of line characters - don&#39;t use for bianry comms!)
  //	PARENB - Parity enable
  //	PARODD - Odd parity (else even)

//*******************************begin::uart参数设置************************************
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

//********************************end::uart参数设置*************************************

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;

//*******************************begin::测试程序************************************
int main(int argc, char *argv[]) &#123;
  Uart u;
  int i;
  char m[256]=&quot;hello world!&quot;;
  u.sendUart(&quot;%s&quot;,&quot;hello world!\r\n&quot;);
  u.sendUart(m);
   
  while (1)
  &#123;
    u.readUart();
    if(strlen(u.serial_message)!=0)
    &#123;
      for(i=0;u.serial_message[i]!=&#39;$&#39;;i++)    //自定协议规定以$结尾
      &#123;
        printf(&quot;%c &quot;,u.serial_message[i]);
      &#125;
    &#125;
    printf(&quot;\n&quot;);    
  &#125;
  u.closeUart();

  return 0;
&#125;
//********************************end::测试程序*************************************
</code></pre>
<p><strong>其中删去了大部分不必要片段，并加入了Uart_Printf()函数，用法同printf()</strong></p>
<p>测试结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6af7567db40ef98ffaec08066206ca83.png"></p>
<p>&lt;2&gt;IIC</p>
<h2 id="六-在jetson-nano上使用OpenCV"><a href="#六-在jetson-nano上使用OpenCV" class="headerlink" title="六.在jetson nano上使用OpenCV"></a>六.在jetson nano上使用OpenCV</h2><p>&lt;1&gt;<strong>python打开摄像头：参考[通过OpenCV调用CSI和USB摄像头](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169070226116800188569163&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169070226116800188569163&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduend~default-2-123967404-null-<br>null.142%5Ev91%5Einsert_down28v1,239%5Ev12%5Econtrol2&amp;utm_term&#x3D;jetsonnano%E8%B0%83%E7%94%A8usb%E6%91%84%E5%83%8F%E5%A4%B4&amp;spm&#x3D;1018.2226.3001.4187<br>“通过OpenCV调用CSI和USB摄像头”)</strong></p>
<p><strong>C++打开，示例如下：</strong></p>
<pre><code>//适用于jetson nano上的模版
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/core.hpp&gt;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;opencv2/imgproc.hpp&gt;
#include &lt;opencv2/objdetect.hpp&gt;
#include &lt;opencv2/imgproc/types_c.h&gt;
#include &lt;opencv2/videoio.hpp&gt;

using namespace std;
using namespace cv;

string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
&#123;
    return &quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +
        to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +
        &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +
        to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;
&#125;

int main()
&#123;
    int capture_width = 1280;
    int capture_height = 720;
    int display_width = 1280;
    int display_height = 720;
    int framerate = 60;
    int flip_method = 0;

    //创建管道
    string pipeline = gstreamer_pipeline(capture_width,
        capture_height,
        display_width,
        display_height,
        framerate,
        flip_method);
    std::cout &lt;&lt; &quot;使用gstreamer管道: \n\t&quot; &lt;&lt; pipeline &lt;&lt; &quot;\n&quot;;

    //管道与视频流绑定
    VideoCapture cap(pipeline, CAP_GSTREAMER);

    //创建显示窗口
    namedWindow(&quot;CSI Camera&quot;, WINDOW_AUTOSIZE);
    Mat img;

    //逐帧显示
    while (true)
    &#123;
        cap.read(img);
        imshow(&quot;CSI Camera&quot;, img);

        if (waitKey(10) == 27)break;
    &#125;

    cap.release();
    destroyAllWindows();
&#125;
</code></pre>
<p>&lt;2&gt;使用官方自带的4.1.1版本OpenCV</p>
<p>自带的OpenCV文件夹在**&#x2F;usr&#x2F;share&#x2F;opencv4** 中，**~&#x2F;sample&#x2F;cpp  **内含众多示例代码</p>
<p>运行示例代码时使用g++编译，命令为：</p>
<pre><code>g++ name.cpp -o name `pkg-config --cflags --libs opencv4`
</code></pre>
<p>命令行输入如下命令即可运行：</p>
<pre><code>./name parameters
</code></pre>
<p>其中name为编写的程序名，parameters程序具体需要的参数</p>
<p>因为官方镜像所有的环境都是配好的，g++编译时加入<code>pkg-config --cflags --libs opencv4</code>就可运行。想要下载全新版本自己配置并了解其中的原理可以参考下面的资料</p>
<p>&lt;3&gt;自己配置其他版本OpenCV参考资料</p>
<p> 1.jetson nano上开发环境配置及使用QT(C++)或VsCode编写运行(Python)<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianbin3200896/article/details/103760640?spm=1001.2014.3001.5506#t6" title="Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）">Jetson Nano<br>从入门到实战（案例：Opencv配置、人脸检测、二维码检测）</a></p>
<p>2.使用CMake编译链接(C++)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43717839/article/details/128032486?spm=1001.2014.3001.5506" title="【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-CSDN博客">【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-<br>CSDN博客</a></p>
<p>3.使用g++命令(C++)</p>
<p>4.配置最新版或其他版本OpenCV：<a target="_blank" rel="noopener" href="https://blog.csdn.net/s15810751918/article/details/107705387?spm=1001.2014.3001.5506" title="linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-CSDN博客">linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47665864/article/details/128945476?spm=1001.2014.3001.5506" title="如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-CSDN博客">如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-<br>CSDN博客</a></p>
<h2 id="七-jetson-nano开机自启动程序"><a href="#七-jetson-nano开机自启动程序" class="headerlink" title="七.jetson nano开机自启动程序"></a>七.jetson nano开机自启动程序</h2><p>步骤：</p>
<p>1.打开文件：</p>
<pre><code>/usr/bin/yoyo.sh
</code></pre>
<p>2.写入命令（开机自动执行的命令），例如：</p>
<pre><code>cd /home/jetson/test/circle_control
./circle
</code></pre>
<p>注：终端路径转至&#x2F;home&#x2F;jetson&#x2F;test&#x2F;circle_control，执行.&#x2F;circle文件</p>
<p>3.终端执行:</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl enable start.service
sudo reboot
</code></pre>
<h2 id="八-实战程序"><a href="#八-实战程序" class="headerlink" title="八.实战程序"></a>八.实战程序</h2><h5 id="1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"><a href="#1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32" class="headerlink" title="1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"></a>1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</h5><pre><code>//*************circle.cpp**************
#include &quot;opencv2/opencv.hpp&quot;
#include &quot;opencv2/highgui.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;

//begin::uart部分************************************************************************
#include &quot;uart.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;unistd.h&gt;       // Used for UART
#include &lt;sys/fcntl.h&gt;    // Used for UART
#include &lt;termios.h&gt;      // Used for UART
#include &lt;string.h&gt;

using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;
  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port
  fid = open(uart_target, O_RDWR | O_NOCTTY );
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

int Uart :: fputc(int ch, FILE *f)
&#123;
	write(fid, &amp;ch, 1);
	return ch;
&#125;

void Uart :: Uart_Printf(char *format, ...)
&#123;
	char String[256];
	va_list arg;
	va_start(arg, format);
	vsprintf(String, format, arg);
	va_end(arg);
	sendUart(String);
&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;
//end::uart部分**************************************************************************

const char* windowname=&quot;win&quot;;
int max_r=100;
int min_r=60;
int min_d=80;
int t_hold=25;
int param1=100;
int param2=20;
const int t_max=255;
const int r_max=1000;
const int d_max=100;
const int p1_max=200;
const int p2_max=200;


int main()
&#123;
  VideoCapture capture(0);
  Mat image;
	Mat matCanny;
  Mat BinImg;
  Mat matDst;
  Uart u;

  void on_Trackbar_1(int, void*);
  void on_Trackbar_2(int, void*);
  void on_Trackbar_3(int, void*);
  void on_Trackbar_4(int, void*);
  void on_Trackbar_5(int, void*);
  void on_Trackbar_6(int, void*);
  namedWindow(windowname,0);
  setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);
  resizeWindow(windowname, 400, 300);
  moveWindow(windowname, 0, 0);
  createTrackbar(&quot;t_hold&quot;,windowname, &amp;t_hold, t_max, on_Trackbar_3);
  createTrackbar(&quot;max_r&quot;,windowname, &amp;max_r, r_max, on_Trackbar_1);
  createTrackbar(&quot;min_r&quot;,windowname, &amp;min_r, r_max, on_Trackbar_2);
  createTrackbar(&quot;min_d&quot;,windowname, &amp;min_d, d_max, on_Trackbar_6);
  createTrackbar(&quot;p_1&quot;,windowname, &amp;param1, p1_max, on_Trackbar_4);
  createTrackbar(&quot;p_2&quot;,windowname, &amp;param2, p2_max, on_Trackbar_5);

	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
    cvtColor(image, matDst, COLOR_BGR2GRAY);
		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV|THRESH_OTSU);
    Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
        
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

    printf(&quot;x:%d\ny:%d\n&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));
    u.Uart_Printf(&quot;#x%dy%d$&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));

    imshow(&quot;matCanny&quot;, matCanny);
    imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;

  u.closeUart();
  return 0;

&#125;

void on_Trackbar_1(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_2(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_3(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_4(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_5(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_6(int, void*)
&#123;
    ;
&#125;
</code></pre>
<p>使用说明：</p>
<p>使用前打开串口权限；程序使用usb摄像头；要将uart.h包含到该文件（circle.cpp）同目录下；</p>
<p>该目录下打开终端输入：<br>进行编译产生可执行文件</p>
<pre><code>g++ circle.cpp -o circle `pkg-config --cflags --libs opencv4`
</code></pre>
<p>该目录下打开终端输入：<br>即可运行</p>
<pre><code>./circle
</code></pre>
<p>注：霍夫圆检测不太稳定，会显示core出错，重启即可，也可以在启动时调节各个参数使稳定</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658">https://blog.csdn.net/qq_32971095/article/details/131511658</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（电源部分）——电赛学习笔记（1）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-29 15:26:49" itemprop="dateCreated datePublished" datetime="2023-06-29T15:26:49+08:00">2023-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（电源部分）——电赛学习笔记（1）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/06/29/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89%E2%80%94%E2%80%94%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>992</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="学习资料来源：B站唐老师讲电赛"><a href="#学习资料来源：B站唐老师讲电赛" class="headerlink" title="学习资料来源：B站唐老师讲电赛"></a><em><strong>学习资料来源：B站唐老师讲电赛</strong></em></h2><p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E7%BA%BF%E6%80%A7%E7%94%B5%E6%BA%90%EF%BC%88%E7%BA%BF%E6%80%A7%E7%A8%B3%E5%8E%8B%E5%99%A8LDO%EF%BC%89%EF%BC%9AVin%E3%80%81Vout%EF%BC%9B%E5%8E%8B%E5%B7%AE%EF%BC%88Vin-V%E5%B7%AE%3EVout%E6%97%B6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0%E3%80%81Ci%E3%80%81Co%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9%EF%BC%8C%E9%99%8D%E5%99%AA%EF%BC%89">一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作）<br>、Ci、Co（输入输出滤波电容，降噪）</a></p>
<p><a href="about:blank#1.%E5%8F%82%E6%95%B0%EF%BC%9AVi%EF%BC%8CVo%EF%BC%88%E5%8F%AF%E8%B0%83%EF%BC%8C%E7%94%B5%E9%98%BB%E5%88%86%E5%8E%8B%EF%BC%89%EF%BC%8C%E5%8E%8B%E9%99%8D%EF%BC%8C%E8%BE%93%E5%87%BA%E7%94%B5%E6%B5%81Io%EF%BC%88max%EF%BC%89%EF%BC%8C%EF%BC%88%E5%99%AA%E5%A3%B0%EF%BC%8C%E9%9D%99%E6%80%81%E7%94%B5%E6%B5%81Iq%EF%BC%8C%E6%95%88%E7%8E%87%3DVo%2FVi%EF%BC%8C%E8%80%97%E6%95%A3%E5%8A%9F%E7%8E%87%3Dv%E5%B7%AE*Iload%EF%BC%89">1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*Iload）</a></p>
<p><a href="about:blank#2.PCB">        2.PCB</a></p>
<p><a href="about:blank#%C2%A0%E4%BA%8C.%E7%94%B5%E5%AE%B9%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E7%94%B5%E8%8D%B7%E6%B3%B5%EF%BC%89"><br>二.电容式开关电源（电荷泵）</a></p>
<p><a href="about:blank#1%C2%B7%E7%A8%B3%E5%8E%8B%E5%9E%8B%E7%94%B5%E8%8D%B7%E6%B3%B5%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%88%E9%A3%9E%E8%B7%A8%E7%94%B5%E5%AE%B9%EF%BC%8CS1%E3%80%81S3%2FS2%E3%80%81S4%E5%88%87%E6%8D%A2%E5%BC%80%E5%85%B3%EF%BC%8CC1%E5%85%85%E6%94%BE%E7%94%B5%EF%BC%89%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B4%9F%E5%8E%8B">1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）​编辑<br>负压</a></p>
<p><a href="about:blank#PCB%EF%BC%9A">PCB：</a></p>
<p><a href="about:blank#%E4%B8%89.%E7%94%B5%E6%84%9F%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E5%8F%82%E6%95%B0%EF%BC%9AVI%EF%BC%9BV0%EF%BC%9BIO%EF%BC%9B%E5%BC%80%E5%85%B3%E8%AF%84%E7%8E%87Fsw%EF%BC%9BEN%EF%BC%9BFB%EF%BC%89">三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</a></p>
<p><a href="about:blank#*%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B%EF%BC%9A">*设计实例：</a></p>
<p><a href="about:blank#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">解决方案：</a></p>
<hr>
<h2 id><a href="#" class="headerlink" title></a></h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d33cf8d47d4d2de8371c40cc43edf710.png"></p>
<h2 id="一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）"><a href="#一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）" class="headerlink" title="一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）"></a>一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）</h2><p>常用：LM1117</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7603ed872f9f27c253be1de796edc562.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/32f005e1cec50c5099ca1201cacda1cb.png"></p>
<p>（模电达林顿管）</p>
<h3 id="1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）"><a href="#1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）" class="headerlink" title="1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I load ）"></a>1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I <em>load</em> ）</h3><p>建立元件参数表</p>
<p>线性电源无法并联扩流</p>
<h4 id="2-PCB"><a href="#2-PCB" class="headerlink" title="2.PCB"></a>2.PCB</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/516abda141133974961903290093a41b.png"></p>
<p>PCB例子：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1e1e1ee1439d5fa0b8dc96cc70d84a13.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/d4a91d9caca72e80e2bb1c0717d16977.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb3f95733581716c40d244efdb00fbb5.png">散热面积大，VCC连GND先过C</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a094e2dea7328ad1cc700b48f97748b4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7b1902e953d9978de38505d24f1141f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6edd9ed81123ce89e76fcd672972982.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae73145b8a1e4c2a6707fbf38c1d0486.png"></p>
<h2 id="二-电容式开关电源（电荷泵）"><a href="#二-电容式开关电源（电荷泵）" class="headerlink" title="二.电容式开关电源（电荷泵）"></a>二.电容式开关电源（电荷泵）</h2><p>常用：HX4002（2.7~5.5-&gt;5）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c570bfe596d08bd80536caa7bc3996b7.png"></p>
<h3 id="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）"><a href="#1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）" class="headerlink" title="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）"></a>1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e956f406406b2a825f0b7d7c9b99a6.png"><br>负压</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/203446207be2fbe6c344b483e902a9e9.png"></p>
<p>半压（两跨容，串联充电，并联充电）、倍压反之</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3c11d9321a69b002cc2346187f8b3f9.png"></p>
<p>ESR（等效串联电阻）；为防电流过大，跨容选2倍手册推荐大小；</p>
<p>减小纹波：加大跨容&#x2F;减小ESR；ESR：MLCC&lt;钽&lt;固态&lt;高频低阻电解&lt;电解</p>
<h3 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a62028779584be27bedc9a881cf1b0af.png"></p>
<p>2.稳压型（加入稳压模块）</p>
<h2 id="三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"><a href="#三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）" class="headerlink" title="三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"></a>三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cccdb639def67c103b72fc6c89d6bfbe.png"></p>
<p>1.开关关充电，开L&#x2F;C双供电</p>
<p>二极管续流（肖特基&#x2F;快恢复，损耗：导通压*电流）<img src="https://i-blog.csdnimg.cn/blog_migrate/01519524c2764e4bb98ef2d0d4a94422.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2abc250f6c37683f7865759f76cd83e7.png"></p>
<p> 改成负压输出的改造（接地端与原输出端互换）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d21361e0b91acac3643071203b9c022.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df20a2e55b8792485d63db18ccf2a9e6.png"></p>
<p>  例：SY8120I稳压芯片结构<br><img src="https://i-blog.csdnimg.cn/blog_migrate/28a2114b9b75501ad4ca1dd053b2eddd.png"></p>
<p>FB接内部误差放大器反相输入端，正向端接0.6V参考，根据RH&#x2F;RL得Vo</p>
<h3 id="设计实例："><a href="#设计实例：" class="headerlink" title="*设计实例："></a>*设计实例：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/284bbac4e893f0274aa71c622f768211.png"></p>
<p> 注：内部电磁干扰问题（EMI），造成高频振铃信号</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/35d73073e335edcb4b1485cfe40bd770.png"></p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/580b343296343253de0d82c49beb967e.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697">https://blog.csdn.net/qq_32971095/article/details/131397697</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">FreeRTOS学习笔记（一）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-24 20:18:51" itemprop="dateCreated datePublished" datetime="2023-04-24T20:18:51+08:00">2023-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="FreeRTOS学习笔记（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/04/24/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><strong>FreeRTOS学习笔记</strong></strong></p>
<p><strong><strong>第一天摘要：</strong></strong></p>
<p>Key：</p>
<p>移植方法，TCB的结构及创建,任务栈，列表和列表项定义及相关函数</p>
<p>实践：rtos移植执行led闪烁</p>
<p>注意点：keil下载device要正确；内存不够删去不需要的heap.c及其他内 核等多余文件（MemMang,RVDS）</p>
<p>代码风格：</p>
<p>FreeRTOS 中详细的数据类型重定义在 portmacro.h 这个头文件中实现，具体 如下</p>
<p>1.2.4.2 变量名 在 FreeRTOS 中，定义变量的时候往往会把变量的类型当作前缀加在变量上，<br>这样的好处是让用户一看到这个变量就知道该变量的类型。比如 char 型变量的 10 前缀是 c，short 型变量的前缀是 s，long 型变量的前缀是<br>l，portBASE_TYPE 类 型变量的前缀是 x。还有其他的数据类型，比如数据结构，任务句柄，队列句柄 等定义的变量名的前缀也是 x。<br>如果一个变量是无符号型的那么会有一个前缀 u，如果是一个指针变量则会 有一个前缀 p。因此，当我们定义一个无符号的 char 型变量的时候会加一个 uc<br>前缀，当定义一个 char 型的指针变量的时候会有一个 pc 前缀。 1.2.4.3 函数名<br>函数名包含了函数返回值的类型、函数所在的文件名和函数的功能，如果是 私有的函数则会加一个 prv（private）的前缀。特别的，在函数名中加入了函<br>数所在的文件名，这极大的帮助了用户提高寻找函数定义的效率和了解函数作用 的目的，具体的举例如下： ①vTaskPrioritySet()函数的返回值为<br>void 型，在 task.c 这个文件中定 义。 ②xQueueReceive()函数的返回值为 portBASE_TYPE 型，在 queue.c 这个<br>文件中定义。 ③vSemaphoreCreateBinary()函数的返回值为 void 型，在 semphr.h 这个 文件中定义。</p>
<p><strong><strong>移植：</strong></strong></p>
<p>FreeRTOSConfig.h 是直接从 demo 文件夹下面拷贝过来的，该头文件对裁 剪整个 FreeRTOS<br>所需的功能的宏均做了定义，有些宏定义被使能，有些宏定义 被失能，一开始我们只需要配置最简单的功能即可。要想随心所欲的配置 FreeRTOS<br>的功能，我们必须对这些宏定义的功能有所掌握，下面我们先简单的 介绍下这些宏定义的含义，然后再对这些宏定义进行修改。 注意：此<br>FreeRTOSConfig.h 文件内容与我们从 demo 移植过来的 FreeRTOSConfig.h 文件不一样，因为这是我们修改过的<br>FreeRTOSConfig.h 文 件，并不会影响 FreeRTOS 的功能，我们只是添加了一些中文注释，并且把相关<br>的头文件进行分类，方便查找宏定义以及阅读，仅此而已。强烈建议使用我们修 加工过的 FreeRTOSConfig.h 文件。若你在移植时直接使用我们工程中<br>FreeRTOSConfig.h 文件，编译会出现报错，因为里面 PendSV_Handler 和 SVC_Handler 函数重定义，需在<br>stm32f10x_it.c 文件中注释掉这两个函数方可， 后面会有讲解，此处先略过</p>
<p>还需要注意的是：中断优先级 0（具有最高的逻辑优先级）不能被 basepri<br>寄存器屏蔽，因此，configMAX_SYSCALL_INTERRUPT_PRIORITY 绝不可以设置成 0。</p>
<p>修改 stm32f10x_it.c 文件 SysTick 中断服务函数是一个非常重要的函数，FreeRTOS 所有跟时间相关的<br>事情都在里面处理，SysTick 就是 FreeRTOS 的一个心跳时钟，驱动着 FreeRTOS 的运行</p>
<p>FreeRTOS 帮 我们实现了 SysTick 的启动的配置：在 port.c 文件中已经实现<br>vPortSetupTimerInterrupt()函数，并且 FreeRTOS 通用的 SysTick 中断服务 函数也实现了：在 port.c<br>文件中已经实现 xPortSysTickHandler()函数，所以 移植的时候只需要我们在 stm32f10x_it.c<br>文件中实现我们对应（STM32）平台 上的 SysTick_Handler()函数即可</p>
<p><strong><strong>延时函数实现：</strong></strong></p>
<p>&#x2F;&#x2F;reload 为 24 位寄存器,最大 值:16777216,在 72M 下,约合 0.233s 左右</p>
<p>void delay_us(u32 nus) {</p>
<p>u32 ticks;</p>
<p> u32 told,tnow,tcnt&#x3D;0;</p>
<p>u32 reload&#x3D;SysTick-&gt;LOAD; &#x2F;&#x2F;LOAD 的值</p>
<p>ticks&#x3D;nus*fac_us; &#x2F;&#x2F;需要的节拍数</p>
<p>told&#x3D;SysTick-&gt;VAL; &#x2F;&#x2F;刚进入时的计数器值</p>
<p>while(1) {</p>
<p>tnow&#x3D;SysTick-&gt;VAL;</p>
<p>if(tnow!&#x3D;told) {</p>
<p>if(tnow&lt;told)tcnt+&#x3D;told-tnow; &#x2F;&#x2F;这里注意一下 SYSTICK 是一个递 减的计数器就可以了.</p>
<p>else tcnt+&#x3D;reload-tnow+told;</p>
<p>told&#x3D;tnow;</p>
<p>if(tcnt&gt;&#x3D;ticks)break; &#x2F;&#x2F;时间超过&#x2F;等于要延迟的时间,则 退出. } }; }</p>
<p>delay_us()是 us 级延时函数，delay_ms 和 delay_xms()都是 ms 级的延 时函数，delay_us()和<br>delay_xms()不会导致任务切换。delay_ms()其实就是对 FreeRTOS 中的延时函数 vTaskDelay()的简单封装，所以在使用<br>delay_ms()的 时候就会导致任务切换</p>
<p>任务栈其实就是一个预先定义好的全局数组，数据类型为 StackType_t，大小由 TASK1_STACK_SIZE 这个宏来定义，默认为 128，单位为<br>字，即 512 字节，这也是 FreeRTOS 推荐的最小的任务栈。在 FreeRTOS 中， 凡是涉及到数据类型的地方，FreeRTOS 都会将标准的 C<br>数据类型用 typedef 重新取一个类型名。这些经过重定义的数据类型放在 portmacro.h 这个头文件。</p>
<p>正如我们所说的那样，任务是一个独立的、无限循环且不能返回的函数</p>
<p><strong><strong>3.2.3 定义任务控制块</strong></strong><strong><strong>：</strong></strong></p>
<p>typedef struct tskTaskControlBlock {</p>
<p>volatile StackType_t <em>pxTopOfStack; &#x2F;</em> 栈顶 *&#x2F; (1)</p>
<p>ListItem_t xStateListItem; &#x2F;* 任务节点 *&#x2F; (2)</p>
<p>StackType_t <em>pxStack; &#x2F;</em> 任务栈起始地址 *&#x2F; (3)</p>
<p>&#x2F;* 任务名称，字符串形式 *&#x2F;(4)</p>
<p>char pcTaskName[ configMAX_TASK_NAME_LEN ];</p>
<p>} tskTCB; typedef</p>
<p><strong><strong>3.2.4 列表和列表项</strong></strong>  :</p>
<p>要想看懂 FreeRTOS 源码并学习其原理，有一个东西需要理解，那就是 FreeRTOS 的列表和列表项。列表和列表项是 FreeRTOS<br>的一个数据结构， FreeRTOS 大量使用到了列表和列表项，它是 FreeRTOS 的基石。要想深入学习 并理解<br>FreeRTOS，那么列表和列表项就必须首先掌握，否则后面根本就没法进 行</p>
<p>列表项就是存放在列表中的项目，FreeRTOS 提供了两种列表项：列表项和 迷你列表项。这两个都在文件 list.h 中有定义</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18f990da82a5f9f6eb5a94ff344eb171.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/0de18e0f75c2b0b544e7ae7f4a1ed981.png"></p>
<p>3.2.4.2.1 列表初始化 新创建或者定义的列表需要对其做初始化处理，列表的初始化其实就是初始 化列表结构体 List_t<br>中的各个成员变量，列表的初始化通过函数 vListInitialise()来完成，此函数在 list.c 中有定义（<strong><strong>P58</strong></strong> ）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/76ca02bd0d186b50e841cd1a219d975d.png"></p>
<p>3.2.4.3.1 列表项插入函数 列表项的插入操作通过函数 vListInsert()来完成，函数原型如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be08fad541f38dea7f1d9a44896cd77f.png"></p>
<p>通过图可以看出，列表是一个环形的，即环形列表</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2048995ef80bb90a1f07f009b28c3884.png"></p>
<p>vListInsertEnd()插入列表的顺序问题（<strong><strong>P66</strong></strong> ）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/300cd190948f1391a19e5ae37f8638bd.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b7d15078dd210766f248d74c83c7ffd.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/130351060">https://blog.csdn.net/qq_32971095/article/details/130351060</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python爬虫学习笔记</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-17 22:22:06" itemprop="dateCreated datePublished" datetime="2023-03-17T22:22:06+08:00">2023-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="python爬虫学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/03/17/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注释给了一些要点</p>
<p>用requests库爬取时网页可能加载不完整，故用selenium库，加sleep延时使加载充分</p>
<p>主要利用re库，利用正则表达式提取html文件中的信息</p>
<p>threading是多线程运行，节省时间</p>
<p>如何使用？</p>
<pre><code>    配置selenium库，下载chomedriver，网上有教程

    更改range函数的范围就可以对该范围内用户信息爬取
</code></pre>
<p>存在问题：</p>
<pre><code>    太慢

    不稳定，会漏用户，测试中        

    用正则表达式麻烦
</code></pre>
<p>改进：</p>
<pre><code>    学习xpath、scrapy爬虫框架、线程池等


from selenium import webdriver
import re
import time
import threading

def blbl_uid_get(uid):

    url=&quot;https://space.bilibili.com/&quot;+str(uid)
    
    # 不开网页显示
    option = webdriver.ChromeOptions()
    option.add_argument(&quot;headless&quot;)

    # 使用selenium模块得到网页完整源码
    driver=webdriver.Chrome(chrome_options=option)
    driver.get(url) 
    respond=driver.page_source
    time.sleep(8)

    # 网页内容爬取测试
    # with open(&quot;blbl.html&quot;,&quot;wb+&quot;) as f:
    #     f.write(respond.encode())

    up_name=re.findall(r&#39;&lt;span id=&quot;h-name&quot;&gt;\s*(.*?)\s*&lt;/span&gt;&#39;,respond,re.S)
    up_fans=re.findall(r&#39;&lt;p id=&quot;n-fs&quot; class=&quot;n-data-v space-fans&quot;&gt;\s*(.*?)\s*&lt;/p&gt;&#39;,respond,re.S)
    # 网页还是缺失了部分信息如下
    # zan_num=re.findall(r&#39;视频、动态、专栏累计获赞([^&quot;]*)&#39;,respond,re.S)
    # watch_num=re.findall(r&#39;截止昨天，播放数总计为([^&quot;]*)&#39;,respond,re.S)
    # read_num=re.findall(r&#39;截止昨天，阅读数总计为([^&quot;]*)&#39;,respond,re.S)
    if len(up_fans)!=0 and len(up_name)!=0:
        # 摘取要寻找的信息
        record=&quot;&quot;
        record=up_name[0]+&quot; &quot;+up_fans[0]+&#39;\n&#39;# +&quot; &quot;+zan_num[0]+&quot; &quot;+watch_num[0]+&quot; &quot;+read_num[0]
        # 写入文件
        with open(&quot;up_fans.txt&quot;,&quot;a+&quot;) as f:
            f.write(record)
            f.close()

    # 一定要quit
    driver.quit()

# 并发执行爬虫
for i in range(348651384,348651400):
    t = threading.Thread(target=blbl_uid_get, args=(i,))
    t.start()
</code></pre>
<p>结果：</p>
<p>70975784467_bili 0<br>chnksxf 0<br>深蓝色五角枫 8<br>-SWQ- 27<br>w773727 0<br>If-There-If 2<br>bili75588510448 0<br>u723510 1<br>o206413 0<br>10292619012_bili 1<br>丶帝丶弑 0<br>t252791 0<br>why13643485777 0<br>丁嘉丽12334 0<br>80204814302_bili 0<br>ddzn17ZXZ 1</p>
<p>结论：显然，-SWQ-在一定范围内粉丝最多</p>
<p>2023年3月20日21:40:43更新</p>
<p>学习了xpath语言，利用lxml库，可以代替re正则表达式</p>
<p>相比正则表达式，xpath更加简单简洁！</p>
<p>注意tree的两种创建方式的不同：本地文件和网络请求</p>
<p>使用xpath要注重标签之间的结构！找好属性即其值，尽量缩小范围，不然很容易多得！</p>
<pre><code>from selenium import webdriver
import time
import threading
from lxml import etree

def blbl_uid_get(uid):

    url=&quot;https://space.bilibili.com/&quot;+str(uid)
    
    # 不开网页显示
    option = webdriver.ChromeOptions()
    option.add_argument(&quot;headless&quot;)

    # 使用selenium模块得到网页完整源码
    driver=webdriver.Chrome(chrome_options=option)
    driver.get(url) 
    time.sleep(2)
    respond=driver.page_source
    with open(&quot;blbl_xpath.html&quot;,&quot;wb&quot;) as f:
        f.write(respond.encode())

    # 利用xpath提取内容(本地调用方式！)
    # paser=etree.HTMLParser(encoding=&#39;utf-8&#39;)
    # tree=etree.parse(&#39;blbl_xpath.html&#39;,parser=paser)

    # 利用xpath提取内容(互联网中响应)
    tree=etree.HTML(respond)

    up_name=tree.xpath(&#39;//div[@class=&quot;h-basic&quot;]//span[@id=&quot;h-name&quot;]/text()&#39;)
    fans_num=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-fs&quot;]/text()&#39;)[0].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)
    # statistics=tree.xpath(&#39;//div[@class=&quot;n-statistics&quot;]//p[@id=&quot;n-bf&quot;]/text()&#39;)
    work_title=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//a[@class=&quot;title&quot;]/text()&#39;)
    work_length=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;length&quot;]/text()&#39;)
    work_play=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;play&quot;]/text()&#39;)
    work_time=tree.xpath(&#39;//div[@class=&quot;content clearfix&quot;]//span[@class=&quot;time&quot;]/text()&#39;)
    min_num=min(len(work_time),len(work_length),len(work_title),len(work_play))

    # 摘取要寻找的信息
    record=&quot;&quot;
    record=&quot;up昵称:&quot;+up_name[0]+&quot;\n&quot;+&quot;粉丝数:&quot;+fans_num+&#39;\n&#39;
    if(min_num!=0):
        record+=&#39;代表作:&#39;+&#39;\n&#39;
        for i in range(0,min_num):
            record+=&quot;作品名:&quot;+work_title[i]+&quot;\n&quot;+&quot;时长:&quot;+work_length[i]+&quot;\n&quot;+&quot;播放量:&quot;+work_play[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)+&quot;\n&quot;+&quot;发布时间:&quot;+work_time[i].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)
    record+=&#39;\n\n&#39;

    # 写入文件
    with open(&quot;blbl_xpath_2.txt&quot;,&quot;w+&quot;,encoding=&#39;utf-8&#39;) as f:
        f.write(record)
        f.close()

    
    # 一定要quit
    driver.quit()

# 并发执行爬虫
for i in range(348651375,348651390):
    t = threading.Thread(target=blbl_uid_get, args=(i,))
    t.start()
</code></pre>
<p>结果如下：</p>
<p>up昵称:68228791709_bili<br>粉丝数:0</p>
<p>up昵称:-SWQ-<br>粉丝数:27<br>代表作:<br>作品名:《刺客信条》6分49秒极限攀爬，同步率1000%<br>时长:04:18<br>播放量:164<br>发布时间:2022-3-20作品名:《消逝的光芒》对断桥、云端的向往以及信仰之跃<br>时长:09:35<br>播放量:419<br>发布时间:2022-2-1作品名:《生化危机2重制版》克莱尔打光弹药后手刃威廉G4<br>时长:12:14<br>播放量:310<br>发布时间:2022-2-1作品名:在西电中秋快乐的一天<br>时长:07:07<br>播放量:166<br>发布时间:2021-9-22作品名:4年菜鸡唯一一次五杀<br>时长:00:52<br>播放量:158<br>发布时间:2021-9-10作品名:沙雕室友们的日常<br>时长:00:21<br>播放量:51<br>发布时间:2020-8-22作品名:2020班级元旦晚会快来康康<br>时长:03:03<br>播放量:109<br>发布时间:2020-1-12作品名:社会我祥哥，同学冒死拍班主任<br>时长:00:13<br>播放量:114<br>发布时间:2019-8-19作品名:【建筑模型】建模锦标赛中华庭院模型展示<br>时长:02:39<br>播放量:2797<br>发布时间:2019-8-19</p>
<p>up昵称:p604904<br>粉丝数:0</p>
<p>up昵称:78992601564_bili<br>粉丝数:0</p>
<p>up昵称:10292619012_bili<br>粉丝数:1</p>
<p>up昵称:DMAP_<br>粉丝数:9<br>代表作:<br>作品名:拍拍猫猫<br>时长:02:03<br>播放量:89<br>发布时间:2022-11-29</p>
<p>up昵称:82212894921_bili<br>粉丝数:0</p>
<p>up昵称:bili75588510448<br>粉丝数:0</p>
<p>up昵称:丁嘉丽12334<br>粉丝数:0</p>
<p>up昵称:68228791709_bili<br>粉丝数:0</p>
<p>up昵称:80204814302_bili<br>粉丝数:0</p>
<p>up昵称:t229231<br>粉丝数:0</p>
<p>up昵称:chnksxf<br>粉丝数:0</p>
<p>up昵称:GH952105677<br>粉丝数:0</p>
<p>up昵称:52393731947_bili<br>粉丝数:0</p>
<p>up昵称:流口水的南方<br>粉丝数:0</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/129629331">https://blog.csdn.net/qq_32971095/article/details/129629331</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 20:37:02" itemprop="dateCreated datePublished" datetime="2022-05-01T20:37:02+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" class="post-meta-item leancloud_visitors" data-flag-title="位图图像文件缩放-西安电子科技大学大一程序基础设计课程设计作业" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/01/%E4%BD%8D%E5%9B%BE%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E7%BC%A9%E6%94%BE-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>问题描述：</li>
</ul>
<p>编写一个程序，可以在命令行输入参数，完成指定文件的缩放，并存储到新文件，命令行参数如下</p>
<p>zoom file1.bmp 200 file2.bmp</p>
<p>第一个参数为可执行程序名称，第二个参数为原始图像文件名，第三个参数为缩放比例（百分比），第四个参数为新文件名</p>
<ul>
<li>问题分析：</li>
</ul>
<ol>
<li>综述：</li>
</ol>
<p>要实现对bmp图像操作，首先要知道bmp图像的存储机理（图像信息如何以二进制信息存储）及文件包含的内容；其次知晓基本的图像缩放算法即可；最后要知晓如何读取和存储文件信息。</p>
<ol>
<li>实现时的困难：<br>1. 定义何种类型变量？<br>2. 文件大小如何读取、计算？<br>3. 像素信息如何读取、写入？</li>
<li>对应解决方案<br>1. 首先创建全局变量，如src_：原图宽高；dst_：缩放后宽高；各函数都可对其进行访问；其次用一个字符数组typedef unsigned char pixel[3];存储一个像素的RGB信息；对于缩放比例用double height_zoom_rate,width_zoom_rate;操作更精准，计算缩放后像素用类型转换即可，如：dst_width&#x3D;(int)(width_zoom_rate<em>src_width); 而在访问文件文件头和信息头时，定义unsigned char <em>buf&#x3D;NULL,<em>bui&#x3D;NULL;方便逐个字节访问，也可以处理小端对齐。<br>2. 即如何根据字节小端对齐计算文件大小；前面已经用buf、bui逐个访问文件头，信息头的每个字节数据，故如：b_size&#x3D;bui[23]<em>16</em>16</em>16</em>16</em>16<em>16+bui[22]<em>16</em>16</em>16*16+bui[21]<em>16</em>16+bui[20];</li>
</ol>
<p>可以读取图像大小；而：</p>
<p>f_size&#x3D;dst_width*dst_height+54;则可计算操作后的文件大小</p>
<ol>
<li><pre><code>1. 每个像素的RGB信息各占一个字节，用fgetc即可读取每个字节。读取完一行的像素后，通过计算填充字节个数（pad_num=(4-(src_width*3)%4)%4;），再用fgetc读掉填充字节，即可读取下一行。写入时采用三个字节为一组（即一个像素的RGB信息），结合最近邻插入法用fwrite写入fwrite(&amp;info[si*src_width+sj],sizeof(pixel),1,fp_n);
</code></pre>
</li>
</ol>
<p>再用fputc（0，fp_n）写入填充字节数。</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&quot;bmp.h&quot;

extern double height_zoom_rate,width_zoom_rate;

int main(int argc, char* argv[]) &#123;
	
	//打开文件 
	FILE*fp=fopen(argv[1],&quot;rb&quot;),*fp_n = fopen(argv[3], &quot;wb&quot;);
	
	//读取文件头、信息头 
	read_bmp_head(fp);
	//读取像素信息 
	read_bmp_data(fp);
	
	//计算长宽缩放比例 
	width_zoom_rate=height_zoom_rate=(atoi(argv[2]) /100.0);
	
	//结合最近邻插入法写入缩放后的图像信息 
	write_data(fp_n);
	//展示操作好的图像信息 
	read_bmp_head(fp_n);
	
	//关闭两个图像文件 
	fclose(fp);
	fclose(fp_n);

	return 0;
&#125;



/*头文件使用说明：
在主程序中：extern double height_zoom_rate,width_zoom_rate;并赋值方可正常运行
包含三个函数：
void read_bmp_head(FILE*fp)； 
void read_bmp_data(FILE*fp)；
void write_data(FILE* fp_n)； 
*/ 
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
//改对取模数为1个字节（默认为8，只可是2^n）
#pragma pack(1)
//存储一个像素信息的三元素字符数组 
typedef unsigned char pixel[3];
//文件头信息
typedef struct tagBITMAPFILEHEADER
&#123;
	unsigned short bfType;		 //保存图片类型。 &#39;BM&#39;(1-2字节) 
	unsigned long bfSize; 	 //位图文件的大小，以字节为单位（3-6字节，低位在前）
	unsigned short bfReserved1;//位图文件保留字，必须为0(7-8字节）
	unsigned short bfReserved2;//位图文件保留字，必须为0(9-10字节）
	unsigned long bfOffBits;  //RGB数据偏移地址,位图数据的起始位置，以相对于位图（11-14字节，低位在前）
&#125;BITMAP_FILE_HEADER;
//信息头信息
typedef struct tagBITMAPINFOHEADER
&#123;
	unsigned long 	biSize; 		 //本结构所占用字节数（15-18字节）
	unsigned long  biWidth; 	 //位图的宽度，以像素为单位（19-22字节）
	unsigned long  biHeight; 	 //位图的高度，以像素为单位（23-26字节）
	unsigned short biPlanes; 	 //目标设备的级别，必须为1(27-28字节）
	unsigned short biBitCount;  //每个像素所需的位数，必须是1（双色）（29-30字节）,4(16色），8(256色）16(高彩色)或24（真彩色）之一

	unsigned long  biCompression;//位图压缩类型，必须是0（不压缩），（31-34字节）
	//1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之一

	unsigned long  biSizeImage;  //位图的大小(其中包含了为了补齐每行字节数是4的倍数而添加的空字节)，以字节为单位（35-38字节）

	unsigned long  biXPelsPerMeter;//位图水平分辨率，每米像素数（39-42字节）
	unsigned long  biYPelsPerMeter;//位图垂直分辨率，每米像素数（43-46字节)
	unsigned long  biClrUsed; 		 //位图实际使用的颜色表中的颜色数（47-50字节）
	unsigned long  biClrImportant; //位图显示过程中重要的颜色数（51-54字节）
&#125;BITMAP_INFO_HEADER;

//全局变量说明：src_：原图宽高；dst_：缩放后宽高；pad_num：每行补齐空字节数；
//f_size: bfSize; b_size: biSizeImage; _zoom_rate: 宽高缩放倍数；sign：是否没计算过宽高标志 
int sign1=1;
int src_width,src_height,dst_width,dst_height;
int pad_num,f_size,b_size;
double height_zoom_rate,width_zoom_rate;
unsigned char *buf=NULL,*bui=NULL;
//创建两个结构体存储文件头和信息头信息 
BITMAP_FILE_HEADER file_head;
BITMAP_INFO_HEADER info_head;
//info指向像素信息的头地址，以info[i](=*(info+i))访问第i个像素 
pixel *info=NULL;

//读取文件头和信息头的信息 
void read_bmp_head(FILE*fp)&#123;
	
	if ( fp == NULL ) &#123;
		printf(&quot;file doesn&#39;t exist!\n&quot;);
		exit(0);
	&#125;
	rewind(fp); 

	//读取信息 
	fread(&amp;file_head, sizeof(BITMAP_FILE_HEADER), 1, fp);
	fread(&amp;info_head, sizeof(BITMAP_INFO_HEADER), 1, fp);
	
	//因为信息是小端对齐，以字节为单位方便读取 
	buf=(unsigned char*)&amp;file_head;
	printf(&quot;\nbfType:\t\t%c %c&quot;,buf[1],buf[0]);
	f_size=buf[5]*16*16*16*16*16*16+buf[4]*16*16*16*16+buf[3]*16*16+buf[2];
	printf(&quot;\nbfSize:\t\t%02x %02x %02x %02x   ----   %d&quot;,buf[5],buf[4],buf[3],buf[2],f_size);
	printf(&quot;\nbfReserved1:\t%02x %02x\nbfReserved2:\t%02x %02x&quot;,buf[7],buf[6],buf[9],buf[8]);
	printf(&quot;\nbf0ffbits:\t%02x %02x %02x %02x&quot;,buf[13],buf[12],buf[11],buf[10]); 
	printf(&quot;\n\n&quot;); 
	
	bui=(unsigned char*)&amp;info_head;
	printf(&quot;\nbiSize:\t\t%02x %02x %02x %02x&quot;,bui[3],bui[2],bui[1],bui[0]);
	src_width=bui[7]*16*16*16*16*16*16+bui[6]*16*16*16*16+bui[5]*16*16+bui[4];
	src_height=bui[11]*16*16*16*16*16*16+bui[10]*16*16*16*16+bui[9]*16*16+bui[8];
	printf(&quot;\nbiWidth:\t%02x %02x %02x %02x   ----   %d&quot;,bui[7],bui[6],bui[5],bui[4],src_width);
	printf(&quot;\nbiHeight:\t%02x %02x %02x %02x   ----   %d&quot;,bui[11],bui[10],bui[9],bui[8],src_height);
	printf(&quot;\nbiPlans:\t%02x %02x&quot;,bui[13],bui[12]);
	printf(&quot;\nbiBitCount:\t%02x %02x&quot;,bui[15],bui[14]);
	printf(&quot;\nbiCompression:\t%02x %02x %02x %02x&quot;,bui[19],bui[18],bui[17],bui[16]);
	b_size=bui[23]*16*16*16*16*16*16+bui[22]*16*16*16*16+bui[21]*16*16+bui[20];
	printf(&quot;\nbiSizeImage:\t%02x %02x %02x %02x   ----   %d&quot;,bui[23],bui[22],bui[21],bui[20],b_size);
	printf(&quot;\nbiXPelsPerMeter:%02x %02x %02x %02x&quot;,bui[27],bui[26],bui[25],bui[24]);
	printf(&quot;\nbiYPelsPerMeter:%02x %02x %02x %02x&quot;,bui[31],bui[30],bui[29],bui[28]);
	printf(&quot;\nbiClrUsed:\t%02x %02x %02x %02x&quot;,bui[35],bui[34],bui[33],bui[32]);
	printf(&quot;\nbiClrImportant:\t%02x %02x %02x %02x\n&quot;,bui[39],bui[38],bui[37],bui[36]);
	
	sign1=0; 
&#125;
	
//将照片像素信息读取，通过全局变量info访问 
void read_bmp_data(FILE*fp)&#123;
	
	void read_bmp_head(FILE*fp);
	if ( fp == NULL ) &#123;
		printf(&quot;file doesn&#39;t exist!\n&quot;);
		exit(0);
	&#125;
	//判断是否计算好了图像的长宽，没有则执行 
	if(sign1)&#123;
		rewind(fp);
		read_bmp_head(fp);
	&#125;
	
	int i,j,k;

	//填充字节数 
	pad_num=(4-(src_width*3)%4)%4;
	//开辟空间 
	info=(pixel*)malloc(src_width*src_height*sizeof(pixel));
	
	//读取像素信息RGB 
	for(i=0;i&lt;src_height;i++)&#123;
		for(j=0;j&lt;src_width;j++)&#123;
			info[i*src_width+j][0]=fgetc(fp);
			info[i*src_width+j][1]=fgetc(fp);
			info[i*src_width+j][2]=fgetc(fp);
		&#125;
		//读掉填充字节 
		for(k=0;k&lt;pad_num;k++)fgetc(fp);
	&#125;
	
&#125;

//将信息写入新文件 
void write_data(FILE* fp_n) &#123;
	
	rewind(fp_n);
	dst_width=(int)(width_zoom_rate*src_width);
	dst_height=(int)(height_zoom_rate*src_height);
	
	//文件头信息修改、拷贝（小对齐，故用&amp;、&gt;&gt;位操作） 
	int f_size=dst_width*dst_height+54,i,j,k;
	buf[2]=0x000000FF&amp;f_size;
	buf[3]=(0x0000FF00&amp;f_size)&gt;&gt;8;
	buf[4]=(0x00FF0000&amp;f_size)&gt;&gt;16;
	buf[5]=(0xFF000000&amp;f_size)&gt;&gt;24;
	
	for(i=0;i&lt;14;i++)fputc(buf[i],fp_n);
	
	//信息头信息修改、拷贝 
	bui[4]=0x000000FF&amp;dst_width;
	bui[5]=(0x0000FF00&amp;dst_width)&gt;&gt;8;
	bui[6]=(0x00FF0000&amp;dst_width)&gt;&gt;16;
	bui[7]=(0xFF000000&amp;dst_width)&gt;&gt;24;
	bui[8]=0x000000FF&amp;dst_height;
	bui[9]=(0x0000FF00&amp;dst_height)&gt;&gt;8;
	bui[10]=(0x00FF0000&amp;dst_height)&gt;&gt;16;
	bui[11]=(0xFF000000&amp;dst_height)&gt;&gt;24;
	
	pad_num= (4-(dst_width*3)%4)%4;
	b_size=dst_height*(dst_width+pad_num)*3;
	bui[20]=0x000000FF&amp;b_size;
	bui[21]=(0x0000FF00&amp;b_size)&gt;&gt;8;
	bui[22]=(0x00FF0000&amp;b_size)&gt;&gt;16;
	bui[23]=(0xFF000000&amp;b_size)&gt;&gt;24; 
	
	for(i=0;i&lt;40;i++)fputc(bui[i],fp_n);
	
	int si,sj;
	
	//像素信息写入 
	for(i=0;i&lt;dst_height;i++)&#123;
		si=i/height_zoom_rate;
		for(j=0;j&lt;dst_width;j++)&#123;
			//最近邻插入法 
			sj=j/width_zoom_rate;
			fwrite(&amp;info[si*src_width+sj],sizeof(pixel),1,fp_n);
		&#125;
		for(k=0;k&lt;pad_num;k++)fputc(0,fp_n);
	&#125;
	/*
	//不行的写法！低效且数值越界 
	for(i=0;i&lt;dst_height;i++)&#123;
		for(j=0;j&lt;dst_width;j++)&#123;
			//最近邻插入法 
			fwrite(&amp;info[(int)(i*src_width/height_zoom_rate+j/width_zoom_rate)],sizeof(pixel),1,fp_n);
		&#125;
		for(k=0;k&lt;pad_num;k++)fputc(0,fp_n);
	&#125;
	*/
&#125;
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124532108">https://blog.csdn.net/qq_32971095/article/details/124532108</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">简单文件数据库-模拟图书馆管理系统-西安电子科技大学大一程序基础设计课程设计作业</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-30 09:50:54" itemprop="dateCreated datePublished" datetime="2022-04-30T09:50:54+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" class="post-meta-item leancloud_visitors" data-flag-title="简单文件数据库-模拟图书馆管理系统-西安电子科技大学大一程序基础设计课程设计作业" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/30/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A8%A1%E6%8B%9F%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%A4%A7%E4%B8%80%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>命令行参数如下：</p>
<p>Libsim –a(-u) xxxx</p>
<p>第一个参数为可执行程序名称；第二个参数为用户身份，-a表示管理员，-u表示读者；第三个参数为用户名</p>
<ul>
<li>问题分析：</li>
</ul>
<p>由于无法直接在文件中插入数据（不是简单覆盖），固采用将文件数据提取为链表的方法，对链表进行操作，最后将链表信息导入文件中。</p>
<ol>
<li>实现时的困难：<br>1. 如何实现管理员和读者双菜单？<br>2. 文件该以哪种方式打开？<br>3. 文件信息读取不全是什么造成的？<br>4. 操作后再读取文件出错，打开文件信息连在一起？<br>5. 删除最后一个数据时出错？<br>6. 如果用户输入的操作都无效（要修改的信息不存在）怎么办？</li>
<li>对应解决方案<br>1. 判断命令行参数信息，用if判断语句分别进入功能即可。<br>2. 操作者只需选择“r（只读）”和“a+（追加）”方式打开文件，防止文件数据意外损失。其中在只有管理员增加数据时才用“a+”，其他模式均以“r”方式打开！<br>3. 因为程序有继续操作选项，而上次操作后文件标志已经为EOF，采用rewind函数即可将文件标志位重置<br>4. 在写入、修改、删除信息时注意最后写入换行符，保证文件可读性以及下一次操作可行<br>5. 因为采用的是链表操作，删除非末尾元素时，下一个链节内容完全拷贝到要删字节，再释放下一个链节即可。但是链表尾指向NULL，访问NULL会出错，要单独考虑。<br>6. 定义变量int sign &#x3D; 0；只有操作有效时sign &#x3D; 1，进入下一步操作，防止文件信息丢失。</li>
</ol>
<pre><code>//程序基本配置文件：1.文件名为“book.txt”的文件；2.文件名为“reader.txt”的文件 
#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
//测试方式选择：1.AUTO：命令行运行；2.标准文件流读入数据；3.手动输入输出数据（用哪个将另外两个#define注释掉即可） 
//#define AUTO
//#define MANUAL1
#define MANUAL2
#define LEN1 sizeof(book_info)
#define LEN2 sizeof(reader_info)
//定义两个结构体，分别存储书本信息和读者借阅信息 
typedef struct Book &#123;
	char code[20];
	char title[100];
	int number;
	struct Book* next;
&#125;book_info;
typedef struct Reader &#123;
	char order[20];
	char name[100];
	char borrow_code[20];
	struct Reader* next;
&#125;reader_info;
const char* book_format = &quot;%s %s %d&quot;, * reader_format = &quot;%s %s %s&quot;;
char file_name[101] = &#123; 0 &#125;;


int main(int argc, char* argv[]) &#123;
	void format_judge(char* type, char* name);
	FILE* open_file();
	void function(char* type, char* name);
	char type[3], name[100];

#ifdef AUTO
	strcpy(type, argv[1]);
	strcpy(name, argv[2]);
#endif
#ifdef MANUAL1
	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif 
#ifdef MANUAL2
	printf(&quot;Enter user&#39;s type(-a/-u) and username:\n&quot;);
	scanf(&quot;%s %s&quot;, type, name);
#endif 

	//输入参数格式正误判断 
	format_judge(type, name);

	//操作函数 
	function(type, name);

	return 0;
&#125;

//打开文件函数 
FILE* open_file() &#123;
	FILE* fp;
	char  ope_way[3] = &#123; 0 &#125;;
	//输入文件名和打开方式 
	printf(&quot;Enter the path of data:&quot;);
	scanf(&quot;%s&quot;, file_name);
	//*****注意操作者只需选择“r（只读）”和“a+（追加）”方式打开文件，防止文件数据意外损失！！！ 
	printf(&quot;Enter the way to operate(r/a+):&quot;);
	scanf(&quot;%s&quot;, ope_way);
	//如果文件不存在，报错 
	if ((fp = fopen(file_name, ope_way)) == NULL) &#123;
		printf(&quot;File not exist\n&quot;);
		exit(0);
	&#125;
	return fp;
&#125;

//显示文件的所有信息 
void show_file(FILE* fp) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;

	//文件位置标志重置，以输出完整程序 
	rewind(fp);
	char c;
	//当文件位置为EOF(文件尾) 
	while (!feof(fp)) &#123;
		c = fgetc(fp);
		printf(&quot;%c&quot;, c);
	&#125;
	printf(&quot;\n&quot;);
&#125;

//命令行输入参数判断 
void format_judge(char* type, char* name) &#123;
	if (type[0] != &#39;-&#39; || (type[1] != &#39;a&#39; &amp;&amp; type[1] != &#39;u&#39;)) &#123;
		printf(&quot;Format Error!\n&quot;);
		exit(0);
	&#125;
&#125;

//覆盖文件函数，用于一次操作结束后将新文件内的数据覆盖到老文件上 
//参数列表：指向原文件指针，指向操作产生的新文件的指针 
void revise_file(FILE* fp, FILE* fp_n) &#123;
	if (fp_n == NULL) &#123;
		printf(&quot;New file failed to open\n&quot;);
		return;
	&#125;
	char c;
	fclose(fp);
	//以“w”方式打开文件，文件原内容擦除 
	fopen(file_name, &quot;w&quot;);
	rewind(fp_n);
	//一个字符一个字符地拷贝到原文件中 
	while ((c = fgetc(fp_n)) != EOF) &#123;
		fputc(c, fp);
	&#125;
	fclose(fp);
&#125;

//功能集成函数
//参数列表：用户类型（-a：管理员/-u：用户）；用户名 
void function(char* type, char* name) &#123;
	FILE* open_file();
	void add_info(FILE * fp, int object);
	void revise_info(FILE * fp, int object);
	void delete_info(FILE * fp, int object);
	void borrow_book(FILE * fp, FILE * fp_r);
	void return_book(FILE * fp_r);
	void search_info(FILE * fp, FILE * fp_r);

	//定义变量：1.option：操作类型；2.object：操作对象；3.sign：判断是否继续操作标志；4.fp：打开文件指针；5.fp_r:读者信息文件指针 
	int option, object, sign = 1;
	FILE* fp = NULL, * fp_r = NULL;

	//管理员模式 
	if (type[1] == &#39;a&#39;) &#123;
		printf(&quot;Administrator, what do you want to do\n\t1.Add information\n\t2.Revise information\n\t3.Delete information\n\t4.Show all the information\nOperate object:\n\t1.book\n\t2.reader\nAnswer:&quot;);
		while (sign) &#123;
			scanf(&quot;%d%d&quot;, &amp;option, &amp;object);
			//进入功能选择，详细见后面各功能函数 
			switch (option) &#123;
			case 1: //增加数据 
			&#123;
				fp = open_file();
				add_info(fp, object);
				break;
			&#125;
			case 2: //修改数据 
			&#123;
				fp = open_file();
				revise_info(fp, object);
				break;
			&#125;
			case 3: //删除数据 
			&#123;
				fp = open_file();
				delete_info(fp, object);
				break;
			&#125;
			case 4: //总览数据 
			&#123;
				if (object == 1) &#123;
					fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);
					show_file(fp);
				&#125;
				else &#123;
					fp_r = fopen(&quot;reader.txt&quot;, &quot;r&quot;);
					show_file(fp_r);
				&#125;
				break;
			&#125;
			default:printf(&quot;Option Error\n&quot;);
			&#125;
			//是否继续进行操作 
			printf(&quot;Continue to operate\n\t1-&gt;yes\n\t0-&gt;no\nAnswer:&quot;);
			scanf(&quot;%d&quot;, &amp;sign);
		&#125;
		fclose(fp);
		fclose(fp_r);
	&#125;
	//用户模式 
	else &#123;
		printf(&quot;User, what do you want to do\n\t1.Borrow books\n\t2.Return books\n\t3.Search information\nAnswer:&quot;);
		while (sign) &#123;
			scanf(&quot;%d&quot;, &amp;option);
			switch (option) &#123;
			case 1: //借书 
			&#123;
				fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);
				fp_r = fopen(&quot;reader.txt&quot;, &quot;a+&quot;);
				if (fp == NULL || fp_r == NULL) &#123;
					printf(&quot;File missing\n&quot;);
				&#125;
				else borrow_book(fp, fp_r);
				break;
			&#125;
			case 2: //还书 
			&#123;
				fp_r = fopen(&quot;reader.txt&quot;, &quot;r+&quot;);
				strcpy(file_name, &quot;reader.txt\0&quot;);
				if (fp_r == NULL) &#123;
					printf(&quot;File missing\n&quot;);
				&#125;
				else return_book(fp_r);
				break;
			&#125;
			case 3: //查数据 
			&#123;
				fp = fopen(&quot;book.txt&quot;, &quot;r&quot;);
				fp_r = fopen(&quot;reader.txt&quot;, &quot;r&quot;);
				if (fp == NULL || fp_r == NULL) &#123;
					printf(&quot;File missing\n&quot;);
				&#125;
				else search_info(fp, fp_r);
				break;
			&#125;
			default:printf(&quot;Option Error\n&quot;);
			&#125;
			printf(&quot;Continue to operate\n\t1-&gt;yes\n\t0-&gt;no\nAnswer:&quot;);
			scanf(&quot;%d&quot;, &amp;sign);
		&#125;
		fclose(fp);
	&#125;
&#125;

//添加数据函数
//参数列表：指向操作文件的指针；操作对象 
void add_info(FILE* fp, int object) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;
	//定义变量：1.num：操作次数；2.book：添加的图书信息的结构体；3.reader：添加的借阅信息结构体 
	int num;
	book_info book;
	reader_info reader;
	//添加图书信息 
	if (object == 1) &#123;
		printf(&quot;How many books you want to add\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		//提示输入图书信息的格式 
		printf(&quot;Information format:book_number title amount\nEnter:\n&quot;);
		while (num--) &#123;
			scanf(book_format, &amp;book.code, &amp;book.title, &amp;book.number);
			fprintf(fp, book_format, book.code, book.title, book.number);
			//*****注意添加完后换行！ 
			fprintf(fp, &quot;\n&quot;);
		&#125;
		printf(&quot;Succeed to operate\n&quot;);
	&#125;
	//添加借阅者信息 
	else if (object == 2) &#123;
		printf(&quot;How many readers you want to add\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		printf(&quot;Information format:reader_number name book_code\nEnter:\n&quot;);
		while (num--) &#123;
			scanf(reader_format, &amp;reader.order, &amp;reader.name, &amp;reader.borrow_code);
			fprintf(fp, reader_format, reader.order, reader.name, reader.borrow_code);
			fprintf(fp, &quot;\n&quot;);
		&#125;
		printf(&quot;Succeed to operate\n&quot;);
	&#125;
	else printf(&quot;Object error\n&quot;);
&#125;

//修改数据函数
//参数列表：指向操作文件的指针；操作对象 
void revise_info(FILE* fp, int object) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;
	rewind(fp);

	book_info* original_information_input_b(FILE * fp);
	reader_info* original_information_input_r(FILE * fp);
	void information_save_b(book_info * head, FILE * fp_n);
	void information_save_r(reader_info * head, FILE * fp_n);
	book_info* get_adress_b(book_info * head_adress, char* search);
	reader_info* get_adress_r(reader_info * head_adress, char* search);
	void revise_file(FILE * fp, FILE * fp_n);

	//定义变量：1.num:操作数；2.sign：操作是否有效标志；3.search：搜素信息（图书号或书名或读者编号或人名）；4.fp_n:指向新文件（存贮操作后的信息）的指针 
	int num, sign = 0;
	char search[100] = &#123; 0 &#125;;
	FILE* fp_n = NULL;
	//修改图书信息 
	if (object == 1) &#123;
		//定义变量：1.head：存储了图书信息的链表头；2. book：存贮修改信息的结构体；3.locat：指向修改数据所在链节的指针  
		book_info* head = original_information_input_b(fp), book, * locat;
		printf(&quot;How many books you want to revise\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		while (num--) &#123;
			printf(&quot;Enter book_code or title:&quot;);
			//输入要找的图书号或书名 
			scanf(&quot;%s&quot;, search);
			//得到所在链表的位置，如果不存在，locat=NULL，不进行下列操作 
			locat = get_adress_b(head, search);
			if (locat != NULL) &#123;
				printf(&quot;Enter the new information(Format:book_number title amount):&quot;);
				//输入要用于替换的数据 
				scanf(book_format, &amp;book.code, &amp;book.title, &amp;book.number);
				strcpy(locat-&gt;code, book.code);
				strcpy(locat-&gt;title, book.title);
				locat-&gt;number = book.number;
				//操作有效 
				sign = 1;
			&#125;
		&#125;
		//如果输入的书本都不存在，即操作无效，不进行下列操作，防止书本信息文件内容被清空（revise_file函数有以“w”方式打开文件，文件内容清空） 
		if (sign) &#123;
			//打开存储修改信息的新文件“book_n.txt” 
			fp_n = fopen(&quot;book_n.txt&quot;, &quot;w+&quot;);
			//将链表信息存入新文件 
			information_save_b(head, fp_n);
			//拷贝新文件中信息到原文件 
			revise_file(fp, fp_n);
			printf(&quot;Succeed to operate\n&quot;);
		&#125;

	&#125;

	if (object == 2) &#123;
		reader_info* head = original_information_input_r(fp), reader, * locat = head;
		//确认是否修改找到信息（针对一个人借多本书的情况） 
		int answer;
		printf(&quot;How many readers you want to revise\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		while (num--) &#123;
			printf(&quot;Enter reader_order or name\n:&quot;);
			scanf(&quot;%s&quot;, search);
			while (locat != NULL) &#123;
				//*****得到该读者的第一条信息(注意搜索起点是locat，结合while循环实现搜索所有而非第一个出现的)！ 
				locat = get_adress_r(locat, reader.order);
				if (locat != NULL) &#123;
					//输出该条信息的内容 
					printf(reader_format, locat-&gt;order, locat-&gt;name, locat-&gt;borrow_code);
					printf(&quot;\nRevise or not\n\t1.yes\n\t2.no\nAnswer:&quot;);
					//确认是否修改该条信息 
					scanf(&quot;%d&quot;, &amp;answer);
					if (answer == 1) &#123;
						printf(&quot;Enter the new information(Format:reader_order name borrow_code):\n&quot;);
						scanf(reader_format, &amp;reader.order, &amp;reader.name, &amp;reader.borrow_code);
						strcpy(locat-&gt;order, reader.order);
						strcpy(locat-&gt;name, reader.name);
						strcpy(locat-&gt;borrow_code, reader.borrow_code);
						sign = 1;
					&#125;
					//标记为指向下一个 
					locat = locat-&gt;next;
				&#125;
			&#125;
		&#125;
		if (sign == 1) &#123;
			fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);
			information_save_r(head, fp_n);
			revise_file(fp, fp_n);
			printf(&quot;Succeed to operate\n&quot;);
		&#125;
	&#125;

&#125;

//删除数据函数
//参数列表：指向操作文件的指针；操作对象 
void delete_info(FILE* fp, int object) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;
	rewind(fp);

	book_info* original_information_input_b(FILE * fp);
	reader_info* original_information_input_r(FILE * fp);
	book_info* get_adress_b(book_info * head_adress, char* search);
	reader_info* get_adress_r(reader_info * head_adress, char* search);
	void information_save_b(book_info * head, FILE * fp_n);
	void information_save_r(reader_info * head, FILE * fp_n);
	void revise_file(FILE * fp, FILE * fp_n);

	int num, answer, sign = 0;
	char search[100];

	if (object == 1) &#123;
		//定义变量：3.free_adress：指向要删除数据链节的指针 
		book_info* head = original_information_input_b(fp), * locat = NULL, * free_adress = NULL;
		printf(&quot;How many books you want to delete\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		while (num--) &#123;
			printf(&quot;Search book_code or title to delete:&quot;);
			scanf(&quot;%s&quot;, search);
			locat = get_adress_b(head, search);
			//删除链节的方式采用复制——释放法，即将下一个链节内容完全拷贝到要删字节，再释放下一个链节 
			if (locat != NULL) &#123;
				//不是链表尾的情况 
				if (locat-&gt;next != NULL) &#123;
					free_adress = locat-&gt;next;
					*locat = *(locat-&gt;next);
					free(free_adress);
				&#125;
				//*****链表尾的情况！（locat-&gt;next=NULL！访问会出错！） 
				else &#123;
					book_info* taget = head;
					//找到要删链节的上一个链节 
					for (; taget-&gt;next != locat; taget = taget-&gt;next);
					//将上一个链节的指向该为NULL，即可去除原先链表尾 
					taget-&gt;next = NULL;
					free(locat);
				&#125;
				sign = 1;
			&#125;
		&#125;
		if (sign) &#123;
			FILE* fp_n = fopen(&quot;book_n.txt&quot;, &quot;w+&quot;);
			information_save_b(head, fp_n);
			revise_file(fp, fp_n);
			printf(&quot;Succeed to operate\n&quot;);
		&#125;
	&#125;

	//删除读者信息，基本和修改读者信息部分相同 
	if (object == 2) &#123;
		reader_info* head = original_information_input_r(fp), * locat = head, * free_adress = NULL;
		printf(&quot;How many readers you want to delete\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		while (num--) &#123;
			printf(&quot;Search reader_order or name to delete:&quot;);
			scanf(&quot;%s&quot;, search);
			while (locat != NULL) &#123;
				locat = get_adress_r(locat, search);
				if (locat != NULL) &#123;
					printf(&quot;This person&#39;s one record:&quot;);
					printf(reader_format, locat-&gt;order, locat-&gt;name, locat-&gt;borrow_code);
					printf(&quot;\nDelelt this record or not?\n\t1.yes\n\t2.no\nAnswer:&quot;);
					scanf(&quot;%d&quot;, &amp;answer);
					if (answer == 1) &#123;
						if (locat-&gt;next != NULL) &#123;
							free_adress = locat-&gt;next;
							*locat = *(locat-&gt;next);
							free(free_adress);
						&#125;
						else &#123;
							reader_info* taget = head;
							for (; taget-&gt;next != locat; taget = taget-&gt;next);
							taget-&gt;next = NULL;
							free(locat);
						&#125;
						sign = 1;
					&#125;
					locat = locat-&gt;next;
				&#125;
			&#125;
		&#125;
		if (sign) &#123;
			FILE* fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);
			information_save_r(head, fp_n);
			revise_file(fp, fp_n);
			printf(&quot;Succeed to operate\n&quot;);
		&#125;
	&#125;
&#125;

//借书函数 
//参数列表：指向图书信息文件的指针；指向读者信息文件的指针 
void borrow_book(FILE* fp, FILE* fp_r) &#123;
	if (fp == NULL || fp_r == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;
	rewind(fp);

	book_info* original_information_input_b(FILE * fp);
	book_info* get_adress_b(book_info * head_adress, char* search);

	int num, answer;
	char search[100];
	book_info* head = original_information_input_b(fp), * locat;

	//询问是否列出馆藏图书列表 
	printf(&quot;Show book list\n\t1.yes\n\t2.no\nAnswer:&quot;);
	scanf(&quot;%d&quot;, &amp;answer);
	if (answer == 1)show_file(fp);
	printf(&quot;How many books you want to borrow\nAnswer:&quot;);
	scanf(&quot;%d&quot;, &amp;num);
	while (num--) &#123;
		printf(&quot;Search book_code or title to borrow:&quot;);
		scanf(&quot;%s&quot;, search);
		locat = get_adress_b(head, search);
		if (locat != NULL) &#123;
			char order[20], name[100];
			printf(&quot;Enter your personal_order and your name:&quot;);
			scanf(&quot;%s%s&quot;, order, name);
			//将借阅信息存储到读者信息文件 
			fprintf(fp_r, reader_format, order, name, locat-&gt;code);
			fprintf(fp_r, &quot;\n&quot;);
			printf(&quot;Succeed to operate\n&quot;);
		&#125;
	&#125;
&#125;

//还书函数
//参数列表：指向读者信息文件的指针 
void return_book(FILE* fp) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return;
	&#125;
	rewind(fp);

	reader_info* original_information_input_r(FILE * fp);
	reader_info* get_adress_r(reader_info * head_adress, char* search);
	void information_save_r(reader_info * head, FILE * fp_n);

	int num, sign = 0;
	reader_info reader, * head = original_information_input_r(fp), * locat = head;

	printf(&quot;How many books you want to return\nAnswer:&quot;);
	scanf(&quot;%d&quot;, &amp;num);
	while (num--) &#123;
		printf(&quot;Enter your person_order name and book_code:&quot;);
		scanf(reader_format, reader.order, reader.name, reader.borrow_code);
		//*****同时判断读者编号和姓名是否符合,直到链表尾 (注意下一次搜寻的起始地址为locat-&gt;next！)
		for (; locat != NULL &amp;&amp; strcmp(locat-&gt;order, reader.order) != 0; locat = get_adress_r(locat-&gt;next, reader.name));
		if (locat != NULL) &#123;
			if (locat-&gt;next != NULL) &#123;
				reader_info* free_adress = locat-&gt;next;
				*locat = *(locat-&gt;next);
				free(free_adress);
			&#125;
			else &#123;
				reader_info* taget = head;
				for (; taget-&gt;next != locat; taget = taget-&gt;next);
				taget-&gt;next = NULL;
				free(locat);
			&#125;
			sign = 1;
		&#125;
		else printf(&quot;Record doesn&#39;t exist\n&quot;);
	&#125;
	if (sign) &#123;
		FILE* fp_n = fopen(&quot;reader_n.txt&quot;, &quot;w+&quot;);
		information_save_r(head, fp_n);
		revise_file(fp, fp_n);
		printf(&quot;Succeed to operate\n&quot;);
	&#125;

&#125;

//查数据函数
//参数列表：指向图书信息文件的指针；指向读者信息文件的指针 
void search_info(FILE* fp, FILE* fp_r) &#123;
	book_info* original_information_input_b(FILE * fp);
	reader_info* original_information_input_r(FILE * fp);
	book_info* get_adress_b(book_info * head_adress, char* search);
	reader_info* get_adress_r(reader_info * head_adress, char* search);

	int answer, num, i = 1;
	char search[100];
	printf(&quot;Want to know what\n\t1.Show all books\n\t2.Search one book\n\t3.Remain to return\nAnswer:&quot;);
	scanf(&quot;%d&quot;, &amp;answer);
	//展示所有馆藏图书 
	if (answer == 1) show_file(fp);
	//输入图书号或书名看有没有 
	else if (answer == 2) &#123;
		book_info* head = original_information_input_b(fp);
		printf(&quot;How many books you want to search\nAnswer:&quot;);
		scanf(&quot;%d&quot;, &amp;num);
		while (num--) &#123;
			printf(&quot;Search book_code or title to show:&quot;);
			scanf(&quot;%s&quot;, search);
			book_info* locat = get_adress_b(head, search);
			if (locat != NULL) &#123;
				printf(book_format, locat-&gt;code, locat-&gt;title, locat-&gt;number);
				printf(&quot;\n&quot;);
				reader_info* head_r = original_information_input_r(fp_r), * locat_r = head_r;
				printf(&quot;Borrow record:\n&quot;);
				for (i = 1; locat_r != NULL; locat_r = locat_r-&gt;next, i++) &#123;
					if (strcmp(locat-&gt;code, locat_r-&gt;borrow_code) == 0)
						printf(&quot;%d : %s %s\n&quot;, i, locat_r-&gt;order, locat_r-&gt;name);
				&#125;
			&#125;
		&#125;
	&#125;
	//输入个人信息查找待还图书 
	else if (answer == 3) &#123;
		reader_info reader, * head = original_information_input_r(fp_r), * locat = head;
		printf(&quot;Enter your personal_order and name:&quot;);
		scanf(&quot;%s%s&quot;, reader.order, reader.name);
		while (locat != NULL) &#123;
			for (; locat != NULL &amp;&amp; strcmp(locat-&gt;name, reader.name) != 0 &amp;&amp; strcmp(locat-&gt;order, reader.order) != 0; locat = get_adress_r(locat-&gt;next, reader.order));
			if (locat == NULL)break;
			else &#123;
				printf(&quot;Borrowed book %d:&quot;, i++);
				printf(&quot;%s&quot;, locat-&gt;borrow_code);
				printf(&quot;\n&quot;);
				locat = locat-&gt;next;
			&#125;
		&#125;

	&#125;

&#125;

//创建链表函数，将图书信息文件提取成链表
//参数列表：指向图书信息文件指针；返回值：链表链头 
book_info* original_information_input_b(FILE* fp) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return NULL;
	&#125;
	//定义变量：1.head：链表头；2.当前链表操作位置指针；3.暂存数据的结构体 
	book_info* head = NULL, * p = NULL, temp;
	int i = 0;
	//从文件中读取信息直道文件尾 
	while (fscanf(fp, book_format, &amp;temp.code, &amp;temp.title, &amp;temp.number) != EOF) &#123;
		i++;
		//如果是链表头，开辟空间地址即为head，不是表头则依照赋值表达式的右结合性将链表进行延伸 
		if (i == 1)head = p = (book_info*)malloc(LEN1);
		else p = p-&gt;next = (book_info*)malloc(LEN1);

		strcpy(p-&gt;code, temp.code);
		strcpy(p-&gt;title, temp.title);
		p-&gt;number = temp.number;

	&#125;
	//链表尾部处理 
	if (i != 0)p-&gt;next = NULL;
	return head;
&#125;

//创建链表函数，将读者信息文件提取成链表
//参数列表：指向读者信息文件指针 返回值：链表链头
reader_info* original_information_input_r(FILE* fp) &#123;
	if (fp == NULL) &#123;
		printf(&quot;File failed to open\n&quot;);
		return NULL;
	&#125;
	reader_info* head = NULL, * p = NULL, temp;
	int i = 0;

	while (fscanf(fp, reader_format, &amp;temp.order, &amp;temp.name, &amp;temp.borrow_code) != EOF) &#123;

		i++;
		if (i == 1)head = p = (reader_info*)malloc(LEN2);
		else p = p-&gt;next = (reader_info*)malloc(LEN2);

		strcpy(p-&gt;order, temp.order);
		strcpy(p-&gt;name, temp.name);
		strcpy(p-&gt;borrow_code, temp.borrow_code);

	&#125;

	if (i != 0)p-&gt;next = NULL;
	return head;
&#125;

//保存链表信息函数，将图书信息链表保存到新文件中 
//参数列表：指向图书信息新文件指针 
void information_save_b(book_info* head, FILE* fp_n) &#123;
	book_info* p = head;
	for (; p != NULL; p = p-&gt;next) &#123;
		fprintf(fp_n, book_format, p-&gt;code, p-&gt;title, p-&gt;number);
		fprintf(fp_n, &quot;\n&quot;);
	&#125;
&#125;

//保存链表信息函数，将读者信息链表保存到新文件中 
//参数列表：指向读者信息新文件指针 
void information_save_r(reader_info* head, FILE* fp_n) &#123;
	reader_info* p = head;
	for (; p != NULL; p = p-&gt;next) &#123;
		fprintf(fp_n, reader_format, p-&gt;order, p-&gt;name, p-&gt;borrow_code);
		fprintf(fp_n, &quot;\n&quot;);
	&#125;
&#125;

//搜索信息函数 
//参数列表：指向图书信息新文件指针 返回值：所找链节地址，无返回NULL 
book_info* get_adress_b(book_info* head_adress, char* search) &#123;
	//定义变量：1.search_adress：当前搜索链节地址 
	book_info* search_adress = head_adress;
	//先对图书号进行匹配，是否满足输入的信息 
	for (; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;code, search) != 0; search_adress = search_adress-&gt;next);
	//如果没有，重置当前搜索地址，再和书名进行匹配 
	if (search_adress == NULL) &#123;
		for (search_adress = head_adress; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;title, search) != 0; search_adress = search_adress-&gt;next);
		if (search_adress != NULL)	return search_adress;
		else &#123;
			printf(&quot;This book doesn&#39;t exist\n&quot;);
			return NULL;
		&#125;
	&#125;
	else return search_adress;
&#125;

//搜索信息函数
//参数列表：指向读者信息新文件指针 返回值：所找链节地址，无返回NULL
reader_info* get_adress_r(reader_info* head_adress, char* search) &#123;
	reader_info* search_adress = head_adress;
	for (; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;order, search) != 0; search_adress = search_adress-&gt;next);
	if (search_adress == NULL) &#123;
		for (search_adress = head_adress; search_adress != NULL &amp;&amp; strcmp(search_adress-&gt;name, search) != 0; search_adress = search_adress-&gt;next);
		if (search_adress != NULL)	return search_adress;
		else &#123;
			printf(&quot;This person doesn&#39;t exist\n&quot;);
			return NULL;
		&#125;
	&#125;
	else return search_adress;

&#125;
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/124508883">https://blog.csdn.net/qq_32971095/article/details/124508883</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">790k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'H2FYHQwVGaUkawg5DkrA6d6M-gzGzoHsz',
      appKey     : 'zndS0u9Qj7qj8CqnJINs2MGT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://h2fyhqwv.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
