<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="舟遥遥以轻飏，风飘飘而吹衣">
<meta property="og:type" content="website">
<meta property="og:title" content="Switch">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:description" content="舟遥遥以轻飏，风飘飘而吹衣">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SWQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="Switch" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to My Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">135</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">2023年电赛E题完整设计暨电赛全记录</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-07 23:56:59" itemprop="dateCreated datePublished" datetime="2023-08-07T23:56:59+08:00">2023-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:33:32" itemprop="dateModified" datetime="2025-02-09T14:33:32+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" class="post-meta-item leancloud_visitors" data-flag-title="2023年电赛E题完整设计暨电赛全记录" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023%E5%B9%B4%E7%94%B5%E8%B5%9BE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%9A%A8%E7%94%B5%E8%B5%9B%E5%85%A8%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.2023%E5%B9%B4E%E9%A2%98%E5%AE%8C%E6%95%B4%E8%AE%BE%E8%AE%A1">一.2023年E题完整设计</a></p>
<p><a href="about:blank#%3C1%3E%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88">&lt;1&gt;选择方案</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E5%A4%8D%E4%BD%8D%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务一：实现按键按下复位（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95%E8%BE%B9%E6%A1%86%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务二：实现激光点绕边框一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%85%89%E7%82%B9%E7%BB%95A4%E7%BA%B8%E8%BE%B9%E7%BC%98%E4%B8%80%E5%91%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89">任务三：实现激光点绕A4纸边缘一周（基础部分）</a></p>
<p><a href="about:blank#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E8%BF%BD%E8%B8%AA%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%EF%BC%88%E5%8F%91%E6%8C%A5%E9%83%A8%E5%88%86%EF%BC%89">任务四：实现绿色激光追踪红色激光（发挥部分）</a></p>
<p><a href="about:blank#%3C2%3E%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D">&lt;2&gt;任务分配</a></p>
<p><a href="about:blank#%3C3%3E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">&lt;3&gt;代码分析</a></p>
<p><a href="about:blank#1.stm32%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.stm32上关键源码分析</a></p>
<p><a href="about:blank#I.%E5%9F%BA%E6%9C%AC%E9%83%A8%E5%88%86">I.基本部分</a></p>
<p><a href="about:blank#II.%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81">II.模块代码</a></p>
<p><a href="about:blank#%281%29Timer%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97">(1)Timer——定时器延时函数模块</a></p>
<p><a href="about:blank#%282%29servo_motor%E2%80%94%E2%80%94%E4%BA%91%E5%8F%B0%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97">(2)servo_motor——云台舵机控制模块</a></p>
<p><a href="about:blank#%E2%91%A0%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E7%9A%84%E6%97%8B%E8%BD%AC">①控制舵机的旋转</a></p>
<p><a href="about:blank#%E2%91%A1%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E5%83%8F%E7%B4%A0%E7%82%B9">②控制激光点到达某一像素点</a></p>
<p><a href="about:blank#%E2%91%A2%E4%B8%8E%E4%B8%8A%E4%BD%8D%E6%9C%BAjetson%20nano%E9%80%9A%E8%AE%AF%E6%8E%A5%E6%94%B6%E7%82%B9%E5%9D%90%E6%A0%87">③与上位机jetson<br>nano通讯接收点坐标</a></p>
<p><a href="about:blank#%E2%91%A3%E5%BE%97%E5%88%B0%E4%B8%80%E7%82%B9%E5%9D%90%E6%A0%87%E5%AF%B9%E5%BA%94%E7%9A%84%E8%88%B5%E6%9C%BApwm%E6%B3%A2OC%E5%80%BC">④得到一点坐标对应的舵机pwm波OC值</a></p>
<p><a href="about:blank#%E2%91%A4%E6%8E%A7%E5%88%B6%E6%BF%80%E5%85%89%E7%82%B9%E6%B2%BF%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%B7%A1%E7%BA%BF">⑤控制激光点沿四边形巡线</a></p>
<p><a href="about:blank#III.%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86">III.主函数与中断函数部分</a></p>
<p><a href="about:blank#%281%29%E7%BA%A2%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(1)红色激光云台</a></p>
<p><a href="about:blank#%282%29%E7%BB%BF%E8%89%B2%E6%BF%80%E5%85%89%E4%BA%91%E5%8F%B0">(2)绿色激光云台</a></p>
<p><a href="about:blank#2.jetson%20nano%E4%B8%8A%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2.jetson<br>nano上关键源码分析</a></p>
<p><a href="about:blank#I.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4">I.相机参数的调整</a></p>
<p><a href="about:blank#II.%E5%85%B3%E9%94%AE%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95">II.关键识别算法</a></p>
<p><a href="about:blank#%281%29%E9%93%85%E7%AC%94%E7%BA%BF%E8%AF%86%E5%88%AB%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(1)铅笔线识别及顶点的计算</a></p>
<p><a href="about:blank#%282%29A4%E7%BA%B8%E9%A1%B6%E7%82%B9%E8%AF%86%E5%88%AB%E5%8F%8A%E5%B7%A1%E7%BA%BF%E9%A1%B6%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97">(2)A4纸顶点识别及巡线顶点的计算</a></p>
<p><a href="about:blank#%283%29%E5%8C%BA%E5%88%86%E7%BA%A2%E7%BB%BF%E6%BF%80%E5%85%89">(3)区分红绿激光</a></p>
<p><a href="about:blank#%E4%BA%8C.%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">二.学习资料分享</a></p>
<p><a href="about:blank#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A">&lt;1&gt;学习笔记</a></p>
<p><a href="about:blank#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99%EF%BC%9A">&lt;2&gt;其他资料</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%A4%87%E8%B5%9B%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95">三.备赛阶段记录</a></p>
<p><a href="about:blank#%E5%9B%9B.%E7%94%B5%E8%B5%9B%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD">四.电赛总结及经验教训</a></p>
<p><a href="about:blank#%3C1%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%81%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84%EF%BC%9A">&lt;1&gt;本次比赛作品的不足、改进之处</a></p>
<p><a href="about:blank#%3C2%3E%E6%9C%AC%E6%AC%A1%E6%AF%94%E8%B5%9B%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%EF%BC%9A">&lt;2&gt;本次比赛的经验教训</a></p>
<hr>
<p>“愿大家都少走弯路，在迷茫时看到希望！”</p>
<h3 id="一-2023年E题完整设计"><a href="#一-2023年E题完整设计" class="headerlink" title="一.2023年E题完整设计"></a>一.2023年E题完整设计</h3><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="&lt;1&gt;选择方案"></a>&lt;1&gt;选择方案</h3><h4 id="任务一：实现按键按下复位（基础部分）"><a href="#任务一：实现按键按下复位（基础部分）" class="headerlink" title="任务一：实现按键按下复位（基础部分）"></a>任务一：实现按键按下复位（基础部分）</h4><p>方法①：识别四顶点位置-&gt;连接对角线得到中心点-&gt;PID调节使激光点与中心点重合</p>
<p>方法②：识别四顶点位置-&gt;对角顶点坐标求平均值得中心点位置-&gt;PID调节使重合</p>
<p>方法③：固定所有器件位置，保证各点PWM值不变，得到中心点PWM固定值，开环设定</p>
<h4 id="任务二：实现激光点绕边框一周（基础部分）"><a href="#任务二：实现激光点绕边框一周（基础部分）" class="headerlink" title="任务二：实现激光点绕边框一周（基础部分）"></a>任务二：实现激光点绕边框一周（基础部分）</h4><p>步骤I：激光点由中心点到达边线左上角</p>
<p>步骤II：顺时针绕一圈</p>
<pre><code>    方法①：两点定线，先确定两点坐标，连线确定等分点，使用PID算法在等分点间移动

    方法②：不使用PID，利用与目标点坐标差计算移动方向，每次移动距离为舵机最小精度值

    方法③：求PWM和坐标(x,y)的函数关系（近似线性），直接设定PWM值到达指定点
</code></pre>
<h4 id="任务三：实现激光点绕A4纸边缘一周（基础部分）"><a href="#任务三：实现激光点绕A4纸边缘一周（基础部分）" class="headerlink" title="任务三：实现激光点绕A4纸边缘一周（基础部分）"></a>任务三：实现激光点绕A4纸边缘一周（基础部分）</h4><p>（与任务二区别：矩形放置角度可以倾斜；要区分两矩形宽度以识别A4纸）</p>
<h4 id="任务四：实现绿色激光追踪红色激光（发挥部分）"><a href="#任务四：实现绿色激光追踪红色激光（发挥部分）" class="headerlink" title="任务四：实现绿色激光追踪红色激光（发挥部分）"></a>任务四：实现绿色激光追踪红色激光（发挥部分）</h4><p>方法①：区分红绿色激光并得到坐标-&gt;PID直接跟踪</p>
<h3 id="任务分配"><a href="#任务分配" class="headerlink" title="&lt;2&gt;任务分配"></a>&lt;2&gt;任务分配</h3><p>将上述任务分解成多个要完成的技术，以便分工：</p>
<p>1.硬件平台搭建</p>
<p>2.stm32控制算法：</p>
<p>①PID控制激光点移动到目标点算法（核心）</p>
<p>②舵机以最小分度值移动算法（细微调节）</p>
<p>③给定两点以及等分数计算所有等分点算法（线上移动减少偏差）</p>
<p>④在PID寻点时获取基本点（矩形顶点及中心）PWM值算法</p>
<p>⑤stm32和jetson nano的通信规则设计与数据互传</p>
<p>3.OpenCV识别算法</p>
<p>①识别铅笔线边框：灰度图转换-&gt;阈值分割成二值图-&gt;霍夫直线变换得到直线上两点（非端点）-&gt;从得到的多条直线中筛选去重-&gt;编写“已知两直线上两点求直线交点”算法-&gt;求得四端点</p>
<p>②识别A4纸边框：阈值分割后利用Harris角点检测出A4框的8个顶点-&gt;编写“从8个顶点中识别两两相邻顶点”算法-&gt;求得框中心线4顶点</p>
<p>③区分红绿激光点算法：转换到Hsv色彩空间-&gt;分别设置阈值，在Hsv空间中二值化图像提取红绿色区域以得到激光点坐标  </p>
<p>4.主函数（程序流程）设计</p>
<p>5.电赛报告书写</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="&lt;3&gt;代码分析"></a>&lt;3&gt;代码分析</h3><h4 id="1-stm32上关键源码分析"><a href="#1-stm32上关键源码分析" class="headerlink" title="1.stm32上关键源码分析"></a>1.stm32上关键源码分析</h4><h5 id="I-基本部分"><a href="#I-基本部分" class="headerlink" title="I.基本部分"></a>I.基本部分</h5><p>(1)引脚使用说明</p>
<p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>引脚使用说明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>​    &#x2F;*<br>​    oled.h				GPIOA PIN0&#x2F;1<br>​    bluetooth.h			GPIOA PIN2&#x2F;3<br>​    joystick.h			GPIOA PIN4&#x2F;5 ADC1_CH4&#x2F;5 GPIOB PIN11&#x2F;12&#x2F;13 EXTI12&#x2F;13<br>​    Pwm.h				GPIOA PIN8&#x2F;11 TIM1_CH1&#x2F;4 50hz<br>​    usart.h				GPIOA PIN9&#x2F;10 TX&#x2F;RX Black&#x2F;White<br>​    beep.h				GPIOB PIN14<br>​    led.h				GPIOB PIN15<br>​    Timer.h				TIM2&#x2F;3<br>​    *&#x2F;</p>
<p>(2)头文件声明</p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>头文件声明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>​    #include “public.h”				&#x2F;&#x2F;公用引用函数封装<br>​    &#x2F;&#x2F;#include “bluetooth.h”		&#x2F;&#x2F;蓝牙模块<br>​    #include “oled.h”				&#x2F;&#x2F;OLED显示屏模块<br>​    #include “Pwm.h”				&#x2F;&#x2F;PWM波生成模块<br>​    #include “servo_motor.h”		&#x2F;&#x2F;云台控制函数模块<br>​    #include “joystick.h”			&#x2F;&#x2F;摇杆控制模块<br>​    #include “string.h”				<br>​    #include “Delay.h”				<br>​    #include “Timer.h”				&#x2F;&#x2F;定时器模块<br>​    #include “usart.h”				&#x2F;&#x2F;uart通信模块<br>​    #include “beep.h”				&#x2F;&#x2F;蜂鸣器模块<br>​    #include “led.h”				&#x2F;&#x2F;led灯模块<br>​    #include “dma.h”				&#x2F;&#x2F;dma数据转存模块</p>
<p>(3)全局变量和宏定义声明</p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>全局变量和宏定义声明</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>​    &#x2F;&#x2F;#define OpenLoop_OL		&#x2F;&#x2F;开环实现功能执行<br>​    #define CloseLoop_CL		&#x2F;&#x2F;闭环实现功能执行<br>​<br>    extern float Voltage[2];	&#x2F;&#x2F;ad测量电压值[0.3.3]			&#x2F;&#x2F;ad.c<br>    extern char  USART_RX_INFO[USART_REC_LEN];	&#x2F;&#x2F;uart接收数据	&#x2F;&#x2F;usart.c<br>    extern int x,y;				&#x2F;&#x2F;激光当前坐标					&#x2F;&#x2F;servo_motor.c<br>    extern int Vertex[4][2];	&#x2F;&#x2F;四顶点位置						&#x2F;&#x2F;servo_motor.c<br>    extern int Vertex_Peak_Pos[4][2];<br>    extern int Vertex_A4[4][2];<br>    extern Pwm Center_Pwm;<br>    extern Pwm Peak_Pwm[4];<br>    extern Pwm A4_Pwm[4];</p>
<pre><code>int Programme_Progress=0;					//比赛程序进度
int order=0;								//蓝牙接收到的命令
int Main_Wait_Stop_Sign =1;					//主程序等待标志位
extern int JoyStick_Control_Stop_Sign;		//摇杆控制程序结束标志位
int Get_Depend_Point_Pos_Stop_Sign=1;
int Get_A4_Point_Pos_Stop_Sign=1;
extern int Follow_Track_Stop_Sign;			//矩形寻迹结束标志位
extern int Follow_Point_Stop_Sign;			//绿激光跟随红激光结束标志位
</code></pre>
<h5 id="II-模块代码"><a href="#II-模块代码" class="headerlink" title="II.模块代码"></a>II.模块代码</h5><h6 id="1-Timer——定时器延时函数模块"><a href="#1-Timer——定时器延时函数模块" class="headerlink" title="(1)Timer——定时器延时函数模块"></a>(1)Timer——定时器延时函数模块</h6><p>​<br>​    #include “Timer.h”<br>​<br>    &#x2F;&#x2F;TIM2&#x2F;3</p>
<pre><code>void Timer_Init(void)
&#123;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	
	TIM_InternalClockConfig(TIM2);
	TIM_InternalClockConfig(TIM3);
	
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = 60000 - 1;	//分辨率1us,最大60ms
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);
	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);
	
&#125;

void Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM2,ENABLE); //启动定时器
	while(TIM2-&gt;CNT &lt; xus);
	TIM2-&gt;CNT = 0;
	TIM_Cmd(TIM2,DISABLE); //关闭定时器
&#125;

void Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)Timer_delay_us(1000);
&#125;

//外部中断专用延时函数
void EXIT_LINE_Timer_delay_us(int xus)
&#123;
	TIM_Cmd(TIM3,ENABLE); //启动定时器
	while(TIM3-&gt;CNT &lt; xus);
	TIM3-&gt;CNT = 0;
	TIM_Cmd(TIM3,DISABLE); //关闭定时器
&#125;

void EXIT_LINE_Timer_delay_ms(int xms)
&#123;
	int i=0;
	for(i=0;i&lt;xms;i++)EXIT_LINE_Timer_delay_us(1000);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>在Timer_Init()中开启了两个定时器TIM1&#x2F;2，由Timer_delay_us()和EXIT_LINE_Timer_delay_us()分别使用，分别在中断函数内外使用，<strong>避免重复调用冲突</strong></p>
<h6 id="2-servo-motor——云台舵机控制模块"><a href="#2-servo-motor——云台舵机控制模块" class="headerlink" title="(2)servo_motor——云台舵机控制模块"></a>(2)servo_motor——云台舵机控制模块</h6><h6 id="①控制舵机的旋转"><a href="#①控制舵机的旋转" class="headerlink" title="①控制舵机的旋转"></a>①控制舵机的旋转</h6><p>​<br>​    int Oc_Lp[4]&#x3D;{750,750,750,750};<br>​    int Oc_Vp[4]&#x3D;{763,763,763,763};<br>​    &#x2F;*********************************************************<br>​    函数功能：云台水平方向旋转<br>​    *********************************************************&#x2F;<br>​    void Spinnig_Level(int diff)<br>​    {<br>​    	if(diff&lt;0)<br>​    	{<br>​    		Oc_Lp[0]&#x3D;Oc_L&#x3D;(Oc_L+diff)&lt;660?660:(Oc_L+diff);<br>​    	}<br>​    	else if(diff&gt;0)<br>​    	{<br>​    		Oc_Lp[0]&#x3D;Oc_L&#x3D;(Oc_L+diff)&gt;840?840:(Oc_L+diff);	<br>​    	}<br>​    	TIM_SetCompare1(TIM1,Oc_L);	<br>​    	int i;<br>​    	for(i&#x3D;3;i&gt;0;i–)Oc_Lp[i]&#x3D;Oc_Lp[i-1];<br>​    }</p>
<p><strong>说明：</strong></p>
<p>这里的Oc_Lp存储的是控制舵机的pwm波参数中的OC寄存器中的值，作为舵机运动最基本的函数，<br><em><strong>舵机的控制通过改变pwm波参数中的OC寄存器中的值实现</strong></em><br>。这里定义数组实现记忆功能，可存储前三次的OC值。并通过三元运算符设定上下限，将最终的OC值通过TIM_SetCompare1()设定。</p>
<h6 id="②控制激光点到达某一像素点"><a href="#②控制激光点到达某一像素点" class="headerlink" title="②控制激光点到达某一像素点"></a>②控制激光点到达某一像素点</h6><p>​<br>​    &#x2F;*********************************************************<br>​    函数功能：云台控制激光点到达某一点<br>​    函数参数：目标点的坐标<br>​    *********************************************************&#x2F;<br>​    int x&#x3D;360,y&#x3D;360;		&#x2F;&#x2F;跟随点当前坐标<br>​    int Reach_Pos_CL_Stop_Sign&#x3D;1;<br>​    &#x2F;&#x2F;云台水平方向旋转PID值<br>​    float Level_Kp&#x3D;0.06;<br>​    float Level_Ki&#x3D;0.02;<br>​    float Level_Kd&#x3D;0.01;<br>​    &#x2F;&#x2F;云台竖直方向旋转PID值<br>​    float Vert_Kp&#x3D;0.06;<br>​    float Vert_Ki&#x3D;0.02;<br>​    float Vert_Kd&#x3D;0.01;<br>​    void Reach_Pos_CL(int Target_X,int Target_Y,int Reach_Pos_CL_MODE)<br>​    {<br>​    	int Sign(int num);<br>​    	void Get_Point_Pos(void);<br>​    	int near(int Target_X,int Target_Y);<br>​    	<br>    	int diff_x,diff_y;<br>    	while(Reach_Pos_CL_Stop_Sign)<br>    	{<br>    		Timer_delay_ms(30);<br>    		Get_Point_Pos();<br>    		if(near(Target_X,Target_Y)&lt;&#x3D;6)<br>    		{<br>    			Beep_Times(10,1,NORMAL_MODE);<br>    			break;<br>    		}<br>    		if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; near(Target_X,Target_Y)&gt;60)					&#x2F;&#x2F;用pid计算舵机单位数<br>    		{<br>    			diff_x&#x3D;Pid_Control(Level_Kp,Level_Ki,Level_Kd,Target_X,x,PID_REALIZE);<br>    			diff_y&#x3D;Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,Target_Y,y,PID_REALIZE);<br>    		}<br>    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;MINMIZE_MODE)		&#x2F;&#x2F;以舵机最小分辨率为单位<br>    		{<br>    			diff_x&#x3D;-Sign(x-Target_X);<br>    			diff_y&#x3D;-Sign(y-Target_Y);<br>    		}<br>    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; near(Target_X,Target_Y)&lt;&#x3D;60)					&#x2F;&#x2F;用pid计算舵机单位数<br>    		{<br>    			diff_x&#x3D;-Sign(x-Target_X);<br>    			diff_y&#x3D;-Sign(y-Target_Y);<br>    			Timer_delay_ms(30);<br>    		}<br>    		Spinnig_Level(X_DIR<em>diff_x);<br>    		Spinnig_Vert(Y_DIR</em>diff_y);<br>    		Timer_delay_ms(20);<br>    	}<br>    }</p>
<pre><code>int Sign(int num)
&#123;
	if(num&gt;5)return 1;
	else if(num&lt;-5)return -1;
	else return 0;
&#125;

int my_abs(int a,int b)
&#123;
	return a-b&gt;0?a-b:b-a;
&#125;

int near(int Target_X,int Target_Y)
&#123;
	return my_abs(Target_X,x)+my_abs(Target_Y,y);
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>输入参数：目标点像素坐标；追踪模式（PID【PID与最小精度混合】模式和最小精度值模式）</p>
<p><strong>追踪过程：</strong></p>
<p>——得到当前激光点坐标：Get_Point_Pos()</p>
<p>——如果接近目标点则蜂鸣器鸣叫并退出【near(Target_X,Target_Y)&lt;&#x3D;6，说明当前坐标与目标横纵坐标差之和{“距离”}小于6个像素】</p>
<p>——如果使用PID模式：</p>
<pre><code>    ——“距离”大于60时采用PID算法快速靠近，计算出OC变化值diff_x、diff_y

    ——“距离”小于60时使用最小精度模式缓慢靠近，利用“符号函数sign()”计算diff
</code></pre>
<p>——调用Spinnig_Level()、Spinnig_Level()进行水平和垂直舵机的旋转</p>
<h6 id="③与上位机jetson-nano通讯接收点坐标"><a href="#③与上位机jetson-nano通讯接收点坐标" class="headerlink" title="③与上位机jetson nano通讯接收点坐标"></a>③与上位机jetson nano通讯接收点坐标</h6><p><strong>a.激光点坐标的实时接收</strong></p>
<p>​<br>​    &#x2F;*********************************************************<br>​    函数功能：stm32获取当前激光坐标<br>​    *********************************************************&#x2F;<br>​    void Get_Point_Pos(void)<br>​    {<br>​    	if(USART_RX_INFO[0]&#x3D;&#x3D;’x’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)<br>​    	{<br>​    		x&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;<br>​    	}<br>​    	if(USART_RX_INFO[4]&#x3D;&#x3D;’y’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)<br>​    	{<br>​    		y&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;<br>​    	}<br>​    }</p>
<p><strong>说明：</strong></p>
<p>规定上位机每次发送数据格式为：以#开头，以$结尾；stm32usart模块对接收数据进行解析</p>
<p>上位机坐标数据格式为：x123y456；123、456代表三位坐标值，字符’x’、’y’起定位作用</p>
<p>stm32对接收到的字符坐标进行解析如上</p>
<p><strong>b.特殊坐标接收</strong></p>
<p>​<br>​    &#x2F;&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>高级控制函数(CloseLoop–CL)</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>​    int Vertex_Peak_Pos[4][2];<br>​    int Center_Pos[2];<br>​    Pwm Center_Pwm;<br>​    Pwm Peak_Pwm[4];<br>​    Pwm A4_Pwm[4];<br>​    &#x2F;&#x2F;获取重要点坐标<br>​    void Get_Point_5(void)<br>​    {<br>​    	int i,j;<br>​    	while(1)<br>​    	{<br>​    		for(i&#x3D;0;i&lt;8;i++)<br>​    		{<br>​    			if(USART_RX_INFO[4<em>i]&#x3D;&#x3D;’a’+i)continue;<br>​    			else break;<br>​    		}<br>​    		if(i&#x3D;&#x3D;8)<br>​    		{<br>​    			for(i&#x3D;0;i&lt;4;i++)<br>​    			{<br>​    				for(j&#x3D;0;j&lt;2;j++)Vertex_Peak_Pos[i][j]&#x3D;(USART_RX_INFO[4</em>(2<em>i+j)+1]-‘0’)<em>100+(USART_RX_INFO[4</em>(2</em>i+j)+2]-‘0’)<em>10+(USART_RX_INFO[4</em>(2*i+j)+3]-‘0’);<br>​    			}<br>​    			break;<br>​    		}<br>​    	}<br>​    	<br>    	while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<br>    	<br>    	Center_Pos[0]&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;<br>    	Center_Pos[1]&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;<br>    	Beep_Times(50,5,NORMAL_MODE);<br>    	<br>    }</p>
<p><strong>说明：</strong></p>
<p>这里接收的是铅笔线框四个顶点的坐标和中心点坐标，但是一次发送的数据长度不能太长，这里拆分成两部分接收（数据格式为：axxxbxxxcxxx…hxxx共8组值四个坐标），<br><em><strong>关键在于两部分的衔接</strong></em></p>
<p>while(!(USART_RX_INFO[0]&#x3D;&#x3D;’i’&amp;&amp;USART_RX_INFO[4]&#x3D;&#x3D;’j’));<em><strong>确保收到四个顶点坐标后持续等待中心点坐标的发送</strong></em></p>
<h6 id="④得到一点坐标对应的舵机pwm波OC值"><a href="#④得到一点坐标对应的舵机pwm波OC值" class="headerlink" title="④得到一点坐标对应的舵机pwm波OC值"></a>④得到一点坐标对应的舵机pwm波OC值</h6><p>​<br>​    int sum_num(int *num,int n)<br>​    {<br>​    	int i,sum;<br>​    	for(i&#x3D;sum&#x3D;0;i&lt;n;i++)sum+&#x3D;num[i];<br>​    	return sum;<br>​    }	<br>​    &#x2F;&#x2F;获取目标点pwm值<br>​    void Get_Pwm(int px,int py,Pwm *target_pwm,int n)<br>​    {<br>​    	Reach_Pos_CL(px,py,PID_MODE);<br>​    	target_pwm-&gt;level&#x3D;sum_num(Oc_Lp,n)&#x2F;n;<br>​    	target_pwm-&gt;vert&#x3D;sum_num(Oc_Vp,n)&#x2F;n;<br>​    }</p>
<p><strong>说明：</strong></p>
<p>通过②控制函数控制激光点到达指定点后记录目标点pwm值并返回；Pwm结构体定义如下</p>
<p>​<br>​    typedef struct Pwm{<br>​    	int level;<br>​    	int vert;<br>​    }Pwm;</p>
<p>可以通过改变参数n的值选择是否滤波，4&gt;n&gt;1时进行滤波，取前几次OC值的平均值，不建议滤波</p>
<h6 id="⑤控制激光点沿四边形巡线"><a href="#⑤控制激光点沿四边形巡线" class="headerlink" title="⑤控制激光点沿四边形巡线"></a>⑤控制激光点沿四边形巡线</h6><p>​<br>​    &#x2F;&#x2F;巡线<br>​    void Follow_Track(int Vertex[4][2],int divide_num)<br>​    {<br>​    	int i,j;<br>​    	float sub_l,sub_v;<br>​    	Pwm Vertex_Pwm[4];<br>​    	for(i&#x3D;0;i&lt;4;i++)Get_Pwm(Vertex[i][0],Vertex[i][1],&amp;Vertex_Pwm[i],1);<br>​    	<br>    	for(i&#x3D;0;i&lt;4;i++)<br>    	{<br>    		sub_l&#x3D;(Vertex_Pwm[(i+1)%4].level-Vertex_Pwm[i].level);	&#x2F;&#x2F;下一个顶点与当前顶点pwm之差<br>    		sub_v&#x3D;(Vertex_Pwm[(i+1)%4].vert-Vertex_Pwm[i].vert);	&#x2F;&#x2F;下一个顶点与当前顶点纵坐标之差<br>    		for(j&#x3D;0;j&lt;divide_num;j++)<br>    		{<br>    			Reach_Pos_OL(Vertex_Pwm[i].level+j<em>sub_l&#x2F;divide_num,Vertex_Pwm[i].vert+j</em>sub_v&#x2F;divide_num);<br>    			Timer_delay_ms(200);<br>    		}<br>    		Reach_Pos_OL(Vertex_Pwm[(i+1)%4].level,Vertex_Pwm[(i+1)%4].vert);<br>    		Timer_delay_ms(300);<br>    	}<br>    	<br>    	Beep_Times(50,5,NORMAL_MODE);<br>    }</p>
<p><strong>说明：</strong></p>
<p>输入参数：四边形顺时针顺序顶点坐标、每段等分数divide_num</p>
<p><strong>巡线过程：</strong></p>
<p>——得到四个顶点坐标对应的水平、数值舵机OC值</p>
<p>——在for循环内依次经过四个顶点，视作四个大任务</p>
<pre><code>    ——内部使用for循环分解小任务，根据等分段数divide_num计算等分点横纵pwm值并移动至
</code></pre>
<p>——任务结束鸣叫示意</p>
<h5 id="III-主函数与中断函数部分"><a href="#III-主函数与中断函数部分" class="headerlink" title="III.主函数与中断函数部分"></a>III.主函数与中断函数部分</h5><h6 id="1-红色激光云台"><a href="#1-红色激光云台" class="headerlink" title="(1)红色激光云台"></a>(1)红色激光云台</h6><p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>主函数部分</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>​    &#x2F;&#x2F;重新重启初值还原设置<br>​    void Programme_Reset(void)<br>​    {<br>​    	Beep_Times(1000,1,NORMAL_MODE);<br>​    	Led_Times(1000,1,NORMAL_MODE);<br>​    	Programme_Progress&#x3D;0;<br>​    	<br>    	Main_Wait_Stop_Sign&#x3D;1;<br>    	JoyStick_Control_Stop_Sign&#x3D;1;<br>    	Follow_Track_Stop_Sign&#x3D;1;<br>    	<br>    	Get_A4_Point_Pos_Stop_Sign&#x3D;1;<br>    	Get_Depend_Point_Pos_Stop_Sign&#x3D;1;<br>    }</p>
<pre><code>int main(void)
&#123;	
	//********************初始化程序********************
	Timer_Init();				//定时器初始化
//	BlueToothInit(9600,USART_Parity_No,USART_StopBits_1,USART_WordLength_8b);	//蓝牙初始化
	OLED_Init();				//oled初始化
	Beep_Init();				//蜂鸣器初始化
	Led_Init();					//led灯初始化
	TIM1_PWM_Init(9999,143);	//一周期20ms，分辨率20ms/10000）
	TIM_SetCompare1(TIM1,750);	//对齐角度为90度(1.5ms)
	TIM_SetCompare4(TIM1,763);	//对齐角度为90度(1.5ms)
	uart_init(115200);			//uart1初始化
	JoyStick_Init();			//JoyStick摇杆初始化
			
	//*************************比赛程序部分*************************
	while(1)
	&#123;
		int i;
		//重新重启初值还原设置
		Programme_Reset();
//		Reach_Pos_CL(50,50,PID_MODE);
		
		Axes_Init();
		
//		Follow_Track(Vertex_Peak_Pos,1);
		
		while(Main_Wait_Stop_Sign);
		//摇杆控制
		JoyStick_Control();
</code></pre>
<p>​    		<br>​    &#x2F;&#x2F;#ifdef OpenLoop_OL<br>​    &#x2F;&#x2F;			Follow_Track_OL();<br>​    &#x2F;&#x2F;#endif			<br>​    &#x2F;&#x2F;#ifdef CloseLoop_CL<br>​    &#x2F;&#x2F;		&#x2F;&#x2F;等待上位机发送初始坐标<br>​    &#x2F;&#x2F;		Get_Depend_Point_Pos();<br>​    &#x2F;&#x2F;		&#x2F;&#x2F;环绕正方形顺时针旋转一周<br>​    &#x2F;&#x2F;		while(Get_Depend_Point_Pos_Stop_Sign);<br>​<br>    		&#x2F;&#x2F;Follow_Track_CL(Vertex_Peak_Pos,2,PID_MODE);<br>    		<br>    &#x2F;&#x2F;#endif</p>
<pre><code>		Pwm_Track(Peak_Pwm,1);
		while(Follow_Track_Stop_Sign);
				
		Get_A4_Point_Pos();
		Timer_delay_ms(2000);
//		Follow_Track_CL(Vertex_A4,4,MINMIZE_MODE);
//		Follow_Track(Vertex_A4,4);
		for(i=0;i&lt;4;i++)Get_Pwm(Vertex_A4[i][0],Vertex_A4[i][1],&amp;A4_Pwm[i],1);
		Pwm_Track(A4_Pwm,6);
		while(Get_A4_Point_Pos_Stop_Sign);
		
	&#125;
&#125;
</code></pre>
<p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>中断函数部分</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>​    &#x2F;&#x2F;按键中断函数<br>​    void EXTI15_10_IRQHandler()<br>​    {<br>​    	if (EXTI_GetITStatus(EXTI_Line11) &#x3D;&#x3D; SET)<br>​    	{<br>​    		EXIT_LINE_Timer_delay_ms(10);										<br>​    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖<br>​    		{<br>​    			Beep_Times(50,2,EXIT_LINE_MODE);<br>​    			Reach_Pos_OL(Oc_L,Oc_V);						&#x2F;&#x2F;保持激光当前指向位置<br>​    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开<br>​<br>    			&#x2F;&#x2F;再次按下才退出<br>    			EXIT_LINE_Timer_delay_ms(10);<br>    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;1);		<br>    			EXIT_LINE_Timer_delay_ms(10);										<br>    			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)&#x3D;&#x3D;0);		&#x2F;&#x2F;软件防抖<br>    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11&#x3D;&#x3D;1)); 	&#x2F;&#x2F;等待按键松开<br>    			Beep_Times(50,2,EXIT_LINE_MODE);<br>    			<br>    			EXTI_ClearITPendingBit(EXTI_Line11);<br>    		}<br>    	}<br>    	<br>    	else if (EXTI_GetITStatus(EXTI_Line12) &#x3D;&#x3D; SET)<br>    	{<br>    		EXIT_LINE_Timer_delay_ms(10);										<br>    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖<br>    		{<br>    			Programme_Progress++;<br>    			Beep_Times(500,1,EXIT_LINE_MODE);<br>    			if(Programme_Progress&#x3D;&#x3D;1)<br>    			{<br>    				Main_Wait_Stop_Sign&#x3D;0;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;2)<br>    			{<br>    				JoyStick_Control_Stop_Sign&#x3D;0;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;3)<br>    			{<br>    &#x2F;&#x2F;				Get_Depend_Point_Pos_Stop_Sign&#x3D;0;<br>    				Follow_Track_Stop_Sign&#x3D;0;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;4)<br>    			{<br>    				Get_A4_Point_Pos_Stop_Sign&#x3D;0;<br>    &#x2F;&#x2F;				Follow_Track_Stop_Sign&#x3D;0;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;5)<br>    			{<br>    &#x2F;&#x2F;				Get_A4_Point_Pos_Stop_Sign&#x3D;0;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;6)<br>    			{<br>    				;<br>    			}<br>    			else if(Programme_Progress&#x3D;&#x3D;7)<br>    			{<br>    				;<br>    			}<br>    			else<br>    			{<br>    				Programme_Reset();<br>    			}<br>    			<br>    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开<br>    			EXTI_ClearITPendingBit(EXTI_Line12);<br>    		}<br>    		<br>    	}<br>    	<br>    	else if (EXTI_GetITStatus(EXTI_Line13) &#x3D;&#x3D; SET)<br>    	{<br>    		EXIT_LINE_Timer_delay_ms(10);										<br>    		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)&#x3D;&#x3D;0)		&#x2F;&#x2F;软件防抖<br>    		{<br>    			Beep_Times(50,3,EXIT_LINE_MODE);<br>    			<br>    			Reach_Pos_OL(Center_Pwm.level,Center_Pwm.vert);<br>    			<br>    			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)&#x3D;&#x3D;0); 	&#x2F;&#x2F;等待按键松开</p>
<pre><code>			//再次按下才退出
			EXIT_LINE_Timer_delay_ms(10);
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==1);		
			EXIT_LINE_Timer_delay_ms(10);										
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)==0);		//软件防抖
			while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13==1)); 	//等待按键松开
			Beep_Times(50,3,EXIT_LINE_MODE);
			
			EXTI_ClearITPendingBit(EXTI_Line13);
		&#125;
	&#125;	
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>主函数与中断函数相辅相成，程序整体使用外部中断推进以及实现一些特殊功能（立即复位）；</p>
<p>由于主函数内小功能函数都借助while()循环实现，设置循环标志位Stop_Sign和程序阶段标志位Programme_Progress来推进主函数；</p>
<p>按下GPIOB,GPIO_Pin_12的按键触发中断，Programme_Progress++以及相应的Stop_Sign&#x3D;0，以控制目前运行小功能停止并进入下一阶段；</p>
<p>在程序开始和结束处执行Programme_Reset()函数，重置各标志位实现程序重新运行；</p>
<p><strong>注意：</strong></p>
<p>在中断函数内部涉及到的延时函数统统使用EXIT_LINE_Timer_delay_ms()函数，区别外部使用的Timer_delay_ms()函数，防止调用冲突程序卡死</p>
<h6 id="2-绿色激光云台"><a href="#2-绿色激光云台" class="headerlink" title="(2)绿色激光云台"></a>(2)绿色激光云台</h6><p>​<br>​    &#x2F;&#x2F;绿车<br>​    int r_x&#x3D;0,r_y&#x3D;0;<br>​    void Get_RaG_Point_Pos(void)<br>​    {<br>​    	if(USART_RX_INFO[0]&#x3D;&#x3D;’g’&amp;&amp; USART_RX_INFO[8]&#x3D;&#x3D;’r’&amp;&amp; USART_RX_INFO[4]&#x3D;&#x3D;’y’&amp;&amp; USART_RX_INFO[12]&#x3D;&#x3D;’y’)				&#x2F;&#x2F;检查数据定位是否正确(上位机发送信息为：x123y456)<br>​    	{<br>​    		x&#x3D;(USART_RX_INFO[1]-‘0’)*100+(USART_RX_INFO[2]-‘0’)*10+USART_RX_INFO[3]-‘0’;<br>​    		y&#x3D;(USART_RX_INFO[5]-‘0’)*100+(USART_RX_INFO[6]-‘0’)*10+USART_RX_INFO[7]-‘0’;<br>​    		r_x&#x3D;(USART_RX_INFO[9]-‘0’)<em>100+(USART_RX_INFO[10]-‘0’)<em>10+USART_RX_INFO[11]-‘0’;<br>​    		r_y&#x3D;(USART_RX_INFO[13]-‘0’)<em>100+(USART_RX_INFO[14]-‘0’)<em>10+USART_RX_INFO[15]-‘0’;<br>​    	}<br>​    }<br>​<br>    void G_Follow_R(int Reach_Pos_CL_MODE)<br>    {<br>    	int Sign(int num);<br>    	void Get_RaG_Point_Pos(void);<br>    	int near(int r_x,int Target_Y);<br>    	<br>    	int diff_x,diff_y,dis;<br>    	while(Reach_Pos_CL_Stop_Sign)<br>    	{<br>    		if(x&#x3D;&#x3D;0&amp;&amp;y&#x3D;&#x3D;0)Reach_Pos_OL(750,750);<br>    		Get_RaG_Point_Pos();<br>    		dis&#x3D;near(r_x,r_y);<br>    		if(dis&lt;&#x3D;20)<br>    		{<br>    			Beep_Times(300,1,NORMAL_MODE);<br>    			Led_Times(300,1,NORMAL_MODE);<br>    			continue;<br>    		}<br>    		if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; dis&gt;60)					&#x2F;&#x2F;用pid计算舵机单位数<br>    		{<br>    			Get_RaG_Point_Pos();<br>    			diff_x&#x3D;Pid_Control(Level_Kp,Level_Ki,Level_Kd,r_x,x,PID_REALIZE);<br>    			diff_y&#x3D;Pid_Control(Vert_Kp,Vert_Ki,Vert_Kd,r_y,y,PID_REALIZE);<br>    		}<br>    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;MINMIZE_MODE)		&#x2F;&#x2F;以舵机最小分辨率为单位<br>    		{<br>    			Get_RaG_Point_Pos();<br>    			diff_x&#x3D;-0.5</em>Sign(x-r_x);<br>    			diff_y&#x3D;-0.5</em>Sign(y-r_y);<br>    		}<br>    		else if(Reach_Pos_CL_MODE&#x3D;&#x3D;PID_MODE &amp;&amp; dis&lt;&#x3D;60)					&#x2F;&#x2F;用pid计算舵机单位数<br>    		{<br>    			Get_RaG_Point_Pos();<br>    			diff_x&#x3D;-0.4</em>Sign(x-r_x);<br>    			diff_y&#x3D;-0.4</em>Sign(y-r_y);</p>
<pre><code>		&#125;
		Spinnig_Level(X_DIR*diff_x);
		Spinnig_Vert(Y_DIR*diff_y);
		Timer_delay_ms(20);
	&#125;
&#125;
</code></pre>
<p><strong>说明：</strong></p>
<p>上位机数据格式为：g123y123r123y123，实时传输红绿激光点两个坐标；</p>
<p>执行点到点的跟踪即可，在主函数中不断重复即可，即while(1)G_Follow_R(PID_MODE);</p>
<h4 id="2-jetson-nano上关键源码分析"><a href="#2-jetson-nano上关键源码分析" class="headerlink" title="2.jetson nano上关键源码分析"></a>2.jetson nano上关键源码分析</h4><p><strong>文件说明：</strong></p>
<p>mian_10、main_11、mian_12是测试函数，分别测试<strong>铅笔线识别效果</strong> 、<strong>A4纸识别效果</strong> 、<strong>红绿激光分别识别效果</strong><br>。设置了滑动条供<strong>调参</strong> 使用，确定好参数</p>
<p>q_1、q_2、q_3即为三个问题对应的程序，分别实现<strong>发送铅笔线顶点和中心坐标后实时传输红色激光点坐标</strong><br>、<strong>发送A4纸顶点坐标后实时传输红色激光点坐标</strong> 、<strong>实时传输红色和绿色激光点坐标</strong></p>
<h5 id="I-相机参数的调整"><a href="#I-相机参数的调整" class="headerlink" title="I.相机参数的调整"></a>I.相机参数的调整</h5><p>​<br>​    string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)<br>​    {<br>​       return “nvarguscamerasrc exposurecompensation&#x3D;1 ! video&#x2F;x-raw(memory:NVMM), width&#x3D;(int)” + to_string(capture_width) + “, height&#x3D;(int)” +<br>​           to_string(capture_height) + “, format&#x3D;(string)NV12, framerate&#x3D;(fraction)” + to_string(framerate) +<br>​           “&#x2F;1 ! nvvidconv flip-method&#x3D;” + to_string(flip_method) + “ ! video&#x2F;x-raw, width&#x3D;(int)” + to_string(display_width) + “, height&#x3D;(int)” +<br>​           to_string(display_height) + “, format&#x3D;(string)BGRx ! videoconvert ! video&#x2F;x-raw, format&#x3D;(string)BGR ! appsink”;<br>​    }</p>
<p>这里设置好管道参数，主要调整曝光和饱和度，方便之后线条的检测以及红绿激光的区分</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h5 id="II-关键识别算法"><a href="#II-关键识别算法" class="headerlink" title="II.关键识别算法"></a>II.关键识别算法</h5><h6 id="1-铅笔线识别及顶点的计算"><a href="#1-铅笔线识别及顶点的计算" class="headerlink" title="(1)铅笔线识别及顶点的计算"></a>(1)铅笔线识别及顶点的计算</h6><p><strong>变量解析：</strong></p>
<p>​<br>​    int Find &#x3D; 0, l_x &#x3D; 0, l_y &#x3D; 0, r_x &#x3D; 0, r_y &#x3D; 0;<br>​    int l[2][2],r[2][2],u[2][2],d[2][2];<br>​    int ul[2],ur[2],dl[2],dr[2],ce[2];</p>
<p>Find有效个数标志位，表示找到了几组有效的边上两点；</p>
<p>l_x、l_y、r_x、r_y寻找标志位，为1则分别表示上下左右边未找到有效值的两点值</p>
<p>l[2][2]、r[2][2]、u[2][2]、d[2][2]分别存储上下左右边上两点坐标</p>
<p>ul[2]、ur[2]、dl[2]、dr[2]、ce[2]分别存储最终的顶点和中心点坐标</p>
<p><strong>过程：</strong></p>
<p>——转换成灰度图-&gt;阈值划分成二制图-&gt;霍夫直线检测得到直线并输出直线上两点坐标</p>
<pre><code>    ——设计算法过滤筛选重复直线并存储两点坐标
</code></pre>
<p>​<br>​    for (size_t i &#x3D; 0; i &lt; linesPPHT.size(); i++) {<br>​                    x1 &#x3D; linesPPHT[i][0], y1 &#x3D; linesPPHT[i][1], x2 &#x3D; linesPPHT[i][2], y2 &#x3D; linesPPHT[i][3];<br>​                    line(image, Point(x1, y1), Point(x2, y2), Scalar(0), 1, 8);<br>​<br>                    if (x1 &lt; 150 &amp;&amp; x2 &lt; 150 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !l_x){Find++;l_x &#x3D; (x2 + x1) &#x2F; 2;l[0][0]&#x3D;x1;l[0][1]&#x3D;y1;l[1][0]&#x3D;x2;l[1][1]&#x3D;y2;}<br>                    else if (y1 &lt; 150 &amp;&amp; y2 &lt; 150 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !l_y){Find++;l_y &#x3D; (y1 + y2) &#x2F; 2;u[0][0]&#x3D;x1;u[0][1]&#x3D;y1;u[1][0]&#x3D;x2;u[1][1]&#x3D;y2;}<br>                    else if (x1 &gt; 570 &amp;&amp; x2 &gt; 570 &amp;&amp; myabs(x2 - x1) &lt; 3 &amp;&amp; !r_x){Find++;r_x &#x3D; (x2 + x1) &#x2F; 2;r[0][0]&#x3D;x1;r[0][1]&#x3D;y1;r[1][0]&#x3D;x2;r[1][1]&#x3D;y2;}<br>                    else if (y1 &gt; 570 &amp;&amp; y2 &gt; 570 &amp;&amp; myabs(y1 - y2) &lt; 3 &amp;&amp; !r_y){Find++;r_y &#x3D; (y1 + y2) &#x2F; 2;d[0][0]&#x3D;x1;d[0][1]&#x3D;y1;d[1][0]&#x3D;x2;d[1][1]&#x3D;y2;}<br>                }</p>
<p>linesPPHT是霍夫直线检测函数的输出，linesPPHT.size()表示检测到直线的条数；这里根据直线上两点坐标值大小判断属于四条边的那一条；属于其中一条且之前未存储（标志位为1）（见if语句中的判断）则存储并将找点标志位Find+1；Find&#x3D;&#x3D;4时即寻找结束</p>
<p>——由于霍夫直线检测算法得到的并非顶点而是直线上两点，设计求两直线交点函数</p>
<p>​<br>​    void crossline(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int cross[2])<br>​    {<br>​        cross[0]&#x3D;(y3<em>x4</em>x2-y4<em>x3</em>x2-y3<em>x4</em>x1+y4<em>x3</em>x1-y1<em>x2</em>x4+y2<em>x1</em>x4+y1<em>x2</em>x3-y2<em>x1</em>x3)&#x2F;(x4<em>y2-x4</em>y1-x3<em>y2+x3</em>y1-x2<em>y4+x2</em>y3+x1<em>y4-x1</em>y3);<br>​        cross[1]&#x3D;(-y3<em>x4</em>y2+y4<em>x3</em>y2+y3<em>x4</em>y1-y4<em>x3</em>y1+y1<em>x2</em>y4-y1<em>x2</em>y3-y2<em>x1</em>y4+y2<em>x1</em>y3)&#x2F;(y4<em>x2-y4</em>x1-y3<em>x2+x1</em>y3-y2<em>x4+y2</em>x3+y1<em>x4-y1</em>x3);<br>​    }</p>
<p>输入的(x1,y1)~(x4,y4)是两条直线上四点坐标，输出交点坐标并赋值给cross；</p>
<p>​<br>​    crossline(l[0][0],l[0][1],l[1][0],l[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ul);<br>​    crossline(r[0][0],r[0][1],r[1][0],r[1][1],u[0][0],u[0][1],u[1][0],u[1][1],ur);<br>​    crossline(l[0][0],l[0][1],l[1][0],l[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dl);<br>​    crossline(r[0][0],r[0][1],r[1][0],r[1][1],d[0][0],d[0][1],d[1][0],d[1][1],dr);<br>​<br>    crossline(ul[0],ul[1],dr[0],dr[1],ur[0],ur[1],dl[0],dl[1],ce);</p>
<p>输入之前得到的坐标计算四个顶点值和中心坐标</p>
<p>——向下位机stm32输出坐标</p>
<p>​<br>​    sprintf(m,”#a%03db%03dc%03dd%03de%03df%03dg%03dh%03d$\n”,ul[0],ul[1],ur[0],ur[1],dr[0],dr[1],dl[0],dl[1]);<br>​    uart.sendUart(m);<br>​    usleep(50000);<br>​    sprintf(m,”#i%03dj%03d$\n”,ce[0],ce[1]);<br>​    uart.sendUart(m);</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3601ad1980fa9663fb6eeb2a41f4fbb1.png"></p>
<h6 id="2-A4纸顶点识别及巡线顶点的计算"><a href="#2-A4纸顶点识别及巡线顶点的计算" class="headerlink" title="(2)A4纸顶点识别及巡线顶点的计算"></a>(2)A4纸顶点识别及巡线顶点的计算</h6><p>过程：</p>
<p>——灰度图-&gt;二值化-&gt;角点检测得到角点坐标CornerImg</p>
<pre><code>    ——设计算法过滤筛选得到八个顶点P[8][2]（绝缘胶布内外边形成两个矩形）
</code></pre>
<p>​<br>​    #define MAX_DIS 20<br>​    int Is_Exit(int i, int j)<br>​    {<br>​        int k &#x3D; 0;<br>​        for (k &#x3D; 0; k &lt; Find; k++)<br>​        {<br>​            if (myabs(P[k][0]-i)+ myabs(P[k][1]-j)&lt;MAX_DIS)return 1;<br>​        }<br>​        return 0;<br>​    }</p>
<p>​<br>​    int P[8][2] &#x3D; { 0 };<br>​    int Find &#x3D; 0;<br>​<br>    for (int j &#x3D; 0; j &lt; CornerImg.rows; j++) {<br>        for (int i &#x3D; 0; i &lt; CornerImg.cols; i++) {<br>            if (CornerImg.at<float>(j, i) &gt; 150.0f) {<br>                if (!Is_Exit(i, j))<br>                {<br>                    P[Find][0] &#x3D; i;<br>                    P[Find][1] &#x3D; j;<br>                    Find++;<br>                }<br>            }<br>        }<br>    }</float></p>
<p>Is_Exit()函数遍历已经视作有效的点，如果与当前坐标(i,j)接近则不存储；找到八个有效点退出</p>
<p>——设计根据八个顶点P[8][2]求得巡线四边形的顶点Vertex[4][2]（同一个角的内外顶点的中点）</p>
<p>​<br>​    int Vertex[4][2] &#x3D; { 0 };<br>​    int sign[8] &#x3D; { 0 };<br>​    int i,j,k,dis,min &#x3D; 1000;<br>​    int temp1, temp2;<br>​    for (k&#x3D;0,i &#x3D; 0; i &lt; 8; i++)<br>​    {<br>​        if (sign[i])continue;<br>​        min &#x3D; 2000;<br>​        for (j &#x3D; 0; j &lt; 8; j++)<br>​        {<br>​            if (i &#x3D;&#x3D; j||sign[j])continue;<br>​            dis &#x3D; myabs(P[i][0] - P[j][0]) + myabs(P[i][1] - P[j][1]);<br>​            if (dis&lt; min)<br>​            {<br>​                min &#x3D; dis;<br>​                temp1 &#x3D; i;<br>​                temp2 &#x3D; j;<br>​            }<br>​        }<br>​        sign[temp1] &#x3D; 1;<br>​        sign[temp2] &#x3D; 1;<br>​        Vertex[k][0] &#x3D; (P[temp1][0] + P[temp2][0])&#x2F;2;<br>​        Vertex[k][1] &#x3D; (P[temp1][1] + P[temp2][1])&#x2F;2;<br>​        k++;<br>​    }</p>
<p>这里使用for循环遍历P[8][2]中顶点，将距离最近的两点视为A4纸一个角内外两边的两个顶点，求其中点存储在Vertex[4][2]中</p>
<p>——设计算法使巡线的四个端点按照顺时针传输给下位机，否则巡线顺序错误</p>
<p>​<br>​    int temp;<br>​    &#x2F;&#x2F;先整体按y值大小排序<br>​    for(i&#x3D;0;i&lt;4;i++)<br>​    {<br>​        for(min&#x3D;Vertex[i][1],j&#x3D;k&#x3D;i;j&lt;4;j++)<br>​        {<br>​            if(Vertex[j][1]&lt;&#x3D;min)k&#x3D;j;<br>​        }<br>​        temp&#x3D;Vertex[k][0];<br>​        Vertex[k][0]&#x3D;Vertex[i][0];<br>​        Vertex[i][0]&#x3D;temp;<br>​        temp&#x3D;Vertex[k][1];<br>​        Vertex[k][1]&#x3D;Vertex[i][1];<br>​        Vertex[i][1]&#x3D;temp;<br>​    }<br>​    &#x2F;&#x2F;y值中等的两点按x值排序<br>​    if(Vertex[1][0]&lt;Vertex[2][0])<br>​    {<br>​        temp&#x3D;Vertex[1][0];<br>​        Vertex[1][0]&#x3D;Vertex[2][0];<br>​        Vertex[2][0]&#x3D;temp;<br>​        temp&#x3D;Vertex[2][1];<br>​        Vertex[2][1]&#x3D;Vertex[1][1];<br>​        Vertex[1][1]&#x3D;temp;<br>​    }</p>
<p>​<br>​    if(Vertex[0][0]&amp;&amp; Vertex[0][1]&amp;&amp;Vertex[1][0]&amp;&amp;Vertex[1][1]&amp;&amp;Vertex[3][0]&amp;&amp; Vertex[3][1]&amp;&amp;Vertex[2][0]&amp;&amp; Vertex[2][1])<br>​    {<br>​        sprintf(m,”#k%03dl%03dm%03dn%03do%03dp%03dq%03dr%03d$\n”, Vertex[0][0], Vertex[0][1],Vertex[1][0], Vertex[1][1],Vertex[3][0], Vertex[3][1],Vertex[2][0], Vertex[2][1]);<br>​        u.sendUart(m);<br>​    }</p>
<p><strong>观察任意矩形顶点坐标规律，要顺时针发送，可将y值最小的作为第一个发送，y值最大的第三个发送，介于中间的两点按x值大小判断，x小的最后发送，大的第二个发送</strong></p>
<p>即先整体按y值大小排序，y值中等的两点按x值排序-&gt;排序后按<strong>0<del>1</del>3~2的顺序</strong> 发送坐标</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c04fe11082712c96042da8f7af526c17.png"></p>
<h6 id="3-区分红绿激光"><a href="#3-区分红绿激光" class="headerlink" title="(3)区分红绿激光"></a>(3)区分红绿激光</h6><p><strong>过程如下：</strong></p>
<p>​<br>​    Point color_recognite(Mat image, Scalar Low, Scalar High)<br>​    {<br>​<br>        vector&lt;vector<Point>&gt; g_vContours;<br>        vector<Vec4i> g_vHierarchy;<br>        vector<Mat> hsvSplit;<br>        double maxarea &#x3D; 0;<br>        int maxAreaIdx &#x3D; 0;<br>        Mat g_grayImage, hsv, g_cannyMat_output;</Mat></Vec4i></Point></p>
<pre><code>    cvtColor(image, hsv, COLOR_BGR2HSV);
    split(hsv, hsvSplit);
    equalizeHist(hsvSplit[2], hsvSplit[2]);
    merge(hsvSplit, hsv);
    inRange(hsv, Low, High, g_grayImage);//二值化识别颜色

    //开操作 (去除一些噪点)
    Mat element = getStructuringElement(MORPH_RECT, Size(2, 2));
    morphologyEx(g_grayImage, g_grayImage, MORPH_OPEN, element);

    //闭操作 (连接一些连通域)
    morphologyEx(g_grayImage, g_grayImage, MORPH_CLOSE, element);
    //  Canny(g_grayImage, g_cannyMat_output, 80, 80 * 2, 3);

    // 寻找轮廓
    findContours(g_grayImage, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));

    //假设contours是用findContours函数所得出的边缘点集
    RotatedRect box;
    Point centre;

    if (g_vContours.size() != 0)
    &#123;
        for (int index = 0; index &lt; g_vContours.size(); index++)
        &#123;
            double tmparea = fabs(contourArea(g_vContours[index]));
            if (tmparea &gt; maxarea)
            &#123;
                maxarea = tmparea;
                maxAreaIdx = index;//记录最大轮廓的索引号
            &#125;
        &#125;

        box = minAreaRect(g_vContours[maxAreaIdx]);
        rectangle(image, box.boundingRect(), Scalar(0, 0, 255), 2);
        centre = box.center;
    &#125;
    return centre;
&#125;
</code></pre>
<p>关键是调用inRange()函数HSV色彩空间二值化的阈值上下限设置</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Home_Wood/article/details/88613977" title="OpenCV学习笔记-inRange()阈值操作函数怎么用_cv.inrange函数">OpenCV学习笔记-<br>inRange()阈值操作函数怎么用_cv.inrange函数</a></p>
<p>并设置滑动条调整参数获得经验值</p>
<p><strong>最终评判标准：</strong></p>
<p>激光在绝缘胶布上是能否识别（黑色胶布吸光；通过提高曝光，调参，增大激光功率等可以解决）</p>
<p>红绿激光靠近时能否区分（红绿在HSC空间互斥，更亮的会掩盖另一个；调inRange()参数解决）</p>
<h2 id="二-学习资料分享"><a href="#二-学习资料分享" class="headerlink" title="二.学习资料分享"></a>二.学习资料分享</h2><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="&lt;1&gt;学习笔记"></a>&lt;1&gt;学习笔记</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797?spm=1001.2014.3001.5501" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697?spm=1001.2014.3001.5501" title="图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-CSDN博客">图像识别小车（电源部分）——电赛学习笔记（1）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991?spm=1001.2014.3001.5501" title="图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-CSDN博客">图像识别小车（电机部分）——电赛学习笔记（2）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?spm=1001.2014.3001.5501" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-CSDN博客">图像识别小车（jetson nano部分）——电赛学习笔记（3）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041?spm=1001.2014.3001.5501" title="图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-CSDN博客">图像识别小车（PCB设计）——电赛学习笔记（4）_switch_swq的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399?spm=1001.2014.3001.5501" title="PID控制算法理解_switch_swq的博客-CSDN博客">PID控制算法理解_switch_swq的博客-<br>CSDN博客</a></p>
<h3 id="其他资料"><a href="#其他资料" class="headerlink" title="&lt;2&gt;其他资料"></a>&lt;2&gt;其他资料</h3><p>1.<a target="_blank" rel="noopener" href="https://space.bilibili.com/28143041/?spm_id_from=333.999.0.0" title="唐老师讲电赛的个人空间-唐老师讲电赛个人主页-哔哩哔哩视频">唐老师讲电赛的个人空间-唐老师讲电赛个人主页-<br>哔哩哔哩视频</a></p>
<p>2.电赛资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ehPdgMU8T16tcQXeLU1xaQ?pwd=1234#list/path=%2F" title="电赛资料_免费高速下载|百度网盘-分享无限制 (baidu.com)">电赛资料_免费高速下载|百度网盘-分享无限制<br>(baidu.com)</a>提取码：1234</p>
<p>3.我的“电赛”、“VS Studio”、“cmake”、“opencv”、“makefile”、“linux、操作系统”、“stm32”收藏夹</p>
<p>3.以及上面笔记中所包含信息</p>
<h2 id="三-备赛阶段记录"><a href="#三-备赛阶段记录" class="headerlink" title="三.备赛阶段记录"></a><strong>三.备赛阶段记录</strong></h2><p>7.2.2023</p>
<ul>
<li>问题 <ol>
<li>Nano板子供电5v4A，需求电流较大</li>
<li>实验室现有开关电源模块似乎调不了5v，需自己设计电源模块</li>
<li>作为底层主要负责，如何为项目打下坚实基础</li>
<li>硬件使用有明确目标，如何学习</li>
</ol>
</li>
<li>解决 <ol>
<li>先不考虑电源模块，用适配器及直流电源供电</li>
<li>先把电机控制写好，提供友善接口</li>
<li>先用简单硬件过度，后期转高级的。如电机先用直流后用伺服。先拼起来，再细化雕琢</li>
</ol>
</li>
<li>收获 <ol>
<li>用vscode远程开发jetson，下载remote-ssh插件，ssh jetson@IP地址；快捷键ctrl+o调出要打开页面</li>
</ol>
</li>
</ul>
<p>7.3.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32很多知识忘记，如定时器和A&#x2F;D、D&#x2F;A；是否需要复习，因复习耗时且不一定需要stm32</li>
<li>目前目标尚不明确</li>
</ol>
</li>
<li>解决 <ol>
<li>先将stm32相关知识看完，stm32作为保底</li>
<li>先搭一个蓝牙遥控小车！</li>
</ol>
</li>
<li>收获 <ol>
<li>修好了学长的小车，看到了PID实现双轮平衡小车的现象</li>
<li>学会了MG995型号舵机控制（控制脉冲占空比实现角度控制）</li>
<li>搭建了测试平台（OLED屏、蓝牙、i2c通讯）</li>
<li>搭建了简单的两轮遥控小车，采用直流电机控制，未加入PWM波调速，实现简单的前进、倒退、转弯。</li>
</ol>
</li>
</ul>
<p>7.4.2023</p>
<ul>
<li>问题 <ol>
<li>昨天做的小车电源直接冒烟，因为电源采用两节3.7V锂电池供电，buck升压到12V以匹配LM298N，电流过大</li>
</ol>
</li>
<li>解决 <ol>
<li>暂时给l298n提供5V电压，驱动能力下降，但系统可以运行。以后电源模块之后重新设计或使用小功率电机</li>
</ol>
</li>
<li>收获 <ol>
<li>主要将昨天搭好的小车完善，并加入了测压模块（利用STM32的ADC外设）</li>
<li>复习了stm32相关知识（外部中断，定制器TIM设置，定时器比较OC产生PWM波）</li>
<li>打开了jetson nano的摄像头，它睁开了眼</li>
</ol>
</li>
</ul>
<p>7.5.2023</p>
<ul>
<li>问题 <ol>
<li>编码器旋转无响应，电机也不动了</li>
<li>烧了一个stm32板子，当时接的自制稳压模块，之前都是好的，不知道什么原因</li>
</ol>
</li>
<li>解决 <ol>
<li>重新测试电机是否能正常工作</li>
<li>在小车到达前有时间学习MPU6050，相关姿态轨迹传输算法</li>
</ol>
</li>
<li>收获 <ol>
<li>在jetson nano上跑了例程及自己上传的几张图片</li>
<li>学会了linux的vim的使用</li>
<li>复习了stm32相关知识（定时器IC输入捕获模式）</li>
<li>学会了超声波测距CS100A模块和红外传感模块以及电机编码器部分</li>
</ol>
</li>
</ul>
<p>7.6.2023</p>
<ul>
<li>问题 <ol>
<li>如何解决电机编码器输出波形峰值小，stm32无法接收</li>
<li>Pwm波和电源需供电，不然波形失真</li>
</ol>
</li>
<li>解决 <ol>
<li>昨天电机不转是因为接线不紧，编码器不行是因为输出电压太小，只有0.5v左右</li>
<li>考虑IO口输出模式，不行加电压比较器，ref&#x3D;0.33V</li>
<li>要重新系统性设计电源了，所有信号共地！</li>
</ol>
</li>
<li>收获 <ol>
<li>拼好了大车，发现了诸多问题，舵机控制程序完成</li>
<li>浅浅学了PCB绘制流程</li>
</ol>
</li>
</ul>
<p>7.7.2023</p>
<ul>
<li>问题 <ol>
<li>控制函数太过简陋，后续仍需不断升级</li>
<li>图像识别进度为零</li>
</ol>
</li>
<li>解决 <ol>
<li>《基于opencv的数字图像处理技术》</li>
</ol>
</li>
<li>收获 <ol>
<li>用洞洞板搭建好了电源系统（12V-5V-3.7V），系统完全移植到大车</li>
<li>新车编码器输出足够大，无需放大器，编码器计数正常</li>
</ol>
</li>
</ul>
<p>7.8.2023</p>
<ul>
<li>收获 <ol>
<li>学会在Windows配置OpenCV环境，掌握OpenCV图像视频基本操作以及一些基础知识</li>
<li>PCB绘制进展</li>
</ol>
</li>
</ul>
<p>7.9.2023</p>
<ul>
<li>收获 <ol>
<li>学会在linux中运行调用OpenCV的c++文件（cmake的使用）</li>
<li>学习OpenCV基本数据结构和类的使用</li>
<li>进一步了解VS studio上编译选项配置以及debug和release的区别</li>
</ol>
</li>
</ul>
<p>7.10.2023</p>
<ul>
<li>收获 <ol>
<li>学会OpenCV灰度变换、直方图、边缘检测、霍夫检测直线和圆</li>
</ol>
</li>
</ul>
<p>7.11.2023</p>
<ul>
<li>问题 <ol>
<li>源码在linux上无法运行（OpenCV调用摄像头出问题，采用CMake方法编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>今天下午加晚上未解决</li>
</ol>
</li>
<li>收获 <ol>
<li>学会阈值分割（图像二值化方法）</li>
</ol>
</li>
</ul>
<p>7.12.2023</p>
<ul>
<li>问题 <ol>
<li>C++无法编译成功，Mat类未定义引用（QT上编译）</li>
</ol>
</li>
<li>解决 <ol>
<li>使用python编写运行成功</li>
</ol>
</li>
<li>收获 <ol>
<li>看完特征提取和目标检测（HOG特征+SVM基本流程；LBP特征+级联分类器）</li>
</ol>
</li>
</ul>
<p>7.13.2023</p>
<ul>
<li>问题 <ol>
<li>依旧无法运行以C++运行OpenCV代码</li>
<li>可以运行的OpenCV代码不能直接以videocapture capture(0)的方法获取视频流</li>
</ol>
</li>
<li>解决 <ol>
<li>重新系统性安装OpenCV库并重走CMake流程</li>
<li>将视频流通过管道gstreamer传输</li>
</ol>
</li>
<li>收获 <ol>
<li>学会CMake以及基本编译链接流程</li>
<li>重新安装配置OpenCV4.8.0，成功在jetson nano上运行OpenCV代码</li>
</ol>
</li>
</ul>
<p>7.14.2023</p>
<ul>
<li>问题 <ol>
<li>但运行自己编写的直线检测程序过于卡顿，一秒一帧</li>
<li>蓝牙模块无法正常工作</li>
</ol>
</li>
<li>解决 <ol>
<li>霍夫直线检测运算量大，不使用该算法</li>
<li>调整视频大小及帧率</li>
<li>经检测应是蓝牙模块问题，重新购买</li>
</ol>
</li>
<li>收获 <ol>
<li>使用画好的pcb搭建小车，将全部器件搭载在小车上</li>
</ol>
</li>
</ul>
<p>7.15.2023</p>
<ul>
<li>问题 <ol>
<li>电机控制出错，一边电机不受控制</li>
<li>目前控制算法学的太少，但图像识别进展不够</li>
</ol>
</li>
<li>解决 <ol>
<li>GPIO口选到了下载口JTDI&#x2F;O，换GPIO口控制</li>
<li>先用超声波模块、MPU6050、红外传感等模块写避障、路径记录、寻迹等功能</li>
</ol>
</li>
<li>收获 <ol>
<li>学会jetson nano上的GPIO使用（基本和树莓派一样）</li>
<li>解决了电机的基本控制问题并将电机的四控制线改成了两根</li>
<li>jetson使用电池供电（器件全供地）；实现stm32与jetson nano的usart通信（照搬蓝牙）</li>
</ol>
</li>
</ul>
<p>7.16.2023</p>
<ul>
<li>问题 <ol>
<li>超声波测距模块中断代码写的不好，拔下模块进入while循环等待，系统卡住</li>
<li>拉肚子</li>
</ol>
</li>
<li>解决 <ol>
<li>使用static变量，进入中断模式改为EXTI_Trigger_Rising_Falling…</li>
<li>休息一天（今日中午至明天中午）</li>
</ol>
</li>
</ul>
<p>7.17.2023</p>
<ul>
<li>问题 <ol>
<li>欲添加mpu6050模块，但其与oled、蓝牙、超声波模块冲突（非引脚分配问题）</li>
</ol>
</li>
<li>解决 <ol>
<li>更改方案，debug试试。仍不行</li>
</ol>
</li>
</ul>
<p>7.18.2023</p>
<ul>
<li>问题 <ol>
<li>昨天问题仍然存在</li>
<li>多个中断之间不协调，影响超声波测距精度。以及测角度过于耗时</li>
</ol>
</li>
<li>解决 <ol>
<li>使用江科大自动化的例程代码，简洁明了，解决冲突</li>
<li>更改各个中断优先级，控制mpu6050的使用</li>
</ol>
</li>
<li>收获</li>
</ul>
<p>7.19.2023</p>
<ul>
<li>收获 <ol>
<li>学会PID算法</li>
<li>重新绘制PCB，解决若干问题</li>
</ol>
</li>
</ul>
<p>7.20.2023</p>
<ul>
<li>问题 <ol>
<li>SysTick定时器冲突问题（外部和中断同时调用delay_us函数会卡死）</li>
</ol>
</li>
<li>解决 <ol>
<li>避免了0.1s定时器中断（数据刷新）的SysTick定时函数</li>
</ol>
</li>
<li>收获 <ol>
<li>使用编码器利用PID编写行驶给定长度函数及测速</li>
</ol>
</li>
</ul>
<p>7.21.2023</p>
<ul>
<li>问题 <ol>
<li>后退时编码器反向计数，上限不明确，速度测算出现问题</li>
</ol>
</li>
<li>解决 <ol>
<li>通过TIM_EncoderInterfaceConfig设置编码器反转依旧向上计数</li>
</ol>
</li>
<li>收获 <ol>
<li>编写小车倒车定长距离</li>
</ol>
</li>
</ul>
<p>7.22.2023</p>
<ul>
<li>收获 <ol>
<li>编写小车以恒定速度行驶和拐弯90度算法</li>
</ol>
</li>
</ul>
<p>7.23.2023</p>
<ul>
<li>收获 <ol>
<li>焊好新到的板子</li>
</ol>
</li>
</ul>
<p>7.24.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson配置难，yolo难跑通</li>
<li>要求设计完整程序，在jetson开机时自动执行</li>
</ol>
</li>
<li>解决 <ol>
<li>学习OpenCV备用</li>
<li>学习python或c++可执行文件Linux开机自动执行方法</li>
</ol>
</li>
</ul>
<p>7.25.2023</p>
<ul>
<li>问题 <ol>
<li>采用硬盘直接克隆方式克隆SD卡依旧无法启动jetson nano系统</li>
</ol>
</li>
<li>解决 <ol>
<li>烧录官方镜像文件，成功还原系统。并发现python和C++环境已经配好，之前不会用。解决yolov5摄像头实时检测问题，方案参考亚博论坛。C++也是，g++编译时加上一个参数就行</li>
</ol>
</li>
</ul>
<p>7.26.2023</p>
<ul>
<li>收获 <ol>
<li>看今年电赛器件清单，简单编写完云台代码，购买K210等器材</li>
</ol>
</li>
</ul>
<p>7.27.2023</p>
<ul>
<li>收获 <ol>
<li>简单编写完红外寻迹功能</li>
<li>解决nano开机启动python文件</li>
</ol>
</li>
</ul>
<p>7.28.2023</p>
<ul>
<li>问题 <ol>
<li>分析电赛清单，云台摄像头加激光笔应该涉及到动态物体追踪</li>
</ol>
</li>
<li>解决 <ol>
<li>学习视频目标跟踪</li>
</ol>
</li>
</ul>
<p>7.29.2023</p>
<ul>
<li>问题 <ol>
<li>Stm32定时器资源有限无法满足云台的加入</li>
</ol>
</li>
<li>解决 <ol>
<li>使用pca9685驱动</li>
</ol>
</li>
<li>收获 <ol>
<li>采用stm32管脚重定义解决pca9685驱动的使用问题</li>
</ol>
</li>
</ul>
<p>7.30.2023</p>
<ul>
<li>问题 <ol>
<li>Jetson nano的C++库不包含串口uart相关内容</li>
</ol>
</li>
<li>解决 <ol>
<li>使用其设备&#x2F;dev&#x2F;tthTSH1，研究网上代码</li>
</ol>
</li>
<li>收获 <ol>
<li>编写以及pca9685控制云台函数</li>
</ol>
</li>
</ul>
<p>7.31.2023</p>
<ul>
<li>问题 <ol>
<li>霍夫圆检测一定也不稳定</li>
</ol>
</li>
<li>解决 <ol>
<li>调整参数或使用深度学习识别物体的方法</li>
</ol>
</li>
<li>收获 <ol>
<li>终于解决串口通信问题，实现C++语言的nano和电脑以及stm32通信</li>
<li>完善霍夫圆检测代码，加入uart传输圆心坐标</li>
<li>学会nano开机自启动程序方法</li>
<li>编写stm32的PID点跟踪函数，实现点跟踪</li>
</ol>
</li>
</ul>
<p>8.1.2023</p>
<ul>
<li>问题 <ol>
<li>走定长不精确，大约是设定5cm行驶6cm这个比例</li>
</ol>
</li>
<li>收获 <ol>
<li>编写摇杆控制云台程序</li>
<li>发现之前使用的pid算法全犯了低级错误，本应用float定义PID值结果用了int，修改后大范围应用，各个控制加入PID平稳精确了很多</li>
</ol>
</li>
</ul>
<h2 id="四-电赛总结及经验教训"><a href="#四-电赛总结及经验教训" class="headerlink" title="四.电赛总结及经验教训"></a>四.电赛总结及经验教训</h2><h3 id="本次比赛作品的不足、改进之处"><a href="#本次比赛作品的不足、改进之处" class="headerlink" title="&lt;1&gt;本次比赛作品的不足、改进之处"></a>&lt;1&gt;本次比赛作品的不足、改进之处</h3><p>1.stm32和jetson<br>nano通讯不稳定（可能原因：杜邦线传输能力差、波特率可能设置高了【但低了影响系统处理速度】）（实际原因：while写成了if，导致时机很难对上，通信规则设计失误！）</p>
<p>2.stm32主函数设计不行，没花时间改进，想要重复运行某个程序只能重启，人机交互也不友好</p>
<p>3.比赛报告没有在头脑风暴之后就开始写，导致后期书写太急，不够规范</p>
<p>4.linux操作不熟，开机自启动程序出现问题，且jetson nano上的程序设计缺乏系统性结构性（每问都写了一个程序，而不是整合成一个大的测试程序）</p>
<p>5.所有任务完成太晚，没有留下时间仔细调试调参找问题。而且全流程过一遍后立马就要封箱了，急急忙忙乱改代码导致出现了<strong>意想不到的错误！再给一天就刚好了啊！！！</strong></p>
<h3 id="本次比赛的经验教训"><a href="#本次比赛的经验教训" class="headerlink" title="&lt;2&gt;本次比赛的经验教训"></a>&lt;2&gt;本次比赛的经验教训</h3><p>1.器件准备很重要：比赛发布器件清单后要备齐，最好每个器件都多买几个。以满足比赛器件需求并防止比赛时器件损坏！（本次比赛oled屏、舵机都反复坏过）</p>
<p>2.器件精度很重要：比赛前统计自己所有器件清单，并实测是否可以使用？精度如何？硬件精度不足会直接导致结果无法满足！（本次比赛刚开始使用的舵机为20kg大扭矩低精度，调了一晚PID参数舵机仍然运动不准，最后才发现是精度问题）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/132150694">https://blog.csdn.net/qq_32971095/article/details/132150694</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">PID控制算法理解</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-25 22:44:50" itemprop="dateCreated datePublished" datetime="2023-07-25T22:44:50+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:28:08" itemprop="dateModified" datetime="2025-02-09T14:28:08+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="PID控制算法理解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-简要回顾PID"><a href="#一-简要回顾PID" class="headerlink" title="一.简要回顾PID"></a>一.简要回顾PID</h2><p>*代码：</p>
<pre><code>//**********pid.h**********
#ifndef _PID_H
#define _PID_H
#include &quot;public.h&quot;

#define PID_REALIZE	0	//位置式PID
#define PID_INCREASE 1	//增量式PID

int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode);

#endif
</code></pre>
<p>​<br>​<br>    &#x2F;&#x2F;<strong><strong><strong><strong><strong>pid.c</strong></strong></strong></strong></strong><br>    #include “pid.h”</p>
<pre><code>//速度环控制
int Pid_Control(float kp,float ki,float kd,int Target_Num,int Current_Num,int PID_Mode)
&#123;
	int Pid_Num=0;		//返回的控制值
	
	static float Error_k=0;
	static float Error_k1=0;
	static float Error_k2=0;
	
	Error_k=Target_Num-Current_Num;
	Error_k1=Error_k-Error_k1;
	
	if(PID_Mode==PID_INCREASE)
	&#123;
		Error_k2=Error_k-2*Error_k1+Error_k2;
		Pid_Num=kp*Error_k+ki*Error_k2+kd*Error_k1;
	&#125;
	
	else if(PID_Mode==PID_REALIZE)
	&#123;
		Pid_Num=kp*Error_k+kd*Error_k1;
	&#125;

	Error_k2=Error_k1;
	Error_k1=Error_k;

	return Pid_Num;
&#125;
</code></pre>
<p>*所需参数：KP&#x2F;KI&#x2F;KD&#x2F;当前值Curr_Num</p>
<p>*返回值：Pid_Num（根据实际情境确定其物理意义，比如可以是增量：如控制电机转速，Pid_Num为增量，可代表增加的电压值等；也可以是直接确定值：如控制小车行进距离，Pid_Num代表当前小车速度）</p>
<p>*位置式PID和增量式PID区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/89508034" title="位置式PID与增量式PID区别浅析">位置式PID与增量式PID区别浅析</a></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二-PID参数意义"><a href="#二-PID参数意义" class="headerlink" title="二.PID参数意义"></a>二.PID参数意义</h2><p>评估指标：最大超调量、上升时间、静差（稳定、准确、快速）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f816706c1aa1692d006fa201b2e511c2.png"></p>
<p> PID三参数：P用于提高响应速度，I减小静差、D减小静差</p>
<p>在实践生产工程中，不同的控制系统对控制器效果的要求不一样。比如平衡车、倒立摆对系统的快速性要求很高,响应太慢会导致系统失控。智能家居里面的门窗自动开合系统,对快速性要求就不高,但是对稳定性和准确性的要求就很高,所以需要严格控制系统的超调量和静差。</p>
<p>所以PID参数在不同的控制系统中是不一样的。只要我们理解了每个PID参数的作用,我们就可以应对工程中的各种项目的PID参数整定了。</p>
<p> 位置控制的调节经验可以总结为：先只使用P控制，增大P系数至系统震荡之后加入微分控制以增大阻尼,消除震荡之后再根据系统对响应和静差等的具体要求，调节P 和<br>I 参数。</p>
<p>一般而言,一个控制系统的控制难度,一般取决于系统的转动惯量和对响应的速度要求等。转动惯量越小、对响应速度要求越低, PID参数就越不敏感。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131927399">https://blog.csdn.net/qq_32971095/article/details/131927399</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（PCB设计）——电赛学习笔记（4）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-25 22:01:44" itemprop="dateCreated datePublished" datetime="2023-07-25T22:01:44+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:26:18" itemprop="dateModified" datetime="2025-02-09T14:26:18+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（PCB设计）——电赛学习笔记（4）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88PCB%E8%AE%BE%E8%AE%A1%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>540</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习来源：B站唐老师讲电赛——PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zg41127BV/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="PCB设计极速入门，立创EDA+ALTIUM DESIGNER 10.0_哔哩哔哩_bilibili">PCB设计极速入门，立创EDA+ALTIUM<br>DESIGNER<br>10.0_哔哩哔哩_bilibili</a></p>
<p>一.设计过程</p>
<p>使用嘉立创EDA加Altium Designer联合设计</p>
<p>1.嘉立创EDA：原理图绘制；器件选型；PCB生成；</p>
<p>ICEDA操作：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f20d7d97b76a22bfbc89dc11ba4cd542.png"></p>
<p>生成的pcd文件和原理图-导出-Altium Designer文件；转至 Altium Designer操作</p>
<p>2.Altium Designer：基础操作；使用规则（右键-设计-规则-desgin rules右键-导入规则-类型全选-<br>寻找规则文件）；字体大小调节（任意字右键-查找相似对象-text height-same-应用-修改text height）；shift s-DSD-<br>shift s-清除（右下角）；注意各个板层（顶层、底层；顶层走不通打过孔底层走；过孔尽量不经过焊盘）</p>
<p>调整好后新建PCB工程-右键添加现有文件-保存工程</p>
<p>走线（TAB键调出参数）</p>
<p>覆铜（放置多边形平面）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42fa1ac446e75661bc31d493a6a28d3c.png"></p>
<p> 打过孔</p>
<p>注意事项：芯片电源引脚加电容滤纹波</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c5d70666df4ea8e0417e843702022b96.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131583041">https://blog.csdn.net/qq_32971095/article/details/131583041</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/18/%E9%9A%8F%E7%AC%94/%E6%80%9D%E4%B9%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/18/%E9%9A%8F%E7%AC%94/%E6%80%9D%E4%B9%A1/" class="post-title-link" itemprop="url">思乡</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-18 19:53:00" itemprop="dateCreated datePublished" datetime="2023-07-18T19:53:00+08:00">2023-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:43:57" itemprop="dateModified" datetime="2025-02-09T14:43:57+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          
            <span id="/2023/07/18/%E9%9A%8F%E7%AC%94/%E6%80%9D%E4%B9%A1/" class="post-meta-item leancloud_visitors" data-flag-title="思乡" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/18/%E9%9A%8F%E7%AC%94/%E6%80%9D%E4%B9%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/18/%E9%9A%8F%E7%AC%94/%E6%80%9D%E4%B9%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>668</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    晨醒时分，做了一个梦，梦到我回家了，第一件事便是担心起妹妹的教育，毕竟已经快整整半年没回家了，但我一直挂念着我那可爱的妹妹，担心她会沉迷电子产品之类的。回到加看到妹妹在玩平板，妈妈还告诉我，爸爸教妹妹在平板上打牌，我觉得这样不行，决定吃完饭理论一下。吃完饭，我找到了爸爸：</p>
<p>​    “这样不行把，让她这样玩游戏，特别是这种带赌的。”</p>
<p>​    “你讲讲怎么不行。”</p>
<p>​    “她现在玩这个，等到上小学，就玩那种带抽的游戏，那上边都有一个转盘，花多少钱才能抽一次。”</p>
<p>​    “那你跟我讲讲要花多少钱。”</p>
<p>​    “能花~<del>200吧~</del>”</p>
<p>​    “嗯，200”</p>
<p>​    “毕竟我们还靠你养老呢”，爸爸带开玩笑地说。</p>
<p>​    “有的人自认为自己聪明，就感觉其他人都很笨”</p>
<p>​    “有的时候不应该给孩子太大压力，不然反而教不好”</p>
<p>​    突然我忍不住了，泪如泉涌，我想起了很多事，久久不能平静。</p>
<p>​    “不应该给孩子太大压力”，让我想起了我的小时候，我的小学及以前。我家是慈父严母型，小时候爸爸管我很松，带我玩各种东西，我妈不让玩的电脑游戏爸爸还特许了，想起小时候刚学写字，连拼音带错字地写小纸条“玩完这把让我玩一会”给正在电脑上下棋的爸爸……小时候的时光真美好啊，想起我也是那么小的时候，曾经睡过电脑房的折叠床上，害怕一切黑暗的地方，用被子衣服堵住缝隙，把床下的东西往外移以堵住下边。童年真是一段美好的记忆…“靠我养老”其实是妈妈无奈妹妹总是调皮曾经说过的玩笑话，但却让我感受到了信任与支持与责任，一个人游学远方，路漫漫…最后一句话让我想到了自己，总是嫌弃他人，确实有些过分，毁了正常的思绪…</p>
<p>​    独在异乡为异客，每逢佳节倍思亲。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" class="post-title-link" itemprop="url">OpenCV学习笔记——《基于OpenCV的数字图像处理》</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-08 23:25:36" itemprop="dateCreated datePublished" datetime="2023-07-08T23:25:36+08:00">2023-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 15:36:12" itemprop="dateModified" datetime="2025-02-09T15:36:12+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/07/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" class="post-meta-item leancloud_visitors" data-flag-title="OpenCV学习笔记——《基于OpenCV的数字图像处理》" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%E2%80%94%E2%80%94%E3%80%8A%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>42k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>38 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>源码下载：<a target="_blank" rel="noopener" href="https://29.s.bookln.cn/q?c=120EL4LP111&sh=sh&vt_=1688811733923#1688811735786" title="下载资源包 (bookln.cn)">下载资源包<br>(bookln.cn)</a></strong></p>
<p><strong>常用函数库：</strong></p>
<p>**         英文：**<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/" title="OpenCV:
OpenCV modules">OpenCV: OpenCV modules</a></p>
<p>**         中文：**<a target="_blank" rel="noopener" href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/index.html" title="Welcome to opencv documentation! — OpenCV 2.3.2 documentation">Welcome to opencv documentation! — OpenCV 2.3.2<br>documentation</a></p>
<p><strong>jetson nano上的OpenCV使用：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</p>
<p><strong>学习OpenCV的推荐网站和文章：</strong></p>
<p><a target="_blank" rel="noopener" href="https://learnopencv.com/getting-started-with-opencv/" title="Getting Started with OpenCV | LearnOpenCV">Getting Started with OpenCV | LearnOpenCV</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spmallick/learnopencv" title="spmallick&#x2F;learnopencv:
Learn OpenCV : C++ and Python Examples (github.com)">spmallick&#x2F;learnopencv: Learn OpenCV : C++ and Python Examples<br>(github.com)</a></p>
<p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">一.图像相关知识</a></p>
<p><a href="about:blank#%E4%BA%8C.opencv%E7%AE%80%E4%BB%8B">二.opencv简介</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%EF%BC%88VS2019%EF%BC%89%E3%80%81%E6%BA%90%E7%A0%81%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%EF%BC%88CMake%EF%BC%89%E3%80%81%E8%B0%83%E7%94%A8%E5%8A%A8%2F%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81cv%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81OpenCV%20API%E7%89%B9%E7%82%B9%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3InputArray%2FOutputArray%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81OpenCV%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81HighGui%E6%A8%A1%E5%9D%97%EF%BC%89">&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV<br>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">&lt;2&gt;示例代码：</a></p>
<p><a href="about:blank#1.%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%9A">1.展示图片：</a></p>
<p><a href="about:blank#2.%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91">2.播放视频</a></p>
<p><a href="about:blank#3.%E6%BB%91%E5%8A%A8%E6%9D%A1%E4%BD%BF%E7%94%A8%EF%BC%9A">3.滑动条使用：</a></p>
<p><a href="about:blank#4.%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%EF%BC%9A">4.鼠标事件响应：</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B%EF%BC%9A">&lt;3&gt;练手：</a></p>
<p><a href="about:blank#1.%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4">1.打开摄像头</a></p>
<p><a href="about:blank#2.%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%8C%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%9A%82%E5%81%9C%2F%E6%92%AD%E6%94%BE">2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</a></p>
<p><a href="about:blank#%3C4%3Elinux%E4%B8%8A%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%EF%BC%9A%E5%8F%82%E8%80%83%EF%BC%9ALinux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8CC%2B%2B%20OpenCV%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3_linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%A5%BDopencv%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%A0%E8%BD%BD_Adenialzz%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2">&lt;4&gt;linux上编译运行：参考：Linux下编译、链接、加载运行C++<br>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客</a></p>
<p><a href="about:blank#%E4%B8%89.OpenCV%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6">三.OpenCV基本数据结构和基本组件</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%83%8F%E5%AE%B9%E5%99%A8Mat%E7%B1%BB%EF%BC%9B%E7%82%B9Point%E7%B1%BB%EF%BC%9B%E9%A2%9C%E8%89%B2Scalar%E7%B1%BB%EF%BC%9B%E5%B0%BA%E5%AF%B8Size%E7%B1%BB%EF%BC%9B%E7%9F%A9%E5%BD%A2Rect%E7%B1%BB%EF%BC%9B%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2RotatedRect%E7%B1%BB%EF%BC%9B%E5%9B%BA%E5%AE%9A%E5%90%91%E9%87%8FVec%E7%B1%BB%EF%BC%9B%E5%A4%8D%E6%95%B0%E7%B1%BBcomplexf%EF%BC%89">&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</a></p>
<p><a href="about:blank#%C2%A0%3C2%3E%E7%BB%83%E6%89%8B%E4%BB%A3%E7%A0%81"> &lt;2&gt;练手代码</a></p>
<p><a href="about:blank#1.Mat%E7%B1%BB%E6%93%8D%E4%BD%9C">1.Mat类操作</a></p>
<p><a href="about:blank#2.%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E6%B5%81%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2">2.摄像头图像流极坐标变换</a></p>
<p><a href="about:blank#3.%E8%AF%BB%E5%8F%96%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0RGB%E5%80%BC%EF%BC%88%E5%B7%A6%E9%94%AE%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%B8%85%E7%A9%BA%EF%BC%89">3.读取图像像素RGB值（左键显示，右键清空）</a></p>
<p><a href="about:blank#4.%E5%88%9B%E5%BB%BA%E4%B8%80%E5%AE%9A%E5%B0%BA%E5%AF%B83%E9%80%9A%E9%81%93RGB%E5%9B%BE%E5%83%8F%EF%BC%8C%E5%B9%B6%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE%E5%85%B6%E5%83%8F%E7%B4%A0%E5%80%BC%EF%BC%8C%E5%B9%B6%E7%BB%98%E5%88%B6%E4%B8%80%E7%BB%BF%E8%89%B2%E5%B9%B3%E9%9D%A2">4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">四.数字图像灰度变换与空间滤波</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%EF%BC%9A%E7%BA%BF%E6%80%A7%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%EF%BC%9B%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%9A%E6%A6%82%E7%8E%87%E3%80%81%E7%B4%AF%E8%AE%A1%EF%BC%89">&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</a></p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">1.灰度变换函数</a></p>
<p><a href="about:blank#2.%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88%E6%A6%82%E7%8E%87%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%89%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0">2.直方图（概率直方图）绘制函数</a></p>
<p><a href="about:blank#%E4%B8%83.%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2">七.图像分割</a></p>
<p><a href="about:blank#%3C1%3E%EF%BC%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%EF%BC%9A%E7%AE%97%E5%AD%90%EF%BC%9A%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%EF%BC%88Sobel%2FPrewitt%2FRoberts%EF%BC%89%E3%80%81%E4%BA%8C%E9%98%B6%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%2FLOG%2FCanny%EF%BC%89%E3%80%81%E6%B7%B7%E5%90%88%EF%BC%9B%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%EF%BC%88%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%EF%BC%89%EF%BC%9A%E7%9B%B4%E7%BA%BF%EF%BC%89">&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</a></p>
<p><a href="about:blank#%EF%BC%88%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%A3%80%E6%B5%8B%E3%80%90%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E3%80%91%EF%BC%9A%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%EF%BC%89">（几何形状检测【霍夫变换】：直线、圆）</a></p>
<p><a href="about:blank#%EF%BC%88%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E3%80%90%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%91%EF%BC%9A%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E3%80%90OTSU%E3%80%81%E4%B8%89%E8%A7%92%E6%B3%95%E3%80%91%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</a></p>
<p><a href="about:blank#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">​编辑<br>&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%92%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B">1.霍夫直线变换和霍夫圆检测</a></p>
<p><a href="about:blank#2.OTSU%E6%96%B9%E6%B3%95%E5%92%8C%E4%B8%89%E8%A7%92%E6%B3%95%E6%B1%82%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC">2.OTSU方法和三角法求全局阈值</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%83%E6%89%8B">&lt;3&gt;练手</a></p>
<p><a href="about:blank#1.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8">1.边缘检测二阶导数算子使用</a></p>
<p><a href="about:blank#2.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%E5%8F%8A%E9%9C%8D%E5%A4%AB%E5%9C%86%E7%9A%84%E6%A3%80%E6%B5%8B">2.霍夫直线变换及霍夫圆的检测</a></p>
<p><a href="about:blank#3.linux%EF%BC%88ubuntu18%EF%BC%89%E4%B8%8A%E5%AE%9E%E7%8E%B0%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%EF%BC%88%E5%8F%AF%E8%B0%83%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89">3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</a></p>
<p><a href="about:blank#4.%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%EF%BC%88OTSU%2F%E4%B8%89%E8%A7%92%E6%B3%95%2F%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%EF%BC%89">4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</a></p>
<p><a href="about:blank#5.%E8%AF%86%E5%88%AB%E8%BD%A6%E9%81%93%EF%BC%88%E4%BA%8C%E5%80%BC%E5%8C%96%E3%80%81%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E3%80%81%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E5%8F%98%E6%8D%A2%EF%BC%89">5.识别车道（二值化、边缘检测、霍夫直线变换）</a></p>
<p><a href="about:blank#%E4%B9%9D.%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%92%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B">九.特征提取和目标检测</a></p>
<p>[&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-<br>LIKE）（分类：SVM&#x2F;级联分类器）](about:blank#%3C1%3E%EF%BC%88%E7%89%B9%E5%BE%81%EF%BC%9AHOG%2FLBP%2FHAAR-<br>LIKE%EF%BC%89%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%9ASVM%2F%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%89)</p>
<p><a href="about:blank#%3C2%3E%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">&lt;2&gt;示例代码</a></p>
<p><a href="about:blank#1.HOG%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%2BSVM">1.HOG特征提取+SVM</a></p>
<p>[2.获取LBP&#x2F;MB-LBP特征函数](about:blank#2.%E8%8E%B7%E5%8F%96LBP%2FMB-<br>LBP%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0)</p>
<p><a href="about:blank#3.cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E4%BD%BF%E7%94%A8">3.cascade级联分类器使用</a></p>
<hr>
<h2 id="一-图像相关知识"><a href="#一-图像相关知识" class="headerlink" title="一.图像相关知识"></a>一.图像相关知识</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb52f259aeff1a793a7899f7f1678e8e.jpeg"></p>
<h2 id="二-opencv简介"><a href="#二-opencv简介" class="headerlink" title="二.opencv简介"></a>二.opencv简介</h2><h5 id="（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV"><a href="#（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动-静态库、cv命名空间、OpenCV" class="headerlink" title="&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV"></a>&lt;1&gt;（主体模块、环境变量配置（VS2019）、源码手动编译（CMake）、调用动&#x2F;静态库、cv命名空间、OpenCV</h5><p>API特点、数据内部接口InputArray&#x2F;OutputArray、错误处理、OpenCV头文件、HighGui模块）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be8b3f267f375a33f3365797cbf719bd.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7637aa7bab9d022a85a835b6b07b0818.jpeg"></p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="&lt;2&gt;示例代码："></a>&lt;2&gt;示例代码：</h5><h6 id="1-展示图片："><a href="#1-展示图片：" class="headerlink" title="1.展示图片："></a>1.展示图片：</h6><p>​<br>​    int main()<br>​    {<br>​    	namedWindow(“lena”, WINDOW_NORMAL);<br>​    	&#x2F;&#x2F;setWindowProperty(“lena”, WND_PROP_FULLSCREEN, WINDOW_FULLSCREEN);<br>​    	setWindowTitle(“lena”, “Lena经典图像窗口”);<br>​    	&#x2F;&#x2F;resizeWindow(“lena”, 400, 300);<br>​    	&#x2F;&#x2F;moveWindow(“lena”, 0, 0);<br>​    	createTrackbar(“t1”, “lena”, NULL, 10, NULL, NULL);<br>​    	Mat img &#x3D; imread(“lena512color.tiff”); &#x2F;&#x2F;读取图像<br>​    	if (img.empty()) {<br>​    		return -1; &#x2F;&#x2F;如果读取图像失败，则返回<br>​    	}<br>​    	imshow(“lena”, img); &#x2F;&#x2F;显示图像<br>​    	waitKey(0); &#x2F;&#x2F;等待用户输入<br>​        std::cout &lt;&lt; “Hello World!\n”;<br>​    }</p>
<h6 id="2-播放视频"><a href="#2-播放视频" class="headerlink" title="2.播放视频"></a>2.播放视频</h6><p>​<br>​    void PlayVideo()<br>​    {<br>​    	cv::VideoCapture capture(“D:&#x2F;files&#x2F;picture and video&#x2F;C0056.MP4”);<br>​    	int nWidth &#x3D; capture.get(CAP_PROP_FRAME_WIDTH); &#x2F;&#x2F;视频图像宽度<br>​    	int nHeight &#x3D; capture.get(CAP_PROP_FRAME_HEIGHT); &#x2F;&#x2F;视频图像高度<br>​    	double dblFrameRate &#x3D; capture.get(CAP_PROP_FPS); &#x2F;&#x2F;视频帧率<br>​    	double dblFrameCnt &#x3D; capture.get(CAP_PROP_FRAME_COUNT); &#x2F;&#x2F;视频总帧数<br>​    	double dblStartFrames &#x3D; dblFrameCnt &#x2F; 2; &#x2F;&#x2F;播放起始帧数<br>​    	capture.set(CAP_PROP_POS_FRAMES, dblStartFrames); &#x2F;&#x2F;从视频中间开始播放<br>​<br>​    	cv::namedWindow(“video”,0 );<br>​    	resizeWindow(“video”, 800, 600);<br>​<br>​    	while (capture.isOpened()) {<br>​    		Mat frame;<br>​    		capture &gt;&gt; frame;<br>​    		if (frame.empty()) {<br>​    			break;<br>​    		}<br>​    		imshow(“video”, frame);<br>​    		waitKey(10);<br>​    	}<br>​    }</p>
<h6 id="3-滑动条使用："><a href="#3-滑动条使用：" class="headerlink" title="3.滑动条使用："></a>3.滑动条使用：</h6><p>​<br>​    滑动条的使用实例<br>​    const int g_nMaxAlphaValue &#x3D; 100; &#x2F;&#x2F;Alpha值的最大值<br>​    int g_nCurAlphaValue;   &#x2F;&#x2F;当前滑动条对应的值<br>​    Mat g_srcImg1; &#x2F;&#x2F;第1张图像<br>​    Mat g_srcImg2; &#x2F;&#x2F;第2张图像<br>​    Mat g_mixImg;  &#x2F;&#x2F;混合图像<br>​    const char cszWindowName[] &#x3D; “mix”;<br>​    &#x2F;&#x2F;拖动滑动条的响应函数<br>​    void on_Trackbar(int, void *)<br>​    {<br>​    	&#x2F;&#x2F;求出当前alpha值相对于最大值的比例<br>​    	double dblAlphaValue &#x3D; double(g_nCurAlphaValue)&#x2F;double(g_nMaxAlphaValue);<br>​    	&#x2F;&#x2F;则beta值为1减去alpha值<br>​    	double dblBetaValue &#x3D; 1.0 - dblAlphaValue;<br>​    	&#x2F;&#x2F;根据alpha和beta的值，对两张图像进行线性混合<br>​    	addWeighted(g_srcImg1, dblAlphaValue, g_srcImg2, dblBetaValue, 0.0, g_mixImg);<br>​    	&#x2F;&#x2F;显示混合图像的效果<br>​    	imshow(cszWindowName, g_mixImg);<br>​    	if (0 &#x3D;&#x3D; g_nCurAlphaValue) {<br>​    		imwrite(“mix0.jpg”, g_mixImg);<br>​    	}<br>​    	if (50 &#x3D;&#x3D; g_nCurAlphaValue) {<br>​    		imwrite(“mix50.jpg”, g_mixImg);<br>​    	}<br>​    	if (100 &#x3D;&#x3D; g_nCurAlphaValue) {<br>​    		imwrite(“mix100.jpg”, g_mixImg);<br>​    	}<br>​    }<br>​<br>​    int main(int argc, char ** argv)<br>​    {<br>​    	&#x2F;&#x2F;加载图像 (两图像的尺寸需相同)<br>​    	g_srcImg1 &#x3D; imread(“lenna.bmp”, IMREAD_COLOR);<br>​    	if (g_srcImg1.empty()) {<br>​    		std::cout &lt;&lt; “读取第1张图像失败” &lt;&lt; std::endl;<br>​    		return -1;<br>​    	}<br>​    	g_srcImg2 &#x3D; imread(“tiffany.bmp”, IMREAD_COLOR);<br>​    	if (g_srcImg2.empty()){<br>​    		std::cout &lt;&lt; “读取第2张图像失败” &lt;&lt; std::endl;<br>​    		return -1;<br>​    	}<br>​    	&#x2F;&#x2F; 设置滑动条的初值为70<br>​    	g_nCurAlphaValue &#x3D; 0;<br>​<br>​    	&#x2F;&#x2F;创建窗口，自动调整大小<br>​    	namedWindow(“mix”, WINDOW_AUTOSIZE);<br>​    	&#x2F;&#x2F;在创建的窗体中创建一个滑动条控件<br>​    	char TrackbarName[50];<br>​    	sprintf_s(TrackbarName, “透明度 %d”, g_nMaxAlphaValue);<br>​    	createTrackbar(TrackbarName, cszWindowName, &amp;g_nCurAlphaValue, g_nMaxAlphaValue, on_Trackbar);<br>​    	&#x2F;&#x2F;调用一次回调函数，以显示图像<br>​    	on_Trackbar(g_nCurAlphaValue, 0);<br>​    	waitKey(0);<br>​    	return 0;<br>​    }</p>
<h6 id="4-鼠标事件响应："><a href="#4-鼠标事件响应：" class="headerlink" title="4.鼠标事件响应："></a>4.鼠标事件响应：</h6><p>​<br>​    Rect g_rectangle; &#x2F;&#x2F;记录要绘制的矩形位置<br>​    bool g_bDrawingBox &#x3D; false;&#x2F;&#x2F;是否进行绘制<br>​    RNG g_rng(12345);  &#x2F;&#x2F;随机数对象<br>​    const String strWndName &#x3D; “MouseWnd”;<br>​    void DrawRactangle(Mat &amp; img, Rect rect)<br>​    {<br>​    	&#x2F;&#x2F;每次绘制矩形的颜色都是随机产生的<br>​    	rectangle(img, rect, Scalar(g_rng.uniform(0, 255), <br>​    		g_rng.uniform(0, 255), g_rng.uniform(0, 255)), 4);<br>​    }<br>​    void onMouseCallback(int event, int x, int y, int flags, void * param)<br>​    {<br>​    	&#x2F;&#x2F;将画矩形的图像作为参数传入回调函数<br>​    	Mat &amp;image &#x3D; <em>(Mat</em>)param;<br>​    	switch (event)<br>​    	{<br>​    		&#x2F;&#x2F;鼠标移动时改变窗口的大小<br>​    	case EVENT_MOUSEMOVE:<br>​    		&#x2F;&#x2F;如果g_bDrawingBox为真，则记录矩形信息到g_rectangle中<br>​    		if (g_bDrawingBox) {<br>​    			g_rectangle.width &#x3D; x - g_rectangle.x;<br>​    			g_rectangle.height &#x3D; y - g_rectangle.y;<br>​    		}<br>​    		break;<br>​    		&#x2F;&#x2F;左键按下时记录窗口的起始位置<br>​    	case EVENT_LBUTTONDOWN:<br>​    		g_bDrawingBox &#x3D; true;<br>​    		&#x2F;&#x2F;记录g_rectangle的起点<br>​    		g_rectangle &#x3D; Rect(x, y, 0, 0);<br>​    		break;<br>​    		&#x2F;&#x2F;左键抬起时将当前绘制的矩形信息写入到图像中<br>​    	case EVENT_LBUTTONUP:<br>​    		&#x2F;&#x2F; 标识符为false<br>​    		g_bDrawingBox &#x3D; false;<br>​    		&#x2F;&#x2F;向起点左边绘制<br>​    		if (g_rectangle.width &lt; 0) {<br>​    			g_rectangle.x +&#x3D; g_rectangle.width;<br>​    			g_rectangle.width *&#x3D; -1;<br>​    		}<br>​    		&#x2F;&#x2F;向起点上边绘制<br>​    		if (g_rectangle.height &lt; 0) {<br>​    			g_rectangle.y +&#x3D; g_rectangle.height;<br>​    			g_rectangle.height *&#x3D; -1;<br>​    		}<br>​    		&#x2F;&#x2F;调用函数进行绘制<br>​    		DrawRactangle(image, g_rectangle);<br>​    		break;<br>​    	}<br>​    }<br>​    int main(int argc, char ** argv)<br>​    {<br>​    	&#x2F;&#x2F;准备参数<br>​    	g_rectangle &#x3D; Rect(-1, -1, 0, 0);<br>​    	Mat srcImage(600, 800, CV_8UC3, Scalar(255,255,255)), tempImage;<br>​    	srcImage.copyTo(tempImage);<br>​    	g_rectangle &#x3D; Rect(-1, -1, 0, 0);<br>​    	&#x2F;&#x2F; 设置鼠标操作回调函数<br>​    	namedWindow(strWndName);<br>​    	setMouseCallback(strWndName, onMouseCallback, (void *)&amp;srcImage);<br>​    	&#x2F;&#x2F; 程序主循环，当进行绘制的标识符为真的时候进行绘制<br>​    	while (true)<br>​    	{<br>​    		&#x2F;&#x2F;复制原图到临时变量，这样可以清除上一次的鼠标拖动结果<br>​    		srcImage.copyTo(tempImage);<br>​    		if (g_bDrawingBox){<br>​    			&#x2F;&#x2F;在鼠标拖动时，每次都对图像进行临时绘制<br>​    			Rect rectCur &#x3D; g_rectangle;<br>​    			&#x2F;&#x2F;鼠标向上或向左移动时，需要对坐标进行处理<br>​    			if (rectCur.width &lt; 0) {<br>​    				rectCur.x +&#x3D; rectCur.width;<br>​    				rectCur.width *&#x3D; -1;<br>​    			}<br>​    			if (rectCur.height &lt; 0) {<br>​    				rectCur.y +&#x3D; rectCur.height;<br>​    				rectCur.height *&#x3D; -1;<br>​    			}<br>​    			DrawRactangle(tempImage, rectCur);<br>​    		}<br>​    		imshow(strWndName, tempImage);<br>​    		if (waitKey(10) &#x3D;&#x3D; 27) &#x2F;&#x2F; 按下ESC键，程序退出<br>​    			break;<br>​    	}<br>​<br>​    	return 0;<br>​    }</p>
<h5 id="练手："><a href="#练手：" class="headerlink" title="&lt;3&gt;练手："></a>&lt;3&gt;练手：</h5><h6 id="1-打开摄像头"><a href="#1-打开摄像头" class="headerlink" title="1.打开摄像头"></a>1.打开摄像头</h6><p>​<br>​    #include “pch.h”                &#x2F;&#x2F;viscalC++预编译头文件<br>​    #include <iostream>             &#x2F;&#x2F;C++标准输入、输出流<br>​    #include &lt;opencv.hpp&gt;           &#x2F;&#x2F;OpenCV头文件<br>​    #include &lt;highgui.hpp&gt;          &#x2F;&#x2F;GUI界面头文件<br>​    using namespace cv;             &#x2F;&#x2F;打开cv的名词空间<br>​<br>​    #pragma comment(lib, “opencv_world480d.lib”)&#x2F;&#x2F;打开动态库<br>​<br>​    int main()<br>​    {<br>​    	cv::namedWindow(“camera”, 0);    &#x2F;&#x2F;新建名为“camera”的窗口<br>​    	VideoCapture capture(0);         &#x2F;&#x2F;打开ID为0的摄像头<br>​    	Mat frame;                       &#x2F;&#x2F;新建Mat变量（矩阵）<br>​    	while (capture.isOpened())<br>​    	{<br>​    		capture &gt;&gt; frame;            &#x2F;&#x2F;用重载运算符方式获取视频帧<br>​    		if (frame.empty())break;<br>​    		imshow(“camera”, frame);     &#x2F;&#x2F;在名为“camera”的窗口显示捕获帧<br>​    		waitKey(10);                 &#x2F;&#x2F;刷新图像，否则无法正常显示<br>​    	}<br>​    }</iostream></p>
<h6 id="2-视频播放器，滑动条控制进度，双击暂停-播放"><a href="#2-视频播放器，滑动条控制进度，双击暂停-播放" class="headerlink" title="2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放"></a>2.视频播放器，滑动条控制进度，双击暂停&#x2F;播放</h6><p>​<br>​    #include “pch.h”<br>​    #include <iostream><br>​    #include &lt;opencv.hpp&gt;<br>​    #include &lt;highgui.hpp&gt;<br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    const char* trackname &#x3D; “progress”;<br>​    const char* windowname &#x3D; “videoplayer”;<br>​    const char* filepath &#x3D; “D:&#x2F;files&#x2F;picture and video&#x2F;C0056.MP4”;<br>​    cv::VideoCapture capture(filepath, CAP_ANY);<br>​    int nWidth &#x3D; capture.get(CAP_PROP_FRAME_WIDTH); &#x2F;&#x2F;视频图像宽度<br>​    int nHeight &#x3D; capture.get(CAP_PROP_FRAME_HEIGHT); &#x2F;&#x2F;视频图像高度<br>​    double dblFrameRate &#x3D; capture.get(CAP_PROP_FPS); &#x2F;&#x2F;视频帧率<br>​    double dblFrameCnt &#x3D; capture.get(CAP_PROP_FRAME_COUNT); &#x2F;&#x2F;视频总帧数<br>​<br>​    const int g_nMaxProgressValue &#x3D; 100;			&#x2F;&#x2F;Alpha值的最大值<br>​    int g_nCurProgressValue;						&#x2F;&#x2F;当前滑动条对应的值<br>​    int Cur_Frame;								&#x2F;&#x2F;记录暂停时的帧数<br>​<br>​    Mat frame;<br>​    int sign &#x3D; 0;<br>​<br>​    int main()<br>​    {<br>​    	void on_Trackbar(int, void*);<br>​    	void onMouseCallback(int event, int x, int y, int flags, void* param);<br>​    	cv::namedWindow(windowname,0);<br>​    	setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);<br>​    	resizeWindow(windowname, 400, 300);<br>​    	moveWindow(windowname, 0, 0);<br>​<br>    	createTrackbar(trackname, windowname, &amp;g_nCurProgressValue, g_nMaxProgressValue, on_Trackbar);<br>    	setMouseCallback(windowname, onMouseCallback, (void*)NULL);</iostream></p>
<pre><code>	while(capture.isOpened())&#123;
		Cur_Frame = capture.get(CAP_PROP_POS_FRAMES);	//获取当前播放帧数
		//判断是否双击，双击则暂停播放
		if (sign)
		&#123;
			capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);
		&#125;

		capture &gt;&gt; frame;

		//如果播放完毕，等待按键，直接退出
		if (Cur_Frame == dblFrameCnt)
		&#123;
			waitKey(0);
			break;
		&#125;

		imshow(windowname, frame);

		//中途按		ESC可以直接退出
		if (waitKey(1) == 27)break;
	&#125;

&#125;

//滑动条回调函数
void on_Trackbar(int, void*)
&#123;
	capture.set(CAP_PROP_POS_FRAMES, g_nCurProgressValue * dblFrameCnt / g_nMaxProgressValue); //从视频中间开始播放
	capture &gt;&gt; frame;
&#125;

//鼠标回调函数
void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if(event==EVENT_LBUTTONDBLCLK)sign = (sign + 1) % 2;
&#125;
</code></pre>
<p>注意控制输出暂停的方法：</p>
<p>1.waitKey等待：键盘控制，可参考其他博主</p>
<p>2.一直输出上一帧：即本人使用方法</p>
<p>​<br>​    capture.set(CAP_PROP_POS_FRAMES, Cur_Frame-1);</p>
<p>3.直接用system（“pause”）  </p>
<h5 id="4-linux上编译运行：参考：-Linux下编译、链接、加载运行C"><a href="#4-linux上编译运行：参考：-Linux下编译、链接、加载运行C" class="headerlink" title="**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++"></a>**&lt; 4&gt;linux上编译运行：参考：[Linux下编译、链接、加载运行C++</h5><p>OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_44966641/article/details/120659285?spm=1001.2014.3001.5506</a><br>“Linux下编译、链接、加载运行C++ OpenCV的两种方式及常见问题的解决_linux下安装配置好opencv后怎么加载_Adenialzz的博客-<br>CSDN博客”)**</p>
<p><strong>CMakeLists.txt编辑：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuliuheng/p/9431275.html" title="[CMAKE]
详解CMakeLists.txt文件 - VictoKu - 博客园 (cnblogs.com)">[CMAKE] 详解CMakeLists.txt文件 - VictoKu - 博客园<br>(cnblogs.com)</a></strong></p>
<p><strong>或参考：jetson nano上的OpenCV使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131511658%22,%22source%22:%22qq_32971095%22%7D" title="图像识别小车（jetson nano部分）">图像识别小车（jetson<br>nano部分）</a>——第五章</strong></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="三-OpenCV基本数据结构和基本组件"><a href="#三-OpenCV基本数据结构和基本组件" class="headerlink" title="三.OpenCV基本数据结构和基本组件"></a>三.OpenCV基本数据结构和基本组件</h2><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><p>&lt;1&gt;（基础图像容器Mat类；点Point类；颜色Scalar类；尺寸Size类；矩形Rect类；旋转矩形RotatedRect类；固定向量Vec类；复数类complexf）</p>
<p>（辅助对象：迭代参数TermCriteria类；范围range类；指针Ptr类）</p>
<p>（工具和系统函数：数学、内存管理、性能优化、异常处理函数）</p>
<p>（图像绘制图形函数：线、矩形、圆、折线）</p>
<p>（图像保存函数；图像几何操作函数：均匀调整（尺寸）、仿射变换、对数极坐标变换）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1811f91ca180329611fd9be36e5e02b.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c2fcbc408c51032f372737fcdbc6a410.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4891ab8394f175c44875a74ca770271d.jpeg"></p>
<h5 id="练手代码"><a href="#练手代码" class="headerlink" title="&lt;2&gt;练手代码"></a>&lt;2&gt;练手代码</h5><h6 id="1-Mat类操作"><a href="#1-Mat类操作" class="headerlink" title="1.Mat类操作"></a>1.Mat类操作</h6><p>​<br>​    int main()<br>​    {<br>​    	namedWindow(“image”, WINDOW_NORMAL);<br>​    	setWindowTitle(“image”, “image:”);<br>​    	Mat img(Size(200, 100), CV_8UC3, Scalar(80, 160, 240));<br>​    	imshow(“image”, img);<br>​    	waitKey(0);<br>​    	return -1;<br>​    }</p>
<h6 id="2-摄像头图像流极坐标变换"><a href="#2-摄像头图像流极坐标变换" class="headerlink" title="2.摄像头图像流极坐标变换"></a>2.摄像头图像流极坐标变换</h6><p>​<br>​    const int g_nMaxValue &#x3D; 100; &#x2F;&#x2F;滑条值的最大值<br>​    int g_nCurValue &#x3D; 0;   &#x2F;&#x2F;当前滑动条对应的值<br>​<br>​    int main()<br>​    {<br>​    	void on_Trackbar(int, void*);<br>​    	namedWindow(“Polor”, WINDOW_NORMAL);<br>​<br>​    	Mat frame;<br>​    	VideoCapture capture(0);<br>​    	int nWidth &#x3D; capture.get(CAP_PROP_FRAME_WIDTH); &#x2F;&#x2F;视频图像宽度<br>​    	int nHeight &#x3D; capture.get(CAP_PROP_FRAME_HEIGHT); &#x2F;&#x2F;视频图像高度<br>​    	createTrackbar(“zoom factor”, “Polor”, &amp;g_nCurValue, g_nMaxValue, on_Trackbar);<br>​    	while (capture.isOpened())<br>​    	{<br>​    		capture &gt;&gt; frame;<br>​    		if (frame.empty())break;<br>​    		logPolar(frame, frame, Point2i(nWidth &#x2F; 2, nHeight &#x2F; 2), g_nCurValue, WARP_FILL_OUTLIERS);<br>​    		imshow(“Polor”, frame);<br>​    		waitKey(1);<br>​    	}<br>​<br>​    }<br>​<br>​    void on_Trackbar(int, void*)<br>​    {<br>​    	;<br>​    }</p>
<h5 id="3-读取图像像素RGB值（左键显示，右键清空）"><a href="#3-读取图像像素RGB值（左键显示，右键清空）" class="headerlink" title="3.读取图像像素RGB值（左键显示，右键清空）"></a>3.读取图像像素RGB值（左键显示，右键清空）</h5><p>​    #include “opencv.hpp”<br>​    #include “highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    const char* filepath &#x3D; “&#x2F;test2.png”;<br>​    const char* windowname &#x3D; “window”;<br>​    const char* windowtitle &#x3D; “image”;<br>​    const char* trackname &#x3D; “fontscale”;	<br>​    int fontscale &#x3D; 1;·								&#x2F;&#x2F;字体大小及线条粗细<br>​    const int max_fontscale &#x3D; 100;<br>​    Mat img &#x3D; imread(filepath, IMREAD_COLOR);<br>​    Mat draw_board &#x3D; img.clone();					&#x2F;&#x2F;图片拷贝以实现清除<br>​    char string[5];<br>​    </iostream></p>
<pre><code>int main()
&#123;
	void on_Trackbar(int, void*);
	void onMouseCallback(int event, int x, int y, int flags, void* param);
	namedWindow(windowname, WINDOW_NORMAL);
	createTrackbar(trackname, windowname, &amp;fontscale, max_fontscale, on_Trackbar);
	setMouseCallback(windowname, onMouseCallback, (void*)NULL);
	if (draw_board.empty())return -1;
	while (!draw_board.empty())
	&#123;
		imshow(windowname, draw_board);
		if (waitKey(1) == 27)break;
	&#125;
	return 0;
&#125;

void on_Trackbar(int, void*)
&#123;
	;
&#125;

void onMouseCallback(int event, int x, int y, int flags, void* param)
&#123;
	if (event == EVENT_LBUTTONDOWN)
	&#123;
		//读取鼠标所指像素的值
		int rgb[3] = &#123; img.at&lt;cv::Vec3b&gt;(x, y)[2],img.at&lt;cv::Vec3b&gt;(x, y)[1], img.at&lt;cv::Vec3b&gt;(x, y)[0] &#125;;
		//putText不支持\n换行，只能手动计算间隔：y + fontscale * 10 * i
		for (int i = 0; i &lt; 3; i++) &#123;
			sprintf_s(string, &quot;%d&quot;, rgb[i]);
			//文字写入图像
			putText(draw_board, string, Point(x, y + fontscale * 10 * i), FONT_HERSHEY_PLAIN, fontscale, Scalar(rgb[2], rgb[1], rgb[0]), fontscale, 8, false);
		&#125;
	&#125;
	if (event == EVENT_RBUTTONDOWN)
	&#123;
		//使显示图像为原始图像，即清零
		draw_board = img.clone();
	&#125;
&#125;
</code></pre>
<p>注：</p>
<p>①.at()函数访问多通道Mat数据元素时为只能用at()函数，且注意at&lt;&gt;内为 Vec3b</p>
<p>​<br>​    at&lt;cv::Vec3b&gt;(x, y)[i]</p>
<p>②.putText()函数无法实现换行，需手动计算</p>
<h6 id="4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"><a href="#4-创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面" class="headerlink" title="4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面"></a>4.创建一定尺寸3通道RGB图像，并逐个访问其像素值，并绘制一绿色平面</h6><p>​<br>​    #include “opencv.hpp”<br>​    #include “highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    const char* filepath &#x3D; “test2.png”;<br>​    const char* windowname &#x3D; “window”;<br>​    const char* windowtitle &#x3D; “image”;<br>​    const char* trackname &#x3D; “fontscale”;<br>​<br>​    #define WIDTH 800<br>​    #define HEIGHT 600<br>​<br>​    int main()<br>​    {<br>​    	namedWindow(windowname, WINDOW_NORMAL);<br>​    	Mat img(WIDTH, HEIGHT, CV_8UC3, Scalar(0, 0, 0));<br>​    	for (int i &#x3D; 0; i &lt; WIDTH; i++) {<br>​    		for (int j &#x3D; 0; j &lt; HEIGHT; j++) {<br>​    			for (int k &#x3D; 0; k &lt; 3; k++) {<br>​    				img.at<Vec3b>(i, j)[k] &#x3D; (i * j * k) % 256;<br>​    			}<br>​    		}<br>​    	}<br>​    	Point p1(200, 50), p2(400, 200);<br>​    	rectangle(img,p1,p2,Scalar(0,255,0),8,8,0);<br>​    	imshow(windowname, img);<br>​    	&#x2F;&#x2F;imwrite(“C:&#x2F;Users&#x2F;user&#x2F;Desktop&#x2F;1.png”, img);<br>​    	waitKey(0);<br>​    	<br>​    }</Vec3b></iostream></p>
<h2 id="四-数字图像灰度变换与空间滤波"><a href="#四-数字图像灰度变换与空间滤波" class="headerlink" title="四.数字图像灰度变换与空间滤波"></a>四.数字图像灰度变换与空间滤波</h2><h5 id="（灰度变换：线性、非线性；直方图：概率、累计）"><a href="#（灰度变换：线性、非线性；直方图：概率、累计）" class="headerlink" title="&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）"></a>&lt;1&gt;（灰度变换：线性、非线性；直方图：概率、累计）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/10f1536c594c088a66be8508027e04c3.jpeg"></p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-灰度变换函数"><a href="#1-灰度变换函数" class="headerlink" title="1.灰度变换函数"></a>1.灰度变换函数</h6><p>①对数变换</p>
<p>​<br>​    &#x2F;&#x2F;对数变换<br>​    void LogTransform(Mat srcImg, Mat &amp;dstImg, const float c&#x3D;1.0f)<br>​    {<br>​    	if (srcImg.empty()){<br>​    		cout &lt;&lt; “No data” &lt;&lt; endl;<br>​    		return;<br>​    	}<br>​    	&#x2F;&#x2F;Mat dstMat &#x3D; Mat::zeros(srcImg.size(), srcImg.type());<br>​    	add(srcImg, Scalar(1.0), srcImg);  &#x2F;&#x2F;计算 s+1<br>​    	srcImg.convertTo(srcImg, CV_32F);  &#x2F;&#x2F;转化为32位浮点型<br>​    	cv::log(srcImg, dstImg); &#x2F;&#x2F;计算log(1+s)<br>​    	dstImg &#x3D; c*dstImg;<br>​    	&#x2F;&#x2F;归一化处理<br>​    	normalize(dstImg, dstImg, 0, 255, NORM_MINMAX);<br>​    	&#x2F;&#x2F;cout &lt;&lt; dstImg &lt;&lt; endl;<br>​    	cout &lt;&lt; dstImg.elemSize() &lt;&lt; endl;<br>​    	&#x2F;&#x2F;将dstImg转换到CV_8U类型<br>​    	convertScaleAbs(dstImg, dstImg);<br>​    	return;<br>​    }</p>
<p><strong>②*伽马变换</strong></p>
<p>​<br>​    &#x2F;&#x2F;伽马校正<br>​    void MyGammaCorrection(const Mat&amp; src, Mat&amp; dst, float fGamma)<br>​    {<br>​    	&#x2F;&#x2F;CV_Assert(src.data);<br>​    	if (src.empty()){<br>​    		return;<br>​    	}<br>​    	&#x2F;&#x2F;只处理位深度为8位的图像<br>​    	CV_Assert(src.depth() !&#x3D; sizeof(uchar));<br>​    	&#x2F;&#x2F;创建查找表<br>​    	unsigned char lut[256];<br>​    	for (int i &#x3D; 0; i &lt; 256; i++){<br>​    		lut[i] &#x3D; saturate_cast<uchar>(pow((float)(i &#x2F; 255.0),<br>​    			fGamma) * 255.0f);<br>​    	}<br>​<br>​    	dst &#x3D; src.clone();<br>​    	const int channels &#x3D; dst.channels();<br>​    	switch (channels){<br>​    	case 1:<br>​    	{<br>​    		&#x2F;&#x2F;MatIterator_<uchar> it;<br>​    		&#x2F;&#x2F;for (it &#x3D; dst.begin<uchar>(); it !&#x3D; dst.end<uchar>(); it++)<br>​    		&#x2F;&#x2F;	*it &#x3D; lut[(*it)];<br>​    		for (int j &#x3D; 0; j &lt; dst.rows; j++){<br>​    			for (int i &#x3D; 0; i &lt; dst.cols; i++){<br>​    				unsigned char val &#x3D; dst.at<uchar>(j, i);<br>​    				dst.at<uchar>(j, i) &#x3D; lut[val];<br>​    			}<br>​    		}<br>​    		break;<br>​    	}<br>​    	case 3:<br>​    	{<br>​    		MatIterator_<Vec3b> it;<br>​    		for (it &#x3D; dst.begin<Vec3b>(); it !&#x3D; dst.end<Vec3b>(); it++){<br>​    			(*it)[0] &#x3D; lut[((*it)[0])];<br>​    			(*it)[1] &#x3D; lut[((*it)[1])];<br>​    			(*it)[2] &#x3D; lut[((*it)[2])];<br>​    		}<br>​    		break;<br>​    	}<br>​    	}<br>​    }</Vec3b></Vec3b></Vec3b></uchar></uchar></uchar></uchar></uchar></uchar></p>
<p>注：saturate_cast&lt;&gt;的使用（防止颜色溢出）参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15698613/article/details/84557588?spm=1001.2014.3001.5506" title="【OpenCV】中saturate_cast&lt;uchar&gt;的含义和用法是什么？_人工智能博士的博客-CSDN博客">【OpenCV】中saturate_cast<uchar>的含义和用法是什么？_人工智能博士的博客-<br>CSDN博客</uchar></a></p>
<h6 id="2-直方图（概率直方图）绘制函数"><a href="#2-直方图（概率直方图）绘制函数" class="headerlink" title="2.直方图（概率直方图）绘制函数"></a>2.直方图（概率直方图）绘制函数</h6><p>①灰度直方图</p>
<p>​<br>​    &#x2F;&#x2F;灰度直方图<br>​    void DrawGrayImgHist(const Mat &amp;srcImg)<br>​    {<br>​    	if (1 !&#x3D; srcImg.channels()){<br>​    		return;<br>​    	}<br>​    	int channels &#x3D; 0;<br>​    	Mat dstHist;<br>​    	int histSize[] &#x3D; { 256 };<br>​    	float midRanges[] &#x3D; { 0, 256 };<br>​    	const float *ranges[] &#x3D; { midRanges };<br>​    	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, <br>​    		1, histSize, ranges, true, true);<br>​    	&#x2F;&#x2F;最终绘制的直方图图像，大小是256×256<br>​    	Mat histImage &#x3D; Mat::zeros(Size(256, 256), CV_8UC1);<br>​    	double dblHistMaxValue;<br>​    	&#x2F;&#x2F;求得直方图的最大值<br>​    	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);<br>​    	&#x2F;&#x2F;将像素的个数整合到图像的最大范围内<br>​    	for (int i &#x3D; 0; i &lt;&#x3D; 255; i++){<br>​    		int value &#x3D; cvRound(dstHist.at<float>(i)<br>​    			* 255 &#x2F; dblHistMaxValue);<br>​    		line(histImage, Point(i, histImage.rows - 1), <br>​    			Point(i, histImage.rows - 1 - value), Scalar(255));<br>​    	}<br>​    	imshow(“直方图”, histImage);<br>​    	imwrite(“desert_hist_规定化之后.bmp”, histImage);<br>​    }</float></p>
<p>注：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12386274.html" title="minMaxLoc 寻找图像全局最大最小值">minMaxLoc 寻找图像全局最大最小值</a></p>
<p>②RGB彩色直方图</p>
<p>​<br>​    &#x2F;&#x2F;RGB彩色直方图<br>​    void DrawRGBImgHist(const Mat &amp;srcImg)<br>​    {<br>​    	if (srcImg.empty() || srcImg.channels() !&#x3D; 3){<br>​    		return;<br>​    	}<br>​    	&#x2F;&#x2F;分割成3个单通道图像 ( R, G 和 B )<br>​    	vector<Mat> rgb_planes;<br>​    	split(srcImg, rgb_planes);<br>​    	&#x2F;&#x2F; 设定bin数目<br>​    	int histSize &#x3D; 256;<br>​    	&#x2F;&#x2F; 设定取值范围 ( R,G,B) )<br>​    	float range[] &#x3D; { 0, 256 };<br>​    	const float* histRange &#x3D; { range };<br>​<br>​    	bool uniform &#x3D; true;<br>​    	bool accumulate &#x3D; true;<br>​<br>​    	Mat r_hist, g_hist, b_hist;<br>​<br>​    	&#x2F;&#x2F;计算直方图:<br>​    	calcHist(&amp;rgb_planes[0], 1, 0, Mat(), r_hist, 1, <br>​    		&amp;histSize, &amp;histRange, uniform, accumulate);<br>​    	calcHist(&amp;rgb_planes[1], 1, 0, Mat(), g_hist, 1, <br>​    		&amp;histSize, &amp;histRange, uniform, accumulate);<br>​    	calcHist(&amp;rgb_planes[2], 1, 0, Mat(), b_hist, 1,<br>​    		&amp;histSize, &amp;histRange, uniform, accumulate);<br>​<br>​    	&#x2F;&#x2F; 创建直方图画布<br>​    	int hist_w &#x3D; 256; int hist_h &#x3D; 200;<br>​    	int bin_w &#x3D; cvRound((double)hist_w &#x2F; histSize);<br>​<br>    	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));</Mat></p>
<pre><code>	// 将直方图归一化到范围 [ 0, histImage.rows ]
	normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX);
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX);

	// 在直方图画布上画出直方图，3个直方图叠加在一起，用不同的颜色表示
	for (int i = 1; i &lt; histSize; i++)
	&#123;
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(r_hist.at&lt;float&gt;(i))),
			Scalar(0, 0, 255), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(g_hist.at&lt;float&gt;(i))),
			Scalar(0, 255, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at&lt;float&gt;(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(b_hist.at&lt;float&gt;(i))),
			Scalar(255, 0, 0), 2, 8, 0);
	&#125;

	// 显示直方图
	imshow(&quot;RGB彩色图像直方图&quot;, histImage);
	imwrite(&quot;./colorhist_for_beatuty_after_qualization.bmp&quot;, histImage);
	waitKey(0);
&#125;
</code></pre>
<p>③累计直方图</p>
<p>​<br>​    &#x2F;&#x2F;画累积直方图<br>​    void DrawAccumulateImgHist(const Mat &amp;srcImg)<br>​    {<br>​    	if (1 !&#x3D; srcImg.channels()){<br>​    		return;<br>​    	}<br>​    	int channels &#x3D; 0;<br>​    	Mat dstHist;<br>​    	int histSize[] &#x3D; { 256 };<br>​    	float midRanges[] &#x3D; { 0, 256 };<br>​    	const float *ranges[] &#x3D; { midRanges };<br>​    	calcHist(&amp;srcImg, 1, &amp;channels, Mat(), dstHist, <br>​    		1, histSize, ranges, true, true);<br>​    	&#x2F;&#x2F;对直方图进行累积<br>​    	for (int i &#x3D; 1; i &lt; dstHist.rows; i++){<br>​    		dstHist.at<float>(i) +&#x3D; dstHist.at<float>(i-1);<br>​    	}<br>​    	&#x2F;&#x2F;最终绘制的直方图图像，大小是256×256<br>​    	Mat histImage &#x3D; Mat::zeros(Size(256, 256), CV_8UC1);<br>​    	double dblHistMaxValue;<br>​    	&#x2F;&#x2F;求得直方图的最大值<br>​    	minMaxLoc(dstHist, 0, &amp;dblHistMaxValue, 0, 0);<br>​    	&#x2F;&#x2F;将像素的个数整合到图像的最大范围内<br>​    	for (int i &#x3D; 0; i &lt; 256; i++){<br>​    		int value &#x3D; cvRound(dstHist.at<float>(i)<br>​    			* 255 &#x2F; dblHistMaxValue);<br>​    		line(histImage, Point(i, histImage.rows - 1), <br>​    			Point(i, histImage.rows - 1 - value), Scalar(255));<br>​    	}<br>​    	imshow(“累积直方图”, histImage);<br>​    	imwrite(“.&#x2F;accumlate.bmp”, histImage);<br>​    }</float></float></float></p>
<h2 id="七-图像分割"><a href="#七-图像分割" class="headerlink" title="七.图像分割"></a>七.图像分割</h2><h5 id="（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）"><a href="#（边缘检测：算子：一阶导数【Sobel-Prewitt-Roberts】、二阶【拉普拉斯-LOG-Canny】）" class="headerlink" title="&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）"></a>&lt;1&gt;（边缘检测：算子：一阶导数【Sobel&#x2F;Prewitt&#x2F;Roberts】、二阶【拉普拉斯&#x2F;LOG&#x2F;Canny】）</h5><h5 id="（几何形状检测【霍夫变换】：直线、圆）"><a href="#（几何形状检测【霍夫变换】：直线、圆）" class="headerlink" title="（几何形状检测【霍夫变换】：直线、圆）"></a>（几何形状检测【霍夫变换】：直线、圆）</h5><h5 id="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"><a href="#（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）" class="headerlink" title="（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）"></a>（阈值分割【二值化】：全局阈值【OTSU、三角法】、自适应阈值）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42061b3c66f846c840087275d00ada91.jpeg"></p>
<h5 id="-2"><a href="#-2" class="headerlink" title></a></h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e731b3257fee71a5ec24342e7b18efb.jpeg"><br>&lt;2&gt;示例代码</p>
<h6 id="1-霍夫直线变换和霍夫圆检测"><a href="#1-霍夫直线变换和霍夫圆检测" class="headerlink" title="1.霍夫直线变换和霍夫圆检测"></a>1.霍夫直线变换和霍夫圆检测</h6><p>​<br>​    void DetectLines()<br>​    {<br>​    	Mat matSrc &#x3D; imread(“Hough_src_clr.png”, IMREAD_GRAYSCALE);<br>​    	Mat matEdge;<br>​    	&#x2F;&#x2F;Canny算子计算图像边缘<br>​    	Canny(matSrc, matEdge, 250, 200, 3, false);<br>​    	imshow(“原图像”, matSrc);<br>​    	imshow(“Canny边缘”, matEdge);<br>​    	imwrite(“hough_src_gray.bmp”, matSrc);<br>​    	imwrite(“hough_src_canny.bmp”, matEdge);<br>​    	std::vector<Vec2f> linesSHT;<br>​    	&#x2F;&#x2F;标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300<br>​    	HoughLines(matEdge, linesSHT, 1, CV_PI &#x2F; 180, 280);<br>​    	Mat matSHT &#x3D; matSrc.clone();<br>​    	for (size_t i &#x3D; 0; i &lt; linesSHT.size(); i++) {<br>​    		&#x2F;&#x2F;直线的rho和theta值<br>​    		float rho &#x3D; linesSHT[i][0], theta &#x3D; linesSHT[i][1];<br>​    		&#x2F;&#x2F;pt1和pt2是直线的两个端点<br>​    		Point pt1, pt2;<br>​    		double a &#x3D; cos(theta), b &#x3D; sin(theta);<br>​    		double x0 &#x3D; a * rho, y0 &#x3D; b * rho;<br>​    		pt1.x &#x3D; cvRound(x0 + 2000 * (-b)); &#x2F;&#x2F;把浮点数转化成整数<br>​    		pt1.y &#x3D; cvRound(y0 + 2000 * (a));<br>​    		pt2.x &#x3D; cvRound(x0 - 2000 * (-b));<br>​    		pt2.y &#x3D; cvRound(y0 - 2000 * (a));<br>​    		line(matSHT, pt1, pt2, Scalar(255), 4);<br>​    	}<br>​    	imshow(“SHT直线检测结果”, matSHT);<br>​    	imwrite(“hough_Lines_SHT.bmp”, matSHT);<br>​    	Mat matPPHT &#x3D; matSrc.clone();<br>​    	std::vector<Vec4i> linesPPHT;<br>​    	&#x2F;&#x2F;累计概率霍夫变换检测直线，得到的是直线的起止端点<br>​    	HoughLinesP(matEdge, linesPPHT, 1, CV_PI &#x2F; 180, 280, 100, 50);<br>​    	for (size_t i &#x3D; 0; i &lt; linesPPHT.size(); i++) {<br>​    		&#x2F;&#x2F;直接绘制直线<br>​    		line(matPPHT, Point(linesPPHT[i][0], linesPPHT[i][1]),<br>​    			Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);<br>​    	}<br>​    	imshow(“PPHT直线检测结果”, matPPHT);<br>​    	imwrite(“Hough_lines_PPHT.bmp”, matPPHT);<br>​    	waitKey(0);<br>​    }</Vec4i></Vec2f></p>
<p>​<br>​    void DetectCircles()<br>​    {<br>​    	Mat src;<br>​    	src &#x3D; imread(“HoughCircles_src_clr.jpg”, IMREAD_GRAYSCALE);<br>​    	&#x2F;&#x2F;imwrite(“HoughCircles_src_gray.bmp”, src);<br>​    	vector<Vec3f> circles;<br>​    	HoughCircles(src, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);<br>​    	&#x2F;&#x2F;在原图中画出圆心和圆<br>​    	for (size_t i &#x3D; 0; i &lt; circles.size(); i++){<br>​    		&#x2F;&#x2F;提取出圆心坐标<br>​    		Point center(round(circles[i][0]), round(circles[i][1]));<br>​    		&#x2F;&#x2F;提取出圆半径<br>​    		int radius &#x3D; round(circles[i][2]);<br>​    		&#x2F;&#x2F;圆心<br>​    		circle(src, center, 3, Scalar(255), -1, 4, 0);<br>​    		&#x2F;&#x2F;圆<br>​    		circle(src, center, radius, Scalar(255), 3, 4, 0);<br>​    	}<br>​    	&#x2F;&#x2F;imwrite(“HoughCircles_circles.bmp”, src);<br>​    	imshow(“Circle”, src);<br>​    	waitKey(0);<br>​    }</Vec3f></p>
<h6 id="2-OTSU方法和三角法求全局阈值"><a href="#2-OTSU方法和三角法求全局阈值" class="headerlink" title="2.OTSU方法和三角法求全局阈值"></a>2.OTSU方法和三角法求全局阈值</h6><p>​<br>​    &#x2F;&#x2F;OTSU方法求阈值<br>​    int OtsuBinary(Mat src)<br>​    {<br>​    	long lPixCnt &#x3D; src.rows * src.cols;<br>​    	long histogram[256] &#x3D; { 0 }; &#x2F;&#x2F;histogram是灰度直方图<br>​    	for (int i &#x3D; 0; i &lt; src.rows; i++) {<br>​    		for (int j &#x3D; 0; j &lt; src.cols; j++) {<br>​    			unsigned char nCurVal &#x3D; src.at<uchar>(i, j);<br>​    			histogram[nCurVal]++;<br>​    		}<br>​    	}<br>​    	int nThreshold &#x3D; 0;<br>​    	long sum0 &#x3D; 0, sum1 &#x3D; 0; &#x2F;&#x2F;存储前景的灰度总和和背景灰度总和<br>​    	long cnt0 &#x3D; 0, cnt1 &#x3D; 0; &#x2F;&#x2F;前景像素总个数和背景像素总个数<br>​    	double w0 &#x3D; 0, w1 &#x3D; 0; &#x2F;&#x2F;前景和背景所占整幅图像的比例<br>​    	double u0 &#x3D; 0, u1 &#x3D; 0;  &#x2F;&#x2F;前景和背景的平均灰度<br>​    	double variance &#x3D; 0; &#x2F;&#x2F;类间方差<br>​    	double maxVariance &#x3D; 0; &#x2F;&#x2F;用来存储最大类间方差<br>​    	for (int i &#x3D; 1; i &lt; 256; i++) &#x2F;&#x2F;遍历所有灰度级别<br>​    	{<br>​    		sum0 &#x3D; 0;    cnt0 &#x3D; 0;  w0 &#x3D; 0;<br>​    		sum1 &#x3D; 0;    cnt1 &#x3D; 0;  w1 &#x3D; 0;<br>​    		for (int j &#x3D; 0; j &lt; i; j++) {<br>​    			cnt0 +&#x3D; histogram[j]; &#x2F;&#x2F;前景像素总和<br>​    			sum0 +&#x3D; j * histogram[j]; &#x2F;&#x2F;前景灰度值总和<br>​    		}<br>​    		&#x2F;&#x2F;前景部分灰度均值<br>​    		u0 &#x3D; cnt0 &gt; 0 ? double(sum0) &#x2F; cnt0 : 0;<br>​    		w0 &#x3D; (double)cnt0 &#x2F; lPixCnt; &#x2F;&#x2F;前景部分所占的比例<br>​    		for (int j &#x3D; i; j &lt;&#x3D; 255; j++) {<br>​    			cnt1 +&#x3D; histogram[j]; &#x2F;&#x2F;背景像素个数<br>​    			sum1 +&#x3D; j * histogram[j]; &#x2F;&#x2F;背景部分灰度值总和<br>​    		}<br>​    		&#x2F;&#x2F;背景部分灰度均值<br>​    		u1 &#x3D; cnt1 &gt; 0 ? double(sum1) &#x2F; cnt1 : 0;<br>​    		w1 &#x3D; 1 - w0;  &#x2F;&#x2F;背景部分所占的比例<br>​    		&#x2F;&#x2F;分割阈值为i时的类间方差<br>​    		variance &#x3D; w0 * w1 * (u0 - u1) * (u0 - u1);<br>​    		if (variance &gt; maxVariance) {<br>​    			maxVariance &#x3D; variance;<br>​    			nThreshold &#x3D; i;<br>​    		}<br>​    	}<br>​<br>​    	return nThreshold;<br>​    }<br>​<br>​    &#x2F;&#x2F;三角法求阈值<br>​    int TriangleBinary(Mat src)<br>​    {<br>​    	long lPixCnt &#x3D; src.rows * src.cols;<br>​    	long histogram[256] &#x3D; { 0 }; &#x2F;&#x2F;histogram是灰度直方图<br>​    	for (int i &#x3D; 0; i &lt; src.rows; i++) {<br>​    		for (int j &#x3D; 0; j &lt; src.cols; j++) {<br>​    			unsigned char nCurVal &#x3D; src.at<uchar>(i, j);<br>​    			histogram[nCurVal]++;<br>​    		}<br>​    	}<br>​<br>​    	&#x2F;&#x2F;左右边界<br>​    	int left_bound &#x3D; 0, right_bound &#x3D; 0;<br>​    	&#x2F;&#x2F;直方图最高峰和相应的灰度值<br>​    	int max_ind &#x3D; 0, maxPeak &#x3D; 0;<br>​    	int temp;<br>​    	bool isflipped &#x3D; false;<br>​<br>​    	&#x2F;&#x2F; 找到最左边零的位置<br>​    	for (int i &#x3D; 0; i &lt; 256; i++) {<br>​    		if (histogram[i] &gt; 0) {<br>​    			left_bound &#x3D; i;<br>​    			break;<br>​    		}<br>​    	}<br>​    	&#x2F;&#x2F;位置再移动一个步长，即为最左侧零位置<br>​    	if (left_bound &gt; 0)<br>​    		left_bound–;<br>​<br>    	&#x2F;&#x2F; 找到最右边零点位置<br>    	for (int i &#x3D; 255; i &gt; 0; i–) {<br>    		if (histogram[i] &gt; 0) {<br>    			right_bound &#x3D; i;<br>    			break;<br>    		}<br>    	}<br>    	&#x2F;&#x2F; 位置再移动一个步长，即为最右侧零位置<br>    	if (right_bound &lt; 255)<br>    		right_bound++;</uchar></uchar></p>
<pre><code>	// 在直方图上寻找最亮的点Hmax
	for (int i = 0; i &lt; 256; i++) &#123;
		if (histogram[i] &gt; maxPeak) &#123;
			maxPeak = histogram[i];
			max_ind = i;
		&#125;
	&#125;

	// 如果最大值落在靠左侧这样就无法满足三角法求阈值，
	 //所以要检测是否最大值是否靠近左侧
	// 如果靠近左侧则通过翻转到右侧位置。
	if (max_ind - left_bound &lt; right_bound - max_ind) &#123;
		isflipped = true;
		int i = 0;
		int j = 255;
		// 左右交换
		while (i &lt; j) &#123;
			temp = histogram[i]; histogram[i] = histogram[j]; histogram[j] = temp;
			i++; j--;
		&#125;
		left_bound = 255 - right_bound;
		max_ind = 255 - max_ind;
	&#125;

	// 计算求得阈值
	double thresh = left_bound;
	double maxDist = 0, tempDist;
	double peakIdxBound = left_bound - max_ind;
	for (int i = left_bound + 1; i &lt;= max_ind; i++)
	&#123;
		// 计算距离
		tempDist = maxPeak * i + peakIdxBound * histogram[i];
		if (tempDist &gt; maxDist) &#123;
			maxDist = tempDist;
			thresh = i;
		&#125;
	&#125;
	thresh--;
	if (isflipped) &#123;
		thresh = 255 - thresh;
	&#125;

	return thresh;
&#125;

//手动二值化处理
Mat Binbary(Mat src, int nThreshold)
&#123;
	//遍历每个像素，对图像进行二值化
	Mat dst = Mat::zeros(src.rows, src.cols, CV_8UC1);
	for (int i = 0; i &lt; src.rows; i++) &#123;
		for (int j = 0; j &lt; src.cols; j++) &#123;
			if (src.at&lt;uchar&gt;(i, j) &gt; nThreshold)
				dst.at&lt;uchar&gt;(i, j) = 255;
		&#125;
	&#125;
	return dst;
&#125;
</code></pre>
<p>*<strong>注：</strong></p>
<p><strong>①二值化的原图都是灰度图，产生灰度图方法见后</strong></p>
<p><strong>②对于固定场景摄像头读取图像可以先调用以上函数求出全局阈值，之后使用cv::threshold()函数时直接调用该阈值，减少每帧计算阈值时间</strong></p>
<h5 id="练手"><a href="#练手" class="headerlink" title="&lt;3&gt;练手"></a>&lt;3&gt;练手</h5><h6 id="1-边缘检测二阶导数算子使用"><a href="#1-边缘检测二阶导数算子使用" class="headerlink" title="1.边缘检测二阶导数算子使用"></a>1.边缘检测二阶导数算子使用</h6><p>​<br>​    #include “opencv.hpp”<br>​    #include “highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    #define IMAGE_TEST<br>​<br>​    #ifdef IMAGE_TEST<br>​    const char* filepath &#x3D; “.&#x2F;Test.jpg”;<br>​    Mat img &#x3D; imread(filepath, IMREAD_COLOR);<br>​    Mat draw_board &#x3D; img.clone();					&#x2F;&#x2F;图片拷贝以实现清除<br>​    #endif<br>​    #ifdef CAMERA_TEST<br>​    VideoCapture capture(0);<br>​    Mat image;<br>​    #endif &#x2F;&#x2F; CAMERA_TEST</iostream></p>
<p>​<br>​    int main()<br>​    {<br>​    	void changing(void);<br>​    	changing();<br>​    }<br>​<br>​    &#x2F;&#x2F;拉普拉斯高通滤波<br>​    void changing(void)<br>​    {<br>​    	Mat LoG_Image(const Mat &amp; image, int kervalue &#x3D; 3, double sigma &#x3D; 1.0f);<br>​<br>​    #ifdef IMAGE_TEST<br>​    	Mat image &#x3D; imread(filepath, IMREAD_COLOR);<br>​    	if (image.empty()) {<br>​    		std::cout &lt;&lt; “打开图片失败,请检查” &lt;&lt; std::endl;<br>​    		return;<br>​    	}<br>​    	imshow(“原图像”, image);<br>​    	Mat matDst;<br>​    &#x2F;&#x2F;	Laplacian(image, matDst, image.depth(), 5);     &#x2F;&#x2F;拉普拉斯算子<br>​    &#x2F;&#x2F;	matDst &#x3D; LoG_Image(image, 3, 1.0f);				&#x2F;&#x2F;LOG算子<br>​    	Canny(image, matDst, 80, 150, 3, false);		&#x2F;&#x2F;canny算子<br>​    	imwrite(“changing.bmp”, matDst);<br>​    	imshow(“变换效果”, matDst);<br>​    	waitKey(0);<br>​    #endif<br>​    #ifdef CAMERA_TEST<br>​    	while (capture.isOpened())<br>​    	{<br>​    		capture &gt;&gt; image;<br>​    		if (image.empty())break;<br>​    		Mat matDst;<br>​    &#x2F;&#x2F;		Laplacian(image, matDst, image.depth(), 5);		&#x2F;&#x2F;拉普拉斯算子<br>​    &#x2F;&#x2F;		matDst &#x3D; LoG_Image(image, 3, 1.0f);				&#x2F;&#x2F;LOG算子<br>​    		Canny(image, matDst, 100, 500, 3, false);		&#x2F;&#x2F;canny算子<br>​    		imshow(“变换效果”, matDst);<br>​    		if (waitKey(1) &#x3D;&#x3D; 27)break;<br>​    	}<br>​    #endif<br>​    }<br>​<br>​    &#x2F;&#x2F;图像LoG算子运算<br>​    Mat LoG_Image(const Mat&amp; image, int kervalue &#x3D; 3, double sigma &#x3D; 1.0f)<br>​    {<br>​    	&#x2F;&#x2F;首先对图像做高斯平滑<br>​    	Mat matTemp;<br>​    	GaussianBlur(image, matTemp, Size(kervalue, kervalue), sigma, sigma, BORDER_DEFAULT);<br>​    	&#x2F;&#x2F;通过拉普拉斯算子做边缘检测<br>​    	Mat laplacian &#x3D; Mat::zeros(image.rows, image.cols, CV_32FC1);<br>​    	Laplacian(matTemp, laplacian, CV_32FC1, 3);<br>​    	&#x2F;&#x2F;求得最大边缘值<br>​    	double dblMaxVal &#x3D; 0;<br>​    	minMaxLoc(laplacian, NULL, &amp;dblMaxVal);<br>​    	Mat dstImg;<br>​    	convertScaleAbs(laplacian, dstImg);<br>​    	imwrite(“edge.bmp”, dstImg);<br>​    	Mat result &#x3D; Mat::zeros(image.rows, image.cols, CV_8UC1);<br>​    	&#x2F;&#x2F;过零点交叉，寻找边缘像素<br>​    	for (int i &#x3D; 1; i &lt; result.rows - 1; i++) {<br>​    		for (int j &#x3D; 1; j &lt; result.cols - 1; j++) {<br>​    			if (laplacian.at<float>(i, j) &lt; 0.1 * dblMaxVal) {<br>​    				continue;<br>​    			}<br>​    			&#x2F;&#x2F;水平、垂直、45度方向，135度4个方向过零点判定<br>​    			if (laplacian.at<float>(i - 1, j) <br>​    				* laplacian.at<float>(i + 1, j) &lt; 0)<br>​    				result.at<uchar>(i, j) &#x3D; 255;<br>​    			if (laplacian.at<float>(i, j + 1) <br>​    				* laplacian.at<float>(i, j - 1) &lt; 0)<br>​    				result.at<uchar>(i, j) &#x3D; 255;<br>​    			if (laplacian.at<float>(i + 1, j + 1) <br>​    				* laplacian.at<float>(i - 1, j - 1) &lt; 0)<br>​    				result.at<uchar>(i, j) &#x3D; 255;<br>​    			if (laplacian.at<float>(i - 1, j + 1) <br>​    				* laplacian.at<float>(i + 1, j - 1) &lt; 0)<br>​    				result.at<uchar>(i, j) &#x3D; 255;<br>​    		}<br>​    	}<br>​    	return result;<br>​    }<br>​<br>​    &#x2F;&#x2F;Canny算子计算图像的梯度和方向<br>​    void CannyEdgeAndDirection(const Mat&amp; src)<br>​    {<br>​    	Mat magX &#x3D; Mat(src.rows, src.cols, CV_32FC1);<br>​    	Mat magY &#x3D; Mat(src.rows, src.cols, CV_32FC1);<br>​    	Mat slopes &#x3D; Mat(src.rows, src.cols, CV_32FC1);<br>​    	Sobel(src, magX, CV_32FC1, 1, 0, 3);&#x2F;&#x2F;水平梯度<br>​    	Sobel(src, magY, CV_32FC1, 1, 0, 3);&#x2F;&#x2F;垂直梯度<br>​    	&#x2F;&#x2F;梯度方向<br>​    	divide(magY, magX, slopes);<br>​    	&#x2F;&#x2F;梯度幅值<br>​    	Mat magnitude;<br>​    	sqrt(magX * magX + magY * magY, magnitude);<br>​    }</uchar></float></float></uchar></float></float></uchar></float></float></uchar></float></float></float></p>
<h6 id="2-霍夫直线变换及霍夫圆的检测"><a href="#2-霍夫直线变换及霍夫圆的检测" class="headerlink" title="2.霍夫直线变换及霍夫圆的检测"></a>2.霍夫直线变换及霍夫圆的检测</h6><p>​<br>​    #include “opencv.hpp”<br>​    #include “highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    VideoCapture capture(0);<br>​    Mat image;<br>​<br>​    &#x2F;&#x2F;#define SHT	&#x2F;&#x2F;SHT检测直线<br>​    &#x2F;&#x2F;#define PPHT	&#x2F;&#x2F;PPHT检测直线<br>​    #define HCD		&#x2F;&#x2F;霍夫圆检测<br>​<br>​    int main()<br>​    {<br>​    	while (capture.isOpened())<br>​    	{<br>​    		capture &gt;&gt; image;<br>​    		if (image.empty())break;<br>​    		Mat matCanny;<br>​    		Mat matDst;<br>​    		Canny(image, matCanny, 100, 300, 3, false);		&#x2F;&#x2F;canny算子<br>​<br>​    #ifdef SHT<br>​    		std::vector<Vec2f> linesSHT;<br>​    		&#x2F;&#x2F;标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为300<br>​    		HoughLines(matCanny, linesSHT, 1, CV_PI &#x2F; 180, 280);<br>​    		&#x2F;&#x2F;直线在原图上绘制<br>​    		matDst &#x3D; image.clone();<br>​    		for (size_t i &#x3D; 0; i &lt; linesSHT.size(); i++) {<br>​    			&#x2F;&#x2F;直线的rho和theta值<br>​    			float rho &#x3D; linesSHT[i][0], theta &#x3D; linesSHT[i][1];<br>​    			&#x2F;&#x2F;pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）<br>​    			Point pt1, pt2;<br>​    			double a &#x3D; cos(theta), b &#x3D; sin(theta);<br>​    			double x0 &#x3D; a * rho, y0 &#x3D; b * rho;<br>​    			pt1.x &#x3D; cvRound(x0 + 2000 * (-b)); &#x2F;&#x2F;把浮点数转化成整数<br>​    			pt1.y &#x3D; cvRound(y0 + 2000 * (a));<br>​    			pt2.x &#x3D; cvRound(x0 - 2000 * (-b));<br>​    			pt2.y &#x3D; cvRound(y0 - 2000 * (a));<br>​    			line(matDst, pt1, pt2, Scalar(255), 4);<br>​    		}<br>​    #endif &#x2F;&#x2F; SHT标准霍夫变换<br>​<br>    #ifdef PPHT<br>    		matDst &#x3D; image.clone();<br>    		std::vector<Vec4i> linesPPHT;<br>    		&#x2F;&#x2F;累计概率霍夫变换检测直线，得到的是直线的起止端点<br>    		HoughLinesP(matCanny, linesPPHT, 1, CV_PI &#x2F; 180, 220, 100, 50);<br>    		for (size_t i &#x3D; 0; i &lt; linesPPHT.size(); i++) {<br>    			&#x2F;&#x2F;直接绘制直线<br>    			line(matDst, Point(linesPPHT[i][0], linesPPHT[i][1]),<br>    				Point(linesPPHT[i][2], linesPPHT[i][3]), Scalar(255), 4, 8);<br>    		}<br>    #endif &#x2F;&#x2F; PPHT累计概率霍夫变换</Vec4i></Vec2f></iostream></p>
<pre><code>#ifdef HCD
		cvtColor(image, matDst, COLOR_BGR2GRAY);
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matDst, circles, HOUGH_GRADIENT, 1, 10, 60, 40, 20, 40);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(matDst, center, 3, Scalar(255), -1, 4, 0);
			//圆  
			circle(matDst, center, radius, Scalar(255), 3, 4, 0);
		&#125;
#endif // HCD霍夫圆检测
</code></pre>
<p>​<br>​    		imshow(“检测结果”, matDst);<br>​    		if (waitKey(1) &#x3D;&#x3D; 27)break;<br>​    	}<br>​    }</p>
<h6 id="3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"><a href="#3-linux（ubuntu18）上实现霍夫圆检测（可调各个参数）" class="headerlink" title="3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）"></a>3.linux（ubuntu18）上实现霍夫圆检测（可调各个参数）</h6><p>参数见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxqmy/p/12333022.html" title="opencv ——
HoughCircles 霍夫圆变换原理及圆检测">opencv —— HoughCircles<br>霍夫圆变换原理及圆检测</a></p>
<p>二值化函数threshold参数：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012566751/article/details/77046445" title="OpenCV基础——threshold函数的使用">OpenCV基础——threshold函数的使用</a></p>
<p>​<br>​    #include “opencv2&#x2F;opencv.hpp”<br>​    #include “opencv2&#x2F;highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​<br>​    VideoCapture capture(0);<br>​    Mat image;<br>​<br>​    const char* windowname&#x3D;”win”;<br>​    int max_r&#x3D;100;<br>​    int min_r&#x3D;60;<br>​    int min_d&#x3D;80;<br>​    int t_hold&#x3D;45;<br>​    int param1&#x3D;100;<br>​    int param2&#x3D;10;<br>​    const int t_max&#x3D;255;<br>​    const int r_max&#x3D;1000;<br>​    const int d_max&#x3D;100;<br>​    const int p1_max&#x3D;200;<br>​    const int p2_max&#x3D;200;<br>​<br>​    int main()<br>​    {<br>​<br>​        void on_Trackbar_1(int, void*);<br>​        void on_Trackbar_2(int, void*);<br>​        void on_Trackbar_3(int, void*);<br>​        void on_Trackbar_4(int, void*);<br>​        void on_Trackbar_5(int, void*);<br>​        void on_Trackbar_6(int, void*);<br>​        namedWindow(windowname,0);<br>​        setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);<br>​        resizeWindow(windowname, 400, 300);<br>​        moveWindow(windowname, 0, 0);<br>​        createTrackbar(“t_hold”,windowname, &amp;t_hold, t_max, on_Trackbar_3);<br>​        createTrackbar(“max_r”,windowname, &amp;max_r, r_max, on_Trackbar_1);<br>​        createTrackbar(“min_r”,windowname, &amp;min_r, r_max, on_Trackbar_2);<br>​        createTrackbar(“min_d”,windowname, &amp;min_d, d_max, on_Trackbar_6);<br>​        createTrackbar(“p_1”,windowname, &amp;param1, p1_max, on_Trackbar_4);<br>​        createTrackbar(“p_2”,windowname, &amp;param2, p2_max, on_Trackbar_5);<br>​<br>    	while (capture.isOpened())<br>    	{<br>    		capture &gt;&gt; image;<br>    		if (image.empty())break;<br>    		Mat matCanny;<br>            Mat BinImg;<br>            Mat matDst;<br>            cvtColor(image, matDst, COLOR_BGR2GRAY);<br>    		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV);<br>            Canny(BinImg, matCanny, 100, 300, 3, false);		&#x2F;&#x2F;canny算子</iostream></p>
<pre><code>		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

        imshow(&quot;matCanny&quot;, matCanny);
        imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<p>​<br>​    void on_Trackbar_1(int, void*)<br>​    {<br>​        ;<br>​    }</p>
<p>​<br>​    void on_Trackbar_2(int, void*)<br>​    {<br>​        ;<br>​    }<br>​<br>​    void on_Trackbar_3(int, void*)<br>​    {<br>​        ;<br>​    }<br>​<br>​    void on_Trackbar_4(int, void*)<br>​    {<br>​        ;<br>​    }<br>​<br>​    void on_Trackbar_5(int, void*)<br>​    {<br>​        ;<br>​    }<br>​<br>​    void on_Trackbar_6(int, void*)<br>​    {<br>​        ;<br>​    }</p>
<p>注：OpenCV提供的SHT输出极坐标下直线的rho和theta值，需根据经验值推算该直线上的两点以绘图；而PPHT直接返回线段两端两点坐标</p>
<p>*注：图像灰度化的方法：可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36853469/article/details/106416128" title="OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客">OpenCV图像灰度化的六种方法_opencv灰度化_郑德帅的博客-CSDN博客</a></p>
<h6 id="4-阈值分割（OTSU-三角法-自适应阈值）"><a href="#4-阈值分割（OTSU-三角法-自适应阈值）" class="headerlink" title="4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）"></a>4.阈值分割（OTSU&#x2F;三角法&#x2F;自适应阈值）</h6><p>​<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    VideoCapture capture(0);<br>​    Mat image;<br>​<br>​    int main()<br>​    {<br>​    	int OtsuBinary(Mat src);<br>​    	int TriangleBinary(Mat src);<br>​    	Mat gray, dst;<br>​<br>​    	capture &gt;&gt; image;<br>​    	cvtColor(image, gray, COLOR_BGR2GRAY);<br>​    	int nThreshold &#x3D; OtsuBinary(gray);<br>​    &#x2F;&#x2F;	int nThreshold &#x3D; TriangleBinary(gray);<br>​    	<br>​    	while(capture.isOpened())<br>​    	{<br>​    		capture &gt;&gt; image;<br>​    		if (image.empty())break;<br>​    		cvtColor(image, gray, COLOR_BGR2GRAY);<br>​<br>    		&#x2F;&#x2F;用OTSU方法<br>    &#x2F;&#x2F;		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);<br>    &#x2F;&#x2F;		threshold(gray, dst, 0, 255, THRESH_BINARY | THRESH_OTSU);<br>    		&#x2F;&#x2F;用三角法<br>    &#x2F;&#x2F;		threshold(gray, dst, nThreshold, 255, THRESH_BINARY);<br>    &#x2F;&#x2F;		threshold(gray, dst, 0, 255, THRESH_BINARY|THRESH_TRIANGLE);<br>    		&#x2F;&#x2F;自适应阈值<br>    		adaptiveThreshold(gray, dst, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 7, 5);</iostream></p>
<pre><code>		imshow(&quot;BinbaryImage&quot;, dst);
		if (waitKey(1) == 27)break;
	&#125;
&#125;
</code></pre>
<p>*<strong>注：自适应阈值保留信息更多，注意使用场合</strong></p>
<h6 id="5-识别车道（二值化、边缘检测、霍夫直线变换）"><a href="#5-识别车道（二值化、边缘检测、霍夫直线变换）" class="headerlink" title="5.识别车道（二值化、边缘检测、霍夫直线变换）"></a><strong>5.识别车道（二值化、边缘检测、霍夫直线变换）</strong></h6><p>​<br>​    #include “opencv.hpp”<br>​    #include “highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​    #pragma comment(lib,”opencv_world480d.lib”)<br>​<br>​    int main() {<br>​    	Mat image &#x3D; imread(“car_track.jpg”, IMREAD_GRAYSCALE);<br>​    	Mat BinImg;<br>​    	threshold(image, BinImg, 150, 255, THRESH_BINARY);<br>​    	imwrite(“BinImg.jpg”, BinImg);<br>​    	Mat matCanny;<br>​    	Canny(BinImg, matCanny, 100, 300, 3, false);		&#x2F;&#x2F;canny算子<br>​    	imwrite(“CannyImg.jpg”, matCanny);<br>​    	Mat matDst &#x3D; image.clone();<br>​<br>​    	std::vector<Vec2f> linesSHT;<br>​    	&#x2F;&#x2F;标准霍夫变换检测直线,距离精度为1像素，角度精度为1度，阈值为100<br>​    	HoughLines(matCanny, linesSHT, 1, CV_PI &#x2F; 180, 100);<br>​    	&#x2F;&#x2F;直线在原图上绘制<br>​    	matDst &#x3D; image.clone();<br>​    	for (size_t i &#x3D; 0; i &lt; linesSHT.size(); i++) {<br>​    		&#x2F;&#x2F;直线的rho和theta值<br>​    		float rho &#x3D; linesSHT[i][0], theta &#x3D; linesSHT[i][1];<br>​    		&#x2F;&#x2F;pt1和pt2是直线的两个端点，2000是经验值（满足覆盖所有前景点像素）<br>​    		Point pt1, pt2;<br>​    		double a &#x3D; cos(theta), b &#x3D; sin(theta);<br>​    		double x0 &#x3D; a * rho, y0 &#x3D; b * rho;<br>​    		pt1.x &#x3D; cvRound(x0 + 2000 * (-b)); &#x2F;&#x2F;把浮点数转化成整数<br>​    		pt1.y &#x3D; cvRound(y0 + 2000 * (a));<br>​    		pt2.x &#x3D; cvRound(x0 - 2000 * (-b));<br>​    		pt2.y &#x3D; cvRound(y0 - 2000 * (a));<br>​    		line(matDst, pt1, pt2, Scalar(255), 8);<br>​    	}<br>​<br>​    	imshow(“car_track”, matDst);<br>​    	waitKey(0);<br>​    	imwrite(“car_track_show.jpg”, matDst);<br>​    }</Vec2f></iostream></p>
<p>处理结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51f19fbe807f911ee210017b64ea64ea.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/699cf9a73e9c5db8f5837d0018fe3604.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/4fa8e85338396b037d05b85d40503c9d.jpeg"><img src="https://i-blog.csdnimg.cn/blog_migrate/a35992394ee154df3670b102dfe9543c.jpeg"></p>
<h2 id="九-特征提取和目标检测"><a href="#九-特征提取和目标检测" class="headerlink" title="九.特征提取和目标检测"></a>九.特征提取和目标检测</h2><h5 id="（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）"><a href="#（特征：HOG-LBP-HAAR-LIKE）（分类：SVM-级联分类器）" class="headerlink" title="&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）"></a>&lt;1&gt;（特征：HOG&#x2F;LBP&#x2F;HAAR-LIKE）（分类：SVM&#x2F;级联分类器）</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd37be7931389615cbb559ae52a7a7ff.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/70661001c310f47939567a8a92d0512d.jpeg"></p>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="&lt;2&gt;示例代码"></a>&lt;2&gt;示例代码</h5><h6 id="1-HOG特征提取-SVM"><a href="#1-HOG特征提取-SVM" class="headerlink" title="1.HOG特征提取+SVM"></a>1.HOG特征提取+SVM</h6><p>​<br>​    &#x2F;&#x2F;SVM参考代码<br>​<br>​    #include “pch.h”<br>​    #include <iostream>	<br>​    #include <fstream><br>​    #include &lt;windows.h&gt;<br>​    &#x2F;&#x2F;#include &lt;afxwin.h&gt;<br>​<br>​    #include <stack><br>​    #include “opencv.hpp”<br>​    using namespace cv;<br>​    using namespace std;<br>​    using namespace cv::ml;<br>​<br>​    #ifdef _DEBUG<br>​    #pragma comment(lib, “opencv_world480d.lib”)<br>​    #else<br>​    #pragma comment(lib, “opencv_world480.lib”)<br>​    #endif<br>​<br>​    &#x2F;&#x2F;************************************<br>​    const char* file_path &#x3D; “E:&#x2F;测试视频数据&#x2F;Video_2016_8_26__10_10_48.mp4”;<br>​    &#x2F;&#x2F;************************************<br>​<br>    vector&lt; float &gt; get_svm_detector(const Ptr&lt; SVM &gt;&amp; svm)<br>    {<br>    	&#x2F;&#x2F;得到支持向量<br>    	Mat sv &#x3D; svm-&gt;getSupportVectors();<br>    	const int sv_total &#x3D; sv.rows;<br>    	&#x2F;&#x2F;得到支持向量对应的系数值<br>    	Mat alpha, svidx;<br>    	double rho &#x3D; svm-&gt;getDecisionFunction(0, alpha, svidx);</stack></fstream></iostream></p>
<pre><code>	CV_Assert(alpha.total() == 1 &amp;&amp; svidx.total() == 1 &amp;&amp; sv_total == 1);
	CV_Assert((alpha.type() == CV_64F &amp;&amp; alpha.at&lt;double&gt;(0) == 1.) ||
		(alpha.type() == CV_32F &amp;&amp; alpha.at&lt;float&gt;(0) == 1.f));
	CV_Assert(sv.type() == CV_32F);
	//将支持向量的值写入一个vector返回
	vector&lt; float &gt; hog_detector(sv.cols + 1);
	memcpy(&amp;hog_detector[0], sv.ptr(), sv.cols * sizeof(hog_detector[0]));
	hog_detector[sv.cols] = (float)-rho;
	return hog_detector;
&#125;

//sampleMat是采样矩阵,labelMat是类别矩阵,nCurRows当前是矩阵的行数
//提取正样本HOG特征
void PosData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;pos_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat imgSrc = imread(files[i], IMREAD_GRAYSCALE); //加载图像
		if (imgSrc.empty()) &#123;
			cout &lt;&lt; files[i] &lt;&lt; &quot; is invalid!&quot; &lt;&lt; endl;
			continue;
		&#125;
		Mat imgDst;
		resize(imgSrc, imgDst, hog.winSize); //将正例缩放到检测窗口大小
		vector&lt;float&gt; featureVec;
		hog.compute(imgDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(+1); //正样本类别为+1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

//提取负样本HOG特征
void NegData(HOGDescriptor&amp; hog, Mat&amp; sampleMat, vector&lt;int&gt;&amp; Labels, int&amp; nRowIdx)
&#123;
	vector&lt;String&gt; files; //文件名列表
	//************************************
	glob(&quot;neg_src/*.*&quot;, files); //搜索positive目录下所有文件
	//************************************
	Rect box;
	box.width = hog.winSize.width;
	box.height = hog.winSize.height;
	for (size_t i = 0; i &lt; files.size(); ++i) &#123;
		Mat img = imread(files[i], IMREAD_GRAYSCALE);
		if (img.empty()) &#123;
			continue;
		&#125;
		Mat matDst;
		if (img.cols &lt;= hog.winSize.width + 1 || img.rows &lt;= hog.winSize.height + 1) &#123;
			//cout &lt;&lt; &quot;image too small&quot; &lt;&lt; endl;
			resize(img, matDst, hog.winSize);
		&#125;
		else &#123;
			//随机选择窗口位置
			box.x = rand() % (img.cols - box.width);
			box.y = rand() % (img.rows - box.height);
			matDst = img(box);
		&#125;

		vector&lt;float&gt; featureVec;
		hog.compute(matDst, featureVec, Size(8, 8), Size(0, 0));
		//将特征向量加入采样矩阵
		for (int i = 0; i &lt; featureVec.size(); i++) &#123;
			sampleMat.at&lt;float&gt;(nRowIdx, i) = featureVec[i];
		&#125;
		nRowIdx++;
		Labels.push_back(-1);//负样本类别为-1 
		cout &lt;&lt; nRowIdx &lt;&lt; files[i] &lt;&lt; endl;
	&#125;
&#125;

void TrainSVMModel()
&#123;
	//车牌检测window大小为128X48,block大小为16X16,cell大小为8X8，滑动窗口大小为8X8
	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), cv::Size(8, 8), 9);
	int nVecLen = hog.getDescriptorSize();
	//样本的特征向量，行数等于正负样本个数，列数等于HOG特征向量长度
	Mat sampleFeatureMat = Mat::zeros(9689, nVecLen, CV_32FC1);
	//样本的类别向量，行数等于所有样本的个数，列数等于1；1表示正样本，-1表示负样本
	vector&lt;int&gt; Labels;
	int nRowIdx = 0;
	PosData(hog, sampleFeatureMat, Labels, nRowIdx);
	NegData(hog, sampleFeatureMat, Labels, nRowIdx);
</code></pre>
<p>​<br>​    	Ptr<SVM> svm &#x3D; SVM::create(); &#x2F;&#x2F;创建一个SVM分类器<br>​    	svm-&gt;setCoef0(0.0);<br>​    	svm-&gt;setDegree(3);<br>​    	svm-&gt;setGamma(0);<br>​    	svm-&gt;setKernel(SVM::LINEAR);<br>​    	svm-&gt;setNu(0.5);<br>​    	svm-&gt;setP(0.1);<br>​    	svm-&gt;setC(0.01);<br>​    	svm-&gt;setType(SVM::EPS_SVR); &#x2F;&#x2F;分类器类型为EPS_SVR<br>​    	&#x2F;&#x2F;************************************<br>​    	&#x2F;&#x2F;训练结束条件：要么达到1000次，要么两次误差小于1e-3<br>​    	svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, 1e-3));<br>​    	&#x2F;&#x2F;************************************<br>​    	svm-&gt;train(sampleFeatureMat, ROW_SAMPLE, Labels);<br>​<br>​    	&#x2F;&#x2F;svm-&gt;trainAuto();<br>​    	&#x2F;&#x2F;直接将支持向量系数写入文本文件，以方便在检测器的头文件中导入<br>​    	vector<float> vecHogCof &#x3D; get_svm_detector(svm);<br>​    	&#x2F;&#x2F;************************************<br>​    	&#x2F;&#x2F;支持向量结果保存<br>​    	ofstream file(“dector.txt”);	<br>​    	&#x2F;&#x2F;************************************<br>​    	for (int i &#x3D; 0; i &lt; vecHogCof.size(); i++) {<br>​    		file &lt;&lt; vecHogCof[i] &lt;&lt; “,”;<br>​    	}<br>​    	file.close();<br>​    }</float></SVM></p>
<p>​<br>​    void TestSVMModel()<br>​    {<br>​    	&#x2F;&#x2F;************************************<br>​    	&#x2F;&#x2F;SVM检测器系数向量都放在hogCof数组中(detect.txt中内容，模型建立好后可直接调用)<br>​    	float hogCof[] &#x3D; {……};<br>​    	&#x2F;&#x2F;************************************<br>​    	<br>​    	&#x2F;&#x2F;创建HOG检测器，参数与训练时的参数相同<br>​    	&#x2F;&#x2F;在这里特别注意将nLevels参数从默认64修改为4，可以加快检测速度<br>​    	HOGDescriptor hog(cv::Size(128, 48), cv::Size(16, 16), cv::Size(8, 8), <br>​    		cv::Size(8, 8), 9, 1, -1.0, HOGDescriptor::L2Hys, 0.2, false, 4);<br>​    	const int vecLen &#x3D; sizeof(hogCof) &#x2F; sizeof(float);<br>​    	vector<float> vecHogCof(hogCof, hogCof + vecLen);<br>​    	hog.setSVMDetector(vecHogCof); &#x2F;&#x2F;设置HOG检测器的系数<br>​<br>​    	&#x2F;&#x2F;打开一个视频文件<br>​    	VideoCapture cap;<br>​    	cap.open(file_path);<br>​    	if (!cap.isOpened()) {<br>​    		return;<br>​    	}<br>​    	Mat frame;<br>​    	int nFrmIdx &#x3D; 0;<br>​    	while (true) {<br>​    		cap &gt;&gt; frame;<br>​    		if (frame.empty()) {<br>​    			break;<br>​    		}<br>​    		vector<Rect> detections; &#x2F;&#x2F;检测到目标矩形位置<br>​    		vector<double> foundWeights; &#x2F;&#x2F;检测到的权重<br>​    		hog.detectMultiScale(frame, detections, foundWeights, 0.5, Size(8, 8), Size(0, 0), 1.1, 3.0, false);<br>​    		for (int i &#x3D; 0; i &lt; detections.size(); i++) {<br>​    			if (frame.rows - detections[i].y &lt; 200)<br>​    				continue;<br>​    			rectangle(frame, detections[i], Scalar(0, 0, 255), 4);<br>​    		}<br>​    		imshow(“LP HOG Detection”, frame);<br>​    		if (detections.size() &gt; 0) {<br>​    			char szFileName[100] &#x3D; { 0 };<br>​    			sprintf_s(szFileName, “%03d.jpg”, nFrmIdx++);<br>​    			imwrite(szFileName, frame);<br>​    		}<br>​<br>​    		waitKey(40);<br>​    	}<br>​    }<br>​<br>​    int mian()<br>​    {<br>​    	TestSVMModel();<br>​    }</double></Rect></float></p>
<p>注：</p>
<p>①.&#x2F;&#x2F;*…*之间的是copy代码时要修改的地方</p>
<p>②.void TrainSVMModel()求出支持向量系数，保存在文件中，之后可以直接复制其中数值以调用</p>
<h6 id="2-获取LBP-MB-LBP特征函数"><a href="#2-获取LBP-MB-LBP特征函数" class="headerlink" title="2.获取LBP&#x2F;MB-LBP特征函数"></a>2.获取LBP&#x2F;MB-LBP特征函数</h6><p>​<br>​    &#x2F;&#x2F;使用函数模板，保证函数对所有类型图像都适用<br>​    &#x2F;&#x2F;_tp参数可以是uchar,float等<br>​    template <typename _tp><br>​    &#x2F;&#x2F;原始LBP特征<br>​    void getOriginLBPFeature(InputArray _src, OutputArray _dst)<br>​    {<br>​    	Mat src &#x3D; _src.getMat();<br>​    	Mat srcExtented;<br>​    	&#x2F;&#x2F;对图像边界进行扩充，边界像素采用复制的形式<br>​    	copyMakeBorder(src, srcExtented, 1, 1, 1, 1, BORDER_REPLICATE);<br>​    	&#x2F;&#x2F;输出图像与原图像大小相同<br>​    	_dst.create(src.rows, src.cols, CV_8UC1);<br>​    	Mat dst &#x3D; _dst.getMat();<br>​    	dst.setTo(0);<br>​    	for (int i &#x3D; 0; i &lt; src.rows; i++) {<br>​    		for (int j &#x3D; 0; j &lt; src.cols; j++) {<br>​    			&#x2F;&#x2F;中心像素的值<br>​    			_tp center &#x3D; srcExtented.at&lt;_tp&gt;(i + 1, j + 1);<br>​    			unsigned char lbpCode &#x3D; 0; &#x2F;&#x2F;LBP编码值<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i, j) &gt; center) &lt;&lt; 7; &#x2F;&#x2F;左上角<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i, j + 1) &gt; center) &lt;&lt; 6; &#x2F;&#x2F;上边<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i, j + 2) &gt; center) &lt;&lt; 5; &#x2F;&#x2F;右上角<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i + 1, j + 2) &gt; center) &lt;&lt; 4; &#x2F;&#x2F;右边<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i + 2, j + 2) &gt; center) &lt;&lt; 3; &#x2F;&#x2F;右下角<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i + 2, j + 1) &gt; center) &lt;&lt; 2; &#x2F;&#x2F;下边<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i + 2, j) &gt; center) &lt;&lt; 1; &#x2F;&#x2F;左下角<br>​    			lbpCode |&#x3D; (srcExtented.at&lt;_tp&gt;(i + 1, j) &gt; center) &lt;&lt; 0; &#x2F;&#x2F;左边<br>​    			dst.at<uchar>(i, j) &#x3D; lbpCode;<br>​    		}<br>​    	}<br>​    }<br>​<br>​    &#x2F;&#x2F;MB-LBP特征<br>​    void getMultiScaleBlockLBPFeature(InputArray _src, OutputArray _dst, int scale)<br>​    {<br>​    	Mat src &#x3D; _src.getMat();<br>​    	int cellSize &#x3D; scale &#x2F; 3;<br>​    	int offset &#x3D; cellSize &#x2F; 2;<br>​    	Mat srcExtented;<br>​    	&#x2F;&#x2F;图像扩大一圈<br>​    	copyMakeBorder(src, srcExtented, offset, offset, offset, offset, BORDER_REFLECT);<br>​    	&#x2F;&#x2F;以当前点为中心，计算每个cell的像素均值<br>​    	Mat cellImage(src.rows, src.cols, CV_8UC1);<br>​    	for (int i &#x3D; 0; i &lt; src.rows; i++) {<br>​    		for (int j &#x3D; 0; j &lt; src.cols; j++) {<br>​    			int temp &#x3D; 0;<br>​    			for (int m &#x3D; -offset; m &lt; offset + 1; m++) {<br>​    				for (int n &#x3D; -offset; n &lt; offset + 1; n++) {<br>​    					temp +&#x3D; srcExtented.at<uchar>(i + n + offset, j + m + offset);<br>​    				}<br>​    			}<br>​    			temp &#x2F;&#x3D; (cellSize * cellSize);<br>​    			cellImage.at<uchar>(i, j) &#x3D; uchar(temp);<br>​    		}<br>​    	}<br>​    	getOriginLBPFeature<uchar>(cellImage, _dst);<br>​    }</uchar></uchar></uchar></uchar></typename></p>
<h6 id="3-cascade级联分类器使用"><a href="#3-cascade级联分类器使用" class="headerlink" title="3.cascade级联分类器使用"></a>3.cascade级联分类器使用</h6><p>​<br>​    &#x2F;&#x2F;级联分类器实现人脸检测<br>​    void DetectFaces()<br>​    {<br>​    	&#x2F;&#x2F;创建一个级联分类器对象，并加载分类器文件<br>​    	&#x2F;&#x2F;CascadeClassifier faceDetector(“haarcascade_frontalface_alt2.xml”);<br>​    	CascadeClassifier faceDetector(“cascade.xml”);<br>​    	if (faceDetector.empty()) {<br>​    		return;<br>​    	}<br>​    	VideoCapture cap(0); &#x2F;&#x2F;打开USB摄像头<br>​    	if (!cap.isOpened()) {<br>​    		return;<br>​    	}<br>​    	Mat frame;<br>​    	while (true) {<br>​    		cap &gt;&gt; frame; &#x2F;&#x2F;从摄像头获取一帧图像<br>​    		if (frame.empty())<br>​    			break;<br>​    		std::vector&lt;cv::Rect&gt; objects;<br>​    		&#x2F;&#x2F;使用级联分类器检测人脸<br>​    		faceDetector.detectMultiScale(frame, objects);<br>​    		&#x2F;&#x2F;对人脸图像进行标记<br>​    		for (int i &#x3D; 0; i &lt; objects.size(); i++) {<br>​    			static int nIdx &#x3D; 0;<br>​    			char szFileName[100] &#x3D; { 0 };<br>​    			sprintf_s(szFileName, “detectedHeadShoulder&#x2F;%03d.jpg”, nIdx++);<br>​    			&#x2F;&#x2F;sprintf_s(szFileName, “DetetecdFaces&#x2F;%03d.jpg”, nIdx++);<br>​    			cv::rectangle(frame, objects[i], Scalar(0, 0, 255), 4);<br>​    			imwrite(szFileName, frame);<br>​    		}<br>​    		imshow(“人脸检测结果”, frame); &#x2F;&#x2F;显示人脸检测结果<br>​<br>​    		if (waitKey(25) &#x3D;&#x3D; 27) &#x2F;&#x2F;暂停25ms，如果按ESC键则退出<br>​    			break;<br>​    	}<br>​    	cap.release(); &#x2F;&#x2F;释放摄像头对象<br>​    	return;<br>​    }</p>
<p>注：分类器文件生成使用opencv_traincacade.exe；创建正样本.vec文件使用opencv_creatsamples.exe；可视化过程使用opencv_visualisation.exe</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797">https://blog.csdn.net/qq_32971095/article/details/131609797</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（电机部分）——电赛学习笔记（2）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 22:32:42" itemprop="dateCreated datePublished" datetime="2023-07-04T22:32:42+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:26:06" itemprop="dateModified" datetime="2025-02-09T14:26:06+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（电机部分）——电赛学习笔记（2）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>907</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><hr>
<h2 id="图片来源：B站唐老师讲电赛"><a href="#图片来源：B站唐老师讲电赛" class="headerlink" title="_  图片来源：B站唐老师讲电赛_"></a><strong>_  图片来源：B站唐老师讲电赛_</strong></h2><p><strong>目录</strong></p>
<p><a href="about:blank#%C2%A0%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90%EF%BC%9AB%E7%AB%99%E5%94%90%E8%80%81%E5%B8%88%E8%AE%B2%E7%94%B5%E8%B5%9B"><br>图片来源：B站唐老师讲电赛</a></p>
<p><a href="about:blank#%E4%B8%80.%E7%94%B5%E6%9C%BA%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84">一.电机部分结构</a></p>
<p><a href="about:blank#%E4%BA%8C.%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">二.步进电机示例</a></p>
<p><a href="about:blank#%E4%B8%89.%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BA%E7%A4%BA%E4%BE%8B">三.伺服电机示例</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%A1%88">四.我们的方案</a></p>
<hr>
<h2 id="一-电机部分结构"><a href="#一-电机部分结构" class="headerlink" title="一.电机部分结构"></a>一.电机部分结构</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcfec2f6ed3a3e801301c91dfeb4307d.jpeg"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b68a6432253fb37113bcd87a78d6af13.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/99f4e23df848c63b9a836035426fe043.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5483b488abe59c6b56599034cee91db9.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/36766f56d5dbe1c3b71e1d2f8cc63d56.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f23bb2de689dbeadc754dd5f58a19811.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/f2fe3b27147efcb57b0964d81171b5b5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4547084918f7ca3e14a1a6aaf1c3ea0c.png"></p>
<h2 id="二-步进电机示例"><a href="#二-步进电机示例" class="headerlink" title="二.步进电机示例"></a>二.步进电机示例</h2><p>1.驱动器：L298N（CSDN搜索使用方法）；控制器：stm32；电源暂时用12V直流源</p>
<p>2.控制：全速模式：in1、in2一低一高控制正反转，全低不转。</p>
<p>pwm控制模式：使能端连接单片机IO口，通过产生pwm波占空比控制速度（相当于有效电压控制）</p>
<p>3.编码器：将编码器产生脉冲当做外部时钟传入单片机定时器，定时读取并清零</p>
<p>4.涉及知识：定时器（内部定时器产生pwm波，外部作为编码计数）</p>
<p>5.示例代码：</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_65683639/article/details/130562162" title="直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-CSDN博客">直流减速编码电机的使用（STM32f103c8t6）L298N电机驱动模块_stm32f103c8t6控制直流电机_阿昕同学的博客-<br>CSDN博客</a></p>
<h2 id="三-伺服电机示例"><a href="#三-伺服电机示例" class="headerlink" title="三.伺服电机示例"></a>三.伺服电机示例</h2><p>MG995型伺服电机：</p>
<p>1.结构：可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/he__yuan/article/details/79195435?spm=1001.2014.3001.5506" title="MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-CSDN博客">MG995舵机工作原理及基于STM32的驱动源代码_斜杠青年&#x2F;的博客-<br>CSDN博客</a></p>
<p>2.控制：通过PWM波占空比控制</p>
<p>固定20ms周期pwm波通过定时器输出  </p>
<p>TIM1_PWM_Init(199,7199);        &#x2F;&#x2F;(7200<em>200)&#x2F;72000000&#x3D;0.02&#x3D;20ms；（分频</em>周期数）</p>
<p>占空比通过函数TIM_SetCompare1（TIM1,num）控制，其中num是低电平占周期数</p>
<p>0.5ms对应195，2.5ms对应175</p>
<p>四.具体器件</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/79abef952376244b07db4ca4c37604b6.png"></p>
<h2 id="四-我们的方案"><a href="#四-我们的方案" class="headerlink" title="四.我们的方案"></a>四.我们的方案</h2><p>后轮电机：MG513直流减速电机（霍尔编码器）</p>
<p>前轮转向电机（采用阿克曼转向结构）：舵机MG995</p>
<p>机械臂电机：舵机MG995</p>
<p>后轮电机驱动：l298n电机驱动模块</p>
<p>舵机驱动：pca9685 PWM伺服驱动器模块</p>
<p>超声波测距：cs100a超声波模块</p>
<p>蓝牙：JDY-31蓝牙模块</p>
<p>显示屏：SSD1306 OLED IIC显示屏</p>
<p>稳压芯片：lm2596可调稳压模块*2（12V-5V-3.3V）</p>
<p>电池：12V3A锂电池（最大电流6A）</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131503991">https://blog.csdn.net/qq_32971095/article/details/131503991</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（jetson nano部分）——电赛学习笔记（3）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 22:30:36" itemprop="dateCreated datePublished" datetime="2023-07-04T22:30:36+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:26:15" itemprop="dateModified" datetime="2025-02-09T14:26:15+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（jetson nano部分）——电赛学习笔记（3）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88jetson%20nano%E9%83%A8%E5%88%86%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E9%9B%B6.%E5%89%8D%E8%A8%80">零.前言</a></p>
<p><a href="about:blank#1.jetson%20nano%E8%B4%AD%E4%B9%B0%E5%95%86%E5%AE%B6%E5%8F%8A%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81">1.jetson<br>nano购买商家及技术支持</a></p>
<p><a href="about:blank#2.%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2.相关环境配置</a></p>
<p><a href="about:blank#3.%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD">3.做好系统备份</a></p>
<p><a href="about:blank#%E4%B8%80.vscode%E8%BF%9C%E7%A8%8Bssh%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5%EF%BC%89">一.vscode远程ssh操作</a></p>
<p><a href="about:blank#%3C1%3E%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9E%E6%8E%A5">&lt;1&gt;局域网连接</a></p>
<p><a href="about:blank#%3C2%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E">&lt;2&gt;电脑直连</a></p>
<p><a href="about:blank#%3C3%3E%E7%94%B5%E8%84%91%E7%9B%B4%E8%BF%9E%2BVNC%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">&lt;3&gt;电脑直连+VNC远程桌面</a></p>
<p><a href="about:blank#%E4%BA%8C.%E6%9D%BF%E8%BD%BD%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%99%E7%A8%8B%EF%BC%9A">二.板载摄像头教程：</a></p>
<p><a href="about:blank#%E4%B8%89.%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B">三.运行例程</a></p>
<p><a href="about:blank#%E5%9B%9B.GPIO%E4%BD%BF%E7%94%A8">四.GPIO使用</a></p>
<p><a href="about:blank#GPIO%E5%BA%93%E7%9A%84API%E7%94%A8%E6%B3%95">GPIO库的API用法</a></p>
<p><a href="about:blank#1.%E5%AF%BC%E5%85%A5%E5%BA%93">1.导入库</a></p>
<p><a href="about:blank#2.%E5%BC%95%E8%84%9A%E7%BC%96%E5%8F%B7">2.引脚编号</a></p>
<p><a href="about:blank#3.%E8%AD%A6%E5%91%8A">3.警告</a></p>
<p><a href="about:blank#4.%E8%AE%BE%E7%BD%AE%E9%80%9A%E9%81%93">4.设置通道</a></p>
<p><a href="about:blank#5.%E8%BE%93%E5%85%A5">5.输入</a></p>
<p><a href="about:blank#6.%E8%BE%93%E5%87%BA">6.输出</a></p>
<p><a href="about:blank#set%20first%20channel%20to%20HIGH%20and%20rest%20to%20LOW">set first channel to HIGH and rest to<br>LOW</a></p>
<p><a href="about:blank#7.%E6%B8%85%E7%90%86">7.清理</a></p>
<p><a href="about:blank#8.jetson%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF%E5%92%8C%E5%BA%93%E7%89%88%E6%9C%AC">8.jetson模块信息和库版本</a></p>
<p><a href="about:blank#9.%E4%B8%AD%E6%96%AD">9.中断</a></p>
<p><a href="about:blank#wait_for_edge%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">wait_for_edge（）函数</a></p>
<p><a href="about:blank#timeout%20is%20in%20milliseconds">timeout is in milliseconds</a></p>
<p><a href="about:blank#event_detected%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">event_detected（）函数</a></p>
<p><a href="about:blank#set%20rising%20edge%20detection%20on%20the%20channel">set rising edge detection on the<br>channel</a></p>
<p><a href="about:blank#%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E8%BE%B9%E7%BC%98%E6%97%B6%E8%BF%90%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">当检测到边缘时运行回调函数</a></p>
<p><a href="about:blank#define%20callback%20function">define callback function</a></p>
<p><a href="about:blank#add%20rising%20edge%20detection">add rising edge detection</a></p>
<p><a href="about:blank#bouncetime%20set%20in%20milliseconds">bouncetime set in<br>milliseconds</a></p>
<p><a href="about:blank#10.%E6%A3%80%E6%9F%A5GPIO%E9%80%9A%E9%81%93%E7%9A%84%E5%8A%9F%E8%83%BD">10.检查GPIO通道的功能</a></p>
<p><a href="about:blank#11.%20PWM">11. PWM</a></p>
<p><a href="about:blank#%E4%BA%94.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1">五.串口通信</a></p>
<p><a href="about:blank#%3C1%3EUART">&lt;1&gt;UART</a></p>
<p><a href="about:blank#1.python%E4%BB%A3%E7%A0%81%EF%BC%9AJetsonHacksNano%2FUARTDemo%3A%20UART%20Demo%20Code%20%28github.com%29">1.python代码：JetsonHacksNano&#x2F;UARTDemo: UART Demo Code<br>(github.com)</a></p>
<p><a href="about:blank#3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点</a></p>
<p><a href="about:blank#2.C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%9AUart%20c%2B%2B%20class%20for%20Nvidia%20Jetson%20Nano">2.C++代码：Uart c++ class for Nvidia Jetson<br>Nano</a></p>
<p><a href="about:blank#%E4%BA%94.%E5%9C%A8jetson%20nano%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV">六.在jetson<br>nano上使用OpenCV</a></p>
<p><a href="about:blank#%E4%B8%83.jetson%20nano%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">七.jetson<br>nano开机自启动程序</a></p>
<p><a href="about:blank#%E5%85%AB.%E5%AE%9E%E6%88%98%E7%A8%8B%E5%BA%8F">八.实战程序</a></p>
<p><a href="about:blank#1.jetson%20nano%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%B0%86%E5%9C%86%E5%BF%83%E5%9D%90%E6%A0%87%E9%80%9A%E8%BF%87uart%E4%BC%A0%E7%BB%99stm32">1.jetson<br>nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</a></p>
<hr>
<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零.前言"></a>零.前言</h2><h5 id="1-jetson-nano购买商家及技术支持"><a href="#1-jetson-nano购买商家及技术支持" class="headerlink" title="1.jetson nano购买商家及技术支持"></a><strong>1.jetson nano购买商家及技术支持</strong></h5><p>***<strong>选购亚博，支持相关开源资料，资料网址：<a target="_blank" rel="noopener" href="https://www.yahboom.com/study/jetson-nano" title="JETSON NANO B01
(yahboom.com)">JETSON NANO B01<br>(yahboom.com)</a></strong></p>
<p>***<strong>常见问题及解答：<a target="_blank" rel="noopener" href="https://www.yuque.com/yahboomtechnology/yahboom_support/kgdd5m#NLt6t" title="Jetson nano A01&#x2F;B01 (yuque.com)">Jetson nano A01&#x2F;B01<br>(yuque.com)</a></strong></p>
<h5 id="2-相关环境配置"><a href="#2-相关环境配置" class="headerlink" title="2.相关环境配置"></a>2.相关环境配置</h5><p>&lt;1&gt;亚博已经在SD卡中将环境配好，插上即可直接使用</p>
<p>&lt;2&gt;***<strong>自行烧录镜像，配置环境</strong> ：</p>
<p>下载之前要格式化SD卡或者U盘，具体操作见“jetson—主板—2.Jetson Nano B01基础教程”，然后烧录镜像文件：</p>
<p>亚博资料里的 “jetson—主板—附录—镜像” 包含**<code>已安装：</code>**</p>
<p><strong><code>CUDA10.2、CUDNNv8、tensorRT、opencv4.1.1、python2、python3、tensorflow2.3、jetpack4.6.1、yolov5、jetson- inference包（包括相关模型）、jetson-gpio库、安装pytorch1.8和torchvesion0.9、安装node v15.0.1、npm7.2.3，jupyter，已开启VNC服务，还有其他课程中所用到的模块。</code></strong></p>
<p>以及Swap空间配置，Jtop安装，只需要TF&#x2F;U盘扩容即可</p>
<p>减少自行配置的麻烦。</p>
<p>如果要从零开始自己配置，“jetson—主板—2.Jetson Nano B01基础教程” 和“4.系统基础设置教程”中包括了大部分操作，甚至包括空环境下载</p>
<h5 id="3-做好系统备份"><a href="#3-做好系统备份" class="headerlink" title="3.做好系统备份"></a>3.做好系统备份</h5><p>如果只是使用亚博官方提供的版本库，可以只用 “jetson—主板—附录—镜像”<br>中的镜像文件作为备份。如果自行配置了其他环境，建议备份系统，可在“jetson—主板—4.系统基础设置教程” 找到具体操作。</p>
<h2 id="一-vscode远程ssh操作"><a href="#一-vscode远程ssh操作" class="headerlink" title="一.vscode远程ssh操作"></a>一.vscode远程ssh操作</h2><h3 id="局域网连接"><a href="#局域网连接" class="headerlink" title="&lt;1&gt;局域网连接"></a>&lt;1&gt;局域网连接</h3><p>1.将jetson连接至路由器——电脑使用该路由wifi——打开VS Code——下载ssh-<br>remote插件——jetson上终端ifconfig查ip——vscode按格式输入：ssh<br>jetson@IP地址——输入密码登录（原始默认用户名为jetson，密码为yahboom）</p>
<p>2.crtl+o选择要打开的文件或侧栏资源管理器选择，文件可在主机写好直接拖入jetson；终端写入代码并操作</p>
<h3 id="电脑直连"><a href="#电脑直连" class="headerlink" title="&lt;2&gt;电脑直连"></a>&lt;2&gt;电脑直连</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15906550/5921556#:~:text=Jetson,Nano%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E6%9C%ACssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9CjetsonnanoSD%E5%8D%A1%E6%88%90%E5%8A%9F%E7%83%A7%E5%BD%95%E5%B9%B6%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B0%86Jetsonnano%E5%92%8C%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%BB%99%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8F%B3%E5%87%BBwlan%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E6%89%BE%E5%88%B0IP%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%89%93%E5%BC%80cmd%EF%BC%9Aarp-a%E8%BF%9E%E6%8E%A5ssh%E5%8D%B3%E5%8F%AF%E3%80%82" title="Jetson Nano——通过网线实现笔记本ssh远程连接">Jetson<br>Nano——通过网线实现笔记本ssh远程连接</a></p>
<h3 id="电脑直连-VNC远程桌面"><a href="#电脑直连-VNC远程桌面" class="headerlink" title="&lt;3&gt;电脑直连+VNC远程桌面"></a>&lt;3&gt;电脑直连+VNC远程桌面</h3><p>jetson nano上设置：[Jetson nano 通过 vnc<br>实现远程桌面控制（已在nano实现）](<a target="_blank" rel="noopener" href="https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171299147716800184169928&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/manbushuizhong/article/details/122121251?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171299147716800184169928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171299147716800184169928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>top_positive~default-1-122121251-null-<br>null.142%5Ev100%5Epc_search_result_base9&amp;utm_term&#x3D;jetson%20nano%20vnc&amp;spm&#x3D;1018.2226.3001.4187<br>“Jetson nano 通过 vnc 实现远程桌面控制（已在nano实现）”)</p>
<p>下载VNC Viewer软件并连接（端口号参考&lt;2&gt;），效果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a3014171eef4ef195b7a33d15e0845bc.png"></p>
<p> 如果无法连接检查接口是否插好，如果成功会有一个不同于端口地址的地址：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/938609aaeb57355774c771bab4569295.png"></p>
<p>如果vnc server显示窗口过小，打开终端输入以下命令调整分辨率：</p>
<p>​<br>​    xrandr –fb 1920x1080</p>
<h2 id="二-板载摄像头教程："><a href="#二-板载摄像头教程：" class="headerlink" title="二.板载摄像头教程："></a>二.板载摄像头教程：</h2><p><strong>获取摄像头相关参数：[linux查看摄像头分辨率参数](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20">https://blog.csdn.net/weixin_44942126/article/details/115110762#:~:text=sudo%20apt%20install%20v4l-utils%2F%2F%E5%AE%89%E8%A3%85v4l2%E5%B7%A5%E5%85%B7%E5%8C%85%20sudo%20v4l2-ctl%20</a><br>–list-<br>devices%2F%2F%E9%80%9A%E8%BF%87v4l2%E6%9F%A5%E7%9C%8B%E6%91%84%E5%83%8F%E5%A4%B4%E8%AE%BE%E5%A4%87%20%2F%2F%E5%BD%93%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%91%84%E5%83%8F%E5%A4%B4%E6%97%B6%EF%BC%8C%E6%8C%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95,sudo%20rmmod%20uvcvideo%2F%2F%E7%A7%BB%E9%99%A4%E6%A8%A1%E5%9D%97%20sudo%20modprobe%20uvcvideo%20nodrop%3D1%20timeout%3D5000<br>“linux查看摄像头分辨率参数”)</strong></p>
<p>​<br>​    Driver Info (not using libv4l2):<br>​            Driver name   : tegra-video<br>​            Card type     : vi-output, imx219 8-0010<br>​            Bus info      : platform:54080000.vi:4<br>​            Driver version: 4.9.255<br>​            Capabilities  : 0x84200001<br>​                    Video Capture<br>​                    Streaming<br>​                    Extended Pix Format<br>​                    Device Capabilities<br>​            Device Caps   : 0x04200001<br>​                    Video Capture<br>​                    Streaming<br>​                    Extended Pix Format<br>​    Priority: 2<br>​    Video input : 0 (Camera 4: ok)<br>​    Format Video Capture:<br>​            Width&#x2F;Height      : 3264&#x2F;2464<br>​            Pixel Format      : ‘RG10’<br>​            Field             : None<br>​            Bytes per Line    : 6528<br>​            Size Image        : 16084992<br>​            Colorspace        : sRGB<br>​            Transfer Function : Default (maps to sRGB)<br>​            YCbCr&#x2F;HSV Encoding: Default (maps to ITU-R 601)<br>​            Quantization      : Default (maps to Full Range)<br>​            Flags             :<br>​<br>    Camera Controls</p>
<pre><code>                     group_hold 0x009a2003 (bool)   : default=0 value=0 flags=execute-on-write
                    sensor_mode 0x009a2008 (int64)  : min=0 max=0 step=0 default=0 value=0 flags=slider
                           gain 0x009a2009 (int64)  : min=0 max=0 step=0 default=0 value=16 flags=slider
                       exposure 0x009a200a (int64)  : min=0 max=0 step=0 default=0 value=13 flags=slider
                     frame_rate 0x009a200b (int64)  : min=0 max=0 step=0 default=0 value=2000000 flags=slider
                    bypass_mode 0x009a2064 (intmenu): min=0 max=1 default=0 value=0
                override_enable 0x009a2065 (intmenu): min=0 max=1 default=0 value=0
                   height_align 0x009a2066 (int)    : min=1 max=16 step=1 default=1 value=1
                     size_align 0x009a2067 (intmenu): min=0 max=2 default=0 value=0
               write_isp_format 0x009a2068 (bool)   : default=0 value=0
       sensor_signal_properties 0x009a2069 (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
        sensor_image_properties 0x009a206a (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
      sensor_control_properties 0x009a206b (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
              sensor_dv_timings 0x009a206c (u32)    : min=0 max=0 step=0 default=0 flags=read-only, has-payload
               low_latency_mode 0x009a206d (bool)   : default=0 value=0
               preferred_stride 0x009a206e (int)    : min=0 max=65535 step=1 default=0 value=0
                   sensor_modes 0x009a2082 (int)    : min=0 max=30 step=1 default=30 value=6 flags=read-only
</code></pre>
<p><strong>注意jetson nano要连接显示屏</strong></p>
<p>jetson@yahboom:&#x2F;home$ <strong>nvgstcapture-1.0  **                              **<br>&#x2F;&#x2F;打开摄像头命令</strong></p>
<p><strong>响应：</strong><br>Encoder null, cannot set bitrate!<br>Encoder Profile &#x3D; High<br>Supported resolutions in case of ARGUS Camera                      <strong>&#x2F;&#x2F;设置分辨率</strong><br>  (2) : 640x480<br>  (3) : 1280x720<br>  (4) : 1920x1080<br>  (5) : 2104x1560<br>  (6) : 2592x1944<br>  (7) : 2616x1472<br>  (8) : 3840x2160<br>  (9) : 3896x2192<br>  (10): 4208x3120<br>  (11): 5632x3168<br>  (12): 5632x4224</p>
<p>Runtime ARGUS Camera Commands:</p>
<p>  <strong>Help : ‘h’<br>  Quit : ‘q’</strong><br>  Set Capture Mode:<br>      mo:<val><br>          (1): image<br>          (2): video<br>  Get Capture Mode:<br>      gmo<br>  Set sensor orientation:<br>      so:<val><br>          (0): none<br>          (1): Rotate counter-clockwise 90 degrees<br>          (2): Rotate 180 degrees<br>          (3): Rotate clockwise 90 degrees<br>  Get sensor orientation:<br>      gso<br>  Set sensor mode:<br>      smo:<val> e.g., smo:1<br>  Get sensor mode:<br>      gsmo<br>  Set Whitebalance Mode:<br><strong>&#x2F;&#x2F;更改相机参数（曝光、饱和度等等）</strong><br>      wb:<val><br>          (0): off<br>          (1): auto<br>          (2): incandescent<br>          (3): fluorescent<br>          (4): warm-fluorescent<br>          (5): daylight<br>          (6): cloudy-daylight<br>          (7): twilight<br>          (8): shade<br>          (9): manual<br>  Get Whitebalance Mode:<br>      gwb<br>  Set Saturation (0 to 2):<br>      st:<val> e.g., st:1.25<br>  Get Saturation:<br>      gst<br>  Set Exposure Compensation (-2 to 2):<br>      ec:<val> e.g., ec:-2<br>  Get Exposure Compensation:<br>      gec<br>  Set Auto Whitebalance Lock:<br>      awbl:<val> e.g., awbl:0<br>  Get Auto Whitebalance Lock:<br>      awbl<br>  Set Auto Exposure Lock:<br>      ael:<val> e.g., ael:0<br>  Get Auto Exposure Lock:<br>      gael<br>  Set TNR Mode:<br>      tnrm:<val> e.g., tnrm:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get TNR Mode:<br>      gtnrm<br>  Set TNR Strength (-1 to 1):<br>      tnrs:<val> e.g., tnrs:0.5<br>  Get TNR Strength:<br>      gtnrs<br>  Set EE Mode:<br>      eem:<val> e.g., eem:1<br>          (0): OFF<br>          (1): FAST<br>          (2): HIGH QUALITY<br>  Get EE Mode:<br>      geem<br>  Set EE Strength (-1 to 1):<br>      ees:<val> e.g., ees:0.5<br>  Get EE Strength:<br>      gees<br>  Set Auto Exposure Anti-Banding (0 to 3):<br>      aeab:<val> e.g., aeab:2<br>          (0): OFF<br>          (1): MODE AUTO<br>          (2): MODE 50HZ<br>          (3): MODE 60HZ<br>  Get Auto Exposure Anti-Banding:<br>      gaeab<br>  Set Gain Range:<br>      gr:<val><space><val> e.g., gr:1 16<br>  Get Gain Range:<br>      ggr<br>  Set Exposure Time Range:<br>      etr:<val><space><val> e.g., etr:34000 35000<br>  Get Exposure Time Range:<br>      getr<br>  Set ISP Digital Gain Range:<br>      dgr:<val><space><val> e.g., dgr:2 152<br>  Get ISP Digital Gain Range:<br>      gdgr<br>  <strong>Capture: enter ‘j’ OR<br>           followed by a timer (e.g., jx5000, capture after 5 seconds) OR<br>           followed by multishot count (e.g., j:6, capture 6 images)<br>           timer&#x2F;multihot values are optional, capture defaults to single shot with timer&#x3D;0s<br>  Start Recording : enter ‘1’<br>  Stop Recording  : enter ‘0’</strong><br>  Video <strong>snapshot</strong>  : enter ‘2’ (While recording video)<br>  Get Preview Resolution:<br>      gpcr<br>  Get Image Capture Resolution:<br>      gicr<br>  Get Video Capture Resolution:<br>      gvcr</val></space></val></val></space></val></val></space></val></val></val></val></val></val></val></val></val></val></val></val></val></val></p>
<p>Runtime encoder configuration options:</p>
<p>  Set Encoding Bit-rate(in bytes):<br>      br:<val> e.g., br:4000000<br>  Get Encoding Bit-rate(in bytes):<br>      gbr<br>  Set Encoding Profile(only for H.264):<br>      ep:<val> e.g., ep:1<br>          (0): Baseline<br>          (1): Main<br>          (2): High<br>  Get Encoding Profile(only for H.264):<br>      gep<br>  Force IDR Frame on video Encoder(only for H.264):<br>      Enter ‘f’ </val></val></p>
<p>bitrate &#x3D; 4000000<br>Encoder Profile &#x3D; High<br>Encoder control-rate &#x3D; 1<br>Encoder EnableTwopassCBR &#x3D; 0<br>Opening in BLOCKING MODE</p>
<p>摘自亚博教程：命令</p>
<ol>
<li>--prev_res 预览视屏的分辨率，高度和宽度，用的是CSI摄像头的话范围是 2 to 12 (5632x4224)</li>
</ol>
<p>e.g.,  nvgstcapture-1.0 –prev-res&#x3D;3</p>
<ol>
<li>--cus-prev-res 自定义预览分辨率，宽度和高度，仅支持CSI摄像头</li>
</ol>
<p>e.g., nvgstcapture-1.0 –cus-prev-res&#x3D;1920x1080</p>
<p>多个命令同时使用的话用！隔开</p>
<p>想关掉摄像头的额话，直接在终端输入q再按回车</p>
<p>想捕获图片的话，在终端输入j再按回车，图片将保存当前目录下</p>
<p><strong>关键参数的调整</strong> ：<a target="_blank" rel="noopener" href="https://mc.dfrobot.com.cn/thread-309615-1-1.html" title="NVIDIA Jetson Nano 2GB
系列文章（9）：调节 CSI 图像质量">NVIDIA Jetson Nano 2GB 系列文章（9）：调节 CSI<br>图像质量</a></p>
<h2 id="三-运行例程"><a href="#三-运行例程" class="headerlink" title="三.运行例程"></a>三.运行例程</h2><ul>
<li><p>MIPI CSI cameras (<code>csi://0</code>)</p>
</li>
<li><p>V4L2 cameras (<code>/dev/video0</code>)</p>
</li>
<li><p>RTP&#x2F;RTSP streams (<code>rtsp://username:password@ip:port</code>)</p>
<p>在&#x2F;home&#x2F;jetson&#x2F;jetson-inference&#x2F;build&#x2F;aarch64&#x2F;bin 中打开终端</p>
<p>输入示例(c++)(python 加.py即可)<br>.&#x2F;imagenet images&#x2F;orange_0.jpg images&#x2F;test&#x2F;output_0.jpg<br>.&#x2F;imagenet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;图像分类推理<br>.&#x2F;detectnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;目标检测推理<br>.&#x2F;segnet –network&#x3D;<model> csi:&#x2F;&#x2F;0           &#x2F;&#x2F;语义分割<br>.&#x2F;posenet &#x2F;dev&#x2F;video0                        &#x2F;&#x2F;姿态估计<br>.&#x2F;posenet –network&#x3D;resnet18-hand csi:&#x2F;&#x2F;0    &#x2F;&#x2F;手部姿态<br>.&#x2F;actionnet csi:&#x2F;&#x2F;0                          &#x2F;&#x2F;动作识别<br>.&#x2F;backgroundnet csi:&#x2F;&#x2F;0                      &#x2F;&#x2F;背景去除<br>.&#x2F;depthnet csi:&#x2F;&#x2F;0                           &#x2F;&#x2F;单眼深度</model></p>
</li>
</ul>
<h2 id="四-GPIO使用"><a href="#四-GPIO使用" class="headerlink" title="四.GPIO使用"></a>四.GPIO使用</h2><p><strong>Python版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio" title="NVIDIA&#x2F;jetson-gpio: A
Python library that enables the use of Jetson&#39;s GPIOs">NVIDIA&#x2F;jetson-gpio: A Python library that enables the use of<br>Jetson’s GPIOs</a></p>
<p><strong>C++版使用说明</strong> ：<a target="_blank" rel="noopener" href="https://github.com/pjueon/JetsonGPIO" title="pjueon&#x2F;JetsonGPIO: A C++
library that enables the use of Jetson&#39;s GPIOs">pjueon&#x2F;JetsonGPIO: A C++ library that enables the use of<br>Jetson’s GPIOs</a></p>
<h4 id="GPIO库的API用法"><a href="#GPIO库的API用法" class="headerlink" title="GPIO库的API用法"></a>GPIO库的API用法</h4><p>Jetson GPIO库提供了RPi.GPIO库提供的所有公共API。下面讨论每种API的用法：</p>
<h5 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h5><p>要导入Jetson.GPIO模块，请使用：</p>
<p>import Jetson.GPIO as GPIO</p>
<p>通过这种方式，您可以在应用程序的其余部分中将该模块称为GPIO。模块也可以使用RPi的名称导入。GPIO代替了Jetson。GPIO用于使用RPi库的现有代码。</p>
<h5 id="2-引脚编号"><a href="#2-引脚编号" class="headerlink" title="2.引脚编号"></a>2.引脚编号</h5><p>Jetson<br>GPIO库提供了四种给IO引脚编号的方法。前两个对应于RPi.GPIO库提供的模式，即BOARD和BCM，分别引用40引脚GPIO接头连接器的引脚号和Broadcom<br>SoC GPIO编号。其余两种模式CVM和TEGRA_SOC使用字符串代替数字，而数字分别对应于CVM CVB连接器和Tegra SoC上的信号名称。</p>
<p>要指定您正在使用哪种模式（强制性），请使用以下函数调用：</p>
<p>GPIO.setmode(GPIO.BOARD)# or</p>
<p>GPIO.setmode(GPIO.BCM)# or</p>
<p>GPIO.setmode(GPIO.CVM)# or</p>
<p>GPIO.setmode(GPIO.TEGRA_SOC)</p>
<p>要检查已设置的模式，可以调用：</p>
<p>mode &#x3D; GPIO.getmode()</p>
<p>该模式必须为GPIO.BOARD，GPIO.BCM，GPIO.CVM，GPIO.TEGRA_SOC或无。</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cynophile/article/details/99310678" title="Jetson Nano GPIO使用、四种模式以及串口解释">Jetson Nano<br>GPIO使用、四种模式以及串口解释</a></p>
<h5 id="3-警告"><a href="#3-警告" class="headerlink" title="3.警告"></a>3.警告</h5><p>您尝试使用的GPIO可能已在当前应用程序外部使用。在这种情况下，如果使用的GPIO配置为除默认方向（输入）以外的任何值，Jetson<br>GPIO库将向您发出警告。如果在设置模式和通道之前尝试清理，它也会警告您。要禁用警告，请使用：</p>
<p>GPIO.setwarnings(False)</p>
<h5 id="4-设置通道"><a href="#4-设置通道" class="headerlink" title="4.设置通道"></a>4.设置通道</h5><p>在用作输入或输出之前，必须先设置GPIO通道。要将通道配置为输入，请调用：</p>
<p>GPIO.setup(channel, GPIO.IN)</p>
<p>要将通道设置为输出，请调用：</p>
<p>GPIO.setup(channel, GPIO.OUT)</p>
<p>也可以为输出通道指定一个初始值：</p>
<p>GPIO.setup(channel, GPIO.OUT, initial&#x3D;GPIO.HIGH)</p>
<p>将一个通道设置为输出时，也可以一次设置多个通道：</p>
<p>channels &#x3D; [18, 12, 13]</p>
<p>GPIO.setup(channels, GPIO.OUT)</p>
<h5 id="5-输入"><a href="#5-输入" class="headerlink" title="5.输入"></a>5.输入</h5><p>要读取通道的值，请使用：</p>
<p>GPIO.input(channel)</p>
<p>这将返回GPIO.LOW或GPIO.HIGH。</p>
<h5 id="6-输出"><a href="#6-输出" class="headerlink" title="6.输出"></a>6.输出</h5><p>要设置配置为输出的引脚的值，请使用：</p>
<p>GPIO.output(channel, state)</p>
<p>状态可以是GPIO.LOW或GPIO.HIGH。</p>
<p>您还可以输出到频道列表或元组：</p>
<p>channels &#x3D; [18, 12, 13] # or use tuples</p>
<p>GPIO.output(channels, GPIO.HIGH) # or GPIO.LOW</p>
<h6 id="set-first-channel-to-HIGH-and-rest-to-LOW"><a href="#set-first-channel-to-HIGH-and-rest-to-LOW" class="headerlink" title="set first channel to HIGH and rest to LOW"></a>set first channel to HIGH and rest to LOW</h6><p>GPIO.output(channel, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH))</p>
<h5 id="7-清理"><a href="#7-清理" class="headerlink" title="7.清理"></a>7.清理</h5><p>在程序结束时，最好清理通道，以便将所有引脚设置为默认状态。要清理所有使用的通道，请使用：</p>
<p>GPIO.cleanup()</p>
<p>如果您不想清除所有通道，也可以清除单个通道或通道列表或元组：</p>
<p>GPIO.cleanup(chan1) # cleanup only chan1</p>
<p>GPIO.cleanup([chan1, chan2]) # cleanup only chan1 and chan2</p>
<p>GPIO.cleanup((chan1, chan2)) # does the same operation as previous statement</p>
<h5 id="8-jetson模块信息和库版本"><a href="#8-jetson模块信息和库版本" class="headerlink" title="8.jetson模块信息和库版本"></a>8.jetson模块信息和库版本</h5><p>要获取有关Jetson模块的信息，请使用&#x2F;阅读：</p>
<p>GPIO.JETSON_INFO</p>
<p>这为Python字典提供了以下键：P1_REVISION，RAM，REVISION，TYPE，MANUFACTURER和PROCESSOR。字典中的所有值都是字符串，但P1_REVISION是整数。</p>
<p>要获取有关库版本的信息，请使用&#x2F;阅读：</p>
<p>GPIO.VERSION</p>
<p>这提供了XYZ版本格式的字符串。</p>
<h5 id="9-中断"><a href="#9-中断" class="headerlink" title="9.中断"></a>9.中断</h5><p>除了繁忙的轮询外，该库还提供了三种监视输入事件的方法：</p>
<h6 id="wait-for-edge（）函数"><a href="#wait-for-edge（）函数" class="headerlink" title="wait_for_edge（）函数"></a>wait_for_edge（）函数</h6><p>该函数阻塞调用线程，直到检测到提供的边缘为止。该函数可以如下调用：</p>
<p>GPIO.wait_for_edge(channel, GPIO.RISING)</p>
<p>第二个参数指定要检测的边缘，可以是GPIO.RISING，GPIO.FALLING或GPIO.BOTH。如果只想将等待时间限制为指定的时间，则可以选择设置超时：</p>
<h6 id="timeout-is-in-milliseconds"><a href="#timeout-is-in-milliseconds" class="headerlink" title="timeout is in milliseconds"></a>timeout is in milliseconds</h6><p>GPIO.wait_for_edge(channel, GPIO.RISING, timeout&#x3D;500)</p>
<p>该函数返回检测到边缘的通道；如果发生超时，则返回无。</p>
<h6 id="event-detected（）函数"><a href="#event-detected（）函数" class="headerlink" title="event_detected（）函数"></a>event_detected（）函数</h6><p>此功能可用于定期检查自上次通话以来是否发生了事件。该函数可以如下设置和调用：</p>
<h6 id="set-rising-edge-detection-on-the-channel"><a href="#set-rising-edge-detection-on-the-channel" class="headerlink" title="set rising edge detection on the channel"></a>set rising edge detection on the channel</h6><p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>run_other_code()</p>
<p>if GPIO.event_detected(channel):</p>
<p>do_something()</p>
<p>和以前一样，您可以检测GPIO.RISING，GPIO.FALLING或GPIO.BOTH的事件。</p>
<h6 id="当检测到边缘时运行回调函数"><a href="#当检测到边缘时运行回调函数" class="headerlink" title="当检测到边缘时运行回调函数"></a>当检测到边缘时运行回调函数</h6><p>此功能可用于为回调函数运行第二个线程。因此，响应边缘，回调函数可以与主程序并发运行。可以按以下方式使用此功能：</p>
<h6 id="define-callback-function"><a href="#define-callback-function" class="headerlink" title="define callback function"></a>define callback function</h6><p>def callback_fn(channel):</p>
<p>print(“Callback called from channel %s” % channel)</p>
<h6 id="add-rising-edge-detection"><a href="#add-rising-edge-detection" class="headerlink" title="add rising edge detection"></a>add rising edge detection</h6><p>GPIO.add_event_detect(channel, GPIO.RISING, callback&#x3D;callback_fn)</p>
<p>如果需要，还可以添加多个回调：</p>
<p>def callback_one(channel):</p>
<p>print(“First Callback”)</p>
<p>def callback_two(channel):</p>
<p>print(“Second Callback”)</p>
<p>GPIO.add_event_detect(channel, GPIO.RISING)</p>
<p>GPIO.add_event_callback(channel, callback_one)</p>
<p>GPIO.add_event_callback(channel, callback_two)</p>
<p>在这种情况下，这两个回调是顺序运行的，而不是同时运行，因为只有线程运行所有回调函数。</p>
<p>为了通过将多个事件折叠为一个事件来防止多次调用回调函数，可以选择设置反跳时间：</p>
<h6 id="bouncetime-set-in-milliseconds"><a href="#bouncetime-set-in-milliseconds" class="headerlink" title="bouncetime set in milliseconds"></a>bouncetime set in milliseconds</h6><p>GPIO.add_event_detect(channel, GPIO.RISING,<br>callback&#x3D;callback_fn,bouncetime&#x3D;200)</p>
<p>如果不再需要边缘检测，可以按以下步骤将其删除：</p>
<p>GPIO.remove_event_detect(channel)</p>
<h5 id="10-检查GPIO通道的功能"><a href="#10-检查GPIO通道的功能" class="headerlink" title="10.检查GPIO通道的功能"></a>10.检查GPIO通道的功能</h5><p>此功能使您可以检查提供的GPIO通道的功能：</p>
<p>GPIO.gpio_function(channel)</p>
<p>该函数返回GPIO.IN或GPIO.OUT。</p>
<h5 id="11-PWM"><a href="#11-PWM" class="headerlink" title="11. PWM"></a>11. PWM</h5><p>请参阅samples&#x2F;simple_pwm.py有关如何使用PWM通道的详细信息。</p>
<p>Jetson.GPIO库仅在附带硬件PWM控制器的引脚上支持PWM。与RPi.GPIO库不同，Jetson.GPIO库不实现软件仿真的PWM。Jetson<br>Nano支持2个PWM通道，而Jetson AGX Xavier支持3个PWM通道。Jetson TX1和TX2不支持任何PWM通道。</p>
<p>系统引脚复用器必须配置为将硬件PWM控制器连接到相关引脚。如果未配置pinmux，则PWM信号将不会到达引脚！Jetson.GPIO库不会动态修改pinmux配置来实现此目的。阅读L4T文档以获取有关如何配置pinmux的详细信息</p>
<p>完整英文版说明见: <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/jetson-gpio">https://github.com/NVIDIA/jetson-gpio</a></p>
<h2 id="五-串口通信"><a href="#五-串口通信" class="headerlink" title="五.串口通信"></a>五.串口通信</h2><h5 id="UART"><a href="#UART" class="headerlink" title="&lt;1&gt;UART"></a>&lt;1&gt;UART</h5><h6 id="1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code"><a href="#1-python代码-：-JetsonHacksNano-UARTDemo-UART-Demo-Code" class="headerlink" title="1.python代码 ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code"></a><strong>1.python代码</strong> ：[JetsonHacksNano&#x2F;UARTDemo: UART Demo Code</h6><p>(github.com)](<a target="_blank" rel="noopener" href="https://github.com/JetsonHacksNano/UARTDemo">https://github.com/JetsonHacksNano/UARTDemo</a><br>“JetsonHacksNano&#x2F;UARTDemo: UART Demo Code (github.com)“)</p>
<p>jetson nano的串口的TXD和RXD引脚分别对应物理引脚8,10</p>
<p>开启串口权限，注意这个权限关机后就也被关闭，下次需要重新开启</p>
<p>​<br>​    sudo chmod 777 &#x2F;dev&#x2F;ttyTHS1</p>
<p>如果要永久打开，可参考：<a target="_blank" rel="noopener" href="https://codeleading.com/article/76115811693/" title="永久修改jetson
nano上电启动串口权限">永久修改jetson<br>nano上电启动串口权限</a></p>
<h5 id="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"><a href="#注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点" class="headerlink" title="注意事项：如果使用USB转TTL模块电脑和nano进行通信注意一下几点"></a>注意事项：<strong>如果使用USB转TTL模块电脑和nano进行通信注意一下几点</strong></h5><pre><code>    1.杜邦线不可太长，太长会乱码

    2.出现只能收不能发的情况是电压不足导致的，把usb转ttl模块的5V口和nano的5V进行连接

    3.如果线合理，但出现乱码，波特率、奇偶校验、停止位检查是否一致

    4.其它情况：[串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据](https://blog.csdn.net/lxj362343/article/details/89646731 &quot;串口收不到数据或者收到错误数据 串口乱码总结_串口没有数据&quot;)
</code></pre>
<h6 id="2-C-代码：-Uart-c-class-for-Nvidia-Jetson"><a href="#2-C-代码：-Uart-c-class-for-Nvidia-Jetson" class="headerlink" title="2.C++代码：[Uart c++ class for Nvidia Jetson"></a>2.C++代码：[Uart c++ class for Nvidia Jetson</h6><p>Nano](<a target="_blank" rel="noopener" href="https://github.com/MathieuBahin/JetsonNanoUart/tree/master">https://github.com/MathieuBahin/JetsonNanoUart/tree/master</a> “Uart c++<br>class for Nvidia Jetson Nano”)</p>
<p>在四中的C++版GPIO库中并未包括uart相关内容，但是利用jetson nano设备中的</p>
<p>​<br>​    &#x2F;dev&#x2F;ttyTHS1</p>
<p>进行系统调用，可实现串口通信。</p>
<p>但github上的C++ uart代码比较复杂，且只适用于特点场景，笔者修改了部分内容如下：</p>
<p>​<br>​    &#x2F;&#x2F;uart.h<br>​    #ifndef _UART_H<br>​    #define _UART_H</p>
<p>​<br>​    &#x2F;&#x2F; Define Constants<br>​    const char *uart_target &#x3D; “&#x2F;dev&#x2F;ttyTHS1”;<br>​    #define     NSERIAL_CHAR   256<br>​    #define     VMINX          1<br>​    #define     BAUDRATE       B115200</p>
<p>​<br>​    class Uart {<br>​    private:<br>​      &#x2F;* data *&#x2F;<br>​      int fid;<br>​    public:<br>​      char serial_message[NSERIAL_CHAR];</p>
<p>​<br>​      Uart ();<br>​      void sendUart(char *msg);<br>​      void readUart();<br>​      void closeUart();<br>​<br>    };<br>    #endif</p>
<p>​<br>​<br>​    &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>​    &#x2F;* @auteur Mathieu Bahin            <em>&#x2F;<br>​    &#x2F;</em> @date_création mars 2020         <em>&#x2F;<br>​    &#x2F;</em> @version 1.0                     <em>&#x2F;<br>​    &#x2F;</em> @email <a href="mailto:&#98;&#97;&#x68;&#105;&#110;&#46;&#x6d;&#97;&#x74;&#104;&#x69;&#x65;&#x75;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">bahin.mathieu@gmail.com</a>   *&#x2F;<br>​    &#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>​<br>    #include “uart.h”<br>    #include &lt;stdio.h&gt;<br>    #include &lt;unistd.h&gt;       &#x2F;&#x2F; Used for UART<br>    #include &lt;sys&#x2F;fcntl.h&gt;    &#x2F;&#x2F; Used for UART<br>    #include &lt;termios.h&gt;      &#x2F;&#x2F; Used for UART<br>    #include &lt;string.h&gt;</p>
<pre><code>using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;

  // SETUP SERIAL WORLD

  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port
</code></pre>
<p>​<br>​      &#x2F;&#x2F;————————————————<br>​      &#x2F;&#x2F;  OPEN THE UART<br>​      &#x2F;&#x2F;————————————————<br>​      &#x2F;&#x2F; The flags (defined in fcntl.h):<br>​      &#x2F;&#x2F;	Access modes (use 1 of these):<br>​      &#x2F;&#x2F;		O_RDONLY - Open for reading only.<br>​      &#x2F;&#x2F;		O_RDWR   - Open for reading and writing.<br>​      &#x2F;&#x2F;		O_WRONLY - Open for writing only.<br>​      &#x2F;&#x2F;	    O_NDELAY &#x2F; O_NONBLOCK (same function)<br>​      &#x2F;&#x2F;               - Enables nonblocking mode. When set read requests on the file can return immediately with a failure status<br>​      &#x2F;&#x2F;                 if there is no input immediately available (instead of blocking). Likewise, write requests can also return<br>​      &#x2F;&#x2F;				   immediately with a failure status if the output can’t be written immediately.<br>​      &#x2F;&#x2F;                 Caution: VMIN and VTIME flags are ignored if O_NONBLOCK flag is set.<br>​      &#x2F;&#x2F;	    O_NOCTTY - When set and path identifies a terminal device, open() shall not cause the terminal device to become the controlling terminal for the process.fid &#x3D; open(“&#x2F;dev&#x2F;ttyTHS1”, O_RDWR | O_NOCTTY | O_NDELAY);		&#x2F;&#x2F;Open in non blocking read&#x2F;write mode<br>​<br>      fid &#x3D; open(uart_target, O_RDWR | O_NOCTTY );</p>
<pre><code>  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);

  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;

  //------------------------------------------------
  // CONFIGURE THE UART
  //------------------------------------------------
  // flags defined in /usr/include/termios.h - see http://pubs.opengroup.org/onlinepubs/007908799/xsh/termios.h.html
  //	Baud rate:
  //         - B1200, B2400, B4800, B9600, B19200, B38400, B57600, B115200,
  //           B230400, B460800, B500000, B576000, B921600, B1000000, B1152000,
  //           B1500000, B2000000, B2500000, B3000000, B3500000, B4000000
  //	CSIZE: - CS5, CS6, CS7, CS8
  //	CLOCAL - Ignore modem status lines
  //	CREAD  - Enable receiver
  //	IGNPAR = Ignore characters with parity errors
  //	ICRNL  - Map CR to NL on input (Use for ASCII comms where you want to auto correct end of line characters - don&#39;t use for bianry comms!)
  //	PARENB - Parity enable
  //	PARODD - Odd parity (else even)

//*******************************begin::uart参数设置************************************
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

//********************************end::uart参数设置*************************************

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;

//*******************************begin::测试程序************************************
int main(int argc, char *argv[]) &#123;
  Uart u;
  int i;
  char m[256]=&quot;hello world!&quot;;
  u.sendUart(&quot;%s&quot;,&quot;hello world!\r\n&quot;);
  u.sendUart(m);
   
  while (1)
  &#123;
    u.readUart();
    if(strlen(u.serial_message)!=0)
    &#123;
      for(i=0;u.serial_message[i]!=&#39;$&#39;;i++)    //自定协议规定以$结尾
      &#123;
        printf(&quot;%c &quot;,u.serial_message[i]);
      &#125;
    &#125;
    printf(&quot;\n&quot;);    
  &#125;
  u.closeUart();

  return 0;
&#125;
//********************************end::测试程序*************************************
</code></pre>
<p><strong>其中删去了大部分不必要片段，并加入了Uart_Printf()函数，用法同printf()</strong></p>
<p>测试结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6af7567db40ef98ffaec08066206ca83.png"></p>
<p>&lt;2&gt;IIC</p>
<h2 id="六-在jetson-nano上使用OpenCV"><a href="#六-在jetson-nano上使用OpenCV" class="headerlink" title="六.在jetson nano上使用OpenCV"></a>六.在jetson nano上使用OpenCV</h2><p>&lt;1&gt;<strong>python打开摄像头：参考[通过OpenCV调用CSI和USB摄像头](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169070226116800188569163&biz_id=0&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/qq_56548850/article/details/123967404?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169070226116800188569163%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169070226116800188569163&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduend~default-2-123967404-null-<br>null.142%5Ev91%5Einsert_down28v1,239%5Ev12%5Econtrol2&amp;utm_term&#x3D;jetsonnano%E8%B0%83%E7%94%A8usb%E6%91%84%E5%83%8F%E5%A4%B4&amp;spm&#x3D;1018.2226.3001.4187<br>“通过OpenCV调用CSI和USB摄像头”)</strong></p>
<p><strong>C++打开，示例如下：</strong></p>
<p>​<br>​    &#x2F;&#x2F;适用于jetson nano上的模版<br>​    #include <iostream><br>​    #include <string><br>​    #include &lt;opencv2&#x2F;opencv.hpp&gt;<br>​    #include &lt;opencv2&#x2F;core.hpp&gt;<br>​    #include &lt;opencv2&#x2F;highgui.hpp&gt;<br>​    #include &lt;opencv2&#x2F;imgproc.hpp&gt;<br>​    #include &lt;opencv2&#x2F;objdetect.hpp&gt;<br>​    #include &lt;opencv2&#x2F;imgproc&#x2F;types_c.h&gt;<br>​    #include &lt;opencv2&#x2F;videoio.hpp&gt;<br>​<br>    using namespace std;<br>    using namespace cv;</string></iostream></p>
<pre><code>string gstreamer_pipeline(int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method)
&#123;
    return &quot;nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)&quot; + to_string(capture_width) + &quot;, height=(int)&quot; +
        to_string(capture_height) + &quot;, format=(string)NV12, framerate=(fraction)&quot; + to_string(framerate) +
        &quot;/1 ! nvvidconv flip-method=&quot; + to_string(flip_method) + &quot; ! video/x-raw, width=(int)&quot; + to_string(display_width) + &quot;, height=(int)&quot; +
        to_string(display_height) + &quot;, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink&quot;;
&#125;

int main()
&#123;
    int capture_width = 1280;
    int capture_height = 720;
    int display_width = 1280;
    int display_height = 720;
    int framerate = 60;
    int flip_method = 0;

    //创建管道
    string pipeline = gstreamer_pipeline(capture_width,
        capture_height,
        display_width,
        display_height,
        framerate,
        flip_method);
    std::cout &lt;&lt; &quot;使用gstreamer管道: \n\t&quot; &lt;&lt; pipeline &lt;&lt; &quot;\n&quot;;

    //管道与视频流绑定
    VideoCapture cap(pipeline, CAP_GSTREAMER);

    //创建显示窗口
    namedWindow(&quot;CSI Camera&quot;, WINDOW_AUTOSIZE);
    Mat img;

    //逐帧显示
    while (true)
    &#123;
        cap.read(img);
        imshow(&quot;CSI Camera&quot;, img);

        if (waitKey(10) == 27)break;
    &#125;

    cap.release();
    destroyAllWindows();
&#125;
</code></pre>
<p>&lt;2&gt;使用官方自带的4.1.1版本OpenCV</p>
<p>自带的OpenCV文件夹在**&#x2F;usr&#x2F;share&#x2F;opencv4** 中，**~&#x2F;sample&#x2F;cpp  **内含众多示例代码</p>
<p>运行示例代码时使用g++编译，命令为：</p>
<p>​<br>​    g++ name.cpp -o name <code>pkg-config --cflags --libs opencv4</code></p>
<p>命令行输入如下命令即可运行：</p>
<p>​<br>​    .&#x2F;name parameters</p>
<p>其中name为编写的程序名，parameters程序具体需要的参数</p>
<p>因为官方镜像所有的环境都是配好的，g++编译时加入<code>pkg-config --cflags --libs opencv4</code>就可运行。想要下载全新版本自己配置并了解其中的原理可以参考下面的资料</p>
<p>&lt;3&gt;自己配置其他版本OpenCV参考资料</p>
<p> 1.jetson nano上开发环境配置及使用QT(C++)或VsCode编写运行(Python)<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianbin3200896/article/details/103760640?spm=1001.2014.3001.5506#t6" title="Jetson Nano 从入门到实战（案例：Opencv配置、人脸检测、二维码检测）">Jetson Nano<br>从入门到实战（案例：Opencv配置、人脸检测、二维码检测）</a></p>
<p>2.使用CMake编译链接(C++)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43717839/article/details/128032486?spm=1001.2014.3001.5506" title="【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-CSDN博客">【C++】Cmake使用教程（看这一篇就够了）_c++ cmake_隐居的遮天恶鬼的博客-<br>CSDN博客</a></p>
<p>3.使用g++命令(C++)</p>
<p>4.配置最新版或其他版本OpenCV：<a target="_blank" rel="noopener" href="https://blog.csdn.net/s15810751918/article/details/107705387?spm=1001.2014.3001.5506" title="linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-CSDN博客">linux下编译安装opencv生成opencv.pc_浓茶淡酒的博客-<br>CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47665864/article/details/128945476?spm=1001.2014.3001.5506" title="如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-CSDN博客">如何在Linux上安装OpenCV_linux 安装opencv_lvzt的博客-<br>CSDN博客</a></p>
<h2 id="七-jetson-nano开机自启动程序"><a href="#七-jetson-nano开机自启动程序" class="headerlink" title="七.jetson nano开机自启动程序"></a>七.jetson nano开机自启动程序</h2><p>步骤：</p>
<p>1.打开文件：</p>
<p>​<br>​    &#x2F;usr&#x2F;bin&#x2F;yoyo.sh</p>
<p>2.写入命令（开机自动执行的命令），例如：</p>
<p>​<br>​    cd &#x2F;home&#x2F;jetson&#x2F;test&#x2F;circle_control<br>​    .&#x2F;circle</p>
<p>注：终端路径转至&#x2F;home&#x2F;jetson&#x2F;test&#x2F;circle_control，执行.&#x2F;circle文件</p>
<p>3.终端执行:</p>
<p>​<br>​    sudo systemctl daemon-reload<br>​    sudo systemctl enable start.service<br>​    sudo reboot</p>
<h2 id="八-实战程序"><a href="#八-实战程序" class="headerlink" title="八.实战程序"></a>八.实战程序</h2><h5 id="1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"><a href="#1-jetson-nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32" class="headerlink" title="1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32"></a>1.jetson nano上进行霍夫圆检测并将圆心坐标通过uart传给stm32</h5><p>​<br>​    &#x2F;&#x2F;<em><strong><strong><strong><strong><strong><strong>circle.cpp</strong></strong></strong></strong></strong></strong></em>*<br>​    #include “opencv2&#x2F;opencv.hpp”<br>​    #include “opencv2&#x2F;highgui.hpp”<br>​    #include <iostream><br>​    using namespace cv;<br>​<br>    &#x2F;&#x2F;begin::uart部分************************************************************************<br>    #include “uart.h”<br>    #include &lt;stdio.h&gt;<br>    #include &lt;stdarg.h&gt;<br>    #include &lt;unistd.h&gt;       &#x2F;&#x2F; Used for UART<br>    #include &lt;sys&#x2F;fcntl.h&gt;    &#x2F;&#x2F; Used for UART<br>    #include &lt;termios.h&gt;      &#x2F;&#x2F; Used for UART<br>    #include &lt;string.h&gt;</iostream></p>
<pre><code>using namespace std;

Uart :: Uart ()&#123;
  int ii, jj, kk;
  struct termios  port_options;   // Create the structure

  tcgetattr(fid, &amp;port_options);	// Get the current attributes of the Serial port
  fid = open(uart_target, O_RDWR | O_NOCTTY );
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
  if (fid == -1)
  &#123;
    printf(&quot;**Error - Unable to open UART**.  \n=&gt;Ensure it is not in use by another application\n=&gt;Ensure proper privilages are granted to accsess /dev/.. by run as a sudo\n&quot;);
  &#125;
  port_options.c_cflag &amp;= ~PARENB;            // Disables the Parity Enable bit(PARENB),So No Parity
  port_options.c_cflag &amp;= ~CSTOPB;            // CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
  port_options.c_cflag &amp;= ~CSIZE;	            // Clears the mask for setting the data size
  port_options.c_cflag |=  CS8;               // Set the data bits = 8
  port_options.c_cflag &amp;= ~CRTSCTS;           // No Hardware flow Control
  port_options.c_cflag |=  CREAD | CLOCAL;                  // Enable receiver,Ignore Modem Control lines
  port_options.c_iflag &amp;= ~(IXON | IXOFF | IXANY);          // Disable XON/XOFF flow control both input &amp; output
  port_options.c_iflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  // Non Cannonical mode
  port_options.c_oflag &amp;= ~OPOST;                           // No Output Processing

  port_options.c_lflag = 0;               //  enable raw input instead of canonical,

  port_options.c_cc[VMIN]  = VMINX;       // Read at least 1 character
  port_options.c_cc[VTIME] = 0;           // Wait indefinetly

  cfsetispeed(&amp;port_options,BAUDRATE);    // Set Read  Speed
  cfsetospeed(&amp;port_options,BAUDRATE);    // Set Write Speed

  // Set the attributes to the termios structure
  int att = tcsetattr(fid, TCSANOW, &amp;port_options);

  if (att != 0 )
  &#123;
    printf(&quot;\nERROR in Setting port attributes&quot;);
  &#125;
  else
  &#123;
    printf(&quot;\nSERIAL Port Good to Go.\n&quot;);
  &#125;

  // Flush Buffers
  tcflush(fid, TCIFLUSH);
  tcflush(fid, TCIOFLUSH);
&#125;

void Uart :: sendUart(char *msg)&#123;
  //--------------------------------------------------------------
  // TRANSMITTING BYTES
  //--------------------------------------------------------------
  char tx_buffer[256]=&#123;0&#125;;

  for (int i = 0; msg[i]!=&#39;\0&#39;; i++) &#123;
    tx_buffer[i] = msg[i];
  &#125;
  printf(&quot;%s\n&quot;,tx_buffer);

  if (fid != -1)
  &#123;
    int count = write(fid, &amp;tx_buffer[0], strlen((const char*)tx_buffer));		//Filestream, bytes to write, number of bytes to write

    printf(&quot;Count = %d\n&quot;, count);

    if (count &lt; 0)  printf(&quot;UART TX error\n&quot;);
  &#125;

&#125;

void Uart :: readUart()&#123;

  //--------------------------------------------------------------
  // RECEIVING BYTES - AND BUILD MESSAGE RECEIVED
  //--------------------------------------------------------------
  unsigned char rx_buffer[VMINX];
  bool          pickup = true;
  int ii;
  int           rx_length;
  int           nread = 0;

  //更新缓存
  tcflush(fid, TCIOFLUSH);
  //清空接收区
  for (ii=0; ii&lt;NSERIAL_CHAR; ii++)  serial_message[ii]=&#39;\0&#39;;

  while (pickup &amp;&amp; fid != -1)
  &#123;
    rx_length = read(fid, (void*)rx_buffer, VMINX);   // Filestream, buffer to store in, number of bytes to read (max)

    if (rx_length&gt;=0)
    &#123;
      if (nread&lt;=NSERIAL_CHAR-1)&#123;
        serial_message[nread] = rx_buffer[0];   // Build message 1 character at a time
      &#125;

      if (rx_buffer[0]==&#39;$&#39;)   pickup=false;    // # symbol is terminator 自定协议规定以$结尾
    &#125;

    nread++;
  &#125;

&#125;

int Uart :: fputc(int ch, FILE *f)
&#123;
	write(fid, &amp;ch, 1);
	return ch;
&#125;

void Uart :: Uart_Printf(char *format, ...)
&#123;
	char String[256];
	va_list arg;
	va_start(arg, format);
	vsprintf(String, format, arg);
	va_end(arg);
	sendUart(String);
&#125;

void Uart :: closeUart()&#123;
  //-------------------------------------------
  //  CLOSE THE SERIAL PORT
  //-------------------------------------------
  close(fid);
&#125;
//end::uart部分**************************************************************************

const char* windowname=&quot;win&quot;;
int max_r=100;
int min_r=60;
int min_d=80;
int t_hold=25;
int param1=100;
int param2=20;
const int t_max=255;
const int r_max=1000;
const int d_max=100;
const int p1_max=200;
const int p2_max=200;
</code></pre>
<p>​<br>​    int main()<br>​    {<br>​      VideoCapture capture(0);<br>​      Mat image;<br>​    	Mat matCanny;<br>​      Mat BinImg;<br>​      Mat matDst;<br>​      Uart u;<br>​<br>      void on_Trackbar_1(int, void*);<br>      void on_Trackbar_2(int, void*);<br>      void on_Trackbar_3(int, void*);<br>      void on_Trackbar_4(int, void*);<br>      void on_Trackbar_5(int, void*);<br>      void on_Trackbar_6(int, void*);<br>      namedWindow(windowname,0);<br>      setWindowProperty(windowname, WND_PROP_ASPECT_RATIO , WINDOW_FREERATIO);<br>      resizeWindow(windowname, 400, 300);<br>      moveWindow(windowname, 0, 0);<br>      createTrackbar(“t_hold”,windowname, &amp;t_hold, t_max, on_Trackbar_3);<br>      createTrackbar(“max_r”,windowname, &amp;max_r, r_max, on_Trackbar_1);<br>      createTrackbar(“min_r”,windowname, &amp;min_r, r_max, on_Trackbar_2);<br>      createTrackbar(“min_d”,windowname, &amp;min_d, d_max, on_Trackbar_6);<br>      createTrackbar(“p_1”,windowname, &amp;param1, p1_max, on_Trackbar_4);<br>      createTrackbar(“p_2”,windowname, &amp;param2, p2_max, on_Trackbar_5);</p>
<pre><code>	while (capture.isOpened())
	&#123;
		capture &gt;&gt; image;
		if (image.empty())break;
    cvtColor(image, matDst, COLOR_BGR2GRAY);
		threshold(matDst, BinImg, t_hold, 255, THRESH_BINARY_INV|THRESH_OTSU);
    Canny(BinImg, matCanny, 100, 300, 3, false);		//canny算子
        
		std::vector&lt;Vec3f&gt; circles;
		HoughCircles(matCanny, circles, HOUGH_GRADIENT, 1, min_d, param1, param2, min_r, max_r);
		//在原图中画出圆心和圆  
		for (size_t i = 0; i &lt; circles.size(); i++) &#123;
			//提取出圆心坐标  
			Point center(round(circles[i][0]), round(circles[i][1]));
			//提取出圆半径  
			int radius = round(circles[i][2]);
			//圆心  
			circle(image, center, 3, Scalar(255,0,0), -1, 4, 0);
			//圆  
			circle(image, center, radius, Scalar(255,0,0), 3, 4, 0);
		&#125;

    printf(&quot;x:%d\ny:%d\n&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));
    u.Uart_Printf(&quot;#x%dy%d$&quot;,(int)round(circles[0][0]),(int)round(circles[0][1]));

    imshow(&quot;matCanny&quot;, matCanny);
    imshow(&quot;BinImg&quot;, BinImg);
		imshow(windowname, image);
		if (waitKey(1) == 27)break;
	&#125;

  u.closeUart();
  return 0;

&#125;

void on_Trackbar_1(int, void*)
&#123;
    ;
&#125;

void on_Trackbar_2(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_3(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_4(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_5(int, void*)
&#123;
    ;
&#125;
void on_Trackbar_6(int, void*)
&#123;
    ;
&#125;
</code></pre>
<p>使用说明：</p>
<p>使用前打开串口权限；程序使用usb摄像头；要将uart.h包含到该文件（circle.cpp）同目录下；</p>
<p>该目录下打开终端输入：<br>进行编译产生可执行文件</p>
<p>​<br>​    g++ circle.cpp -o circle <code>pkg-config --cflags --libs opencv4</code></p>
<p>该目录下打开终端输入：<br>即可运行</p>
<p>​<br>​    .&#x2F;circle</p>
<p>注：霍夫圆检测不太稳定，会显示core出错，重启即可，也可以在启动时调节各个参数使稳定</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658">https://blog.csdn.net/qq_32971095/article/details/131511658</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89/" class="post-title-link" itemprop="url">图像识别小车（电源部分）——电赛学习笔记（1）</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-29 15:26:49" itemprop="dateCreated datePublished" datetime="2023-06-29T15:26:49+08:00">2023-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-09 14:26:11" itemprop="dateModified" datetime="2025-02-09T14:26:11+08:00">2025-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span id="/2023/06/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="图像识别小车（电源部分）——电赛学习笔记（1）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/06/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/06/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%B0%8F%E8%BD%A6%EF%BC%88%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>992</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="学习资料来源：B站唐老师讲电赛"><a href="#学习资料来源：B站唐老师讲电赛" class="headerlink" title="学习资料来源：B站唐老师讲电赛"></a><em><strong>学习资料来源：B站唐老师讲电赛</strong></em></h2><p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E7%BA%BF%E6%80%A7%E7%94%B5%E6%BA%90%EF%BC%88%E7%BA%BF%E6%80%A7%E7%A8%B3%E5%8E%8B%E5%99%A8LDO%EF%BC%89%EF%BC%9AVin%E3%80%81Vout%EF%BC%9B%E5%8E%8B%E5%B7%AE%EF%BC%88Vin-V%E5%B7%AE%3EVout%E6%97%B6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%89%C2%A0%E3%80%81Ci%E3%80%81Co%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9%EF%BC%8C%E9%99%8D%E5%99%AA%EF%BC%89">一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作）<br>、Ci、Co（输入输出滤波电容，降噪）</a></p>
<p><a href="about:blank#1.%E5%8F%82%E6%95%B0%EF%BC%9AVi%EF%BC%8CVo%EF%BC%88%E5%8F%AF%E8%B0%83%EF%BC%8C%E7%94%B5%E9%98%BB%E5%88%86%E5%8E%8B%EF%BC%89%EF%BC%8C%E5%8E%8B%E9%99%8D%EF%BC%8C%E8%BE%93%E5%87%BA%E7%94%B5%E6%B5%81Io%EF%BC%88max%EF%BC%89%EF%BC%8C%EF%BC%88%E5%99%AA%E5%A3%B0%EF%BC%8C%E9%9D%99%E6%80%81%E7%94%B5%E6%B5%81Iq%EF%BC%8C%E6%95%88%E7%8E%87%3DVo%2FVi%EF%BC%8C%E8%80%97%E6%95%A3%E5%8A%9F%E7%8E%87%3Dv%E5%B7%AE*Iload%EF%BC%89">1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*Iload）</a></p>
<p><a href="about:blank#2.PCB">        2.PCB</a></p>
<p><a href="about:blank#%C2%A0%E4%BA%8C.%E7%94%B5%E5%AE%B9%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E7%94%B5%E8%8D%B7%E6%B3%B5%EF%BC%89"><br>二.电容式开关电源（电荷泵）</a></p>
<p><a href="about:blank#1%C2%B7%E7%A8%B3%E5%8E%8B%E5%9E%8B%E7%94%B5%E8%8D%B7%E6%B3%B5%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%88%E9%A3%9E%E8%B7%A8%E7%94%B5%E5%AE%B9%EF%BC%8CS1%E3%80%81S3%2FS2%E3%80%81S4%E5%88%87%E6%8D%A2%E5%BC%80%E5%85%B3%EF%BC%8CC1%E5%85%85%E6%94%BE%E7%94%B5%EF%BC%89%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%B4%9F%E5%8E%8B">1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）​编辑<br>负压</a></p>
<p><a href="about:blank#PCB%EF%BC%9A">PCB：</a></p>
<p><a href="about:blank#%E4%B8%89.%E7%94%B5%E6%84%9F%E5%BC%8F%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%EF%BC%88%E5%8F%82%E6%95%B0%EF%BC%9AVI%EF%BC%9BV0%EF%BC%9BIO%EF%BC%9B%E5%BC%80%E5%85%B3%E8%AF%84%E7%8E%87Fsw%EF%BC%9BEN%EF%BC%9BFB%EF%BC%89">三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</a></p>
<p><a href="about:blank#*%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B%EF%BC%9A">*设计实例：</a></p>
<p><a href="about:blank#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">解决方案：</a></p>
<hr>
<h2 id><a href="#" class="headerlink" title></a></h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d33cf8d47d4d2de8371c40cc43edf710.png"></p>
<h2 id="一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）"><a href="#一-线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差-Vout时正常工作）-、Ci、Co（输入输出滤波电容，降噪）" class="headerlink" title="一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）"></a>一.线性电源（线性稳压器LDO）：Vin、Vout；压差（Vin-V差&gt;Vout时正常工作） 、Ci、Co（输入输出滤波电容，降噪）</h2><p>常用：LM1117</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7603ed872f9f27c253be1de796edc562.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/32f005e1cec50c5099ca1201cacda1cb.png"></p>
<p>（模电达林顿管）</p>
<h3 id="1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）"><a href="#1-参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率-Vo-Vi，耗散功率-v差-I-load-）" class="headerlink" title="1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I load ）"></a>1.参数：Vi，Vo（可调，电阻分压），压降，输出电流Io（max），（噪声，静态电流Iq，效率&#x3D;Vo&#x2F;Vi，耗散功率&#x3D;v差*I <em>load</em> ）</h3><p>建立元件参数表</p>
<p>线性电源无法并联扩流</p>
<h4 id="2-PCB"><a href="#2-PCB" class="headerlink" title="2.PCB"></a>2.PCB</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/516abda141133974961903290093a41b.png"></p>
<p>PCB例子：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1e1e1ee1439d5fa0b8dc96cc70d84a13.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/d4a91d9caca72e80e2bb1c0717d16977.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb3f95733581716c40d244efdb00fbb5.png">散热面积大，VCC连GND先过C</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a094e2dea7328ad1cc700b48f97748b4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7b1902e953d9978de38505d24f1141f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6edd9ed81123ce89e76fcd672972982.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae73145b8a1e4c2a6707fbf38c1d0486.png"></p>
<h2 id="二-电容式开关电源（电荷泵）"><a href="#二-电容式开关电源（电荷泵）" class="headerlink" title="二.电容式开关电源（电荷泵）"></a>二.电容式开关电源（电荷泵）</h2><p>常用：HX4002（2.7~5.5-&gt;5）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c570bfe596d08bd80536caa7bc3996b7.png"></p>
<h3 id="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）"><a href="#1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3-S2、S4切换开关，C1充放电）" class="headerlink" title="1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）"></a>1·稳压型电荷泵开关稳压器原理（飞跨电容，S1、S3&#x2F;S2、S4切换开关，C1充放电）</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e956f406406b2a825f0b7d7c9b99a6.png"><br>负压</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/203446207be2fbe6c344b483e902a9e9.png"></p>
<p>半压（两跨容，串联充电，并联充电）、倍压反之</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3c11d9321a69b002cc2346187f8b3f9.png"></p>
<p>ESR（等效串联电阻）；为防电流过大，跨容选2倍手册推荐大小；</p>
<p>减小纹波：加大跨容&#x2F;减小ESR；ESR：MLCC&lt;钽&lt;固态&lt;高频低阻电解&lt;电解</p>
<h3 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a62028779584be27bedc9a881cf1b0af.png"></p>
<p>2.稳压型（加入稳压模块）</p>
<h2 id="三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"><a href="#三-电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）" class="headerlink" title="三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）"></a>三.电感式开关电源（参数：VI；V0；IO；开关评率Fsw；EN；FB）</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cccdb639def67c103b72fc6c89d6bfbe.png"></p>
<p>1.开关关充电，开L&#x2F;C双供电</p>
<p>二极管续流（肖特基&#x2F;快恢复，损耗：导通压*电流）<img src="https://i-blog.csdnimg.cn/blog_migrate/01519524c2764e4bb98ef2d0d4a94422.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2abc250f6c37683f7865759f76cd83e7.png"></p>
<p> 改成负压输出的改造（接地端与原输出端互换）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d21361e0b91acac3643071203b9c022.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df20a2e55b8792485d63db18ccf2a9e6.png"></p>
<p>  例：SY8120I稳压芯片结构<br><img src="https://i-blog.csdnimg.cn/blog_migrate/28a2114b9b75501ad4ca1dd053b2eddd.png"></p>
<p>FB接内部误差放大器反相输入端，正向端接0.6V参考，根据RH&#x2F;RL得Vo</p>
<h3 id="设计实例："><a href="#设计实例：" class="headerlink" title="*设计实例："></a>*设计实例：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/284bbac4e893f0274aa71c622f768211.png"></p>
<p> 注：内部电磁干扰问题（EMI），造成高频振铃信号</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/35d73073e335edcb4b1485cfe40bd770.png"></p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/580b343296343253de0d82c49beb967e.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131397697">https://blog.csdn.net/qq_32971095/article/details/131397697</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%A3%B0%E9%9F%B3%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%B2%E6%89%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%A3%B0%E9%9F%B3%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%B2%E6%89%B0/" class="post-title-link" itemprop="url">声音是一种干扰.</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 16:22:00" itemprop="dateCreated datePublished" datetime="2023-05-19T16:22:00+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-10 00:41:27" itemprop="dateModified" datetime="2025-02-10T00:41:27+08:00">2025-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
                </span>
            </span>

          
            <span id="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%A3%B0%E9%9F%B3%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%B2%E6%89%B0/" class="post-meta-item leancloud_visitors" data-flag-title="声音是一种干扰." title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%A3%B0%E9%9F%B3%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%B2%E6%89%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%A3%B0%E9%9F%B3%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B9%B2%E6%89%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​       声音是一种干扰，吵闹的声音让人无法专心，娱乐游戏的声音吸引人的注意力，诱导脱离现实，忘记现实，迷失自我。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%BA%94%E5%BD%93%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E6%B8%85%E6%99%B0%E7%9A%84%E5%A4%B4%E8%84%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="舟遥遥以轻飏，风飘飘而吹衣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%BA%94%E5%BD%93%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E6%B8%85%E6%99%B0%E7%9A%84%E5%A4%B4%E8%84%91/" class="post-title-link" itemprop="url">应当时刻保持一个清晰的头脑</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 16:22:00" itemprop="dateCreated datePublished" datetime="2023-05-19T16:22:00+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-10 00:43:25" itemprop="dateModified" datetime="2025-02-10T00:43:25+08:00">2025-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
                </span>
            </span>

          
            <span id="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%BA%94%E5%BD%93%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E6%B8%85%E6%99%B0%E7%9A%84%E5%A4%B4%E8%84%91/" class="post-meta-item leancloud_visitors" data-flag-title="应当时刻保持一个清晰的头脑" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%BA%94%E5%BD%93%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E6%B8%85%E6%99%B0%E7%9A%84%E5%A4%B4%E8%84%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/05/19/%E9%9A%8F%E7%AC%94/%E6%80%9D%E8%80%83/%E5%BA%94%E5%BD%93%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E6%B8%85%E6%99%B0%E7%9A%84%E5%A4%B4%E8%84%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>72</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​       应当时刻保持一个清晰的头脑，不应让陋习懒惰使大脑混乱停顿，做出无脑行为是多么可耻羞愧。</p>
<p>​       无底线，不自律，堕落的坏事总是一起发生，一个接着一个。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description">舟遥遥以轻飏，风飘飘而吹衣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:18</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'H2FYHQwVGaUkawg5DkrA6d6M-gzGzoHsz',
      appKey     : 'zndS0u9Qj7qj8CqnJINs2MGT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://h2fyhqwv.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
