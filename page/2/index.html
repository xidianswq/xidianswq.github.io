<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Switch">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SWQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="Switch" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" class="post-title-link" itemprop="url">西电计科大三上数据库系统概论代码合集</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-14 00:14:45" itemprop="dateCreated datePublished" datetime="2023-12-14T00:14:45+08:00">2023-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" class="post-meta-item leancloud_visitors" data-flag-title="西电计科大三上数据库系统概论代码合集" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/12/14/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E8%AF%BE%E6%9C%AC%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90">一.课本课后作业解析</a></p>
<p><a href="about:blank#1.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E">1.问题说明</a></p>
<p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p>
<p><a href="about:blank#2.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E">2.问题说明</a></p>
<p><a href="about:blank#%C2%A0%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"> &lt;1&gt;代码解析</a></p>
<p><a href="about:blank#%C2%A03.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"> 3.问题说明</a></p>
<p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p>
<p><a href="about:blank#%C2%A04.%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"> 4.问题说明</a></p>
<p><a href="about:blank#%3C1%3E%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">&lt;1&gt;代码解析</a></p>
<p><a href="about:blank#%E4%BA%8C.openGauss%E5%AE%9E%E8%B7%B5%E5%B9%B3%E5%8F%B0%E5%AE%9E%E9%AA%8C">二.openGauss实践平台实验</a></p>
<p><a href="about:blank#1.%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0">1.关系模型描述</a></p>
<p><a href="about:blank#%C2%A0%3C1%3E%E6%9E%84%E5%BB%BA%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><br>&lt;1&gt;构建关系模型</a></p>
<p><a href="about:blank#%3C2%3E%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%C2%A0">&lt;2&gt;插入测试数据
</a></p>
<p><a href="about:blank#2.%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90">2.问题解析</a></p>
<p><a href="about:blank#%E4%B8%89.%E4%B8%8A%E6%9C%BA%E4%BD%9C%E4%B8%9A">三.上机作业</a></p>
<p><a href="about:blank#1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">1.需求分析</a></p>
<p><a href="about:blank#%3C1%3E%E5%86%85%E5%AE%B9">&lt;1&gt;内容</a></p>
<p><a href="about:blank#%3C2%3E%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82">&lt;2&gt;基本要求</a></p>
<p><a href="about:blank#2.%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">2.概念结构设计</a></p>
<p><a href="about:blank#%3C1%3E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E4%B9%89">&lt;1&gt;数据库语义</a></p>
<p><a href="about:blank#%3C2%3EE-R%E5%9B%BE%E8%AE%BE%E8%AE%A1">&lt;2&gt;E-R图设计</a></p>
<p><a href="about:blank#3.%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">3.逻辑结构设计</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">（1）关系模型</a></p>
<p><a href="about:blank#4.%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">4.功能实现</a></p>
<p><a href="about:blank#%3C1%3E%E5%BB%BA%E5%BA%93%E6%97%B6%E5%BA%94%E5%BD%95%E5%85%A5%E4%B8%80%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%EF%BC%88%E4%B8%8D%E8%83%BD%E8%BF%87%E5%B0%91%EF%BC%89%E5%AD%A6%E7%94%9F%E3%80%81%E6%95%99%E5%B8%88%E3%80%81%E8%AF%BE%E7%A8%8B%E3%80%81%E6%88%90%E7%BB%A9%E7%AD%89%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息</a></p>
<p><a href="about:blank#%3C2%3E%E5%BD%95%E5%85%A5%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%BA%94%E5%8C%85%E5%90%AB%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%E3%80%81%E6%80%A7%E5%88%AB%E3%80%81%E5%87%BA%E7%94%9F%E5%B9%B4%E6%9C%88%E3%80%81%E7%8F%AD%E7%BA%A7%E7%AD%89%E4%BF%A1%E6%81%AF">&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息</a></p>
<p><a href="about:blank#%3C3%3E%E6%8C%89%E5%AD%A6%E5%8F%B7%E3%80%81%E5%A7%93%E5%90%8D%E3%80%81%E4%B8%93%E4%B8%9A%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息</a></p>
<p><a href="about:blank#%3C4%3E%E5%BD%95%E5%85%A5%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E4%B8%80%E9%97%A8%E8%AF%BE%E7%9A%84%E6%88%90%E7%BB%A9">&lt;4&gt;录入一位学生一门课的成绩</a></p>
<p><a href="about:blank#%3C5%3E%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E6%89%80%E4%BF%AE%E7%9A%84%E8%AF%BE%E7%A8%8B%E3%80%81%E6%80%A7%E8%B4%A8%EF%BC%88%E5%BF%85%E4%BF%AE%E6%88%96%E9%80%89%E4%BF%AE%EF%BC%89%E3%80%81%E5%AD%A6%E6%9C%9F%E3%80%81%E5%AD%A6%E5%88%86%E5%8F%8A%E6%88%90%E7%BB%A9">&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩</a></p>
<p><a href="about:blank#%3C6%3E%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%BD%8D%E5%AD%A6%E7%94%9F%E8%A2%AB%E5%93%AA%E4%BA%9B%E6%95%99%E5%B8%88%E6%95%99%E8%BF%87%E8%AF%BE">&lt;6&gt;查询一位学生被哪些教师教过课</a></p>
<p><a href="about:blank#%3C7%3E%E6%9F%A5%E8%AF%A2%E5%BF%AB%E8%A6%81%E8%A2%AB%E5%BC%80%E9%99%A4%E7%9A%84%E5%AD%A6%E7%94%9F%EF%BC%88%E8%B7%9D%E8%A2%AB%E5%BC%80%E9%99%A4%E5%B7%AE3%E5%AD%A6%E5%88%86%E4%B9%8B%E5%86%85%EF%BC%89">&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）</a></p>
<p><a href="about:blank#5.%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3">5.主要问题及解决</a></p>
<p><a href="about:blank#6.%E6%80%BB%E7%BB%93">6.总结</a></p>
<p><a href="about:blank#7.%E9%99%84%E5%BD%95">7.附录</a></p>
<p><a href="about:blank#%3C1%3ETXT%E8%BD%ACSQL%20C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC">&lt;1&gt;TXT转SQL<br>C语言程序脚本</a></p>
<hr>
<h2 id="一-课本课后作业解析"><a href="#一-课本课后作业解析" class="headerlink" title="一.课本课后作业解析"></a>一.课本课后作业解析</h2><h3 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1.问题说明"></a>1.问题说明</h3><pre><code>    用SQL语句建立第2章习题6中的4个表（要求给出主码和外码约束，但无需插入记录）：
</code></pre>
<p>设有一个SPJ数据库，包括S，P，J及SPJ4个关系模式：</p>
<p>S(SNO, SNAME, STATUS, CITY);</p>
<p>P(PNO, PNAME, COLOR, WEIGHT);</p>
<p>J(JNO, JNAME, CITY);</p>
<p>SPJ(SNO, PNO, JNO, QTY)。</p>
<pre><code>    供应商表S由供应商代码（SNO）、供应商姓名（SNAME）、供应商状态（STATUS）、供应商所在城市（CITY）组成。

    零件表P由零件代码（PNO）、零件名（PNAME）、颜色（COLOR）、重量（WEIGHT）组成。

    工程项目表J由工程项目代码（JNO）、工程项目名（JNAME）、工程项目所在城市（CITY）组成。

    供应情况表SPJ由供应商代码（SNO）、零件代码（PNO）、工程项目代码（JNO）、供应数量（QTY）组成，表示某供应商供应某种零件给某工程项目的数量为QTY。
</code></pre>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*-- 删除已有的表*/
/*-- 注意要先删除参照表（如SC），再删除被参照表（如Student，Course）*/
DROP TABLE SPJ;
DROP TABLE S;
DROP TABLE P;
DROP TABLE J;


/*创建基本表*/
/*注意要先创建被参照表，再创建参照表*/
CREATE TABLE S(
SNO CHAR(10) PRIMARY KEY,	/*-- 列级完整性约束的方式，定义主码*/
SNAME CHAR(20),
STATUS INT,
CITY CHAR(10)
); 

CREATE TABLE P(
PNO CHAR(10) PRIMARY KEY,
PNAME CHAR(20),
COLOR CHAR(10),
WEIGHT CHAR(10)
);

CREATE TABLE J(
JNO CHAR(10) PRIMARY KEY,
JNAME CHAR(20),
CITY CHAR(10)
);

CREATE TABLE SPJ(
SNO CHAR(10),
PNO CHAR(10),
JNO CHAR(10),
QTY INT,
PRIMARY KEY (SNO,PNO,JNO),
FOREIGN KEY (SNO) REFERENCES S(SNO),	/*-- 表级完整性约束的方式，定义外码；注意参照列Cpno必须加括号*/
FOREIGN KEY (PNO) REFERENCES P(PNO),	
FOREIGN KEY (JNO) REFERENCES J(JNO)	
);
</code></pre>
<p>插入测试数据：</p>
<pre><code>/*-- 向基本表中插入数据*/
INSERT INTO S VALUES (&#39;S1&#39;,&#39;精益&#39;,20,&#39;天津&#39;);
INSERT INTO S VALUES (&#39;S2&#39;,&#39;盛锡&#39;,10,&#39;北京&#39;);
INSERT INTO S VALUES (&#39;S3&#39;,&#39;东方红&#39;,30,&#39;北京&#39;);
INSERT INTO S VALUES (&#39;S4&#39;,&#39;丰泰盛&#39;,20,&#39;天津&#39;);
INSERT INTO S VALUES (&#39;S5&#39;,&#39;为民&#39;,20,&#39;上海&#39;);

/*-- 如果根据参照关系表中一行参照了另外一行，应先插入被参照行（如(&#39;6&#39;,...,...,...)），后插入参照行（如(...,...,&#39;6&#39;,...)）*/
INSERT INTO P VALUES (&#39;P1&#39;,&#39;螺母&#39;,&#39;红&#39;,12);
INSERT INTO P VALUES (&#39;P2&#39;,&#39;螺栓&#39;,&#39;绿&#39;,17);
INSERT INTO P VALUES (&#39;P3&#39;,&#39;螺丝刀&#39;,&#39;蓝&#39;,14);
INSERT INTO P VALUES (&#39;P4&#39;,&#39;螺丝刀&#39;,&#39;红&#39;,14);
INSERT INTO P VALUES (&#39;P5&#39;,&#39;凸轮&#39;,&#39;蓝&#39;,40);
INSERT INTO P VALUES (&#39;P6&#39;,&#39;齿轮&#39;,&#39;红&#39;,30);

INSERT INTO J VALUES (&#39;J1&#39;,&#39;三建&#39;,&#39;北京&#39;);
INSERT INTO J VALUES (&#39;J2&#39;,&#39;一汽&#39;,&#39;长春&#39;);
INSERT INTO J VALUES (&#39;J3&#39;,&#39;弹簧厂&#39;,&#39;天津&#39;);
INSERT INTO J VALUES (&#39;J4&#39;,&#39;造船厂&#39;,&#39;天津&#39;);
INSERT INTO J VALUES (&#39;J5&#39;,&#39;机车厂&#39;,&#39;唐山&#39;);
INSERT INTO J VALUES (&#39;J6&#39;,&#39;无线电厂&#39;,&#39;常州&#39;);
INSERT INTO J VALUES (&#39;J7&#39;,&#39;半导体厂&#39;,&#39;南京&#39;);

INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J1&#39;,200);
INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J3&#39;,100);
INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J4&#39;,700);
INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P2&#39;,&#39;J2&#39;,100);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J1&#39;,400);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J2&#39;,200);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J4&#39;,500);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P3&#39;,&#39;J5&#39;,400);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P5&#39;,&#39;J1&#39;,400);
INSERT INTO SPJ VALUES (&#39;S2&#39;,&#39;P5&#39;,&#39;J2&#39;,100);
INSERT INTO SPJ VALUES (&#39;S3&#39;,&#39;P1&#39;,&#39;J1&#39;,200);
INSERT INTO SPJ VALUES (&#39;S3&#39;,&#39;P3&#39;,&#39;J1&#39;,200);
INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P5&#39;,&#39;J1&#39;,100);
INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P6&#39;,&#39;J3&#39;,300);
INSERT INTO SPJ VALUES (&#39;S4&#39;,&#39;P6&#39;,&#39;J4&#39;,200);
INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P2&#39;,&#39;J4&#39;,100);
INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P3&#39;,&#39;J1&#39;,200);
INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P6&#39;,&#39;J2&#39;,200);
INSERT INTO SPJ VALUES (&#39;S5&#39;,&#39;P6&#39;,&#39;J4&#39;,500);
</code></pre>
<h3 id="2-问题说明"><a href="#2-问题说明" class="headerlink" title="2.问题说明"></a>2.问题说明</h3><p>针对建立的4个表用SQL完成第2章习题6中的查询：</p>
<p>（1）求供应工程J1零件的供应商号码SNO；</p>
<p>（2）求供应工程J1零件P1的供应商号码SNO;</p>
<p>（3）求供应工程J1零件为红色的供应商号码SNO；</p>
<p>（4）求没有使用天津供应商生产的红色零件的工程号JNO；</p>
<p>（5）求至少使用了供应商S1所供应的全部零件的工程号JNO。</p>
<h4 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*求供应工程J1零件的供应商号码SNO*/
SELECT DISTINCT SNO
FROM SPJ
WHERE JNO=&#39;J1&#39;;

/*求供应工程J1零件P1的供应商号码SNO*/
SELECT DISTINCT SNO
FROM SPJ
WHERE JNO=&#39;J1&#39; AND PNO=&#39;P1&#39;;

/*求供应工程J1零件为红色的供应商号码SNO*/
SELECT DISTINCT SNO
FROM SPJ
WHERE JNO=&#39;J1&#39; AND PNO IN(
    SELECT DISTINCT PNO
    FROM P
    WHERE COLOR=&#39;红&#39;
);

/*求没有使用天津供应商生产的红色零件的工程号JNO*/
SELECT DISTINCT JNO
FROM SPJ
WHERE SNO NOT IN (
    SELECT SNO
    FROM S
    WHERE CITY=&#39;天津&#39;
    ) OR PNO NOT IN(
        SELECT DISTINCT PNO
        FROM P
        WHERE COLOR=&#39;红&#39;
);

/*求至少使用了供应商S1所供应的全部零件的工程号JNO*/
/*方法一*/
SELECT DISTINCT JNO
FROM SPJ
WHERE SNO=&#39;S1&#39;
GROUP BY JNO 
HAVING COUNT(PNO)=(SELECT COUNT(DISTINCT PNO) FROM SPJ WHERE SNO=&#39;S1&#39;);

/*方法二*/
SELECT DISTINCT JNO
FROM SPJ X
WHERE NOT EXISTS(
    SELECT DISTINCT PNO
    FROM SPJ Y
    WHERE SNO=&#39;S1&#39; AND NOT EXISTS(
        SELECT *
        FROM SPJ Z
        WHERE Z.SNO=&#39;S1&#39; AND Y.PNO=Z.PNO AND X.JNO=Z.JNO
    )
);
</code></pre>
<h3 id="3-问题说明"><a href="#3-问题说明" class="headerlink" title="3.问题说明"></a>3.问题说明</h3><p>针对建立的4个表用SQL完成一下各项操作：</p>
<p>（1）找出所有供应商的姓名和所在城市；</p>
<p>（2）找出所有零件的名称、颜色、重量；</p>
<p>（3）找出使用供应商S1所供应零件的工程号码；</p>
<p>（4）找出工程项目J2使用的各种零件的名称及其数量；</p>
<p>（5）找出上海厂商供应的所有零件号码；</p>
<p>（6）找出使用上海产的零件的工程名称；</p>
<p>（7）找出没有使用天津产的零件的工程号码；</p>
<p>（8）把全部红色零件的颜色改成蓝色；</p>
<p>（9）由S5供给J4的零件P6改为由S3供应，请作出必要的修改；</p>
<p>（10）从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录；</p>
<p>（11）请将(S2,J6,P4,200)插入供应情况关系。</p>
<h4 id="代码解析-2"><a href="#代码解析-2" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*找出所有供应商的姓名和所在城市*/
SELECT SNAME,CITY
FROM S;

/*找出所有零件的名称、颜色、重量*/
SELECT PNAME,COLOR,WEIGHT
FROM P;

/*找出使用供应商S1所供应零件的工程号码*/
SELECT DISTINCT JNO
FROM SPJ
WHERE SNO=&#39;S1&#39;;

/*找出工程项目J2使用的各种零件的名称及其数量*/
SELECT PNAME,QTY
FROM SPJ,P
WHERE SPJ.PNO=P.PNO AND JNO=&#39;J2&#39;;

/*找出上海厂商供应的所有零件号码*/
SELECT DISTINCT PNO
FROM SPJ,S
WHERE SPJ.SNO=S.SNO AND CITY=&#39;上海&#39;;

/*找出使用上海产的零件的工程名称*/
SELECT DISTINCT JNO
FROM SPJ,S
WHERE SPJ.SNO=S.SNO AND CITY=&#39;上海&#39;;

/*找出没有使用天津产的零件的工程号码*/
SELECT DISTINCT JNO
FROM SPJ,S
WHERE SPJ.SNO=S.SNO AND CITY!=&#39;天津&#39;;

/*把全部红色零件的颜色改成蓝色*/
UPDATE P
SET COLOR=&#39;蓝&#39;
WHERE COLOR=&#39;红&#39;;

/*由S5供给J4的零件P6改为由S3供应，请作出必要的修改*/
UPDATE SPJ
SET SNO=&#39;S3&#39;
WHERE SNO=&#39;S5&#39; AND PNO=&#39;P6&#39; AND JNO=&#39;J4&#39;;

/*从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录*/
ALTER TABLE SPJ 
ADD FOREIGN KEY (SNO) REFERENCES S(SNO) ON DELETE CASCADE;/*添加外键，设置级联删除*/
DELETE FROM S WHERE SNO=&#39;S2&#39;;


/*请将(S2,J6,P4,200)插入供应情况关系*/
INSERT INTO SPJ VALUES (&#39;S1&#39;,&#39;P1&#39;,&#39;J1&#39;,200);
</code></pre>
<h3 id="4-问题说明"><a href="#4-问题说明" class="headerlink" title="4.问题说明"></a>4.问题说明</h3><pre><code>    请为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）。针对该视图完成下列查询：
</code></pre>
<p>（1）找出三建工程项目使用的各种零件代码及其数量；</p>
<p>（2）找出供应商S1的供应情况。</p>
<h4 id="代码解析-3"><a href="#代码解析-3" class="headerlink" title="&lt;1&gt;代码解析"></a>&lt;1&gt;代码解析</h4><pre><code>/*为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）*/
CREATE VIEW PROD(SNO,PNO,QTY)
AS
SELECT SNO,PNO,QTY
FROM SPJ
WHERE JNO=&#39;J1&#39;

/*找出三建工程项目使用的各种零件代码及其数量*/
SELECT PNO,SUM(QTY)
FROM PROD
GROUP BY PNO;


/*找出供应商S1的供应情况*/
SELECT PNO,QTY
FROM PROD
WHERE SNO=&#39;S1&#39;;
</code></pre>
<h2 id="二-openGauss实践平台实验"><a href="#二-openGauss实践平台实验" class="headerlink" title="二.openGauss实践平台实验"></a>二.openGauss实践平台实验</h2><h3 id="1-关系模型描述"><a href="#1-关系模型描述" class="headerlink" title="1.关系模型描述"></a>1.关系模型描述</h3><p>学籍管理数据库有如下关系模式：</p>
<p>学生Student（学号Sno，姓名Sname，性别Ssex，年龄Sage，系别Sdept）；</p>
<p>课程Course（课程号Cno，课程名称Cname，先修课Cpno，学分Ccredit）；</p>
<p>成绩SC（学号Sno，课程号Cno，成绩Grade）。</p>
<h4 id="构建关系模型"><a href="#构建关系模型" class="headerlink" title="&lt;1&gt;构建关系模型"></a>&lt;1&gt;构建关系模型</h4><pre><code>/*构建关系模型*/
CREATE TABLE Student(
    Sno CHAR(10) PRIMARY KEY,	/*-- 列级完整性约束的方式，定义主码*/
    Sname CHAR(20),
    Ssex CHAR(10),
    Sage INT,
    Sdept CHAR(10)
);

CREATE TABLE Course(
    Cno CHAR(10) PRIMARY KEY,	/*-- 列级完整性约束的方式，定义主码*/
    Cname CHAR(20),
    Cpno CHAR(10),
    Ccredit INT
);

CREATE TABLE SC(
    Sno CHAR(10),
    Cno CHAR(10),
    Grade INT,
    PRIMARY KEY (Sno,Cno),
    FOREIGN KEY (Sno) REFERENCES Student(Sno),	/*-- 表级完整性约束的方式，定义外码；注意参照列Cpno必须加括号*/
    FOREIGN KEY (Cno) REFERENCES Course(Cno)
);
</code></pre>
<h4 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="&lt;2&gt;插入测试数据"></a>&lt;2&gt;插入测试数据</h4><pre><code>/*插入示例数据*/
INSERT INTO Student VALUES (&#39;1&#39;,&#39;SWQ&#39;,&#39;男&#39;,20,&#39;CS&#39;);
INSERT INTO Student VALUES (&#39;2&#39;,&#39;SSS&#39;,&#39;男&#39;,19,&#39;CS&#39;);
INSERT INTO Student VALUES (&#39;3&#39;,&#39;WWW&#39;,&#39;男&#39;,17,&#39;CS&#39;);
INSERT INTO Student VALUES (&#39;4&#39;,&#39;QQQ&#39;,&#39;男&#39;,17,&#39;IS&#39;);

INSERT INTO Course VALUES (&#39;1&#39;,&#39;OS&#39;,&#39;2&#39;,4);
INSERT INTO Course VALUES (&#39;2&#39;,&#39;MATH&#39;,&#39;3&#39;,5);
INSERT INTO Course VALUES (&#39;3&#39;,&#39;ENG&#39;,&#39;3&#39;,2);

INSERT INTO SC VALUES (&#39;1&#39;,&#39;1&#39;,94);
INSERT INTO SC VALUES (&#39;2&#39;,&#39;1&#39;,85);
INSERT INTO SC VALUES (&#39;3&#39;,&#39;1&#39;,72);
INSERT INTO SC VALUES (&#39;4&#39;,&#39;1&#39;,94);
INSERT INTO SC VALUES (&#39;1&#39;,&#39;2&#39;,69);
INSERT INTO SC VALUES (&#39;2&#39;,&#39;2&#39;,99);
INSERT INTO SC VALUES (&#39;3&#39;,&#39;2&#39;,77);
INSERT INTO SC VALUES (&#39;4&#39;,&#39;2&#39;,58);
INSERT INTO SC VALUES (&#39;1&#39;,&#39;3&#39;,100);
INSERT INTO SC VALUES (&#39;2&#39;,&#39;3&#39;,78);
INSERT INTO SC VALUES (&#39;3&#39;,&#39;3&#39;,87);
INSERT INTO SC VALUES (&#39;4&#39;,&#39;3&#39;,67);
</code></pre>
<h3 id="2-问题解析"><a href="#2-问题解析" class="headerlink" title="2.问题解析"></a>2.问题解析</h3><pre><code>/*查询年龄不大于19的“女”生的学号和姓名。*/
SELECT Sno,Sname
FROM Student
WHERE Sage&lt;20 AND Ssex=&#39;女&#39;;

/*查询所有姓“王”的学生的学号、姓名和性别。*/
SELECT Sno,Sname,Ssex
FROM Student
WHERE Sname LIKE &#39;王%&#39;;

/*查询“CS”系年龄大于本系平均年龄的学生的学号、姓名和年龄。*/
SELECT Sno,Sname,Sage
FROM Student X
WHERE Sdept=&#39;CS&#39; AND Sage&gt;(
    SELECT AVG(Sage)
    FROM Student
    GROUP BY Sdept
    HAVING Sdept=&#39;CS&#39;
)

/*
错误写法：
SELECT Sno,Sname,Sage
FROM Student
WHERE Sdept=&#39;CS&#39;
GROUP BY Sdept
HAVING Sage&gt;AVG(Sage);
*/

/*查询每门课程的课程号、课程名、平均成绩、最低成绩和最高成绩。*/
SELECT DISTINCT Course.Cno,Cname,AVG(Grade),MIN(Grade),MAX(Grade)
FROM Course,SC
WHERE Course.Cno=SC.Cno
GROUP BY Course.Cno;

/*查询至少选修了学号为“200215121”的学生所选全部课程*/
SELECT Sno
FROM Student
WHERE NOT EXISTS(
    SELECT Cno
    FROM SC X
    WHERE Sno=&#39;200215121&#39; AND NOT EXISTS(
        SELECT *
        FROM SC Y
        WHERE Y.Sno=Student.Sno AND X.Cno=Y.Cno
    )
);

/*查询每门课程分数排名第1的学生学号、课程号和成绩。*/
SELECT Sno,Cno,Grade
FROM SC X
WHERE NOT EXISTS(
    SELECT *
    FROM SC Y
    WHERE X.Cno=Y.Cno AND Y.Grade&gt;X.Grade
);

/*查询每门课程分数排名第2的学生学号、课程号和成绩。*/
SELECT Sno,Cno,Grade
FROM SC X
WHERE EXISTS(
    SELECT Cno
    FROM SC Y
    WHERE X.Cno=Y.Cno AND X.Grade&lt;Y.Grade
    GROUP BY Y.Cno
    HAVING COUNT(Y.Sno)=1
);

/*将一个新学生元组（学号：200215228；姓名：陈冬；性别*/
INSERT
INTO Student(Sno,Sname,Ssex,Sage,Sdept)
VALUES(&#39;200215228&#39;,&#39;陈冬&#39;,&#39;男&#39;,18,&#39;IS&#39;);

/*将所有学生的年龄增加1岁。*/
UPDATE Student
SET Sage=Sage+1;

/*删除学号为“200215122”的学生的选课记录。*/
DELETE
FROM SC
WHERE Sno=&#39;200215122&#39;;

/*创建视图View_IS，找出Sdept为IS的学生的学号*/
CREATE VIEW View_IS(Sno,Sname)
AS
SELECT Sno,Sname
FROM Student
WHERE Sdept=&#39;IS&#39;;
</code></pre>
<h2 id="三-上机作业"><a href="#三-上机作业" class="headerlink" title="三.上机作业"></a>三.上机作业</h2><h3 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h3><h4 id="内容"><a href="#内容" class="headerlink" title="&lt;1&gt;内容"></a>&lt;1&gt;内容</h4><pre><code>    为某大学设计一套学籍管理数据库系统
</code></pre>
<h4 id="基本要求"><a href="#基本要求" class="headerlink" title="&lt;2&gt;基本要求"></a>&lt;2&gt;基本要求</h4><p>①设计学籍管理数据库，符合给定的语义（P3），并实现一定的功能需求（P4）<br>②使用一种DBMS，如SQL Server，具体不限</p>
<h3 id="2-概念结构设计"><a href="#2-概念结构设计" class="headerlink" title="2.概念结构设计"></a>2.概念结构设计</h3><h4 id="数据库语义"><a href="#数据库语义" class="headerlink" title="&lt;1&gt;数据库语义"></a>&lt;1&gt;数据库语义</h4><p>①学校有若干专业，每个专业每年招若干个班，每个班有若干学生<br>②每个专业有自己的教学计划，规定了该专业相关课程的性质（必修或选修）以及授课学期；例如，数据库课程对计算机专业为必修、在大三上学期，但对数学专业可能为选修、在大三下学期，而中文专业可能不学这门课<br>③一位教师可以给多个班带课，但不能给一个班带多门课<br>④一门课程最多允许学生一次补考；学生达到如下条件之一的被开除：不及格必修课累计达10学分、或不及格选修课累计达15学分<br>⑤上述语义未涉及到的事项和细节，可自行做出合理假定</p>
<h4 id="E-R图设计"><a href="#E-R图设计" class="headerlink" title="&lt;2&gt;E-R图设计"></a>&lt;2&gt;E-R图设计</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/912e583d76c9b2ec0803211714b62171.png"></p>
<h3 id="3-逻辑结构设计"><a href="#3-逻辑结构设计" class="headerlink" title="3.逻辑结构设计"></a>3.逻辑结构设计</h3><h4 id="（1）关系模型"><a href="#（1）关系模型" class="headerlink" title="（1）关系模型"></a>（1）关系模型</h4><pre><code>DROP TABLE Schedule;
DROP TABLE SC;
DROP TABLE Student;
DROP TABLE Teather;
DROP TABLE Course;
DROP TABLE Class;
DROP TABLE Department;
</code></pre>
<p>专业信息表（专业代号和专业名）：</p>
<pre><code>CREATE TABLE Department(
    Dept CHAR(10) PRIMARY KEY,
    Dname CHAR(75)
);
</code></pre>
<p>班级表（班级编号和从属专业）：</p>
<pre><code>CREATE TABLE Class(
    Class_no CHAR(10) PRIMARY KEY,
    Dept CHAR(10),
    FOREIGN KEY (Dept) REFERENCES Department(Dept) ON DELETE CASCADE
);
</code></pre>
<p>学生表（学号、姓名、性别、出生年月、从属班级）：</p>
<pre><code>CREATE TABLE Student(
    Sno CHAR(10) PRIMARY KEY,
    Sname CHAR(20),
    Ssex CHAR(4),
    Sbrith CHAR(10),
    Class_no CHAR(20),
    FOREIGN KEY (Class_no) REFERENCES Class(Class_no) ON DELETE CASCADE
);
</code></pre>
<p>课程表（课程号、课程名、从属专业、必&#x2F;选修、开课时间、学分）：</p>
<pre><code>CREATE TABLE Course(
    Cno CHAR(20) PRIMARY KEY,
    Cname CHAR(75),
    Dept CHAR(10),
    Creq CHAR(10),
    Cterm CHAR(20),
    Ccredit INT,
    FOREIGN KEY (Dept) REFERENCES Department(Dept) ON DELETE CASCADE
);
</code></pre>
<p>教师表（编号、姓名、所带课程）：</p>
<pre><code>CREATE TABLE Teacher(
    Tno CHAR(10) PRIMARY KEY,
    Tname CHAR(20),
    Cno CHAR(10),
    FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE
);
</code></pre>
<p>上课表（班级、老师、课程号）：</p>
<pre><code>CREATE TABLE Schedule(
    Class_no CHAR(10),
    Cno CHAR(10),
    Tno CHAR(10),
    PRIMARY KEY (Class_no,Cno),
    FOREIGN KEY (Class_no) REFERENCES Class(Class_no) ON DELETE CASCADE,
    FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE,
    FOREIGN KEY (Tno) REFERENCES Teacher(Tno) ON DELETE CASCADE
);
</code></pre>
<p>成绩表（学号、课程号、成绩）：</p>
<pre><code>CREATE TABLE SC(
    Sno CHAR(10),
    Cno CHAR(10),
    Score INT,
    PRIMARY KEY (Sno,Cno),
    FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE,
     FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE CASCADE
);
</code></pre>
<p>其中相关约束条件均实现，各个编号的主码约束及引用约束。  </p>
<h3 id="4-功能实现"><a href="#4-功能实现" class="headerlink" title="4.功能实现"></a>4.功能实现</h3><p>*说明：由于示例数据数量庞大且与自己设计的表格结构不同，如果要在示例数据中自行添加其他信息过于繁杂，于是将课程信息表Course和学生信息表Student拆分成两部分，基本信息和细节信息表_Detail。见下面示例。<br>本数据库的功能实现采用MySQL软件实现，安装过程参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64338546/article/details/127149096?spm=1001.2014.3001.5506" title="【MySQL基础】MySQL介绍及安装">【MySQL基础】MySQL介绍及安装<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/m0_64338546&#x2F;article&#x2F;details&#x2F;127149096?spm&#x3D;1001.2014.3001.5506</a>完成后进入界面如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f4aa57e5edc0f357d8688c3877bb324.png"></p>
<p> 建表结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/226e6c620c54190be5bd6eabc8a25a30.png"></p>
<p>另外可使用table_status和desc命令查看表格详细数据：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cde497672b0b674364b7e6fbc2bc75ad.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb274a08847e8854f4719fcce5fb89a4.png"></p>
<h4 id="建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息"><a href="#建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息" class="headerlink" title="&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息"></a>&lt;1&gt;建库时应录入一定数量的（不能过少）学生、教师、课程、成绩等基本信息</h4><p>将示例数据文件通过C语言程序导出SQL插入信息语句，如下：</p>
<p>示例数据：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba24a79a9bde63b6f40780345bc96984.png"></p>
<p>导出的SQL插入语句：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c20b757c92574505beb2946017fb2a29.png"></p>
<p>插入结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd918f68acfc938d9057152b7a15b0b0.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3057357a7d4e952deced2417493b28d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c6794ab2d25179d8b29f1c4bd9f6533.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c80ab3a13c2d49e9a14e3314fdfc8d47.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3db46ba539941fed33d161dc47b0762.png"></p>
<h4 id="录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息"><a href="#录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息" class="headerlink" title="&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息"></a>&lt;2&gt;录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息</h4><pre><code>/*录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息*/
INSERT INTO Student (Sno, Sname, Ssex, Sbrith, Class_no) VALUES (&#39;03051108&#39;,&#39;司武强&#39;,&#39;男&#39;,&#39;20030411&#39;,&#39;2103014&#39;);
</code></pre>
<p>实际拆分成两部分插入：</p>
<pre><code>/*录入一位学生，应包含学号、姓名、性别、出生年月、班级等信息*/
INSERT INTO Student (Sno, Sname, Ssex) VALUES (&#39;03051109&#39;,&#39;司武强&#39;,&#39;男&#39;);
INSERT INTO Student_Detail (Sno, Sbrith, Class_no) VALUES (&#39;03051109&#39;,&#39;20030411&#39;,&#39;210101&#39;);
</code></pre>
<h4 id="按学号、姓名、专业三种方式查询学生基本信息"><a href="#按学号、姓名、专业三种方式查询学生基本信息" class="headerlink" title="&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息"></a>&lt;3&gt;按学号、姓名、专业三种方式查询学生基本信息</h4><pre><code>/*按学号、姓名、专业三种方式查询学生基本信息*/
SELECT *
FROM Student
WHERE Sno=&#39;03051108&#39;;

SELECT *
FROM Student
WHERE Sname=&#39;司武强&#39;;

SELECT *
FROM Student,Class
WHERE Student.Class_no=Class.Class_no AND Dept=&#39;CS&#39;;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f0fd577e9a6cc2cb7c09c1023cc9d8bc.png"></p>
<h4 id="录入一位学生一门课的成绩"><a href="#录入一位学生一门课的成绩" class="headerlink" title="&lt;4&gt;录入一位学生一门课的成绩"></a>&lt;4&gt;录入一位学生一门课的成绩</h4><pre><code>/*录入一位学生一门课的成绩*/
INSERT INTO SC (Sno,Cno,Score) VALUES (&#39;03051108&#39;,&#39;CS3121014&#39;,99);
</code></pre>
<p>录入结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/98e6d06dd16ce5436e2aac93f85ad6cd.png"></p>
<h4 id="查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩"><a href="#查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩" class="headerlink" title="&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩"></a>&lt;5&gt;查询一位学生所修的课程、性质（必修或选修）、学期、学分及成绩</h4><pre><code>SELECT Student.Sno,Sname,Cname,Creq,Cterm,Score
FROM Course,SC,Student
WHERE Course.Cno=SC.Cno AND SC.Sno=Student.Sno AND (Student.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;);
</code></pre>
<p>查询他的必修课平均成绩：</p>
<pre><code>SELECT AVG(Score)
FROM SC
WHERE Sno=&#39;03051108&#39; AND EXISTS(
    SELECT *
    FROM Course
    WHERE SC.Cno=Course.Cno AND Course.Creq=&#39;必修&#39;
);
/*或*/
SELECT Student.Sno,Sname,AVG(Score)
FROM Student,SC,Course
WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno
GROUP BY Student.Sno,SC.Sno,Course.Creq
HAVING Course.Creq=&#39;必修&#39; AND (SC.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;);
</code></pre>
<p> 所有课程平均成绩（平均成绩应按学分加权）：</p>
<pre><code>SELECT Student.Sno,Sname,SUM(Score*Ccredit)/SUM(Ccredit)
FROM Student,SC,Course
WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno
GROUP BY Student.Sno
HAVING Student.Sno=&#39;03051108&#39; OR Sname=&#39;司武强&#39;;
</code></pre>
<p>注：由于课程信息庞大，查询时皆忽略条件“必修”</p>
<p>查询结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c061cd1cbc43256dba341cce842c1fef.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0524d3e8e4cea528fe7d439432b449db.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bfbea01fbea4ba90344d8e8a3b4a76a5.png"></p>
<h4 id="查询一位学生被哪些教师教过课"><a href="#查询一位学生被哪些教师教过课" class="headerlink" title="&lt;6&gt;查询一位学生被哪些教师教过课"></a>&lt;6&gt;查询一位学生被哪些教师教过课</h4><pre><code>/*查询一位学生被哪些教师教过课*/
SELECT Tname,Cname
FROM Student,Schedule,Teacher,Course
WHERE Student.Class_no=Schedule.Class_no AND Schedule.Tno=Teacher.Tno AND Schedule.Cno=Course.Cno AND (Student.Sno=&#39;03051108&#39; OR Student.Sname=&#39;司武强&#39;;
</code></pre>
<h4 id="查询快要被开除的学生（距被开除差3学分之内）"><a href="#查询快要被开除的学生（距被开除差3学分之内）" class="headerlink" title="&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）"></a>&lt;7&gt;查询快要被开除的学生（距被开除差3学分之内）</h4><pre><code>/*查询快要被开除的学生（距被开除差3学分之内）*/
SELECT Sno,Sname
FROM Student
WHERE 10&lt;=(
    SELECT SUM(Ccredit)
    FROM SC,Course
    WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Creq=&#39;必修&#39; AND Score&lt;60
) OR 15&lt;=(
    SELECT SUM(Ccredit)
    FROM SC,Course
    WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Creq=&#39;选修&#39; AND Score&lt;60
);
</code></pre>
<p>查询结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/766ca586e00ab2d430092a38e54e9465.png"></p>
<h3 id="5-主要问题及解决"><a href="#5-主要问题及解决" class="headerlink" title="5.主要问题及解决"></a>5.主要问题及解决</h3><p>&lt;1&gt;问题：插入数据工作量庞大且繁琐，示例数据与期望表结构不同</p>
<pre><code>    解决：于是将课程信息表Course和学生信息表Student拆分成两部分，基本信息和细节信息表_Detail。将示例数据文件通过C语言程序导出SQL插入信息语句。

    改进：利用const char数组定义某个属性的可能取值，利用random函数插入细节数据
</code></pre>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><pre><code>    数据库的查询速度极快，基本在0.01s左右。但唯一的不足之处在于插入数据不便，需要用INSERT语句且符合表的结构。采用图形界面将优化这一不足。
</code></pre>
<h3 id="7-附录"><a href="#7-附录" class="headerlink" title="7.附录"></a>7.附录</h3><h4 id="TXT转SQL-C语言程序脚本"><a href="#TXT转SQL-C语言程序脚本" class="headerlink" title="&lt;1&gt;TXT转SQL C语言程序脚本"></a>&lt;1&gt;TXT转SQL C语言程序脚本</h4><p>主程序（INSERT_SQL.c）：</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&quot;school_sql.h&quot;

int main()
&#123;

	INSERT_(&quot;Department&quot;,&quot;Department.txt&quot;, &quot;INSERT_Department.sql&quot;);
	INSERT_(&quot;Class&quot;,&quot;Class.txt&quot;, &quot;INSERT_Class.sql&quot;);
	INSERT_Course(&quot;Course&quot;, &quot;Course.txt&quot;, &quot;INSERT_Course.sql&quot;);
	INSERT_(&quot;Student&quot;,&quot;Student.txt&quot;, &quot;INSERT_Student.sql&quot;);
	INSERT_(&quot;SC&quot;,&quot;SC.txt&quot;, &quot;INSERT_SC.sql&quot;);

	return 0;
&#125;
</code></pre>
<p>头文件（school.h）:</p>
<pre><code>#ifndef SCHOOL_SQL_H
#define SCHOOL_SQL_H
#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const char Dept[5]=
&#123;
	&quot;CS&quot;, &quot;IS&quot;, &quot;AI&quot;, &quot;ES&quot;, &quot;CE&quot;
&#125;;

const char Class_no[10]=
&#123;
	&quot;_210101&quot;, &quot;_210102&quot;, &quot;_210103&quot;, &quot;_210204&quot;，&quot;_210305&quot;，&quot;_210406&quot;，&quot;_210407&quot;，&quot;_210508&quot;，&quot;_210509&quot;，&quot;_210510&quot;
&#125;;

const char Creq=
&#123;
    &quot;选修&quot;，&quot;必修&quot;
&#125;;


//函数功能：读取文本数据生成插入SQL语句 
void INSERT_(char [], char [], char []);
#endif
</code></pre>
<p>插入函数（school.c）:</p>
<pre><code>#include&quot;school_sql.h&quot;

/*
@function：将文件中的数据导出成SQL插入语句
@parameter：插入表的名字，数据来源文件名src，导出文件名dst
@account：默认导出形式字符CHAR
*/
void INSERT_(char table[], char src[], char dst[])
&#123;
	FILE* fr, * fw;
	char c;
	if ((fr = fopen(src, &quot;r&quot;)) == NULL) &#123;
		printf(&quot;%s File not exist\n&quot;, src);
		exit(0);
	&#125;
	fw = fopen(dst, &quot;w&quot;);
	fprintf(fw, &quot;\nINSERT INTO %s VALUES\n(&#39;&quot;,table);
	while (!feof(fr)) &#123;
		c = fgetc(fr);
		printf(&quot;%c&quot;, c);
		if (c == &#39;\n&#39;)fprintf(fw, &quot;&#39;),\n(&#39;&quot;);
		else if (c == &#39;,&#39;)fprintf(fw, &quot;&#39;,&#39;&quot;);
		else fprintf(fw, &quot;%c&quot;, c);
	&#125;
	//需手动检查结果是否正确 
	fprintf(fw, &quot;&#39;);&quot;);
&#125;

/*
@function：将文件中的数据导出成SQL插入语句（定制）
@parameter：插入表的名字，数据来源文件名src，导出文件名dst
@account：第三个数据形式为INT（插入SQL语句第三个数据无&#39;&#39;）
*/
void INSERT_Course(char table[], char src[], char dst[])
&#123;
	FILE* fr, * fw;
	char c;
	int i = 0, cnt = 0;
	if ((fr = fopen(src, &quot;r&quot;)) == NULL) &#123;
		printf(&quot;%s File not exist\n&quot;, src);
		exit(0);
	&#125;
	fw = fopen(dst, &quot;w&quot;);
	fprintf(fw, &quot;\nINSERT INTO %s VALUES\n(&#39;&quot;, table);
	while (!feof(fr)) &#123;
		c = fgetc(fr);
		printf(&quot;%c&quot;, c);
		if (c == &#39;\n&#39;) &#123;
			cnt = 0;
			fprintf(fw, &quot;),\n(&#39;&quot;);
		&#125;
		else if (c == &#39;,&#39;) &#123;
			cnt++;
			if (cnt == 2)fprintf(fw, &quot;&#39;,&quot;);
			else fprintf(fw, &quot;&#39;,&#39;&quot;);
		&#125;
		else fprintf(fw, &quot;%c&quot;, c);
	&#125;
	//需手动检查结果是否正确 
	fprintf(fw, &quot;);&quot;);
&#125;
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/134984670">https://blog.csdn.net/qq_32971095/article/details/134984670</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">数字滤波器设计——Matlab实现数字信号处理＜1＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-13 13:05:15" itemprop="dateCreated datePublished" datetime="2023-12-13T13:05:15+08:00">2023-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="数字滤波器设计——Matlab实现数字信号处理＜1＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/12/13/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%9C1%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9">一.实验内容</a></p>
<p><a href="about:blank#%E4%BA%8C.%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">二.代码分析</a></p>
<p><a href="about:blank#1.%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E9%83%A8%E5%88%86">1.信号产生部分</a></p>
<p><a href="about:blank#2.%E5%88%A9%E7%94%A8%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%87%AA%E7%94%B1%E7%94%9F%E6%88%90%E6%89%80%E9%9C%80%E7%9A%84x%28t%29">2.利用傅立叶级数展开的方法，自由生成所需的x(t)</a></p>
<p><a href="about:blank#3.%E9%80%9A%E8%BF%87%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E9%87%87%E6%A0%B7%E9%97%B4%E9%9A%94T%EF%BC%88%E5%88%86%E5%88%AB%E9%80%89T%3E%E6%88%96%3C1%2F2fc%EF%BC%89%EF%BC%8C%E4%BB%8Ex%28t%29%E8%8E%B7%E5%BE%97%E7%9B%B8%E5%BA%94%E7%9A%84x%28n%29">3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)</a></p>
<p><a href="about:blank#3.%E5%AF%B9%E8%8E%B7%E5%BE%97%E7%9A%84%E4%B8%8D%E5%90%8Cx%28n%29%E5%88%86%E5%88%AB%E4%BD%9C%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%8C%E5%88%86%E6%9E%90%E5%85%B6%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E7%89%B9%E6%80%A7%EF%BC%88%E7%BB%99%E5%87%BA%E5%B9%85%E9%A2%91%E4%B8%8E%E7%9B%B8%E9%A2%91%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%EF%BC%89">3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）</a></p>
<p><a href="about:blank#4.%E5%88%A9%E7%94%A8%E5%B7%B4%E7%89%B9%E6%B2%83%E6%80%9D%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8">4.利用巴特沃思滤波器设计数字滤波器</a></p>
<p><a href="about:blank#%3C1%3E%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;1&gt;低通滤波器</a></p>
<p><a href="about:blank#%3C2%3E%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;2&gt;高通滤波器</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%98%E5%9B%BE">&lt;3&gt;绘图</a></p>
<p><a href="about:blank#5.%E5%88%A9%E7%94%A8%E7%AA%97%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E6%B3%95%E6%88%96%E9%A2%91%E7%8E%87%E9%87%87%E6%A0%B7%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8">5.利用窗函数设计法或频率采样法设计数字滤波器</a></p>
<p><a href="about:blank#%3C1%3E%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;1&gt;高通滤波器</a></p>
<p><a href="about:blank#%3C2%3E%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8">&lt;2&gt;低通滤波器</a></p>
<p><a href="about:blank#%3C3%3E%E7%BB%98%E5%9B%BE">&lt;3&gt;绘图</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">三.实验结果</a></p>
<hr>
<h2 id="一-实验内容"><a href="#一-实验内容" class="headerlink" title="一.实验内容"></a>一.实验内容</h2><p>1．利用傅立叶级数展开的方法，自由生成所需的x(t)；</p>
<p>2．通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)（作出x(n)图形）；</p>
<p>3．对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）；</p>
<p>4．利用巴特沃思、切比雪夫或椭圆滤波器设计数字滤波器（滤波特性自定），要求通过改变滤波器参数或特性（低通、高通、带通或带阻）设计至少两种数字滤波器，分析所设计滤波器（画出频率特性曲线），并对上述给出的不同x(n)分别进行滤波（画出滤波结果），然后加以讨论；</p>
<p>5．利用窗函数设计法或频率采样法设计数字滤波器（滤波特性自定），要求通过改变滤波器参数或特性（低通、高通、带通或带阻等）设计至少两种数字滤波器，分析所设计滤波器（画出频率特性曲线），并对上述给出的不同x(n)分别进行滤波（画出滤波结果），然后加以讨论。</p>
<h2 id="二-代码分析"><a href="#二-代码分析" class="headerlink" title="二.代码分析"></a>二.代码分析</h2><h5 id="1-信号产生部分"><a href="#1-信号产生部分" class="headerlink" title="1.信号产生部分"></a>1.信号产生部分</h5><pre><code>function [signal]=signal_xt(t_length,T,f,A,u)
%%  函数描述
%   功能：利用傅立叶级数展开的方法，自由生成所需的x(t)（不含直流量）；
%   输入参数：产生序列的长度t_length；采样间隔T；f(t)的基波频率f；傅立叶级数展开的各项幅值和相位。故最高频率为fc=length(A)*f
%   使用举例：signal=signal_xt(3,0.01,1,[1,2,3,4],[0,1,0,1])
%%  t,y初始化并计算
t=0:T:t_length-T;
t_num=t_length/T;
signal=zeros(1,t_num);
max=0;
min=0;
for i=1:t_num  
    for k=1:length(A)
        %   计算函数值
        signal(i)= signal(i) + A(k)*cos(2*pi*k*t(i)*f+u(k));
        %   最大最小值记录
        if max&lt;signal(i)
            max=signal(i);
        end
        if min&gt;signal(i)
            min=signal(i);
        end
    end
end
%%  结果展示
figure;
subplot(2,1,1);
plot(t,signal);
%   x，y轴范围限制及标题
axis([0-0.1,t_length+0.1,min-0.5,max+0.5])
title(&#39;x(t)&#39;); 
xlabel(&#39;t&#39;);
ylabel(&#39;x(t)&#39;); 
grid on

subplot(2,1,2);
stem(t,signal,&quot;.&quot;);
%   x，y轴范围限制及标题
axis([0-0.1,t_length+0.1,min-0.5,max+0.5])
title(&#39;x(t)&#39;); 
xlabel(&#39;t&#39;);
ylabel(&#39;x(t)&#39;); 
grid on
</code></pre>
<p>function [signal]&#x3D;signal_xt(t_length,T,f,A,u)<br>%%  函数描述<br>%   功能：利用傅立叶级数展开的方法，自由生成所需的x(t)（不含直流量）；<br>%   输入参数：产生序列的长度t_length；采样间隔T；f(t)的基波频率f；傅立叶级数展开的各项幅值和相位。故最高频率为fc&#x3D;length(A)*f<br>%   使用举例：signal&#x3D;signal_xt(3,0.01,1,[1,2,3,4],[0,1,0,1])</p>
<h5 id="2-利用傅立叶级数展开的方法，自由生成所需的x-t"><a href="#2-利用傅立叶级数展开的方法，自由生成所需的x-t" class="headerlink" title="2.利用傅立叶级数展开的方法，自由生成所需的x(t)"></a>2.利用傅立叶级数展开的方法，自由生成所需的x(t)</h5><pre><code>%%  利用傅立叶级数展开的方法，自由生成所需的x(t)，即signal_origin；
t_length=1;     %生成长度
f=1;            %基础频率
A=[3,1,1,3];    %各项幅度
u=[-1,0,1,0];   %各项相位
signal_origin=signal_xt(t_length,0.01,f,A,u);
fc=f*length(A);
</code></pre>
<h5 id="3-通过选择不同的采样间隔T（分别选T-或"><a href="#3-通过选择不同的采样间隔T（分别选T-或" class="headerlink" title="3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)"></a>3.通过选择不同的采样间隔T（分别选T&gt;或&lt;1&#x2F;2fc），从x(t)获得相应的x(n)</h5><pre><code>%%  通过选择不同的采样间隔T（分别选T&gt;或&lt;1/2fc），从x(t)获得相应的x(n)；
T=[1/(2*fc+1),1/fc,1/(4*fc)];
N=zeros(1,length(T));
for i=1:length(T)
    N(i)=1/T(i);
end
x1=signal_xt(t_length,T(1),f,A,u);
x2=signal_xt(t_length,T(2),f,A,u);
x3=signal_xt(t_length,T(3),f,A,u);
</code></pre>
<p>选取频率分别为2fc+1、fc、4fc</p>
<h5 id="3-对获得的不同x-n-分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）"><a href="#3-对获得的不同x-n-分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）" class="headerlink" title="3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）"></a>3.对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）</h5><pre><code>%%  对获得的不同x(n)分别作傅立叶变换，分析其频率响应特性（给出幅频与相频特性曲线）；
X1=fft(x1,N(1));
X2=fft(x2,N(2));
X3=fft(x3,N(3));

%   绘制
figure;
%   幅值绘制
subplot(2,3,1);
stem(0:N(1)-1,abs(X1),&#39;.&#39;);
title(&quot;X1&quot;);
grid on

subplot(2,3,2);
stem(0:N(2)-1,abs(X2),&#39;.&#39;);
title(&quot;X2&quot;);
grid on

subplot(2,3,3);
stem(0:N(3)-1,abs(X3),&#39;.&#39;);
title(&quot;X3&quot;);
grid on

%   相位绘制
subplot(2,3,4);
stem(0:N(1)-1,angle(X1),&#39;.&#39;);
title(&quot;X1&quot;);
grid on

subplot(2,3,5);
stem(0:N(2)-1,angle(X2),&#39;.&#39;);
title(&quot;X2&quot;);
grid on

subplot(2,3,6);
stem(0:N(3)-1,angle(X3),&#39;.&#39;);
title(&quot;X3&quot;);
grid on
</code></pre>
<p>使用 fft 函数进行 DFT，注意结果频率响应是复数，使用abs函数得其幅值，angle函数得其相位。</p>
<h5 id="4-利用巴特沃思滤波器设计数字滤波器"><a href="#4-利用巴特沃思滤波器设计数字滤波器" class="headerlink" title="4.利用巴特沃思滤波器设计数字滤波器"></a>4.利用巴特沃思滤波器设计数字滤波器</h5><h6 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="&lt;1&gt;低通滤波器"></a>&lt;1&gt;低通滤波器</h6><pre><code>%   设置低通滤波器参数
wp=0.35;    %通带边界频率
ws=0.7;     %阻带截止频率
Rp=3;
As=15;
%   计算滤波器阶数N和3dB截止频率wc
[Nc,wc]=buttord(wp,ws,Rp,As,&#39;s&#39;);
%   计算滤波器系统函数分子分母多项式系数
[Bz,Az]=butter(Nc,wc,&#39;low&#39;);
wk=64;
Hk=freqz(Bz,Az,wk);
</code></pre>
<p>参数设置及函数使用参考课本《数字信号处理》</p>
<h6 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="&lt;2&gt;高通滤波器"></a>&lt;2&gt;高通滤波器</h6><pre><code>%   设置高通滤波器参数
wp=0.75;
ws=0.5;
rp=3;
rs=15;
[Nc,wc]=buttord(wp,ws,rp,rs,&#39;s&#39;);
[Bz,Az]=butter(Nc,wc,&#39;high&#39;);
wk=64; 
Hk=freqz(Bz,Az,wk);
</code></pre>
<h6 id="绘图"><a href="#绘图" class="headerlink" title="&lt;3&gt;绘图"></a>&lt;3&gt;绘图</h6><pre><code>%   绘图
figure;
subplot(2,3,1);
stem(0:1/63:1,abs(Hk),&#39;.&#39;);
xlabel(&#39;频率&#39;);
ylabel(&#39;滤波器幅度/dB&#39;);
grid on

%   滤波后结果
m1=filter(Bz,Az,x1);
m2=filter(Bz,Az,x2);
m3=filter(Bz,Az,x3);
Y1=fft(m1,N(1));
Y2=fft(m2,N(2));
Y3=fft(m3,N(3));
%   绘图
subplot(2,3,4);
stem(0:N(1)-1,abs(Y1),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
subplot(2,3,5);
stem(0:N(2)-1,abs(Y2),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
subplot(2,3,6);
stem(0:N(3)-1,abs(Y3),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
</code></pre>
<h5 id="5-利用窗函数设计法或频率采样法设计数字滤波器"><a href="#5-利用窗函数设计法或频率采样法设计数字滤波器" class="headerlink" title="5.利用窗函数设计法或频率采样法设计数字滤波器"></a>5.利用窗函数设计法或频率采样法设计数字滤波器</h5><h6 id="高通滤波器-1"><a href="#高通滤波器-1" class="headerlink" title="&lt;1&gt;高通滤波器"></a>&lt;1&gt;高通滤波器</h6><pre><code>%   设置高通滤波器参数
wp=pi/2;
ws=pi/4;
Bt=wp-ws;   %过渡带宽度
N0=ceil(6.2*pi/Bt); %汉宁窗计算所需h(n)长度N0
Nn=N0+mod(N0+1,2);  %确保h(n)长度为奇数
wc=(wp+ws)/2/pi;    %理想高通滤波器通带截止频率
hn=fir1(Nn-1,wc,&#39;HIGH&#39;,hanning(Nn));
%   高通滤波器频率响应
Hk=fft(hn,length(hn));
</code></pre>
<h6 id="低通滤波器-1"><a href="#低通滤波器-1" class="headerlink" title="&lt;2&gt;低通滤波器"></a>&lt;2&gt;低通滤波器</h6><pre><code>%   设置低通滤波器参数
wp=pi/4;
ws=pi/2;
Bt=abs(wp-ws);   %过渡带宽度
N0=ceil(6.2*pi/Bt); %汉宁窗计算所需h(n)长度N0
Nn=N0+mod(N0+1,2);  %确保h(n)长度为奇数
wc=(wp+ws)/2/pi;    %理想高通滤波器通带截止频率
hn=fir1(Nn-1,wc,&#39;LOW&#39;,hanning(Nn));
%   低通滤波器频率响应
Hk=fft(hn,length(hn));
</code></pre>
<h6 id="绘图-1"><a href="#绘图-1" class="headerlink" title="&lt;3&gt;绘图"></a>&lt;3&gt;绘图</h6><pre><code>%   滤波结果
y1=conv(hn,x1);
y2=conv(hn,x2);
y3=conv(hn,x3);
n1=length(y1);
n2=length(y2);
n3=length(y3);
Y1=fft(y1,n1);
Y2=fft(y2,n2);
Y3=fft(y3,n3);
%   绘图
figure;
subplot(2,3,1);
stem(0:Nn-1,hn,&#39;.&#39;);
xlabel(&#39;n&#39;);
ylabel(&#39;h(n)&#39;);
grid on
subplot(2,3,2);
stem(0:Nn-1,abs(Hk),&#39;.&#39;);
xlabel(&#39;k&#39;);
ylabel(&#39;H(k)&#39;);
grid on
subplot(2,3,4);
stem(0:n1-1,abs(Y1),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
subplot(2,3,5);
stem(0:n2-1,abs(Y2),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
subplot(2,3,6);
stem(0:n3-1,abs(Y3),&#39;.&#39;);
title(&#39;滤波后Y频率特性&#39;);
grid on
</code></pre>
<h2 id="三-实验结果"><a href="#三-实验结果" class="headerlink" title="三.实验结果"></a>三.实验结果</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e404226ec441727c6370000e1fe978b0.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d098f58a0b1f335d62fc631ac9bf1b8.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/aaf3e4f6a8465e5e2a158ebfd1c1b9cf.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3fc4cd9d29dc56cd60409b4c12728d90.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c551894f0d504e9663311db49f1e796b.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d1539ef72b30697b76fb425b6b10928a.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/134966834">https://blog.csdn.net/qq_32971095/article/details/134966834</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">2023年FPGA创新大赛记录</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-15 16:45:48" itemprop="dateCreated datePublished" datetime="2023-11-15T16:45:48+08:00">2023-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/" class="post-meta-item leancloud_visitors" data-flag-title="2023年FPGA创新大赛记录" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/15/2023%E5%B9%B4FPGA%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">一.基本信息</a></p>
<p><a href="about:blank#%E4%BA%8C.%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95">二.设计记录</a></p>
<p><a href="about:blank#1.%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3">1.任务分解</a></p>
<p><a href="about:blank#2.%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">2.模块设计</a></p>
<p><a href="about:blank#%E4%B8%89.%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5">三.设计实践</a></p>
<p><a href="about:blank#1.adc_stm32%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E6%A8%A1%E5%9D%97">1.adc_stm32<br>信号采集模块</a></p>
<p><a href="about:blank#2.proc_fpga%20FPGA%E4%B8%BB%E4%BD%93%E6%A8%A1%E5%9D%97">2.proc_fpga<br>FPGA主体模块</a></p>
<p><a href="about:blank#%3C1%3Euart%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94uart_rx">&lt;1&gt;uart协议数据接收模块——uart_rx</a></p>
<p><a href="about:blank#%3C2%3E%E4%B8%B2%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94decoder">&lt;2&gt;串行数据解码模块——decoder</a></p>
<p><a href="about:blank#%3C3%3E%20%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">&lt;3&gt; 顶层模块</a></p>
<p><a href="about:blank#3.signal_proc%20%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97">3.signal_proc<br>信号处理模块</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A">四.注意事项</a></p>
<hr>
<h2 id="一-基本信息"><a href="#一-基本信息" class="headerlink" title="一.基本信息"></a>一.基本信息</h2><p>参赛厂商：AMD</p>
<p>参赛平台：基于AMD的FPGA&#x2F;Zynq&#x2F;Versal器件（无资源限制）</p>
<p>开发方向：基于AMD板卡的综合类赛道</p>
<p>开发平台：正点原子 DFZU2EG MPSoc 开发板</p>
<p>平台资源：</p>
<table>
<thead>
<tr>
<th>Application Processing Unit</th>
<th>Quad-core Arm® Cortex®-A53 MPCore™ up to 1.5GHz</th>
</tr>
</thead>
<tbody><tr>
<td>Real-Time Processing Unit</td>
<td>Dual-core Arm Cortex-R5F MPCore™ up to 600MHz</td>
</tr>
<tr>
<td>Graphics Processing Unit</td>
<td>Arm Mali™-400 MP2 up to 667MHz</td>
</tr>
<tr>
<td>Dynamic Memory Interface</td>
<td>DDR4, LPDDR4, DDR3, DDR3L, LPDDR3</td>
</tr>
<tr>
<td>High-Speed Peripherals</td>
<td>PCIe® Gen2, USB3.0, SATA 3.1, DisplayPort, Gigabit</td>
</tr>
<tr>
<td>Ethernet</td>
<td></td>
</tr>
</tbody></table>
<p>103k System Logic Cells，6.5MB Total RAM，240 DSP Slices，252 Maximum I&#x2F;O Pins</p>
<p>作品名称：基于FPGA的图神经网络传感器系统</p>
<p>作品简介：</p>
<pre><code>    对传感器系统进行建模，生成图模型并利用图神经网络对传感器系统运行状态进行评估。作品首先采集大量传感器数据，并根据事先对传感器群建模成图的模型，将传感器输出信号进行分析，主要分析图网络频域特性，进行初步判断然后用深度学习训练数据集，分析系统的状态。应用场景比如复杂环境因素影响下的农作物种植情况分析，工厂机械臂分析运行出错过热，太空站或基地的外壳完整性检测等。   
</code></pre>
<h2 id="二-设计记录"><a href="#二-设计记录" class="headerlink" title="二.设计记录"></a>二.设计记录</h2><h3 id="1-任务分解"><a href="#1-任务分解" class="headerlink" title="1.任务分解"></a>1.任务分解</h3><pre><code>    信号采集接口（多路信号采集、多种信号类型接口：通信协议接口、电压接口），数据打包模块，上层数据处理，结果显示模块。
</code></pre>
<h3 id="2-模块设计"><a href="#2-模块设计" class="headerlink" title="2.模块设计"></a>2.模块设计</h3><p>&lt;1&gt;ADC模块</p>
<p>输入：多路电压采集</p>
<p>输出：采用通信协议进行串行&#x2F;时分复用并行输出</p>
<p>实现：利用stm32的ADC通道采集多路传感器信息，利用usart发送数据。</p>
<p>&lt;2&gt;数据接收模块</p>
<p>输入：下位机（stm32）usart串行输入数据</p>
<p>输出：每字节数据及数据有效位</p>
<p>实现：Verillog编写usart解码模块</p>
<p>&lt;3&gt;数据解包模块</p>
<p>输入：数据接收模块输出的每字节数据及数据有效位</p>
<p>输出：10个传感器并行的120位数据</p>
<p>实现：解析数据流识别数据包头（“FF”）和有效数据</p>
<p>&lt;4&gt;数据处理模块</p>
<p>输入：10个传感器并行的120位数据</p>
<p>输出：10bit的10个传感器异常与否判断</p>
<p>实现：利用HLS综合C语言算法实现输入到输出的转换函数（IP 核）</p>
<h2 id="三-设计实践"><a href="#三-设计实践" class="headerlink" title="三.设计实践"></a>三.设计实践</h2><h3 id="1-adc-stm32-信号采集模块"><a href="#1-adc-stm32-信号采集模块" class="headerlink" title="1.adc_stm32 信号采集模块"></a>1.adc_stm32 信号采集模块</h3><pre><code>    利用 stm32 最小系统板上 ADC1 的 10 个通道资源，利用 DMA1 数据转运，通过1路 usart 串行发送出去。
</code></pre>
<p> stm32关键代码：</p>
<p>（1）初始化stm32的多个ADC外设并启用DMA转运</p>
<pre><code>void AD_Init(void)
&#123;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
	
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);				//72M/6=12,ADC最大时间不能超过14M
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	//设置模拟输入模式
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
//	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
//	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);
	
	//ADC1,ADC通道x,规则采样顺序值为y,采样时间为55.5周期
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 5, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 6, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 7, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 8, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 9, ADC_SampleTime_55Cycles5);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 10, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 11, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 12, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 13, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 14, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 15, ADC_SampleTime_55Cycles5);
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 16, ADC_SampleTime_55Cycles5);
		
	ADC_InitTypeDef ADC_InitStructure;
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;					//ADC工作在独立模式
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;				//ADC数据右对齐
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//外部触发转换关闭
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;					//模数转换工作在连续转换模式
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;						//是否使用扫描模式
	ADC_InitStructure.ADC_NbrOfChannel = CHANNEL_NUM;					//顺序进行规则转换的ADC通道的数目
	ADC_Init(ADC1, &amp;ADC_InitStructure);
	
	//DMA初始化
	DMA_InitTypeDef DMA_InitStructure;
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&amp;ADC1-&gt;DR;				//DMA外设ADC基地址
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//数据宽度为16位
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;			//外设地址寄存器不变
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value;					//DMA外设ADC基地址
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;			//数据宽度为16位
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;						//内存地址寄存器递增
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;							//内存作为数据传输的目的地
	DMA_InitStructure.DMA_BufferSize = CHANNEL_NUM;								//DMA通道的DMA缓存的大小
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;								//工作在循环缓存模式
	//M2M是否使用软件触发
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;								//DMA通道x没有设置为内存到内存传输
	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;						//DMA通道 x拥有中优先级
	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);
	
	//外设使能
	DMA_Cmd(DMA1_Channel1, ENABLE);
	ADC_DMACmd(ADC1, ENABLE);
	ADC_Cmd(ADC1, ENABLE);
	
	//复位校准寄存器
	ADC_ResetCalibration(ADC1);
	while (ADC_GetResetCalibrationStatus(ADC1) == SET);
	ADC_StartCalibration(ADC1);
	while (ADC_GetCalibrationStatus(ADC1) == SET);
	
	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
&#125;
</code></pre>
<p>（2）初始化stm32的多个ADC外设并启用DMA转运</p>
<pre><code>void Get_Voltage()
&#123;
	int i=0;

	//数据包起始标志
	Usart_TransmitByte(0xFF);
	Usart_TransmitByte(0xFF); 
	for(i=0;i&lt;CHANNEL_NUM;i++)
	&#123;
		Usart_TransmitByte(AD_Value[i]&gt;&gt;8);
		Usart_TransmitByte(AD_Value[i]&amp;0x00FF);
	&#125;
	
&#125;
</code></pre>
<h3 id="2-proc-fpga-FPGA主体模块"><a href="#2-proc-fpga-FPGA主体模块" class="headerlink" title="2.proc_fpga FPGA主体模块"></a>2.proc_fpga FPGA主体模块</h3><p>利用 xilinx zynq 接收 stm32 发送的数据并进行处理。</p>
<p>系统框图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f595c2dc3bd9102257bbf9596af891d6.png"></p>
<p>实际本体是uart_rx——decoder——signal_proc三部分，rs232与电脑通信测试时使用。</p>
<h4 id="uart协议数据接收模块——uart-rx"><a href="#uart协议数据接收模块——uart-rx" class="headerlink" title="&lt;1&gt;uart协议数据接收模块——uart_rx"></a>&lt;1&gt;uart协议数据接收模块——uart_rx</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98f598971dff58761f4758e9f27128c6.png"></p>
<p> 这里uart_rx、uart_tx、rs232模块代码沿用之前学习代码。</p>
<h4 id="串行数据解码模块——decoder"><a href="#串行数据解码模块——decoder" class="headerlink" title="&lt;2&gt;串行数据解码模块——decoder"></a>&lt;2&gt;串行数据解码模块——decoder</h4><p> 代码解析：</p>
<pre><code>`timescale 1ns / 1ps

module decoder
#(
    parameter   CHANNEL_NUM =   4&#39;d10    //传感器通道数
)
(
    input   wire            sys_rst_n       ,
    input   wire    [7:0]   data_serial     ,
    input   wire            in_flag         ,
    output  reg     [119:0]  data_parallel ,
    output  reg             out_flag    
);

reg [3:0]   channel_cnt ;
reg         byte_cnt    ;
reg         r_en        ;

//r_en串行数据解码标志
always@(posedge in_flag or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        r_en &lt;= 1&#39;b0;
    else if(data_serial == 8&#39;hFF &amp;&amp; byte_cnt == 1&#39;b1)
        r_en &lt;= 1&#39;b1;
    else if(channel_cnt &gt; CHANNEL_NUM)
        r_en &lt;= 1&#39;b0;
    else
        r_en &lt;= r_en;
        
//byte_cnt数据高低字节计数
always@(posedge in_flag or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        byte_cnt &lt;= 1&#39;b0;
    else if(r_en == 1&#39;b1)
        byte_cnt &lt;= ~byte_cnt;
    else if(r_en == 1&#39;b0&amp;&amp;data_serial == 8&#39;hFF)
        byte_cnt &lt;= 1&#39;b1;
    else
        byte_cnt &lt;= 1&#39;b0;

//channel_cnt处理通道数计数
always@(negedge byte_cnt or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        channel_cnt &lt;= 1&#39;b0;
    else if(channel_cnt &gt; CHANNEL_NUM)
        channel_cnt &lt;= 1&#39;b0;
    else if(r_en == 1&#39;b1&amp;&amp;channel_cnt &lt;= CHANNEL_NUM)
        channel_cnt &lt;= channel_cnt+1;
    else
        channel_cnt &lt;= 1&#39;b0;
        
//串转并输出
always@(negedge in_flag or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        data_parallel &lt;= 120&#39;b0;
    else if(r_en == 1&#39;b1)
        if(byte_cnt == 1&#39;b0)
            case(channel_cnt)
                4&#39;b0001:data_parallel[7 :0]         &lt;=  data_serial[7:0];
                4&#39;b0010:data_parallel[19:12]        &lt;=  data_serial[7:0];
                4&#39;b0011:data_parallel[31:24]        &lt;=  data_serial[7:0];
                4&#39;b0100:data_parallel[43:36]        &lt;=  data_serial[7:0];
                4&#39;b0101:data_parallel[55:48]        &lt;=  data_serial[7:0];
                4&#39;b0110:data_parallel[67:60]        &lt;=  data_serial[7:0];
                4&#39;b0111:data_parallel[79:72]        &lt;=  data_serial[7:0];
                4&#39;b1000:data_parallel[91:84]        &lt;=  data_serial[7:0];
                4&#39;b1001:data_parallel[103:96]       &lt;=  data_serial[7:0];
                4&#39;b1010:data_parallel[115:108]      &lt;=  data_serial[7:0];
                default:data_parallel &lt;= data_parallel;
            endcase
        else
            case(channel_cnt)
                4&#39;b0001:data_parallel[11:7  +1]  &lt;= data_serial[3:0];
                4&#39;b0010:data_parallel[23:19 +1]  &lt;= data_serial[3:0];
                4&#39;b0011:data_parallel[35:31 +1]  &lt;= data_serial[3:0];
                4&#39;b0100:data_parallel[47:43 +1]  &lt;= data_serial[3:0];
                4&#39;b0101:data_parallel[58:55 +1]  &lt;= data_serial[3:0];
                4&#39;b0110:data_parallel[71:67 +1]  &lt;= data_serial[3:0];
                4&#39;b0111:data_parallel[83:79 +1]  &lt;= data_serial[3:0];
                4&#39;b1000:data_parallel[95:91 +1]  &lt;= data_serial[3:0];
                4&#39;b1001:data_parallel[107:103+1]  &lt;= data_serial[3:0];
                4&#39;b1010:data_parallel[119:115+1]  &lt;= data_serial[3:0];
                default:data_parallel &lt;= data_parallel;
            endcase
    else
        data_parallel &lt;= data_parallel;

//out_flag转换成功标志位
always@(posedge channel_cnt or negedge sys_rst_n)
    if(sys_rst_n == 1&#39;b0)
        out_flag &lt;= 1&#39;b0;
    else if(channel_cnt ==  CHANNEL_NUM)
        out_flag &lt;= 1&#39;b1;
    else
        out_flag &lt;= 1&#39;b0;

endmodule
</code></pre>
<p> 波形图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/46d0090f8addb62c8be3ca925881e31a.png"></p>
<pre><code>     decode 模块检测到两个连续的 FF 后 r_en 使能开始记录数据，数据的高低字节用 byte_cnt 加以区分，每记录两个字节使 channel_cnt 加一，超出 CHANNEL_NUM 结束记录， data_parallel 输出120为并行数据。
</code></pre>
<p>仿真代码：</p>
<pre><code>`timescale 1us / 1ns
module  tb_decoder();
 
//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire     [119:0] data_parallel  ;
wire             out_flag       ;
// wire     [3:0]   channel_cnt    ;
// wire             byte_cnt       ;
// wire             r_en           ;

reg     [7:0]   data_serial;
reg             in_flag;
reg             sys_rst_n;
            
//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化系统时钟、全局复位和输入信号
initial begin
    in_flag = 1&#39;b0;
    sys_rst_n = 1&#39;b0;
    #100
    sys_rst_n = 1&#39;b1;
end
 
//调用任务rx_byte
initial begin
    #200
    rx_data();
end
 
//创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7
task    rx_data();  //因为不需要外部传递参数，所以括号中没有输入
    integer	j;
    for(j=0; j&lt;255; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化255
        rx_serial();
endtask
 
//创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来
task    rx_serial();
    integer i;
    for(i=0; i&lt;22; i=i+1)   begin
        case(i)
            0: data_serial &lt;= 8&#39;hFF ;
            1: data_serial &lt;= 8&#39;hFF ;
            2: data_serial &lt;= 8&#39;d1  ;
            3: data_serial &lt;= 8&#39;d0  ;
            4: data_serial &lt;= 8&#39;d2  ;
            5: data_serial &lt;= 8&#39;d0  ;
            6: data_serial &lt;= 8&#39;d3  ;
            7: data_serial &lt;= 8&#39;d0  ;
            8: data_serial &lt;= 8&#39;d4  ;
            9: data_serial &lt;= 8&#39;d0  ;
            10: data_serial &lt;= 8&#39;d5  ;
            11: data_serial &lt;= 8&#39;d0  ;
            12: data_serial &lt;= 8&#39;d6  ;
            13: data_serial &lt;= 8&#39;d0  ;
            14: data_serial &lt;= 8&#39;d7  ;
            15: data_serial &lt;= 8&#39;d0  ;
            16: data_serial &lt;= 8&#39;d8  ;
            17: data_serial &lt;= 8&#39;b0  ;
            18: data_serial &lt;= 8&#39;d9  ;
            19: data_serial &lt;= 8&#39;d0  ;
            20: data_serial &lt;= 8&#39;d10 ;
            21: data_serial &lt;= 8&#39;d0  ;
        endcase
        in_flag &lt;= 1&#39;b1;
        #0.001;
        in_flag &lt;= 1&#39;b0;
        #10;
    end
endtask
 
//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------ rs232_inst ------------------------
decoder 
#(
    .CHANNEL_NUM    (4&#39;d10)    //传感器通道数
)
decoder_inst
(
    .sys_rst_n      (sys_rst_n    ),
    .data_serial    (data_serial  ),
    .in_flag        (in_flag      ),
    .data_parallel  (data_parallel),
    .out_flag       (out_flag     )
    
    // .channel_cnt    (channel_cnt  ),
    // .byte_cnt       (byte_cnt     ),
    // .r_en           (r_en         )
);
 
endmodule
 
 
</code></pre>
<h4 id="顶层模块"><a href="#顶层模块" class="headerlink" title="&lt;3&gt; 顶层模块"></a>&lt;3&gt; 顶层模块</h4><p>代码解析：</p>
<pre><code>`timescale 1ns / 1ps

module proc_fpga
(
    input   wire      clk_in1_p     ,
    input   wire      clk_in1_n     ,
    input   wire      sys_rst_n     ,
    
    //发送数据线
    output  wire     pc_tx           ,      //数据发送线
    // input   wire     [7:0]   tx_data ,      //发送的一字节数据
    // input   wire             tx_flag ,      //发送数据就位标志
    
    //接收数据线
    input   wire     pc_rx           ,     //数据接收线
    // output  wire     [7:0]   rx_data ,      //接受的一字节数据
    // output  wire             rx_flag ,      //一字节数据接收完成标志

    input   wire     s1_rx           ,      
    input   wire     s2_rx           ,  
    
    output  wire    [15:0]      result             
    
);

wire clk_100M;
wire locked;
      
wire     [7:0]   sensor1_data ;
wire             sensor1_flag ;
wire     s2_rx                ;    
wire     [7:0]   sensor2_data ;
wire             sensor2_flag ;
//wire     s3_rx                ,    
//wire     [7:0]   sensor3_data ,
//wire             sensor3_flag 

wire    [119:0] data1_parallel   ;
wire    out1_flag        ;
wire    [119:0] data2_parallel   ;
wire    out2_flag        ;

//回环测试线
wire     [7:0]   pc_data ;
wire             pc_flag ;
wire     [7:0]   result_low;

wire [11:0]  b1  ;   
wire [11:0]  b2  ;
wire [11:0]  b3  ;
wire [11:0]  b4  ;
wire [11:0]  b5  ;
wire [11:0]  b6  ;
wire [11:0]  b7  ;
wire [11:0]  b8  ;
wire [11:0]  b9  ;
wire [11:0]  b10 ;
wire [11:0]  b11 ;
wire [11:0]  b12 ;
wire [11:0]  b13 ;
wire [11:0]  b14 ;
wire [11:0]  b15 ;
wire [11:0]  b16 ;

assign data1_parallel[11:0]     = b1       ;
assign data1_parallel[23:12]    = b2       ;
assign data1_parallel[35:24]    = b3       ;
assign data1_parallel[47:36]    = b4       ;
assign data1_parallel[59:48]    = b5       ;
assign data1_parallel[71:60]    = b6       ;
assign data1_parallel[83:72]    = b7       ;
assign data1_parallel[95:84]    = b8       ;
assign data1_parallel[107:96]   = b9       ;
assign data1_parallel[119:108]  = b10      ;
assign data2_parallel[11:0]     = b11      ;
assign data2_parallel[23:12]    = b12      ;
assign data2_parallel[35:24]    = b13      ;
assign data2_parallel[47:36]    = b14      ;
assign data2_parallel[59:48]    = b15      ;
assign data2_parallel[71:60]    = b16      ;

//pll时钟产生模块
clk_pll clk_pll_inst
   (
    // Clock out ports
    .clk_100M(clk_100M),     // output clk_100M
    // Status and control signals
    .reset(~sys_rst_n), // input reset
    .locked(locked),       // output locked
   // Clock in ports
    .clk_in1_p(clk_in1_p),    // input clk_in1_p
    .clk_in1_n(clk_in1_n)    // input clk_in1_n
);

//usart通信模块
rs232 rs232_pc_inst
(
    .sys_clk(clk_100M),
    .sys_rst_n(sys_rst_n),
    .rx_data    (pc_data    ),  //output    [7:0]   rx_data
    .rx_flag    (pc_flag    ),  //output            rx_flag
    .tx_data    (pc_data    ),
    .tx_flag    (pc_flag    ),
    .rx(pc_rx),
    .tx(pc_tx)
);

//传感器数据接收
uart_rx uart_rx_sensor1_inst
(
    .sys_clk(clk_100M),
    .sys_rst_n(sys_rst_n),
   .po_data    (sensor1_data    ),  //output    [7:0]   rx_data
   .po_flag    (sensor1_flag    ),  //output            rx_flag
    // .po_data    (pc_data    ),  //回环测试
    // .po_flag    (pc_flag    ),  //回环测试    
    .rx(s1_rx)
);

uart_rx uart_rx_sensor2_inst
(
    .sys_clk(clk_100M),
    .sys_rst_n(sys_rst_n),
    .po_data    (sensor2_data    ),  //output    [7:0]   rx_data
    .po_flag    (sensor2_flag    ),  //output            rx_flag`
    .rx(s2_rx)
);

// uart_rx uart_rx_sensor3_inst
// (
    // .sys_clk(clk_100M),
    // .sys_rst_n(sys_rst_n),
    // .po_data    (sensor3_data    ),  //output    [7:0]   rx_data
    // .po_flag    (sensor3_flag    ),  //output            rx_flag
    // .rx(s3_rx)
// );

decoder decoder1_inst
(
    .sys_rst_n     (sys_rst_n)      ,
    .data_serial   (sensor1_data)   ,
    .in_flag       (sensor1_flag)   ,
    .data_parallel (data1_parallel) ,
    .out_flag      (out1_flag)
);

decoder decoder2_inst
(
    .sys_rst_n     (sys_rst_n)      ,
    .data_serial   (sensor2_data)   ,
    .in_flag       (sensor2_flag)   ,
    .data_parallel (data2_parallel) ,
    .out_flag      (out2_flag)
);

signal_proc_inst signal_proc_inst_inst
(
    .ap_clk     (clk_100M)                  ,
    .ap_rst     (sys_rst_n)                 ,
    .a1         (b1 )    ,
    .a2         (b2 )    ,
    .a3         (b3 )    ,
    .a4         (b4 )    ,
    .a5         (b5 )    ,
    .a6         (b6 )    ,
    .a7         (b7 )    ,
    .a8         (b8 )    ,
    .a9         (b9 )    ,
    .a10        (b10)    ,
    .a11        (b11)    ,
    .a12        (b12)    ,
    .a13        (b13)    ,
    .a14        (b14)    ,
    .a15        (b15)    ,
    .a16        (b16)    ,
    .c1         (result[0])                 ,
    .c2         (result[1])                 ,
    .c3         (result[2])                 ,
    .c4         (result[3])                 ,
    .c5         (result[4])                 ,
    .c6         (result[5])                 ,
    .c7         (result[6])                 ,
    .c8         (result[7])                 ,
    .c9         (result[8])                 ,
    .c10        (result[9])                 ,
    .c11        (result[10])                ,
    .c12        (result[11])                ,
    .c13        (result[12])                ,
    .c14        (result[13])                ,
    .c15        (result[14])                ,
    .c16        (result[15])    
);

endmodule
</code></pre>
<p>仿真代码：</p>
<pre><code>`timescale 1ns / 1ps
module  tb_proc_fpga();
 
//********************************************************************//
//****************** Parameter and Internal Signal *******************//
//********************************************************************//
//wire  define
wire    tx          ;
reg     rx          ;
wire     [7:0]   rx_data;
wire             rx_flag;//reg   define
wire     [7:0]   tx_data;
wire             tx_flag;

reg     clk_in1_p;
reg     clk_in1_n;
reg     sys_rst_n;

always #5 clk_in1_p = ~clk_in1_p;
always #5 clk_in1_n = ~clk_in1_n;

assign tx_data=rx_data;
assign tx_flag=rx_flag;

 
 
parameter   UART_BPS    =   20&#39;d115200        ,   //比特率
            CLK_FREQ    =   28&#39;d100_000_000  ;   //时钟频率
            
//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//
//初始化系统时钟、全局复位和输入信号
initial begin
    clk_in1_p = 1&#39;b0;
    clk_in1_n = 1&#39;b1;
    rx        &lt;= 1&#39;b1;
    sys_rst_n = 1&#39;b0;
    #100
    sys_rst_n = 1&#39;b1;
end
 
//调用任务rx_byte
initial begin
    #200
    rx_byte();
end
 
//创建任务rx_byte，本次任务调用rx_bit任务，发送8次数据，分别为0~7
task    rx_byte();  //因为不需要外部传递参数，所以括号中没有输入
    integer	j;
    for(j=0; j&lt;255; j=j+1)    //调用8次rx_bit任务，每次发送的值从0变化255
        rx_bit(j);
endtask
 
//创建任务rx_bit，每次发送的数据有10位，data的值分别为0到7由j的值传递进来
task    rx_bit(
    input   [7:0]   data
);
    integer i;
    for(i=0; i&lt;10; i=i+1)   begin
        case(i)
            0: rx &lt;= 1&#39;b0;
            1: rx &lt;= data[0];
            2: rx &lt;= data[1];
            3: rx &lt;= data[2];
            4: rx &lt;= data[3];
            5: rx &lt;= data[4];
            6: rx &lt;= data[5];
            7: rx &lt;= data[6];
            8: rx &lt;= data[7];
            9: rx &lt;= 1&#39;b1;
        endcase
        #(1000000000/UART_BPS); //每发送1位数据延时
    end
endtask
 
//********************************************************************//
//*************************** Instantiation **************************//
//********************************************************************//
//------------------------ rs232_inst ------------------------
proc_fpga   proc_fpga_inst
(
    .clk_in1_p        (clk_in1_p        ),
    .clk_in1_n        (clk_in1_n        ),
    .sys_rst_n        (sys_rst_n        ),
    // .rx_data          (rx_data),  //output    [7:0]   rx_data
    // .rx_flag          (rx_flag),  //output            rx_flag
    // .tx_data          (tx_data),
    // .tx_flag          (tx_flag),
    .s1_rx               (rx               ),
    .pc_tx               (tx               )
);
 
endmodule
 
 
</code></pre>
<h3 id="3-signal-proc-信号处理模块"><a href="#3-signal-proc-信号处理模块" class="headerlink" title="3.signal_proc 信号处理模块"></a>3.signal_proc 信号处理模块</h3><p>HLS工程代码解析：</p>
<pre><code>#include &lt;ap_cint.h&gt;
#include &lt;math.h&gt;
void signal_proc(uint12 a1,uint12 a2,uint12 a3,uint12 a4,uint12 a5,uint12 a6,uint12 a7,uint12 a8,uint12 a9,uint12 a10,uint12 a11,uint12 a12,uint12 a13,uint12 a14,uint12 a15,uint12 a16,uint1 *c1,uint1 *c2,uint1 *c3,uint1 *c4,uint1 *c5,uint1 *c6,uint1 *c7,uint1 *c8,uint1 *c9,uint1 *c10,uint1 *c11,uint1 *c12,uint1 *c13,uint1 *c14,uint1 *c15,uint1 *c16)
&#123;
#pragma HLS INTERFACE ap_none port=a1
#pragma HLS INTERFACE ap_none port=a2
#pragma HLS INTERFACE ap_none port=a3
#pragma HLS INTERFACE ap_none port=a4
#pragma HLS INTERFACE ap_none port=a5
#pragma HLS INTERFACE ap_none port=a6
#pragma HLS INTERFACE ap_none port=a7
#pragma HLS INTERFACE ap_none port=a8
#pragma HLS INTERFACE ap_none port=a9
#pragma HLS INTERFACE ap_none port=a10
#pragma HLS INTERFACE ap_none port=a11
#pragma HLS INTERFACE ap_none port=a12
#pragma HLS INTERFACE ap_none port=a13
#pragma HLS INTERFACE ap_none port=a14
#pragma HLS INTERFACE ap_none port=a15
#pragma HLS INTERFACE ap_none port=a16
#pragma HLS INTERFACE ap_none port=c1
#pragma HLS INTERFACE ap_none port=c2
#pragma HLS INTERFACE ap_none port=c3
#pragma HLS INTERFACE ap_none port=c4
#pragma HLS INTERFACE ap_none port=c5
#pragma HLS INTERFACE ap_none port=c6
#pragma HLS INTERFACE ap_none port=c7
#pragma HLS INTERFACE ap_none port=c8
#pragma HLS INTERFACE ap_none port=c9
#pragma HLS INTERFACE ap_none port=c10
#pragma HLS INTERFACE ap_none port=c11
#pragma HLS INTERFACE ap_none port=c12
#pragma HLS INTERFACE ap_none port=c13
#pragma HLS INTERFACE ap_none port=c14
#pragma HLS INTERFACE ap_none port=c15
#pragma HLS INTERFACE ap_none port=c16
#pragma HLS INTERFACE ap_ctrl_none port=return
	uint5 i;
	uint12 b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16;
	uint2 time=0;
	uint16 xzuo[16]=&#123;1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4&#125;;
	uint16 yzuo[16]=&#123;1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4&#125;;
	double A[256];
	for(i=0;i&lt;=15;i++)
	    for(int j=0;j&lt;=15;j++)
	    &#123;
	    	A[i*16+j]=sqrt((xzuo[i]-xzuo[j])*(xzuo[i]-xzuo[j])+(yzuo[i]-yzuo[j])*(yzuo[i]-yzuo[j]));
	    	A[i*16+j]=(1.0)/(A[i*16+j]*A[i*16+j]*A[i*16+j]);
		&#125;
    for(i=0;i&lt;=15;i++)
    &#123;
    	A[17*i]=0;
	&#125;

	while(1)
	&#123;
		if(time==0)
		&#123;
			b1=a1;
			b2=a2;
			b3=a3;
			b4=a4;
			b5=a5;
			b6=a6;
			b7=a7;
			b8=a8;
			b9=a9;
			b10=a10;
			b11=a11;
			b12=a12;
			b13=a13;
			b14=a14;
			b15=a15;
			b16=a16;
			time++;
		&#125;
		else
		&#123;
			uint5 i,j;
			double yuzhi=0.01;
			uint12 graphsig[16];
			uint12 graphsigq[16];
			double Bian,jiubian,xinbian;
			/* 此处假设该图信号的邻接矩阵不变，所以前面的只算一次 */
			graphsig[0] = a1;
			graphsig[1] = a2;
			graphsig[2] = a3;
			graphsig[3] = a4;
			graphsig[4] = a5;
			graphsig[5] = a6;
			graphsig[6] = a7;
			graphsig[7] = a8;
			graphsig[8] = a9;
			graphsig[9] = a10;
			graphsig[10] = a11;
			graphsig[11] = a12;
			graphsig[12] = a13;
			graphsig[13] = a14;
			graphsig[14] = a15;
			graphsig[15] = a16;
			/* 现在时刻图信号 */
			graphsigq[0] = b1;
			graphsigq[1] = b2;
			graphsigq[2] = b3;
			graphsigq[3] = b4;
			graphsigq[4] = b5;
			graphsigq[5] = b6;
			graphsigq[6] = b7;
			graphsigq[7] = b8;
			graphsigq[8] = b9;
			graphsigq[9] = b10;
			graphsigq[10] = b11;
			graphsigq[11] = b12;
			graphsigq[12] = b13;
			graphsigq[13] = b14;
			graphsigq[14] = b15;
			graphsigq[15] = b16;

			double dianbianhe[16];
			for(i=0;i&lt;=15;i++)
			&#123;
				Bian=0;
				for(j=0;j&lt;=15;j++)
				&#123;
					jiubian=((graphsigq[i]-graphsigq[j])*(graphsigq[i]-graphsigq[j]));
					xinbian=((graphsig[i]-graphsig[j])*(graphsig[i]-graphsig[j]));
					Bian=Bian+(xinbian-jiubian)*(xinbian-jiubian)*A[i*16+j];
				&#125;
				dianbianhe[i]=Bian;
			&#125;
			for(i=0;i&lt;=15;i++)
			&#123;
				if(dianbianhe[i]&gt;=yuzhi)
				&#123;
					if(i==0) *c1=1;
					else if(i==1) *c2=1;
					else if(i==2) *c3=1;
					else if(i==3) *c4=1;
					else if(i==4) *c5=1;
					else if(i==5) *c6=1;
					else if(i==6) *c7=1;
					else if(i==7) *c8=1;
					else if(i==8) *c9=1;
					else if(i==9) *c10=1;
					else if(i==10) *c11=1;
					else if(i==11) *c12=1;
					else if(i==12) *c13=1;
					else if(i==13) *c14=1;
					else if(i==14) *c15=1;
					else if(i==15) *c16=1;
				&#125;
			&#125;
			b1=a1;
			b2=a2;
			b3=a3;
			b4=a4;
			b5=a5;
			b6=a6;
			b7=a7;
			b8=a8;
			b9=a9;
			b10=a10;
			b11=a11;
			b12=a12;
			b13=a13;
			b14=a14;
			b15=a15;
			b16=a16;
		&#125;
	&#125;
&#125;
</code></pre>
<p>综合后 IP 核 ：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc63d71546b24ba8b8aafcf1a9c565ee.png"></p>
<h2 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四.注意事项"></a>四.注意事项</h2><p>&lt;1&gt;实例化时注意各个模块的时序，检查代码使用的时钟频率及各参数是否正确；实例化时连接线的运用，不能重复对一变量赋值！；注意实例调用时名称统一。</p>
<p>&lt;2&gt;编写好仿真文件进行仿真后再下载。</p>
<p>&lt;3&gt;报错：[DRC MDRV-1] Multiple Driver Nets</p>
<p>[Vivado综合报multi-driven<br>nets的错误的解决方法](<a target="_blank" rel="noopener" href="https://blog.csdn.net/wordwarwordwar/article/details/80428358?ops_request_misc=&request_id=&biz_id=102&utm_term=multiple%20driver%20nets&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/wordwarwordwar/article/details/80428358?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=multiple%20driver%20nets&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-blog-2<del>all</del>sobaiduweb~default-0-80428358.nonecase&amp;spm&#x3D;1018.2226.3001.4187<br>“Vivado综合报multi-driven nets的错误的解决方法”)</p>
<p>[Vivado编译过程中出现[DRC MDRV-1] Multiple Driver<br>Nets](<a target="_blank" rel="noopener" href="https://blog.csdn.net/jk_101/article/details/131824877?ops_request_misc=&request_id=&biz_id=102&utm_term=multiple%20driver%20nets&utm_medium=distribute.pc_search_result.none-">https://blog.csdn.net/jk_101/article/details/131824877?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=multiple%20driver%20nets&amp;utm_medium=distribute.pc_search_result.none-</a><br>task-<br>blog-2<del>all</del>sobaiduweb~default-1-131824877.nonecase&amp;spm&#x3D;1018.2226.3001.4187<br>“Vivado编译过程中出现[DRC MDRV-1] Multiple Driver Nets”)</p>
<p>&lt;4&gt;未使用的输入输出不要定义，定义后生成比特流前必须绑定引脚</p>
<p>&lt;5&gt;按照官方推荐的配套工具软件，比如Vivado 2023.1对应Vitis HLS<br>2023.1，如果使用不配套版本，HLS导出的IP核Vivado可能无法完全识别，报错“missing<br>Source”（全部展开IP核显示有缺少模块说明，如下图：）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/50188b6c5223368c01c9481331d5b841.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133853116">https://blog.csdn.net/qq_32971095/article/details/133853116</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-title-link" itemprop="url">进阶设计一（DDR3）——FPGA学习笔记＜？＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-29 21:15:35" itemprop="dateCreated datePublished" datetime="2023-10-29T21:15:35+08:00">2023-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="进阶设计一（DDR3）——FPGA学习笔记＜？＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/10/29/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%88DDR3%EF%BC%89%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><pre><code>    DDR3 SDRAM，以其单位存储量大、高数据带宽、读写速度快、价格相对便宜等优点 吸引了大批客户，占领市场较大份额。同时，作为内存条中不可缺少的一部分，DDR3 SDRAM 在计算机领域也占有一席之地。

    要掌握 DDR3 SDRAM 的基本概念、数据存取原理、操作命令以及操作时序等相关知识。在掌 握 DDR3 SDRAM 的相关理论知识后，讲解 AXI4 接口，并且使用该接口配置 Xilinx 的 MIG IP 核，设计一个可进行读写操作的 DDR3 SDRAM 控制器，并上板验证。
</code></pre>
<h3 id="1-DDR3-SDRAM基础概念"><a href="#1-DDR3-SDRAM基础概念" class="headerlink" title="1.DDR3 SDRAM基础概念"></a>1.DDR3 SDRAM基础概念</h3><pre><code>    DDR3 SDRAM 英 文 全 称 “ **Double-Data-Rate Three Synchronous Dynamic Random Access Memory** ”，译为“第三代**双倍速率同步动态随机存取** 内存”或“同步动态随机存储 器”，是动态随机存储器(Dynamic Random Access Memory，简称 DRAM)的一类。 同步、动态、随机是其性能特点的外在说明。

    **双倍速率(Double-Data-Rate)** ：DDR3 SDRAM 存储器与 SDRAM 有一个很大的不同， DDR3 SDRAM 或者说带 DDR 开头的。包括 DDR1、DDR2、DDR3、DDR4、DDR4，他们都有一个很大的相似点，就是**双边沿输出输入数据** ，通俗来讲就是在一个周期内输出 2 次 数据，上升沿输出一次数据，下降沿输出一次数据。而 SDRAM 则是在一个周期内的上升 沿输出一次数据，下降沿不输出，所以同频率的 DDR3 SDRAM 与 SDRAM 相比速度快一 倍。

    **同步(Synchronous)** ：与通常的异步 DRAM 不同，DDR3 SDRAM 存在一个同步接口， 其工作时钟的时钟频率与对应控制器(CPU/FPGA)的时钟频率相同，并且 SDRAM 内部的命 令发送与数据传输均以此时钟为基准，实现指令或数据的同步操作；

    **动态(Dynamic)** ：DDR3 SDRAM 需要不断的刷新来保证存储阵列内数据不丢失；

   **  随机(Random)**：数据在 DDR3 SDRAM 中并不是按照线性依次存储，而是可以自由指定地址进行数据的读写。

    第一代 SDR SDRAM 采用单端时钟信号，SDRAM 只在时钟的上升沿进行数据采样； 而后面的四代 SDRAM 由于工作频率比较快，所以采用可降低干扰的**差分时钟信号** 作为同步时钟，双沿采样，速度更快，且功耗更低。同时技术的不断发展、制造工艺的不断提 高，使得五代 SDRAM 的更新过程中，集成度越来越高、内核电压越来越低(SDR:3.3V、 DDR:2.5V、DDR2:1.8V、DDR3:1.5V、DDR4:1.2V)，这也是 SDRAM 速度提高、功耗降低的重要原因。

    由于 DDR3 SDRAM 需要不断刷新来保证数据的可靠性，**以及行列地址线分时复用等原因，使其对操作时序的 要求较为严格，进而导致控制逻辑较为复杂。**
</code></pre>
<h3 id="2-DDR3-SDRAM存取原理"><a href="#2-DDR3-SDRAM存取原理" class="headerlink" title="2.DDR3 SDRAM存取原理"></a>2.DDR3 SDRAM存取原理</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1f3e93d3d6e3e3edeb231ab5b8c0ae5.png"></p>
<pre><code>    对于 DDR3 SDRAM，我们将类比于单元格的存储空间称之为存储单元，N(行列个数乘积)个存储单元构成一个存储阵列，这个存储阵列我们称之为一个逻辑Bank(LogicalBank）简称 L-Bank、Bank)。DDR3 SDRAM 内部并不是一个全容量的 L-Bank，而是**分割为若干个 L-Bank** ，目前大多为 4 个。若干 L-Bank 的分割，原因有二，一是技术、成本等诸多因素；二是由于 DDR3 SDRAM 的工作原理限制，单一 L-Bank 可能会造成非常严重的寻址冲突，大幅度降低内存效率。

    这样一来，在对 DDR3 SDRAM 进行数据存取时，要**先确定 L-Bank 地址** ，定位到指定 逻辑 Bank，**再依次确定行地址和列地址** ，选中存储单元，进而进行数据的存取操作，而且 一次只能对一个 L-Bank 的一个存储单元进行操作。

    DDR3 SDRAM 的基本存储单位是存储单元，而一个存储单元的容量为若干个 Bit，对 于 DDR3 SDRAM 而言就是芯片的位宽，每个 Bit 存放于一个单独的**存储体** 中，存储体是利 用电容能够保持电荷以及可充放电的特性制成，主要由行选通三极管、列选通三极管、存 储电容以及刷新放大器构成。电容所存储的电荷会随时间慢慢释放，这就需要不断刷新为 电容充电，以保证存储数据可靠性。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/866e1ed63d8f65a8cdcd7109c64133cc.png"></p>
<pre><code>    将每个存储单元简化为单 Bit 的存储体，再将若干存储体排列为矩阵，同一行将行地 址线相连，同一列将列地址线相连，就构成了一个存储阵列的简化模型。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f9736f70fea11026c66c77c690af13c.png"></p>
<h3 id="3-DDR3-SDRAM器件引脚"><a href="#3-DDR3-SDRAM器件引脚" class="headerlink" title="3.DDR3 SDRAM器件引脚"></a>3.DDR3 SDRAM器件引脚</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f27df221f173245d0ec20805d218f20.png"></p>
<p>注：x4、x8、x16 分别表示位宽 4bit、8bit、16bit；<strong>＃符号表示信号为低电平有效</strong> ；短 划线-表示 x8 和 x4<br>引脚功能相同，x16 引脚功能相同与前者不同，我们的是 x16。</p>
<pre><code>    我们以镁光公司生产的、容量为 4Megx16x4Banks 的 DDR3 SDRAM 芯片为例，对其做一下功能介绍。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c4e2e22141c5a36927e70daaaf76459e.png"></p>
<pre><code>    注：表格中某些信号只介绍了后文设计实验中所涉及到的功能，更多功能介绍请查阅 芯片对应数据手册。
</code></pre>
<p>SDRAM 内部功能框图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e728de47fc70dff996003930f8c53c2f.png"></p>
<pre><code>    DDR3 SDRAM 内部包含一个逻辑控制单元，内部包含模式寄存器和 命令解码器。外部通过 CS_N、RAC_N、CAS_N、WE_N 以及地址总线向逻辑控制单元输 入命令，命令经过命令解码器进行译码后，将控制参数保存到模式寄存器中，逻辑控制单 元进而控制逻辑运行。

    外部通过地址总线输入地址信息，地址信息在逻辑控制单元进行逻辑控制时起到辅助 作用，除此之外，复用的地址总线与 Bank 控制逻辑、行地址复用器、列地址计数锁存 器、列地址解码器等内部器件共同作用，精确选定存储阵列中与行列地址相对应的存储单 元，进而进行数据存取操作。
</code></pre>
<p>容量计算方法可简化为： 存储容量(Bit)&#x3D;L-Bank 存储单元数×数据位宽(Bit)×L-Bank 个数</p>
<p>SDRAM 芯片的另一个概念：速度等级。DDR3 SDRAM 速度等级相关参数截图，具体见图</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/60e0374fc53606c56859b380fda22e26.png"></p>
<pre><code>    包括速度等级在内的 6 个相关参数。时钟频率(Clock Frequency)，单位 MHz，所列举的具体参数为 SDRAM 正常工作的最高时钟频率，SDRAM 工作时只能**等于 或低于这一时钟频率** ；tRCD 表示写入**自激活命令到开始进行数据读写，中间所需的等待时 间** ，列举的数值表示等待时间的最小值，单位为 ns；tRP 表示自预充电指令写入到预充电完成 所 需 的 等 待 时 间 ， 列 举 的 数 值 表 示 等 待 时 间 的 最 小 值 ， 单 位 为 ns ；**CL(CAS(READ)latency)列选通潜伏期，表示自数据读指令写入到第一个有效数据输出所需 等待时间** ，单位 ns；TargettRCD-tRP-CL 表示最大工作频率下，tRCD、tRP、CL 等待的最小时 钟周期数。
</code></pre>
<h3 id="4-AXI-接口概述"><a href="#4-AXI-接口概述" class="headerlink" title="4.AXI 接口概述"></a>4.AXI 接口概述</h3><pre><code>    Advancede Xtensible Interface，即高级可扩展接口，它是 **ARM 公司 所提出的 AMBA（Advanced Microcontroller Bus Architecture）协议的一部分** 。之所以要采 用 AXI4 接口对 ddr 进行读写是因为 Xilinx 的 mig ddr Ip 核，无论是 6 系列还是 7 系列还是 最新的 FPGA，都集成了 AXI4 接口，为了采用 AXI4 接口进行读写，后续可以兼容 xilinx 的其他 fpga，可复用性更强。
</code></pre>
<p>AXI 协议是一种高性能、高带宽、低延迟的片内总线，具有如下特点：</p>
<p>1、总线的地址&#x2F;控制和数据通道是分离的；</p>
<p>2、支持不对齐的数据传输；</p>
<p>3、支持突发传输，突发传输过程中只需要首地址；</p>
<p>4、具有分离的读&#x2F;写数据通道；</p>
<p>5、支持显著传输访问和乱序访问；</p>
<p>6、更加容易进行时序收敛。</p>
<p>AXI4 协议支持以下三种类型的接口：</p>
<p>1、AXI4：高性能存储映射接口。</p>
<p>2、AXI4-Lite：简化版的 AXI4 接口，用于较少数据量的存储映射通信。</p>
<p>3、AXI4-Stream：用于高速数据流传输，非存储映射接口。</p>
<pre><code>    在这里我们首先解释一下**存储映射（MeamoryMap）** 这一概念。如果一个协议是存储 映射的，那么主机所发出的会话（无论读或写）就会**标明一个地址** 。这个地址对应于系统 存储空间中的一个地址，表明是针对该存储空间的读写操作。**AXI4 协议支持突发传输** ，主 要用于处理器访问存储器等需要指定地址的高速数据传输场景。AXI-Lite 为外设提供单个 数据传输，主要用于访问一些低速外设中的寄存器。**而 AXI-Stream 接口则像 FIFO 一样， 数据传输时不需要地址，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接口等需要高速数据传输的场合。**
</code></pre>
<h3 id="5-AXI4-接口讲解"><a href="#5-AXI4-接口讲解" class="headerlink" title="5.AXI4 接口讲解"></a>5.AXI4 接口讲解</h3><p>在本章我们重点介绍 AXI4 接口，它由五个独立的通道构成：</p>
<p>1、读地址 2、读数据 3、写地址 4、写数据 5、写响应</p>
<p>下面是使用读地址和读数据通道实现<strong>读传输过程</strong> 的示意图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cda28565b6a3cceaaefa7d089061712e.png"></p>
<pre><code>    从上图中可以看到，在一个读传输过程中，主机首先在**读地址通道** 给出**读地址和控制 信号** ，然后从机由**读数据通道返回读出的数据** 。另外我们需要注意的是，这是一次**突发读操作** ，主机只给出一个地址，从该地址连**续突发读出四个数据** 。
</code></pre>
<p>写传输过程如下图所示，它用到了写地址、写数据和写响应三个通道：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3cacdc3809b6780897b8925b49a1d79f.png"></p>
<pre><code>    主机在写地址 通道给出写地址和控制信号，然后在写数据通道连续**突发写四个数据** 。从机在接收数据之 后，在写响应通道给出响应信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f2a8579995320eff3cbae1852918c33.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a8c880c2210b35bf29c9ffd20109d563.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1eab0ea821db4da4963da6f3f55e7d96.png"></p>
<p><strong>突发写时序：</strong></p>
<pre><code>    AXI4 突发写可以分为 7 个状态，写空闲，写通道写地址等待，写通道写地址，写数据 等待，写数据循环，接受写应答，写结束这 7 种状态。**之所以划分为 7 个状态是为了后续 写程序的状态机做准备。**
</code></pre>
<p><strong>写空闲</strong> ：等待触发突发信号。</p>
<p><strong>写通道写地址等待</strong> ：准备好写地址 AWADDR，然后拉高 AWVALID。</p>
<p><strong>写通道写地址</strong> ：从机接受到 AWVALID，发出 AWREADY。</p>
<p><strong>写数据等待</strong> ：准备好数据 WDATA，拉高 WVALID。</p>
<p><strong>写数据循环</strong> ：从机接受 WVALID ，确认数据 WDATA 有 效 并 且接 受 ， 发 出 WREADY，AXI 是突发传输：循环该操作到接受到<br>WLAST 最后一个数据标志位。</p>
<p><strong>接受写应答</strong> ：接受到从机发出的 BVALID，主机发出 BREADY。</p>
<p><strong>写结束</strong> ：拉低未拉低的信号，进入写空闲。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a0f06fb6a50995ff5c2cbe2d97b5402.png"></p>
<p><strong>突发读时序：</strong></p>
<pre><code>    AXI4 突发读可以分为 6 个状态，读空闲，读通道写地址等待，读通道写地址，读数据 等待，读数据循环，读结束这 6 种状态。之所以划分为 6 个状态是为了后续写程序的状态 机做准备。
</code></pre>
<p><strong>读空闲</strong> ：等待触发突发信号。</p>
<p><strong>读通道写地址等待</strong> ：准备好写地址 ARADDR，然后拉高 ARVALID。</p>
<p><strong>读通道写地址</strong> ：从机接受到 ARVALID，发出 ARREADY。</p>
<p><strong>读数据等待</strong> ：从机器准备好数据 WDATA，从机拉高 RVALID。</p>
<p><strong>读数据循环</strong> ：主机接受 RVALID，确认数据 RDATA 有效并且接受，发出 RREADY 给 从机，AXI 是突发传输：循环该操作到接受到<br>RLAST 最后一个数据标志位。</p>
<p><strong>读结束</strong> ：拉低未拉低的信号，进入读空闲。</p>
<p>从上面的时序图与时序分析可知两种关系必须被保持：</p>
<p>（1）读数据必须总是跟在与其数据相关联的地址之后。</p>
<p>（2）写响应必须总是跟在与其相关联的写事务的最后出现。</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133984011">https://blog.csdn.net/qq_32971095/article/details/133984011</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-title-link" itemprop="url">嵌入式Linux_Petalinux二——FPGA学习笔记＜？＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-08 11:20:35" itemprop="dateCreated datePublished" datetime="2023-10-08T11:20:35+08:00">2023-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="嵌入式Linux_Petalinux二——FPGA学习笔记＜？＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前置学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133468006?spm=1001.2014.3001.5502" title="嵌入式Linux_Petalinux一">嵌入式Linux_Petalinux一</a></p>
<p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p>
<p>关于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/451782049" title="SecureCRT
中如何配置颜色">SecureCRT 中如何配置颜色</a></p>
<h2 id="一-Linux-基础外设的使用"><a href="#一-Linux-基础外设的使用" class="headerlink" title="一.Linux 基础外设的使用"></a>一.Linux 基础外设的使用</h2><pre><code>    之前使用 Petalinux 搭建了 Linux 系统，有了系统就可以在系统上使用相应外设以及运行应用程序。本章我们学习如何通过 Linux 系统控制开发板上的基础外设，如 LED、按键、EEPROM、以太网等。这些外设都可以**在终端通过 Shell 来控制** 。
</code></pre>
<p>输入以下命名查看系统：</p>
<pre><code>cat /proc/version                                       #查看内核版本信息
top                                                     #检测资源使用情况
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df37df1a05bea06ea851e839d48f5a45.png"></p>
<p>Linux version 5.4.0 (cx@cx-ubtu) (gcc version 9.2.0 (GCC)) #11 SMP Mon Nov 14<br>13:40:04 CST 2022</p>
<h3 id="1-GPIO-之-LED-的使用"><a href="#1-GPIO-之-LED-的使用" class="headerlink" title="1.GPIO 之 LED 的使用"></a>1.GPIO 之 LED 的使用</h3><pre><code>    GPIO 驱动程序通过 **sysfs 文件** 系统提供了用户空间对 GPIO 的访问，因而通过终端控制 LED 极其方便。我们启动开发板，进入之前定制的 Linux 系统后在串口终端中输入如下命令**进入到 sysfs 文件系统的 leds 接口处** ：


cd /sys/class/leds
ls
</code></pre>
<p>通过 ls 命令可以看到我们在设备树中配置的 led，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eff74364cc7414a63dba7718a405969d.png"></p>
<p>我们先来看下 led 下的内容，以 ps_led1 为例，输入 ls -l ps_led1，执行结果如下图 所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0968615b0a3d479ce6a50411c038ed5d.png"></p>
<pre><code>    可以看到有 brightness 和 trigger。Brightness 可以控制 led 灯的亮灭，trigger 可以选择触发方式。我们向 ps_led1 的 brightness 写入 0，即输入命令:


cd ./ps_led1
echo 0 &gt; brightness
</code></pre>
<p>或者用下面命令查看brightness的当前值，再用vim修改：</p>
<pre><code>cat brightness
vim brightness
</code></pre>
<p>对应开发板上led灯的亮灭。</p>
<p>然后输入命令查看led灯的触发方式：</p>
<pre><code>cat trigger
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae8ef58e273543418e7c98f64fc27d91.png"></p>
<pre><code>    可以看到触发方式非常多，**其中“[ ]”中的内容表示当前触发方式** 。可知当前触发方式为 none，也就是表示无任何触发反应。
</code></pre>
<p>想设置使用某种触发方式输入 echo 命令如上，如：</p>
<pre><code>echo heartbeat &gt; trigger

    需要提醒的是并不是所有的触发方式都能有反应，必须满足触发条件并且 brightness 值为 1 才行。
</code></pre>
<h3 id="2-GPIO-之按键的使用"><a href="#2-GPIO-之按键的使用" class="headerlink" title="2.GPIO 之按键的使用"></a>2.GPIO 之按键的使用</h3><pre><code>    GPIO 按键的使用非常简单，通过读取文件/dev/input/event0 可以获取由 GPIO 按键生成 的按键事件。在串口终端中输入命令：


cat /dev/input/event0 | hexdump
</code></pre>
<p>然后按下一个 按键，输入事件将打印到控制台</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db2e1f071232d45000b84c0bad2afe08.png"></p>
<h3 id="3-EEPROM-的使用"><a href="#3-EEPROM-的使用" class="headerlink" title="3.EEPROM 的使用"></a>3.EEPROM 的使用</h3><pre><code>    配置设备树的时候，我们在设备树文件中配置了一个 EEPROM 的 I2C 外设， 我们来看下如何读写 EEPROM。        
</code></pre>
<p>在 <strong>&#x2F;sys&#x2F;class&#x2F;i2c-adapter</strong> 目录下有三个 <strong>I2C 总线控制器</strong> ，相关操作如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5601bd79a638177ee7ef566139bc685a.png"></p>
<pre><code>    可以看到**器件地址 50 对应的文件夹 0-0050，对应 eeprom** 。 进入到 0-0050/目录下，可以看到该目录有一个 eeprom 文件，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/71633056d776965dd23fd591be34ffbd.png"></p>
<pre><code>cd /sys/class/i2c-adapter
ls
cd i2c-0
ls
cd 0-0050
ls
echo &quot;hello world&quot; &gt; eeprom
head -1 eeprom
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/75d85c1547d2f818686853e002923d8a.png"></p>
<h3 id="4-RTC-的使用"><a href="#4-RTC-的使用" class="headerlink" title="4.RTC 的使用"></a>4.RTC 的使用</h3><pre><code>    对于 RTC，linux 有一个专用的命令：hwclock。

    在 Linux 中有**硬件时钟与系统时钟** 两种时钟。硬件时钟是指电路板上的时钟设备（包括主 控芯片内的时钟模块），也就是通常可在 **BIOS 画面设定的时钟** 。系统时钟则是指 **kernel 中的时钟** 。当 Linux 启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有 Linux 相关指令与函数都是**读取系统时钟的设定** 。

    使用 date 和 hwclock 命令可分别查看和设定系统时钟和硬件时钟。 在串口终端中输入下面的指令查看系统时间：


date
hwclock
</code></pre>
<p>输入下面的指令将系统时间设置为当前日期和时间:</p>
<pre><code>date -s &quot;2023-10-9 14:39:00&quot;
</code></pre>
<p>在串口终端中输入下面的命令将系统时间写入 RTC 时钟芯片中:</p>
<pre><code>hwclock -w
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9223fa2dc1aa34fdf217d48e9aac1243.png"></p>
<h3 id="5-miniDP-接口的使用"><a href="#5-miniDP-接口的使用" class="headerlink" title="5.miniDP 接口的使用"></a>5.miniDP 接口的使用</h3><pre><code>    开发板带有一个 miniDP 接口，可以接显示器显示。一般显示使用的是 DP 接口或者 HDMI 接口，与开发板的 miniDP 接口不同，所以还需要一根 miniDP 转 DP 线或者 miniDP 转 HDMI 线。下面分别展示不同接口显示器的线材接口。

    1\. DP 接口显示器：使用公对公的 mini DP 转 DP 线连接开发板和 DP 显示器即可，线材接 口如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07a72fa907063d261bf71257b8497f61.png"></p>
<pre><code>    2\. HDMI接口显示器：需要使用主动式miniDP转HDMI线来连接开发板和HDMI显示器。 需要注意的是并不是市面上所有的 miniDP 转 HDMI 线都可以使用，至于原因，Xilinx 官方也 只是说由于历史原因，但并未透露更多细节。笔者在购买市面上大量的 miniDP 转 HDMI 线并 进行测试后发现，** _有些线 linux 系统下能显示，但是裸机 Vitis 下不能显示或显示有问题，有些线无法使用_** ，最终测试发现有一根线 linux 和 Vitis 下都能正常显示。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/141936bb09289673f07c3a351763d89e.png"></p>
<pre><code>    使用转接线将开发板的 miniDP 与显示器连接后，按 PS 的复位按键重启开发板，重启后会在显示器显示控制台终端。
</code></pre>
<h3 id="6-USB-的使用"><a href="#6-USB-的使用" class="headerlink" title="6.USB 的使用"></a>6.USB 的使用</h3><p>将 USB 接口的设备接到开发板的 USB 接口，在串口中断中会打印如下信息：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1dbb118230d5c36a3b5ea2e8bd9f90a.png"></p>
<p>显示的“Product: USB Keyboard”表明检测到插入的设备是 USB 键盘。</p>
<h3 id="7-以太网的使用"><a href="#7-以太网的使用" class="headerlink" title="7.以太网的使用"></a>7.以太网的使用</h3><pre><code>    DFZU2EG_4EV MPSoC开发板有两路千兆以太网接口，PL_ETH和PS_ETH；由于PL_ETH 网口使用了 PL 端 IO 资源，而 PS_ETH 使用了 PS 端 IO 资源，所以这里也把 PL_ETH 网口称 为 PL 网口、而把 PS_ETH 网口称为 PS 网口。
</code></pre>
<p>注：连接网口的网线要使用千兆网线，譬如 CAT-5E 类网线或 CAT-6 类网线，笔者在实 际测试当中，发现 CAT-5E<br>类网线并不稳定，所以这里推荐使用 CAT-6 类网线进行测试。</p>
<h4 id="1、查看网络设备"><a href="#1、查看网络设备" class="headerlink" title="1、查看网络设备"></a>1、查看网络设备</h4><p> 在串口终端执行下面这条命令可以<strong>查看系统中的所有网络设备</strong> ，如下所示：</p>
<pre><code>ip -s a
#或者
ifconfig -a
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a8a98f0b7c13331ab6701a4e43b83186.png"></p>
<pre><code>    其中 eth0 表示开发板上的 PL_ETH 网口、 而 eth1 则表示开发板上的 PS_ETH 网口。还可以直接使用 **ifconfig** 命令不加任何选项查看当前系统**已经激活（打开）的网络设备** （等同于命令 **ip link show up** ），如下图所示：


ifconfig
或
ip link show up
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/53a9bd3bd086937144b1035f4db021fe.png"></p>
<pre><code>    系统默认只激活了 eth0，而 eth1 并没有激活，上图中的 eth0 就是开发板上的 PL 网口，可 以通过 ifconfig 命令或者 ip 命令来关闭或激活对应的网口。 ifconfig 命令打开或关闭 PL 网口的命令如下所示：


ifconfig eth0 down //关闭 eth0（PL 网口）
ifconfig eth0 up //打开 eth0（PL 网口）
</code></pre>
<p>如果是用 ip 命令，则对应命令如下：</p>
<pre><code>ip link set eth1 down //关闭 eth1（PS 网口）
ip link set eth1 up //打开 eth1（PS 网口）

    下面我们在使用 PS 网口的时候，需要先把 PL 网口给关闭，只打开 PS 网口；同理使用 PL 网口的时候，需要把 PS 网口给关闭，只打开 PL 网口；在后面的使用当中，笔者以 PL 网 口为例进行介绍，PS 网口使用方式相同。
</code></pre>
<h4 id="2、外网连接测试（有路由器）"><a href="#2、外网连接测试（有路由器）" class="headerlink" title="2、外网连接测试（有路由器）"></a>2、外网连接测试（有路由器）</h4><p>执行下面的命令打开开发板的 PL 网口，并且关闭 PS 网口：</p>
<pre><code>ip link set eth1 down //关闭 PS 网口
ip link set eth0 up //打开 PL 网口
ip link show up
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5fc18910c9637d0ca383f9393ef6f18.png"></p>
<pre><code>    接下来我们需要给 PL 网口分配一个 IP 地址，使用 udhcpc 命令从 DHCP 服务器中动态 获取一个 IP 地址，如下所示：


udhcpc -i eth0 //eth0 动态获取 IP 地址
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c576aa9c09612f23d4a89791951fd1a.png"></p>
<pre><code>    可以看到，笔者这里 PL 网口动态获取得到的 IP 地址为 192.168.2.219。获 取到 IP 地址之后，接下来我们需要测试下开发板是不是能够上网，也就是测试开发板 PL 网 口是否工作正常、是否能够连接外网。当然首先确定开发板 PL 网口连接到的路由器是能够连 接外网的，我们可以使用 ping 命令来测试开发板与另一台主机的网络连接是否通畅。

    ping 命令是基于 **ICMP** （Internet Control Message Protocol）协议来工作的，执行 ping 命令 本地主机会向目标主机发送一份 ICMP 回显请求报文，并等待目标主机返回 ICMP 应答；因为 ICMP 协议会要求目标主机收到消息之后，必须返回 ICMP 应答消息给本地主机，如果本地主 机收到了目标主机的应答，则表示两台主机之间的网络运行、网络连接是正常的。


ping -c 10 www.baidu.com //测试开发板与百度服务器之间网络连接情

    从上图可以知道，我们通过开发板对百度服务器主机（IP 地址：14.215.177.39）发送了 10 次应答请求，并且每次都收到了它的应答消息（64 字节数据），并且没有数据丢失，说明 开发板与百度服务器主机之间的网络运行、网络连接是 OK 的，也就意味着我们的开发板与外 网是连通的。 PS 网口的外网连接测试同理。
</code></pre>
<h4 id="3、电脑直连测试（无路由器）"><a href="#3、电脑直连测试（无路由器）" class="headerlink" title="3、电脑直连测试（无路由器）"></a>3、电脑直连测试（无路由器）</h4><pre><code>    在开发过程中，电脑和开发板互相访问是经常需要的，这可以通过路由器来实现，连接到 同一路由器的设备是可以互相访问的，如果没有路由器，也可以使用网线将开发板 PS 网口或 者 PL 网口直接连接到电脑的以太网接口上，也就是电脑直连，不过这种方式不能访问外网。 笔者以 PL 网口为例，用网线将开发板的 PL 网口和电脑的以太网接口相连接。
</code></pre>
<p>连接好网线之后，需要设置电脑以太网的 IP 地址，可参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QJ411v7xk/?spm_id_from=333.999.0.0&vd_source=01cde8042a76495bf513aa4407a56cd6" title="Linux开发板网络直连电脑的设置方法">Linux开发板网络直连电脑的设置方法<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://www.bilibili.com/video/BV1QJ411v7xk/?spm_id_from&#x3D;333.999.0.0&amp;vd_source&#x3D;01cde8042a76495bf513aa4407a56cd6</a></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b17f18975241cf0242477f6467254f7a.png"></p>
<p>配置完成后，在串口终端中执行下面这些命令打开开发板的 PL 网口，并且关闭 PS 网口：</p>
<pre><code>ip link set eth1 down //关闭 PS 网口
ip link set eth0 up //打开 PL 网口
ip link show up
</code></pre>
<p>执行下面的命令设置开发板 eth0 网口的静态 IP 地址为 192.168.2.88：</p>
<pre><code>ip addr add 192.168.2.88/24 dev eth0

    将开发板的静态 IP 地址设置为 192.168.2.88，这样开发板的 IP 地址和电脑的 IP 就在同一 网段。设置完开发板的静态 IP 地址后，进行 Ping 测试，看开发板和电脑能不能相互 Ping 通。 首先开发板 ping 电脑，命令如下：


ping -c4 192.168.2.89
</code></pre>
<p>如果 Ping 不通电脑，请关闭电脑的防火墙后再尝试。</p>
<p>电脑 ping 开发板。首先打开电脑的 cmd 命令提示符，然后输入如下命令：</p>
<pre><code>ping 192.168.2.88
</code></pre>
<h3 id="8-eMMC-的使用"><a href="#8-eMMC-的使用" class="headerlink" title="8.eMMC 的使用"></a>8.eMMC 的使用</h3><pre><code>    注意，由于 2019.2 版本 petalinux 内核中驱动的问题，在做本实验前需要将出厂的 vivado 工程中 SDIO0，就也就是 **eMMC 的工作时钟由 200M 改为 100M** ，如下图所示，然后编译并导 出 xsa 文件，使用新导出的文件配置 petalinux 工程。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32649bd1f2f18ee4d548e60910182177.png"></p>
<pre><code>    开发板板载 8GB eMMC，接下来通过简单的读写来学习 eMMC 的使用。 开发板成功启动后，进入系统，输入“df -Th”命令，**查看挂载的文件系统** ，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d608ed53f1af767c4baaad973372d7a.png"></p>
<pre><code>     其中“/dev/mmcblk0p1” 和“/dev/mmcblk0p2”就是 eMMC 设备，代表 eMMC 的两个分区，分别挂载在**“/media/mmcblk0p1”和“/media/mmcblk0p2”** 两个挂载点。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/19ccb7804f2f10db4c0d4c188bc7ef0c.png"></p>
<p>可以先看一下emmc中的内容：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ccba3740912f31afd6976e11bb50c9c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f488e3936031b5c3e89806e80ca9b35.png"></p>
<p>可以看到里面是之前用 petalinux 制作好的启动镜像文件和 linux 系统文件。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2883eb35f130294a656b388174b84e41.png"></p>
<p>接下来参考制作 SD 启动卡的步骤，将 eMMC 格式化成一个分区。</p>
<p>分别执行下面两个命令，先使用 umount 指令从挂载点<strong>卸载 eMMC</strong> ，再使用 fdisk 指令对 eMMC 分区，结果如下图所示：</p>
<pre><code>umount /run/media/mmcblk0p1 /run/media/mmcblk0p2
fdisk /dev/mmcblk0
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5873fb2cafd89a8736490f399460fad8.png"></p>
<p>执行后输入“p”，结果如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/56895f538457aefd068f703d8191458f.png"></p>
<pre><code>    可以看到 eMMC 有 p1 和 p2 两个分区，输入“d”删除分区，在接下来的分区序号选择命令行中，输入“1”，选择删除第一个分区，再次输入“d”，删除第二个分区，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/914da14b57ed5701b3dded0fbee04e49.png"></p>
<pre><code>    接下来**输入“n”创建1个新分区** ，输入“p”选择创建主分区，按回车键，然后选择“1”， 接下来的设置按回车，选择默认即可，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/234bec0c77ee3c952f7b2eda8eab4395.png"></p>
<p>输入“p”检查分区表，可以看到新建的分区，如果没有问题，输入“w”保存并退出， 如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce229eb7c62cd552353c9d4dd0bb73c0.png"></p>
<pre><code>    输入 echo “www.openedv.com” &gt; /media/mmcblk0p1/test.txt 命令在 eMMC 中创建名为 test.txt 的文本文件，并向文件中写入内容为“www.openedv.com”的文本内容，然后使用 cat /run/media/mmcblk0p1/test.txt 命令，将文件中的内容打印出来，可以看到写入和读出的内容相 同。
</code></pre>
<h2 id="二-使用-Vitis-开发-Linux-应用"><a href="#二-使用-Vitis-开发-Linux-应用" class="headerlink" title="二.使用 Vitis 开发 Linux 应用"></a>二.使用 Vitis 开发 Linux 应用</h2><pre><code>    本章我们以创建 “Hello World”工程为例学习如何**使用 Vitis 开发 Linux 应用** 以及如何让应用程序运行在 Petalinux 搭建的 Linux 系统上。运行方式本章介绍了三种，可根据个人喜好选择。
</code></pre>
<h3 id="1-创建基于-Vitis-的-Linux-平台工程"><a href="#1-创建基于-Vitis-的-Linux-平台工程" class="headerlink" title="1.创建基于 Vitis 的 Linux 平台工程"></a>1.创建基于 Vitis 的 Linux 平台工程</h3><p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133674422">https://blog.csdn.net/qq_32971095/article/details/133674422</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">Linux系统——OS学习笔记＜1＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-02 13:04:53" itemprop="dateCreated datePublished" datetime="2023-10-02T13:04:53+08:00">2023-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="Linux系统——OS学习笔记＜1＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/10/02/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C1%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">一.Ubuntu<br>系统入门</a></p>
<p><a href="about:blank#1.VMware%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%81%E7%A8%8B">1.VMware<br>创建虚拟机流程</a></p>
<p><a href="about:blank#2.Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8">2.Ubuntu 系统入门</a></p>
<p><a href="about:blank#%3C1%3EShell%20%E5%91%BD%E4%BB%A4">&lt;1&gt;Shell 命令</a></p>
<p><a href="about:blank#1%E3%80%81%E7%9B%AE%E5%BD%95%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20ls">1、目录信息查看命令<br>ls</a></p>
<p><a href="about:blank#2%E3%80%81%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E5%91%BD%E4%BB%A4%20cd">2、目录切换命令<br>cd</a></p>
<p><a href="about:blank#3%E3%80%81%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%20pwd">3、当前路径显示命令<br>pwd</a></p>
<p><a href="about:blank#4%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%20uname">4、系统信息查看命令<br>uname</a></p>
<p><a href="about:blank#5%E3%80%81%E6%B8%85%E5%B1%8F%E5%91%BD%E4%BB%A4%20clear">5、清屏命令<br>clear</a></p>
<p><a href="about:blank#6%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%BA%AB%E4%BB%BD%E5%91%BD%E4%BB%A4%20sudo">6、切换用户执行身份命令<br>sudo</a></p>
<p><a href="about:blank#7%E3%80%81%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20adduser">7、添加用户命令<br>adduser</a></p>
<p><a href="about:blank#8%E3%80%81%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20deluser">8、删除用户命令<br>deluser</a></p>
<p><a href="about:blank#9%E3%80%81%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%20su">9、切换用户命令<br>su</a></p>
<p><a href="about:blank#10%E3%80%81%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%91%BD%E4%BB%A4%20cat">10、显示文件内容命令<br>cat</a></p>
<p><a href="about:blank#11%E3%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4%20ifconfig">11、显示和配置网络属性命令<br>ifconfig</a></p>
<p><a href="about:blank#12%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%20man">12、系统帮助命令<br>man</a></p>
<p><a href="about:blank#13%E3%80%81%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%20reboot">13、 系统重启命令<br>reboot</a></p>
<p><a href="about:blank#14%E3%80%81%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%97%AD%E5%91%BD%E4%BB%A4%20poweroff">14、系统关闭命令<br>poweroff</a></p>
<p><a href="about:blank#15%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%20install">15、软件安装命令<br>install</a></p>
<p><a href="about:blank#%3C2%3EAPT%20%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7">&lt;2&gt;APT 下载工具</a></p>
<p><a href="about:blank#1%E3%80%81%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93">1、更新本地数据库</a></p>
<p><a href="about:blank#2%E3%80%81%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">2、检查依赖关系</a></p>
<p><a href="about:blank#3%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">3、软件安装</a></p>
<p><a href="about:blank#4%E3%80%81%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0">4、软件更新</a></p>
<p><a href="about:blank#5%E3%80%81%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6">5、卸载软件</a></p>
<p><a href="about:blank#%3C3%3EUbuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91">&lt;3&gt;Ubuntu<br>下文本编辑</a></p>
<p><a href="about:blank#%3C4%3E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">&lt;4&gt;文件系统</a></p>
<p><a href="about:blank#1.Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">1.Linux<br>文件系统结构</a></p>
<p><a href="about:blank#2.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">2.文件操作命令</a></p>
<p><a href="about:blank#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E2%80%94touch">1、创建新文件命令—touch</a></p>
<p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir">2、文件夹创建命令—mkdir</a></p>
<p><a href="about:blank#3%E3%80%81%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rm">3、文件及目录删除命令—rm</a></p>
<p><a href="about:blank#4%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%28%E7%9B%AE%E5%BD%95%29%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%E2%80%94rmdir">4、文件夹(目录)删除命令—rmdir</a></p>
<p><a href="about:blank#5%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4%E2%80%94cp">5、文件复制命令—cp</a></p>
<p><a href="about:blank#6%E3%80%81%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%91%BD%E4%BB%A4%E2%80%94mv">6、文件移动命令—mv</a></p>
<p><a href="about:blank#3.%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">3.文件压缩和解压缩</a></p>
<p><a href="about:blank#1%E3%80%81%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">1、图形化压缩和解压缩</a></p>
<p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">2、命令行进行文件的压缩和解压缩</a></p>
<p><a href="about:blank#%E2%91%A0%E5%91%BD%E4%BB%A4%20zip">①命令 zip</a></p>
<p><a href="about:blank#%E2%91%A1%E5%91%BD%E4%BB%A4%20unzip">②命令 unzip</a></p>
<p><a href="about:blank#%E2%91%A2%E5%91%BD%E4%BB%A4%20tar">③命令 tar</a></p>
<p><a href="about:blank#4.%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2">4.文件查询和搜索</a></p>
<p><a href="about:blank#1%E3%80%81%E5%91%BD%E4%BB%A4%20find">1、命令 find</a></p>
<p><a href="about:blank#2%E3%80%81%E5%91%BD%E4%BB%A4%20grep">2、命令 grep</a></p>
<p><a href="about:blank#5.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">5.文件类型</a></p>
<p><a href="about:blank#%3C5%3ELinux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">&lt;5&gt;Linux<br>用户权限管理</a></p>
<p><a href="about:blank#1.Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F">1.Ubuntu 用户系统</a></p>
<p><a href="about:blank#2.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">2.权限管理</a></p>
<p><a href="about:blank#3.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">3.权限管理命令</a></p>
<p><a href="about:blank#1%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chmod">1、权限修改命令<br>chmod</a></p>
<p><a href="about:blank#2%E3%80%81%E6%96%87%E4%BB%B6%E5%BD%92%E5%B1%9E%E8%80%85%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4%20chown">2、文件归属者修改命令<br>chown</a></p>
<p><a href="about:blank#%3C6%3ELinux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86">&lt;6&gt;Linux<br>磁盘管理</a></p>
<p><a href="about:blank#1.Linux%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.Linux<br>磁盘管理基本概念</a></p>
<p><a href="about:blank#2.%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2.磁盘管理命令</a></p>
<p><a href="about:blank#1%E3%80%81%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20fdisk">1、磁盘分区命令<br>fdisk</a></p>
<p><a href="about:blank#2%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%91%BD%E4%BB%A4%20mkfs">2、格式化命令<br>mkfs</a></p>
<p><a href="about:blank#3%E3%80%81%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4%20mount">3、挂载分区命令<br>mount</a></p>
<p><a href="about:blank#4%E3%80%81%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4%20umount">4、卸载命令<br>umount</a></p>
<p><a href="about:blank#3.Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8">3.Linux C<br>编程入门</a></p>
<p><a href="about:blank#%3C1%3E%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">&lt;1&gt;编写代码</a></p>
<p><a href="about:blank#%3C2%3E%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">&lt;2&gt;编译代码</a></p>
<p><a href="about:blank#%3C3%3EGCC%20%E7%BC%96%E8%AF%91%E5%99%A8">&lt;3&gt;GCC 编译器</a></p>
<p><a href="about:blank#1%E3%80%81gcc%20%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">1、gcc<br>命令格式如下：</a></p>
<p><a href="about:blank#2%E3%80%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B">2、编译流程</a></p>
<p><a href="about:blank#%3C4%3EMakefile%20%E5%9F%BA%E7%A1%80">&lt;4&gt;Makefile 基础</a></p>
<p><a href="about:blank#1%E3%80%81Makefile%20%E7%AE%80%E4%BB%8B">1、Makefile 简介</a></p>
<p><a href="about:blank#2%E3%80%81Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5">2、Makefile 的引入</a></p>
<p><a href="about:blank#3%E3%80%81Makefile%20%E8%AF%AD%E6%B3%95">3、Makefile 语法</a></p>
<p><a href="about:blank#%E2%91%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F">①Makefile<br>规则格式</a></p>
<p><a href="about:blank#%E2%91%A1Makefile%20%E5%8F%98%E9%87%8F">②Makefile 变量</a></p>
<p><a href="about:blank#%E2%91%A2Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">③Makefile<br>模式规则</a></p>
<p><a href="about:blank#%E2%91%A3Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F">④Makefile<br>自动化变量</a></p>
<p><a href="about:blank#%E2%91%A4Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87">⑤Makefile 伪目标</a></p>
<p><a href="about:blank#%E2%91%A5Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">⑥Makefile<br>条件判断</a></p>
<p><a href="about:blank#%E2%91%A6Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">⑦Makefile<br>函数使用</a></p>
<hr>
<p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p>
<h2 id="一-Ubuntu-系统入门"><a href="#一-Ubuntu-系统入门" class="headerlink" title="一.Ubuntu 系统入门"></a>一.Ubuntu 系统入门</h2><pre><code>    在虚拟机上安装 Ubuntu 操作系统，安装好以后 Ubuntu 的设置、基本操作。想详细的学习 Ubuntu 系统的话可以参考《鸟哥的 linux 私房菜》这本书使用的 CentOS 操作系统，但是 Ubuntu 下完全可以使用。当 Ubuntu 系统入门以后，我们重点要学的就是如何在 Linux 下进行 C 语言开发，如何 使用 gcc 编译器、如何编写 Makefile 文件等等。如果此前已经使用过 Ubuntu 操作系统，并且从事过 Linux C 编程工作的话本篇就不需要看了。
</code></pre>
<h3 id="1-VMware-创建虚拟机流程"><a href="#1-VMware-创建虚拟机流程" class="headerlink" title="1.VMware 创建虚拟机流程"></a>1.VMware 创建虚拟机流程</h3><h3 id="2-Ubuntu-系统入门"><a href="#2-Ubuntu-系统入门" class="headerlink" title="2.Ubuntu 系统入门"></a>2.Ubuntu 系统入门</h3><pre><code>    本章的主要目的是教会读者掌握后续嵌入式开发所需的 Ubuntu 基本技能，比如**系统的基本设置、常用的 shell 命令、vim 编辑器的基本操作** 等等，如果想详 细的学习 Ubuntu 操作系统请参考其它更为详细的书籍，本章参考了《Ubuntu Linux 从入门到 精通》
</code></pre>
<h4 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="&lt;1&gt;Shell 命令"></a>&lt;1&gt;Shell 命令</h4><pre><code>    将多个 Shell 命令按照一定的格式放到一个文本中，那么这个文本就叫做 Shell 脚本。严格意义上来讲，Shell 是一个应用程序，它负责接收用户输入的命令，然后根据命令做出相应的动作，**Shell 负责将应用层或者用户输入的命令传递给系统内核，由操作系统内核来完成相应的工作，然后将结果反馈给应用层或者用户。**
</code></pre>
<p><strong>Shell 命令的格式</strong> 如下：</p>
<pre><code>command -options [argument]
</code></pre>
<p><strong>command</strong> : Shell 命令名称。</p>
<p><strong>options</strong> ：选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。</p>
<p><strong>argument</strong> ：Shell 命令是可以带参数的，也可以不带参数运行。</p>
<pre><code>    Shell 命令是**支持自动补全功能** 的，因为 Shell 命令非常多，如果不作自动补全的话就需要用户去记忆这些命令的全部字母。使用自动补全功能以后我们只需要输入命令的前面一部分字母，然后按下 **TAB 键** ，如果只有一个命令匹配的话就会自动补全这个命令剩下的字母。
</code></pre>
<p><strong>常用 Shell 命令：</strong></p>
<h5 id="1、目录信息查看命令-ls"><a href="#1、目录信息查看命令-ls" class="headerlink" title="1、目录信息查看命令 ls"></a><strong>1、目录信息查看命令 ls</strong></h5><pre><code>ls [选项] [路径]
主要参数有：
-a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。
-l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。
-t 将文件按照创建时间排序列出。
-A 和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。
-R 递归列出所有文件，包括子目录中的文件。

    Shell 命令里面的参数是可以组合在一起用的，比如组合“-al”就是显示所有文件的详细 信息，包括以“.”开头的隐藏文件。
</code></pre>
<h5 id="2、目录切换命令-cd"><a href="#2、目录切换命令-cd" class="headerlink" title="2、目录切换命令 cd"></a><strong>2、目录切换命令 cd</strong></h5><pre><code>cd [路径]
示例：
cd / //进入到根目录“/”下，Linux 系统的根目录为“/”,
cd /usr //进入到目录“/usr”里面。
cd .. //进入到上一级目录。
cd ~ //切换到当前用户主目录
</code></pre>
<h5 id="3、当前路径显示命令-pwd"><a href="#3、当前路径显示命令-pwd" class="headerlink" title="3、当前路径显示命令 pwd"></a><strong>3、当前路径显示命令 pwd</strong></h5><h5 id="4、系统信息查看命令-uname"><a href="#4、系统信息查看命令-uname" class="headerlink" title="4、系统信息查看命令 uname"></a><strong>4、系统信息查看命令 uname</strong></h5><pre><code>uname [选项]
可选的选项参数如下：
-r 列出当前系统的具体内核版本号。
-s 列出系统内核名称。
-o 列出系统信息。
</code></pre>
<h5 id="5、清屏命令-clear"><a href="#5、清屏命令-clear" class="headerlink" title="5、清屏命令 clear"></a><strong>5、清屏命令 clear</strong></h5><h5 id="6、切换用户执行身份命令-sudo"><a href="#6、切换用户执行身份命令-sudo" class="headerlink" title="6、切换用户执行身份命令 sudo"></a><strong>6、切换用户执行身份命令 sudo</strong></h5><pre><code>    Ubuntu(Linux)是一个允许多用户的操作系统，其中权限最大的就是**超级用户 root** ，有时候 我们执行一些操作的时候是需要用 root 用户身份才能执行，比如安装软件。通过 sudo 命令可以使我们暂时将身份切换到 root 用户。当使用 sudo 命令的时候是需要输入密码的，这里要注 意输入密码的时候是没有任何提示的！命令格式如下：


sudo [选项] [命令]
选项主要参数如下：
-h 显示帮助信息。
-l 列出当前用户可执行与不可执行的命令
-p 改变询问密码的提示符。

    假如我们现在要**创建一个新的用户 test** ，创建新用户的命令为“**adduser** ”，创建新用户的权限只有 root 用户才有，我们在装系统的时候创建的那个用户是没有这个权限的，比如我的 “zuozhongkai”用户。所以创建新用户的话需要使用“sudo”命令以 root 用户执行“adduser” 这个命令，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c242489236851475c5f139aaf39a0d35.png"></p>
<h5 id="7、添加用户命令-adduser"><a href="#7、添加用户命令-adduser" class="headerlink" title="7、添加用户命令 adduser"></a><strong>7、添加用户命令 adduser</strong></h5><pre><code>adduser [参数] [用户名]
常用的参数如下：
-system 添加一个系统用户
-home DIR DIR 表示用户的主目录路径
-uid ID ID 表示用户的 uid。
-ingroup GRP 表示用户所属的组名。
</code></pre>
<h5 id="8、删除用户命令-deluser"><a href="#8、删除用户命令-deluser" class="headerlink" title="8、删除用户命令 deluser"></a><strong>8、删除用户命令 deluser</strong></h5><pre><code>deluser [参数] [用户名]
主要参数有：
-system 当用户是一个系统用户的时候才能删除。
-remove-home 删除用户的主目录
-remove-all-files 删除与用户有关的所有文件。
-backup 备份用户信息
</code></pre>
<h5 id="9、切换用户命令-su"><a href="#9、切换用户命令-su" class="headerlink" title="9、切换用户命令 su"></a><strong>9、切换用户命令 su</strong></h5><pre><code>    **命令“su” 可以直接将当前用户切换为 root 用户** ，切换到 root 用户以后获得系统最高权限，在 root 用户下，所有的命令都可以无障碍执行，不需要在 前面加上“sudo”，“su”命令格式如下：


su [选项] [用户名]
常用选项参数如下：
-c –command 执行指定的命令，执行完毕以后回复原用户身份。
-login 改变用户身份，同时改变工作目录和 PATH 环境变量。
-m 改变用户身份的时候不改变环境变量
-h 显示帮助信息
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/06fd80a8ca5c2c4e5ad67b6fd8deac4c.png"></p>
<pre><code>    使用命令“sudo su”切换到 root 用户，su 命令不写明用户名的话默认 切换到 root 用户。然后输入密码，密码正确的话就会切换到 root 用户，可以看到切换到 root 用户以后提示符的“@”符号前面的用户名变成了“root”，表示当前的用户是 root 用户。并 且以“#”结束。

    注意！！由于 **root 用户权限太大，稍微不注意就可能删除掉系统文件，导致系统奔溃** ， 因此强烈建议大家，**不要以 root 用户运行 Ubuntu** 。当要用到 root 身份执行某些命令的时候使用“sudo”命令即可。

    要**切换回原来的用户** ，使用命令“**sudo su 用户名** ”即可。
</code></pre>
<h5 id="10、显示文件内容命令-cat"><a href="#10、显示文件内容命令-cat" class="headerlink" title="10、显示文件内容命令 cat"></a><strong>10、显示文件内容命令 cat</strong></h5><pre><code>cat [选项] [文件]
选项主要参数如下：
-n 由 1 开始对所有输出的行进行编号。
-b 和-n 类似，但是不对空白行编号。
-s 当遇到连续两个行以上空白行的话就合并为一个行空白行。
</code></pre>
<h5 id="11、显示和配置网络属性命令-ifconfig"><a href="#11、显示和配置网络属性命令-ifconfig" class="headerlink" title="11、显示和配置网络属性命令 ifconfig"></a><strong>11、显示和配置网络属性命令 ifconfig</strong></h5><pre><code>ifconfig interface options | address
主要参数如下：
interface 网络接口名称，比如 eth0 等。
up 开启网络设备。
down 关闭网络设备。
add IP 地址，设置网络 IP 地址。
netmask add 子网掩码。


    在图中有两个网卡：ens33 和 lo，ens33 是我的电脑实际使用的网卡，lo 是回测网 卡。可以看出网卡 ens33 的 IP 地址为 192.168.31.235，我们使用命令“ifconfig”将网卡 ens33 的 IP 地址改为 192.168.31.20，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7f7e119e714d7803c899b06b145c47c7.png"></p>
<h5 id="12、系统帮助命令-man"><a href="#12、系统帮助命令-man" class="headerlink" title="12、系统帮助命令 man"></a><strong>12、系统帮助命令 man</strong></h5><pre><code>man [命令名]
</code></pre>
<p>按“q”键退出到终端。</p>
<h5 id="13、-系统重启命令-reboot"><a href="#13、-系统重启命令-reboot" class="headerlink" title="13、 系统重启命令 reboot"></a><strong>13、 系统重启命令 reboot</strong></h5><h5 id="14、系统关闭命令-poweroff"><a href="#14、系统关闭命令-poweroff" class="headerlink" title="14、系统关闭命令 poweroff"></a><strong>14、系统关闭命令 poweroff</strong></h5><h5 id="15、软件安装命令-install"><a href="#15、软件安装命令-install" class="headerlink" title="15、软件安装命令 install"></a><strong>15、软件安装命令 install</strong></h5><pre><code>格式如下：
install [选项]... [-T] 源文件 目标文件
或：install [选项]... 源文件... 目录
或：install [选项]... -t 目录 源文件...
或：install [选项]... -d 目录...

    截至目前，我们都没有讲过 Ubuntu 下如何安装软件，因为 Ubuntu 安装软件不像 Windows 下那样，直接双击.exe 文件就开始安装了。Ubuntu 下很多软件是需要**先自行下载源码** ，下载源码以后**自行编译** ，**编译完成以后使用命令“intsall”来安装** 。当然 Ubuntu 下也有其它的软件安装方法，但是用的最多的就是自行编译源码然后安装，尤其是嵌入式Linux开发。

    “install”命令是将文件(通常是编译后的文件)**复制到目的位置** ，在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录中同时设置其所有权和权限模式。在第四种形式会创建指定的目录。命令“install”通常和命令“apt-get”组合在一起使用的。
</code></pre>
<h4 id="APT-下载工具"><a href="#APT-下载工具" class="headerlink" title="&lt;2&gt;APT 下载工具"></a>&lt;2&gt;APT 下载工具</h4><pre><code>    对于长时间使用 Windows 的我们，下载安装软件非常容易，Windows 下有很多的下载软 件，Ubuntu 同样有不少的下载软件，本节我们讲解 Ubuntu 下我们用的最多的下载工具：APT 下载工具，APT 下载工具可以实现软件**自动下载、配置、安装二进制或者源码** 的功能。APT 下载工具和我们前面讲解的“install”命令结合在一起构成了 Ubuntu 下最常用的下载和安装软件方法。它解决了 Linux 平台下一安装软件的一个缺陷，即**软件之间相互依赖** 。

    APT 采用的 **C/S 模式** ，也就是**客户端/服务器模式** ，我们的 PC 机作为客户端，当需要下载软件的时候就向服务器请求，因此我们需要知道服务器的地址，也叫做安装源或者更新源。
</code></pre>
<p>打开“软件和更新”设置，打开方式如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/523881d52264434de75ee6b79f8c8361.png"></p>
<pre><code>    在上图中的“Ubuntu 软件”选项卡下面的“下载自”就是 **APT 工具的安装源** ，因为我们是在中国，所以需要选择中国的服务器，否则的话可能会导致下载失败！这个也就是网上说的 Ubuntu 安装成功以后要更新源。

    在我们使用 APT 工具下载安装或者更新软件的时候，首先会在下载列表中**与本机软件对比** ，看一下需要下载哪些软件，或者升级哪些软件，默认情况下 APT 会下载最新的软件包， 被安装的软件包**所依赖的其它软件也会被下载安装** 。说了这么多，APT 下载工具究竟怎么用呢？APT 工具常用的命令如下：
</code></pre>
<h5 id="1、更新本地数据库"><a href="#1、更新本地数据库" class="headerlink" title="1、更新本地数据库"></a><strong>1、更新本地数据库</strong></h5><pre><code>sudo apt-get update
</code></pre>
<p>这个命令会<strong>访问源地址，并且获取软件列表</strong> 并保存在本电脑上。如果想查看<strong>本地哪些软件可以更新</strong> 的话可以使用如下命令。</p>
<h5 id="2、检查依赖关系"><a href="#2、检查依赖关系" class="headerlink" title="2、检查依赖关系"></a><strong>2、检查依赖关系</strong></h5><pre><code>sudo apt-get check

    有时候本地某些软件可能存在依赖关系，所谓依赖关系就是 A 软件依赖于 B 软件。通过 如下命令可以查看依赖关系，如果存在依赖关系的话 APT 会提出解决方案。
</code></pre>
<h5 id="3、软件安装"><a href="#3、软件安装" class="headerlink" title="3、软件安装"></a><strong>3、软件安装</strong></h5><pre><code>sudo apt-get install package-name
</code></pre>
<p>注：<strong>推荐使用 apt 替代 apt-get</strong></p>
<h5 id="4、软件更新"><a href="#4、软件更新" class="headerlink" title="4、软件更新"></a><strong>4、软件更新</strong></h5><pre><code>sudo apt-get upgrade package-name
</code></pre>
<h5 id="5、卸载软件"><a href="#5、卸载软件" class="headerlink" title="5、卸载软件"></a><strong>5、卸载软件</strong></h5><pre><code>sudo apt-get remove package-name
</code></pre>
<h4 id="Ubuntu-下文本编辑"><a href="#Ubuntu-下文本编辑" class="headerlink" title="&lt;3&gt;Ubuntu 下文本编辑"></a>&lt;3&gt;Ubuntu 下文本编辑</h4><pre><code>    Ubuut 下有一个自带的文本编辑器，那就是 Gedit。Gedit 是一个窗口式的编辑器，本节我们重点讲解的是另外一 个编辑器：VI/VIM 编辑器。

    我们如果要在**终端模式下进行文本编辑** 或者修改文件就可以使用 VI/VIM 编辑器，Ubuntu 自带了 VI 编辑器。VIM 编辑 器是 VI 编辑器升级版本，VI/VIM 编辑器都是一种**基于指令式的编辑器** ，不需要鼠标，也没有菜单，仅仅**使用键盘来完成所有的编辑** 工作。
</code></pre>
<p>安装 VIM 编辑器，命令如下：</p>
<pre><code>sudo apt-get install vim

    VIM 编辑器有 3 中工作模式：**输入模式、指令 模式和底行模式** ，通过切换不同的模式可以完成不同的功能。

    打开终端，输入命令：vi test.txt 。在终端中输入上图中所示的命令以后就会创建一个 test.txt 文档，并且用 VIM 打开了。VIM **默认是以只读模式打开的文档** ，因此我们要**切换到输入模式** ，切换到输入模式的命令如下：


i 在当前光标所在字符的前面，转为输入模式
I 在当前光标所在行的行首转换为输入模式
a 在当前光标所在字符的后面，转为输入模式
A 在光标所在行的行尾，转换为输入模式
o 在当前光标所在行的下方，新建一行，并转为输入模式
O 在当前光标所在行的上方，新建一行，并转为输入模式
s 删除光标所在字符。 r 替换光标处字符

    但是不能使用快捷键 Ctrl+S 来保存，这是因为在 Ubuntu 下 Ctrl+S 快捷 键不是用来完成保存的功能的，而是暂停该终端！所以你一旦在使用终端的时候按下 Ctrl+S 快捷键，那么你的终端肯定不会再有任何反应，如果你按下 **Ctrl+S 关闭了当前终端可以 按下 Ctrl+Q 来重新打开终端** 。

    我们需要从 VIM 现在的**输入模式切换到指令模式** ，方式就是按下键盘的 **ESC** 键

    指令模式顾名思义就是输入指令的模式，这些 指令是控制文本的指令，我们将这些指令进行分类，如下所示：


1、移动光标指令：
h(或左方向键) 光标左移一个字符。
l(或右方向键) 光标右移一个字符。
j(或下方向键) 光标下移一行。
k(或上方向键) 光标上移一行。
nG 光标移动到第 n 行首。
n+ 光标下移 n 行。
n- 光标上移 n 行。

2、屏幕翻滚指令
Ctrl+f 屏幕向下翻一页，相当于下一页。
Ctrl+b 屏幕向上翻一页，相当于上一页。

3、复制、删除和粘贴指令
cc 删除整行，并且修改整行内容。
dd 删除改行，不提供修改功能。
ndd 删除当前行向下 n 行。
x 删除光标所在的字符。
X 删除光标前面的一个字符。
nyy 复制当前行及其下面 n 行。
p 粘贴最近复制的内容。

    保存文档的命令是在**底行模式** 中，我们要先进入到指令模式，进入底行模式的方式是**先进入指令模式 下，然后在指令模式下输入“：”进入底行模式**
</code></pre>
<p>常用的命令如下：</p>
<pre><code>x 保存当前文档并且退出。
q 退出。
w 保存文档。
q! 退出 VI/VIM，不保存文档。
</code></pre>
<p>如果我们要退出并保存文本的话需要在“：”底行模式下输入“wq”</p>
<pre><code>    还可以 在指令模式下**输入“/”进入底行模式** ，在“/”后面输入要**搜索** 的内容，然后按下回车键就会找到与字符串匹配的部分
</code></pre>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="&lt;4&gt;文件系统"></a>&lt;4&gt;文件系统</h4><pre><code>    Linux 有多种文件系统，不同的文件系统支持不同的体系。文件系统是管理数 据的，而可以存储数据的物理设备有硬盘、U 盘、SD 卡、NAND FLASH、NOR FLASH、网 络存储设备等。不同的存储设备其物理结构不同，不同的物理结构就需要不同的文件系统去管 理，比如管理 NAND FLASH 的话使用 YAFFS 文件系统，管理硬盘、SD 卡的话就是 ext 文件 系统等等。

    Windows 下一般有 FAT、NTFS 和 exFAT 这些文件系统。同样的，在 Linux 下我们使用 fdisk 创建好分区以后也是要先在创建好的分区 上面创建文件系统，也就是格式化。 在 Windows 下有磁盘分区的概念，比如 C，D，E 盘等，在 Linux 下没有这个概念，因此 Linux 下你找不到像 C、D、E 盘这样的东西。前面我们说了 Linux 下可以给磁盘分割，在 Linux 下创建一个分区并且格式化好以后我们要将 其“挂载”到一个目录下才能访问这个分区。Windows 的文件系统挂载过程是其内部完成的， 用户是看不到的，Linux 下我们使用 mount 命令来挂载磁盘。挂载磁盘的时候是需要确定挂载 点的，也就是你的这个磁盘要挂载到哪个目录下。

    Linux 下的文件系统主要有 ext2、ext3、ext4 等文件系统。Linux 还支持其 他的 UNIX 文件系统，比如 XFS、JFS、UFS 等，也支持 Windows 的 FAT 文件系统和网络文 件系统 NFS 等。这里我们主要讲一下 Linux 自带的 ext2、ext3 和 ext4 文件系统。
</code></pre>
<p>在终端中输入如下命令来查询当前磁盘挂载的是什么文件系统：</p>
<pre><code>df -T –h
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5e5c67fe02fe10eb124ecd486b2765bb.png"></p>
<h5 id="1-Linux-文件系统结构"><a href="#1-Linux-文件系统结构" class="headerlink" title="1.Linux 文件系统结构"></a>1.Linux 文件系统结构</h5><pre><code>    Linux 只有一个根目录“/”。Ubuntu 是支持多用户的，Ubuntu 为每个用户创建了一个根目录，只要你创建了一个用户，那么系统就会在/home 这个目录下创建一个以这个用户名命名的文件 夹，这个文件夹就是这个用户的根目录。
</code></pre>
<p>我们来看一下根目录“&#x2F;”中的 一些重要的文件夹：</p>
<pre><code>/bin 存储一些二进制可执行命令文件，/usr/bin 也存放了一些基于用户的命令文件。
/sbin 存储了很多系统命令，/usr/sbin 也存储了许多系统命令。
/root 超级用户 root 的根目录文件。
/home 普通用户默认目录，在该目录下，每个用户都有一个以本用户名命名的文件夹。
/boot 存放 Ubuntu 系统内核和系统启动文件。
/mnt 通常包括系统引导后被挂载的文件系统的挂载点。
/dev 存放设备文件，我们后面学习 Linux 驱动主要是跟这个文件夹打交道的。
/etc 保存系统管理所需的配置文件和目录。
/lib 保存系统程序运行所需的库文件，/usr/lib 下存放了一些用于普通用户的库文件。
/lost+found 一般为空，当系统非正常关机以后，此文件夹会保存一些零散文件。
/var 存储一些不断变化的文件，比如日志文件
/usr 包括与系统用户直接有关的文件和目录，比如应用程序和所需的库文件。
/media 存放 Ubuntu 系统自动挂载的设备文件。
/proc 虚拟目录，不实际存储在磁盘上，通常用来保存系统信息和进程信息。
/tmp 存储系统和用户的临时文件，该文件夹对所有的用户都提供读写权限。
/opt 可选文件和程序的存放目录。
/sys 系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。
</code></pre>
<h5 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2.文件操作命令"></a>2.文件操作命令</h5><h6 id="1、创建新文件命令—touch"><a href="#1、创建新文件命令—touch" class="headerlink" title="1、创建新文件命令—touch"></a><strong>1、创建新文件命令—touch</strong></h6><pre><code>touch [参数] [文件名]
使用 touch 创建文件的时候，如果[文件名]的文件不存在，那就直接创建一个以[文件名]
命名的文件，如果[文件名]文件存在的话就仅仅修改一下此文件的最后修改日期，常用的命令
参数如下：
-a 只更改存取时间。
-c 不建立任何文件。
-d&lt;日期&gt; 使用指定的日期，而并非现在日期。
-t&lt;时间&gt; 使用指定的时间，而并非现在时间。
</code></pre>
<h6 id="2、文件夹创建命令—mkdir"><a href="#2、文件夹创建命令—mkdir" class="headerlink" title="2、文件夹创建命令—mkdir"></a>2、文件夹创建命令—mkdir</h6><pre><code>mkdir [参数] [文件夹名目录名]
主要参数如下：
-p 如所要创建的目录其上层目录目前还未创建，那么会一起创建上层目录。
</code></pre>
<h6 id="3、文件及目录删除命令—rm"><a href="#3、文件及目录删除命令—rm" class="headerlink" title="3、文件及目录删除命令—rm"></a>3、文件及目录删除命令—rm</h6><pre><code>    要删除一个文件或者文件夹可以使用 命令“rm”，此命令可以完成删除一个文件或者多个文件及文件夹，它可以实现递归删除。 对于链接文件，只删除链接，原文件保持不变，所谓的链接文件，其实就是 Windows 下的快 捷方式文件，此命令格式如下：


rm [参数] [目的文件或文件夹目录名]
命令主要参数如下：
-d 直接把要删除的目录的硬连接数据删成 0，删除该目录。
-f 强制删除文件和文件夹(目录)。
-i 删除文件或者文件夹(目录)之前先询问用户.
-r 递归删除，指定文件夹(目录)下的所有文件和子文件夹全部删除掉。
-v 显示删除过程。

    直接使用命令“rm”是无法删除文件夹(目录)的，我们需要加上 参数“-rf”，也就是强制递归删除文件夹(目录)
</code></pre>
<h6 id="4、文件夹-目录-删除命令—rmdir"><a href="#4、文件夹-目录-删除命令—rmdir" class="headerlink" title="4、文件夹(目录)删除命令—rmdir"></a>4、文件夹(目录)删除命令—rmdir</h6><p>它可以不加任何参数的删除掉指定的文件夹(目 录)，命令格式如下：</p>
<pre><code>rmdir [参数] [文件夹(目录)]
命令主要参数如下：
-p 删除指定的文件夹(目录)以后，若上层文件夹(目录)为空文件夹(目录)的话就将其一起
删除。
</code></pre>
<h6 id="5、文件复制命令—cp"><a href="#5、文件复制命令—cp" class="headerlink" title="5、文件复制命令—cp"></a>5、文件复制命令—cp</h6><pre><code>cp [参数] [源地址] [目的地址]
主要参数描述如下：
-a 此参数和同时指定“-dpR”参数相同
-d 在复制有符号连接的文件时，保留原始的连接。
-f 强行复制文件，不管要复制的文件是否已经存在于目标目录。
-I 覆盖现有文件之前询问用户。
-p 保留源文件或者目录的属性。
-r 或-R递归处理，将指定目录下的文件及子目录一并处理
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fdd2b97a66de0166f090b556b64996c4.png"></p>
<pre><code>    通配符“*”，“*.c”就表示 test1 下的所有以“.c”结尾的文件，也就是 a.c 和 b.c。“../test2”中的“../”表示上级目录，因此“../test2”就是上级目录下的 test2 文件夹。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9edd7298f52909aee3caad55eb8418d.png"></p>
<h6 id="6、文件移动命令—mv"><a href="#6、文件移动命令—mv" class="headerlink" title="6、文件移动命令—mv"></a>6、文件移动命令—mv</h6><pre><code>mv [参数] [源地址] [目的地址]
主要参数描述如下：
-b 如果要覆盖文件的话覆盖前先进行备份。
-f 若目标文件或目录与现在的文件重复，直接覆盖目标文件或目录。
-I 在覆盖之前询问用户。
</code></pre>
<h5 id="3-文件压缩和解压缩"><a href="#3-文件压缩和解压缩" class="headerlink" title="3.文件压缩和解压缩"></a>3.文件压缩和解压缩</h5><p>Ubuntu 下图形化以及命 令行这两种压缩和解压缩操作:</p>
<h6 id="1、图形化压缩和解压缩"><a href="#1、图形化压缩和解压缩" class="headerlink" title="1、图形化压缩和解压缩"></a>1、图形化压缩和解压缩</h6><p>在要压缩或者解压的文件上点击鼠标右键， 然后选择要进行的操作——压缩&#x2F;提取</p>
<h6 id="2、命令行进行文件的压缩和解压缩"><a href="#2、命令行进行文件的压缩和解压缩" class="headerlink" title="2、命令行进行文件的压缩和解压缩"></a>2、命令行进行文件的压缩和解压缩</h6><p>命令行下进行压缩和解压缩常用的命令有三个：zip、unzip 和 tar：</p>
<h6 id="①命令-zip"><a href="#①命令-zip" class="headerlink" title="①命令 zip"></a>①命令 zip</h6><p>zip 命令是针对.zip 文件的，用于将一个或者多个文件压缩成一个.zip 结尾的文件，格式如下：</p>
<pre><code>zip [参数] [压缩文件名.zip] [被压缩的文件]
主要参数函数如下：
-b&lt;工作目录&gt; 指定暂时存放文件的目录。
-d 从 zip 文件中删除一个文件。
-F 尝试修复已经损毁的压缩文件。
-g 将文件压缩入现有的压缩文件中，不需要新建压缩文件。
-h 帮助。
-j 只保存文件的名，不保存目录。
-m 压缩完成以后删除源文件。
-n&lt;字尾符号&gt; 不压缩特定扩展名的文件。
-q 不显示压缩命令执行过程。
-r 递归压缩，将指定目录下的所有文件和子目录一起压缩。
-v 显示指令执行过程。
-num 压缩率，为 1~9 的数值。
</code></pre>
<p>使用 zip 命令进行 test2 文件夹的压缩，我们使用的命令如下： zip -rv test2.zip test2</p>
<h6 id="②命令-unzip"><a href="#②命令-unzip" class="headerlink" title="②命令 unzip"></a>②命令 unzip</h6><pre><code>unzip [参数] [压缩文件名.zip]
主要参数如下：
-l 显示压缩文件内所包含的文件。
-t 检查压缩文件是否损坏，但不解压。
-v 显示命令显示的执行过程。
-Z 只显示压缩文件的注解。
-C 压缩文件中的文件名称区分大小写。
-j 不处理压缩文件中的原有目录路径。
-L 将压缩文件中的全部文件名改为小写。
-n 解压缩时不要覆盖原有文件。
-P&lt;密码&gt; 解压密码。
-q 静默执行，不显示任何信息。
-x&lt;文件列表&gt; 指定不要处理.zip 中的哪些文件。
-d&lt;目录&gt; 把压缩文件解到指定目录下。
</code></pre>
<h6 id="③命令-tar"><a href="#③命令-tar" class="headerlink" title="③命令 tar"></a>③命令 tar</h6><pre><code>    Linux 下最常用的.bz2 和.gz 这两种压缩格式。其它格式的压缩和解压使用 命令 tar，tar 将压缩和解压缩集合在一起，使用不同的参数即可，命令格式如下：


tar [参数] [压缩文件名] [被压缩文件名]
常用参数如下：
-c 创建新的压缩文件。
-C&lt;目的目录&gt; 切换到指定的目录。
-f&lt;备份文件&gt; 指定压缩文件。
-j 用 tar 生成压缩文件，然后用 bzip2 进行压缩。
-k 解开备份文件时，不覆盖已有的文件。
-m 还原文件时，不变更文件的更改时间。
-r 新增文件到已存在的备份文件的结尾部分。
-t 列出备份文件内容。
-v 显示指令执行过程。
-w 遭遇问题时先询问用户。
-x 从备份文件中释放文件，也就是解压缩文件。
-z 用 tar 生成压缩文件，用 gzip 压缩。
-Z 用 tar 生成压缩文件，用 compress 压缩。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e5e7cf4b3d0a2d1d46d57f90bd86a38.png"></p>
<p>在上面命令中，-vcjf 表示创建 bz2 格式的压缩文件，-vczf 表示创建.gz 格式的压缩文 件。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cac42b4dab88584feb7f441772bd694.png"></p>
<pre><code>    上述两行命令中，-vxjf 用来完成.bz2 格式压缩文件的解压，-vxzf 用来完成.gz 格式压缩文 件的解压。要熟练掌握使用 tar 命令来完成.bz2 和.gz 格式的文件压缩和解压缩。
</code></pre>
<h5 id="4-文件查询和搜索"><a href="#4-文件查询和搜索" class="headerlink" title="4.文件查询和搜索"></a>4.文件查询和搜索</h5><pre><code>    在嵌入式 Linux 开发中常常需要在 Linux 源码文件中查询某个**文件是否存在** ，或者搜索哪些文件都**调用了某个函数** 等等。本节我们就讲解两个最 常用的文件查询和搜索命令：**find** 和 **grep** 。
</code></pre>
<h6 id="1、命令-find"><a href="#1、命令-find" class="headerlink" title="1、命令 find"></a>1、命令 find</h6><p>find 命令用于在目录结构中查找文件，其命令格式如下：</p>
<pre><code>find [路径] [参数] [关键字]
路径是要查找的目录路径，如果不写的话表示在当前目录下查找，关键字是文件名的一部
分，主要参数如下：
-name&lt;filename&gt; 按照文件名称查找，查找与 filename 匹配的文件，可使用通配符。
-depth 从指定目录下的最深层的子目录开始查找。
-gid&lt;群组识别码&gt; 查找符合指定的群组识别码的文件或目录。
-group&lt;群组名称&gt; 查找符合指定的群组名称的文件或目录。
-size&lt;文件大小&gt; 查找符合指定文件大小的文件。
-type&lt;文件类型&gt; 查找符合指定文件类型的文件。
-user&lt;拥有者名称&gt;查找符合指定的拥有者名称的文件或目录。
find 命令的参数有很多，常用的就这些，关于其它的参数大家可以自行上网查找
</code></pre>
<h6 id="2、命令-grep"><a href="#2、命令-grep" class="headerlink" title="2、命令 grep"></a>2、命令 grep</h6><pre><code>    **在文件中搜索一串关键字** ，grep 就是完 成这个功能的，grep 命令用于查找包含指定关键字的文件，如果发现某个文件的内容包含所指 定的关键字，grep 命令就会把包含指定关键字的这一行标记出来，grep 命令格式如下：


grep [参数] 关键字 文件列表
grep 命令一次只能查一个关键字，主要参数如下：
-b 在显示符合关键字的那一列前，标记处该列第 1 个字符的位编号。
-c 计算符合关键字的列数。
-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用此参数！否则 grep 指令将回
报信息并停止搜索。
-i 忽略字符大小写。
-v 反转查找，只显示不匹配的行。
-r 在指定目录中递归查找。
</code></pre>
<h5 id="5-文件类型"><a href="#5-文件类型" class="headerlink" title="5.文件类型"></a>5.文件类型</h5><p>使用命令“ls -l”来查看用户根目录下所有文件的详细信息</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9775c00441c48eb60dac4172e8a138aa.png"></p>
<p>在上图中，每个文件的详细信息占一行，每行最前面都是一个符号就标记了当前文件类型， 比如 test1 的第一个字符是“d”，test1.tar.bz2<br>文件第一个字符是“-”。这些字符表示的文件类型如下：</p>
<pre><code>- 普通文件，一些应用程序创建的，比如文档、图片、音乐等等。
d 目录文件。
c 字符设备文件，Linux 驱动里面的字符设备驱动，比如串口设备，音频设备等。
b 块设备文件，存储设备驱动，比如硬盘，U 盘等。
l 符号连接文件，相当于 Windwos 下的快捷方式。
s 套接字文件。
p 管道文件，主要指 FIFO 文件。
</code></pre>
<p>后面学习 <strong>Linux 驱动开发</strong> 的时候基本是在和<strong>字符设备文件</strong> 和<strong>块设备文件</strong> 打交道。</p>
<h4 id="Linux-用户权限管理"><a href="#Linux-用户权限管理" class="headerlink" title="&lt;5&gt;Linux 用户权限管理"></a>&lt;5&gt;Linux 用户权限管理</h4><h6 id="1-Ubuntu-用户系统"><a href="#1-Ubuntu-用户系统" class="headerlink" title="1.Ubuntu 用户系统"></a>1.Ubuntu 用户系统</h6><pre><code>    装系统的时候创建的用户其权限比后面创建的用户大一点，但是没有 root 用户权限大， Ubuntu 下用户类型分为以下 3 类：
</code></pre>
<p>● 初次创建的用户，此用户可以完成比普通用户更多的功能。</p>
<p>● root 用户，系统管理员，拥有所有权利。</p>
<p>● 普通用户，安装完操作系统以后被创建的用户。</p>
<pre><code>    以上三种用户，每个用户都有一个 ID 号，称为 UID，操作系统通过 UID 来识别是哪个用 户，用户相关信息可以在文件/etc/passwd 中查看到
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/771a5136f3710899083fa41699d937ad.png"></p>
<pre><code>    从配置文件 passwd 中可以看到，每个用户名后面都有两个数字，比如用户“zuozhongkai” 后面“1000:1000”，第一个数字是用户的 ID，另一个是用户的 GID，也就是用户组 ID。Ubuntu 里面每个用户都属于一个用户组里面，用户组就是一组有相同属性的用户集合。
</code></pre>
<h6 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h6><pre><code>    对于嵌入式开发一般不关注**用户的权限问题** ，因为嵌入式基本是单用户，做嵌入式开发重点关注的是**文件的权限问题** 。 对于一个文件通常有三种权限：**读(r)、写(w)和执行(x)** ，使用命令“**ls -l** ”可以查看某个目 录下所有文件的权限信息，如：


-rw-rw-r-- 1 zuozhongkai zuozhongkai 0 12 月 25 20:44 test.c

    其中“-rw-rw-r--”表示**文件权限与用户和用户组之间的关系** ，第一位表示文件类型，上一 小节已经说了。剩下的 9 位**以 3 位为一组** ，**分别表示文件拥有者的权限，文件拥有者所在用户组的权限以及其它用户权限** 。后面的**“zuozhongkai zuozhongkai”分别代表文件拥有者(用户) 和该用户所在的用户组** ，因此文件 test.c 的权限情况如下：

    ①、文件 test.c 的拥有者是用户 zuozhongkai，其对文件 tesst.c 的权限是“rw-”，也就是 对该文件拥有读和写两种权限。

    ②、用户 zuozhongkai 所在的用户组也叫做 zuozhongkai，其组内用户对于文件 test.c 的权 限是“rw-”，也是拥有读和写这两种权限。         

    ③、其它用户对于文件 test.c 的权限是“r--”，也就是只读权限。 对于文件，可读权限表示可以打开查看文件内容，可写权限表示可以对文件进行修改，可执行权限就是可以运行此文件(如果是软件的话)。对于文件夹，拥有可读权限才可以使用命令 ls 查看文件夹中的内容，**拥有可执行权限才能进入到文件夹内部** 。

    除了用 r、w 和 x 表示以外， 我们也可以使用二进制数表示，三种权限就可以使用 3 位二进制数来表示，一种权限对应一个 二进制位，如果该位为 1 就表示具备此权限，如果该位为 0 就表示没不具备此权限，如下表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f81b8eae64f7d2e4f654d3232de0e342.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/15a31e64d77cb241198b539487d3ea6c.png"></p>
<pre><code>    前面的文件 test.c 其权限为“rw-rw-r--”，因此其十进制表示就是：664。

    另外我们也开始使用 a、u、g 和 o 表示文件的归属关系，用=、+和-表示文件权限的变化， 如下表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3ca28a83c1229c2b850b18f568c0c362.png"></p>
<pre><code>    对于文件 test.c，我们想要修改其归属用户(zuozhongkai)对其拥有可执行权限，那么就可以 使用：u+x。如果希望设置归属用户及其所在的用户组都对其拥有可执行权限就可以使用：gu+x。
</code></pre>
<h6 id="3-权限管理命令"><a href="#3-权限管理命令" class="headerlink" title="3.权限管理命令"></a>3.权限管理命令</h6><pre><code>    可以使用 Shell 来操作文件的权限管理，主要用到“chmod”和“chown”这两个命令：
</code></pre>
<h6 id="1、权限修改命令-chmod"><a href="#1、权限修改命令-chmod" class="headerlink" title="1、权限修改命令 chmod"></a>1、权限修改命令 chmod</h6><pre><code>    命令“chmod”用于修改**文件或者文件夹的权限** ，权限可以使用前面讲的数字表示也可以 使用字母表示，命令格式如下：


chmod [参数] [文件名/目录名]
主要参数如下：
-c 效果类似“-v”参数，但仅回显更改的部分。
-f 不显示错误信息。
-R 递归处理，指定目录下的所有文件及其子文件目录一起处理。
-v 显示指令的执行过程。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3045966479f706fd2acc5cde644c1850.png"></p>
<pre><code>    在上图中，我们修改文件 test 的权限为 766，修改完成以后的 test 文件权限为“rwxrw-rw-”， 和我们设置的一样，说明权限修改成功。上面我们是通过数字来修改权限的，我们接下来使用字母来修改权限，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6bd35ca1b6e1e1629e108c746630441f.png"></p>
<pre><code>    上面两个例子都是修改文件的权限，接下来我们修改文件夹的权限，新建一个 test 文件夹， 在文件夹 test 里面创建 a.c、b.c 和 c.c 三个文件，test 文件夹下的文件 a.c、b.c 和 c.c 的权限均为“rw-rw-r--”，我们将 test 文件夹 下的所有文件权限都改为“rwxrwxrwx”，也就是数字 777，操作如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f7b16b3540313a758a86add48c277a8.png"></p>
<h6 id="2、文件归属者修改命令-chown"><a href="#2、文件归属者修改命令-chown" class="headerlink" title="2、文件归属者修改命令 chown"></a>2、文件归属者修改命令 chown</h6><p>命令 chown 用来修改某个文件或者目录的归属者用户或者用户组，命令格式如下：</p>
<pre><code>chown [参数] [用户名.&lt;组名&gt;] [文件名/目录]
其中[用户名.&lt;组名&gt;]表示要将文件或者目录改为哪一个用户或者用户组，用户名和组名用
“.”隔开，其中用户名和组名中的任何一个都可以省略，命令主要参数如下：
-c 效果同-v 类似，但仅回显更改的部分。
-f 不显示错误信息。
-h 只对符号连接的文件做修改，不改动其它任何相关的文件。
-R 递归处理，将指定的目录下的所有文件和子目录一起处理。
-v 显示处理过程。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7241a6cc8931d0f72cc27bb10effe8c.png"></p>
<h4 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="&lt;6&gt;Linux 磁盘管理"></a>&lt;6&gt;Linux 磁盘管理</h4><h5 id="1-Linux-磁盘管理基本概念"><a href="#1-Linux-磁盘管理基本概念" class="headerlink" title="1.Linux 磁盘管理基本概念"></a>1.Linux 磁盘管理基本概念</h5><pre><code>    Linux 的磁盘管理体系和 Windows 有很大的区别，在 Windows 下经常会遇到“分区”这个概念，在 Linux 中一般不叫“分区”而叫**“挂载点”** 。 “挂载点”就是将一个硬盘的一部 分做成文件夹的形式，这个文件夹的名字就是“挂载点”，不管在哪个发行版的 Linux 中，用 户是绝对看到不到 C 盘、D 盘这样的概念的，只能看到以文件夹形式存在的“挂载点”。
</code></pre>
<p>文件&#x2F;etc&#x2F;fstab 详细的记录了 Ubuntu 中硬盘分区的情况：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a3bc3e97a3d219def7e1c541dbed467.png"></p>
<pre><code>    “/ was on /dev/sda1 during installation”，意思是根目录“/”是在/dev/sda1 上的，其中“/”是挂载点，**“/dev/sda1”就是我们装 Ubuntu 系统的硬盘** 。由于我们的系统是安装在虚拟机中的，因此图 中没有出现实际的硬盘。可以通过如下命令查看当前系统中的磁盘：


ls /dev/sd*
</code></pre>
<p>上述命令就是打印出所有以&#x2F;dev&#x2F;sd 开头的设备文件</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cec4bbd0cada4073445feeeb68007f2f.png"></p>
<pre><code>    在图中有四个磁盘设备文件，其中**sd 表示是 SATA 硬盘或者其它外部设备** ，最后面的数字表示该**硬盘上的第 n 个分区** ，比如/dev/sda1 就表示磁盘 sda 上的第一个分区。图中都是以/dev/sda 开头的，说明当前只有一个硬盘。如果再插上 U 盘、SD 卡啥的就可能会出 现/dev/sdb，/dev/sdc 等等。如果你的 U 盘有两个分区那么可能就会出现/dev/sdb1、dev/sdb2 这 样的设备文件。比如我现在插入我的 U 盘，插入 U 盘会提示 U 盘是接到主机还是虚拟机
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7293b9ea5d13716ed4cf99bf1a73f2a0.png"></p>
<h5 id="2-磁盘管理命令"><a href="#2-磁盘管理命令" class="headerlink" title="2.磁盘管理命令"></a>2.磁盘管理命令</h5><h6 id="1、磁盘分区命令-fdisk"><a href="#1、磁盘分区命令-fdisk" class="headerlink" title="1、磁盘分区命令 fdisk"></a>1、磁盘分区命令 fdisk</h6><p>如果要对某个磁盘进行分区，可以使用命令 fdisk，命令格如下：</p>
<pre><code>fdisk [参数]
主要参数如下：
-b&lt;分区大小&gt; 指定每个分区的大小。
-l 列出指定设备的分区表。
-s&lt;分区编号&gt; 将指定的分区大小输出到标准的输出上，单位为块。
-u 搭配“-l”参数，会用分区数目取代柱面数目，来表示每个分区的起始地址。

    比如我要对 U 盘进行分区，**千万不要对自己装 Ubuntu 系统进行分区！！！** 可以使用如下命令：


sudo fdisk /dev/sdb
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b79740fbfb552d056496462ceab27102.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42ca5bc370ae284b9d794f1b74a1eff.png"></p>
<p>p 显示现有的分区</p>
<p>n 建立新分区</p>
<p>t 更改分区类型</p>
<p>d 删除现有的分区</p>
<p>a 更改分区启动标志</p>
<p>w 对分区的更改写入到硬盘或者存储器中</p>
<p>q 不保存退出</p>
<h6 id="2、格式化命令-mkfs"><a href="#2、格式化命令-mkfs" class="headerlink" title="2、格式化命令 mkfs"></a>2、格式化命令 mkfs</h6><pre><code>    使用命令 fdisk 创建好一个分区以后，我们需要对其格式化，也就是在这个分区上创建一 个文件系统，Linux 下的格式化命令为 mkfs，命令格式如下：


mkfs [参数] [-t 文件系统类型] [分区名称]
主要参数如下：
fs 指定建立文件系统时的参数
-V 显示版本信息和简要的使用方法。
-v 显示版本信息和详细的使用方法。
</code></pre>
<p>比如我们要格式化 U 盘的分区&#x2F;dev&#x2F;sdb1 为 FAT 格式，那么就可以使用如下命令：</p>
<pre><code>mkfs –t vfat /dev/sdb1
</code></pre>
<h6 id="3、挂载分区命令-mount"><a href="#3、挂载分区命令-mount" class="headerlink" title="3、挂载分区命令 mount"></a>3、挂载分区命令 mount</h6><pre><code>    我们需要将/dev/sdb1 这个**分区挂载到一个文件夹中，然后通过这个文件访问 U 盘** ， 磁盘挂载命令为 mount，命令格式如下：


mount [参数] -t [类型] [设备名称] [目的文件夹]
命令主要参数有：
-V 显示程序版本。
-h 显示辅助信息。
-v 显示执行过程详细信息。
-o ro 只读模式挂载。
-o rw 读写模式挂载。
-s-r 等于-o ro。
-w 等于-o rw。


    一般我们把挂载点放到“/mnt” 目录下，在“/mnt”下创建一个 tmp 文件夹，然后将 U 盘的/dev/sdb1 分区挂载到/mnt/tmp 文 件夹里面，操作如图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07d3a057fe42131964d315015bc0a845.png"></p>
<h6 id="4、卸载命令-umount"><a href="#4、卸载命令-umount" class="headerlink" title="4、卸载命令 umount"></a>4、卸载命令 umount</h6><pre><code>    当我们不在需要访问已经挂载的 U 盘，可以通过 umount 将其从卸载点卸除，命令格式如下：


umount [参数] -t [文件系统类型] [设备名称]
-a 卸载/etc/mtab 中的所有文件系统。
-h 显示帮助。
-n 卸载时不要将信息存入到/etc/mtab 文件中
-r 如果无法成功卸载，则尝试以只读的方式重新挂载。
-t &lt;文件系统类型&gt; 仅卸载选项中指定的文件系统。
-v 显示执行过程。

    上面我们将 U 盘挂载到了文件夹/mnt/tmp 里面，这里我们使用命令 umount 将其卸载掉， 操作如图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4d8dc86df68eec73b0027777819655.png"></p>
<h3 id="3-Linux-C-编程入门"><a href="#3-Linux-C-编程入门" class="headerlink" title="3.Linux C 编程入门"></a>3.Linux C 编程入门</h3><pre><code>    Ubuntu 下也有一些可以进行编程的工具，但是大多都只是编辑 器，也就是只能进行代码编辑，如果要编译的话就需要用到 **GCC 编译器** ，使用 GCC 编译器 肯定就要接触到 **Makefile** 。本章就讲解如何在 Ubuntu 下进行 C 语言的编辑和编译、GCC 和 Makefile 的使用和编写。

    代码编写工具很多，比如 VIM 编辑器、Emacs 编辑器、VScode 编辑器等等，本教程使用 Ubuntu 自带的 VIM 编辑器。
</code></pre>
<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="&lt;1&gt;编写代码"></a>&lt;1&gt;编写代码</h4><p>首先设置 TAB 键为 4 字节</p>
<pre><code>    VI 编辑器默认 TAB 键为 8 空格，我们改成 4 空格，用 vi 打开文件/etc/vim/vimrc，在此文件最后面输入如下代码：


set ts=4
</code></pre>
<p>接着设置 VIM 编辑器显示行号：</p>
<pre><code>set nu
</code></pre>
<p>然后使用vim编写代码保存。</p>
<h4 id="编译代码"><a href="#编译代码" class="headerlink" title="&lt;2&gt;编译代码"></a>&lt;2&gt;编译代码</h4><p>Ubuntu 下的 C 语言编译器是 GCC，GCC 编译器在我们安装 Ubuntu 的时候就已经默认安 装好了，可以通过如下命令查看 GCC<br>编译器的版本号：</p>
<pre><code>gcc -v

    如果输入命令“gcc -v”命令以后，你的终端输出信息，那么说明你 的电脑已经有 GCC 编译器了。最后下面的“gcc version 5.4.0”说明本机的 GCC 编译器版本为 5.4.0 的。注意观察在图 3.1.2.1 中有**“Target: x86_64-linux-gnu”** 一行，这说明 Ubuntu 自带的 GCC 编译器是针对 X86 架构的，因此只能编译在 X86 架构 CPU 上运行的程序。如果想要编译在 ARM 上运行的程序就需要针对 ARM 架构的 GCC 编译器，也就是**交叉编译器** ！我们进行 ARM 开发，因此肯定要安装**针对 ARM 架构的 GCC 交叉编译器** ，当然了，这是后面的事， 现在我们不用管这些，只要知道不同的目标架构，其 GCC 编译器是不同的。

    如何使用 GCC 编译器来编译 main.c 文件呢？GCC 编译器是命令模式的，因此需要输入命 令来使用 gcc 编译器来编译文件，输入如下命令：


gcc main.c -o main

    我们使用“gcc main.c –o main”来编译 main.c 文件，使用参数“-o”来指 定编译生成的可执行文件名字。
</code></pre>
<h4 id="GCC-编译器"><a href="#GCC-编译器" class="headerlink" title="&lt;3&gt;GCC 编译器"></a>&lt;3&gt;GCC 编译器</h4><h5 id="1、gcc-命令格式如下："><a href="#1、gcc-命令格式如下：" class="headerlink" title="1、gcc 命令格式如下："></a>1、gcc 命令格式如下：</h5><pre><code>gcc [选项] [文件名字]
主要选项如下：
-c 只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。
-o&lt;输出文件名&gt; 用来指定编译结束以后的输出文件名，如果不使用这个选项的话 GCC
默认编译出来的可执行文件名字为 a.out。
-g 添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编
译的时候生成调试所需的符号信息。
-O 对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进
行优化，这样产生的可执行文件执行效率就高。
-O2 比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。
</code></pre>
<h5 id="2、编译流程"><a href="#2、编译流程" class="headerlink" title="2、编译流程"></a>2、编译流程</h5><pre><code>    GCC 编译器的编译流程是：**预处理、汇编、编译和链接** 。预处理就是对程序中的宏定义等相关的内容先进行前期的处理。汇编是先将 C 文件转换为汇编文件。当 C 文件转换为汇编文件以后就是文件编译了，**编译过程就是将 C 源文件编译成.o 结尾的目标文件** 。编译生成的.o 文件不能直接执行，而是需要最后的链接，如果你的工程有很多个 c 源文件的话最终就会有很多.o 文件，将这些**.o 文件链接在一起形成完整的一个可执行文件** 。
</code></pre>
<h4 id="Makefile-基础"><a href="#Makefile-基础" class="headerlink" title="&lt;4&gt;Makefile 基础"></a>&lt;4&gt;Makefile 基础</h4><h6 id="1、Makefile-简介"><a href="#1、Makefile-简介" class="headerlink" title="1、Makefile 简介"></a>1、Makefile 简介</h6><pre><code>    当文件数量很多时用终端输入 GCC 命令的方法显然是不现实的。编写一个文件，这个文件描述了编译哪些源码文件、如何编译，每次需要编译工程的时只需要使用这个文件就行了，为此提出了一个 解决**大工程编译的工具** ：**Make** ，**描述哪些文件需要编译、哪些需要重新编译的文件** 就叫做 **Makefile** ，Makefile 就跟脚本文件一样，Makefile 里面还可以执行系统命令。使用的时候只需要一个 make 命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。如果大家以 前一直使用 IDE 来编写 C 语言的话肯定没有听说过 Makefile 这个东西，其实这些 IDE 是有的， 只不过这些 **IDE 对其进行了封装** ，提供给大家的是已经经过封装后的图形界面了，我们在 IDE 中添加要编译的 C 文件，然后点击按钮就完成了编译。在 Linux 下用的最多的是 GCC 编译器， 这是个没有 UI 的编译器，因此 Makefile 就需要我们自己来编写了。作为一个专业的程序员， 是一定要懂得 Makefile 的，一是因为在 Linux 下你不得不懂 Makefile，再就是通过 Makefile 你就能了解整个工程的处理过程。如果想详细的研究 Makefile，推荐阅读《跟我一起写 Makefile》这份文档。
</code></pre>
<h6 id="2、Makefile-的引入"><a href="#2、Makefile-的引入" class="headerlink" title="2、Makefile 的引入"></a>2、Makefile 的引入</h6><pre><code>    我们完成这样一个小工程，在这个工程中我们有 main.c、input.c 和 calcu.c 这三个 C 文件和 input.h、calcu.h 这两个头文件。其中 main.c 是主体。接下来使用 gcc 的方法来对其进行编译， 在终端输入如下命令：


gcc main.c calcu.c input.c -o main

   如果有一个文件被修改了，使用上面的命令编译的时候所有的文件都会重新编译。最好的办法肯定是哪个文件被修改了，只编译这个修改的文件即可，其它没有修改的文件就不需要再次重新编译了，为此我们改变我们的编译方法，如果第一次编译工程，我们先将工程中的文件都编译一遍，然后后面修改了哪个文件就编译哪个文件， 命令如下：


gcc -c main.c
gcc -c input.c
gcc -c calcu.c
gcc main.o input.o calcu.o -o main

    上述命令前三行分别是将 main.c、input.c 和 calcu.c 编译成对应的.o 文件，所以使用了“-c” 选项，**“-c”选项我们上面说了，是只编译不链接** 。最后一行命令是将编译出来的所有.o 文件链接成可执行文件 main。假如我们现在修改了 calcu.c 这个文件，**只需要将 caclue.c 这一个文 件重新编译成.o 文件，然后再将所有的.o 文件链接成可执行文件** ，只需要下面两条命令即可：


gcc -c calcu.c
gcc main.o input.o calcu.o -o main

    但是这样就又有一个问题，如果修改的文件一多，会非常麻烦，为此我们需要这样一个工具：
</code></pre>
<p>1、如果工程没有编译过，那么工程中的所有.c 文件都要被编译并且链接成可执行程序。</p>
<p>2、如果工程中只有个别 C 文件<strong>被修改</strong> 了，那么<strong>只编译这些被修改的 C 文件即可</strong> 。</p>
<p>3、如果工程的<strong>头文件被修改了，那么我们需要编译所有引用这个头文件的 C 文件</strong> ，并且 链接成可执行文件。</p>
<pre><code>    很明显，能够完成这个功能的就是 Makefile 了，在工程目录下创建名为“Makefile”的文件， 文件名**一定要叫做“Makefile”！！！区分大小写** ！

    Makefile 和 C 文件可以处于同一个目录的，在 Makefile 文件中输入如下代码：


main: main.o input.o calcu.o
    gcc -o main main.o input.o calcu.o
main.o: main.c
    gcc -c main.c
input.o: input.c
    gcc -c input.c
calcu.o: calcu.c
    gcc -c calcu.c

clean:
    rm *.o
    rm main

    上述代码中所有行首需要空出来的地方一定要**使用“TAB”键！不要使用空格键！** 这是 Makefile 的语法要求。**（可以看出这里的Makefile文件类似于脚本，把所有文件编译指令集合）**

    Makefile 编写好以后我们就可以使用 Make 命令来编译我们的工程了，直接在命令行中输 入“make”即可，Make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在 的话就会按照 Makefile 里面定义的编译方式进行编译。

    使用命令“Make”编译完成以后就会在当前工程目录下生成各种.o 和可执行文件，说明我们编译成功了。使用 make 命令编译工程的时候可能会提示如图所示错误:
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/272c8273e54202132793b1944a9cab74.png"></p>
<p>错误来源一般有两点:</p>
<p>1、Makefile 中命令缩进没有使用 TAB 键！</p>
<p>2、VI&#x2F;VIM 编辑器使用空格代替了 TAB 键，修改文件&#x2F;etc&#x2F;vim&#x2F;vimrc，在文件最后面加上 如下所示代码：</p>
<pre><code>set noexpandtab

    之后再输入make指令只会重新编译被修改的文件和最后的可执行文件，其它没有修改过的文件就没有编译。
</code></pre>
<h6 id="3、Makefile-语法"><a href="#3、Makefile-语法" class="headerlink" title="3、Makefile 语法"></a>3、Makefile 语法</h6><h6 id="①Makefile-规则格式"><a href="#①Makefile-规则格式" class="headerlink" title="①Makefile 规则格式"></a>①Makefile 规则格式</h6><p>Makefile 里面是由一系列的<strong>规则</strong> 组成的，这些规则格式如下：</p>
<pre><code>目标…... : 依赖文件集合……
    命令 1
    命令 2
    ……
</code></pre>
<p>比如下面这条规则：</p>
<pre><code>main : main.o input.o calcu.o
    gcc -o main main.o input.o calcu.o


    这条规则的**目标** 是 main，main.o、input.o 和 calcu.o 是生成 main 的**依赖文件** ，如果要更新 目标 main，就必须要先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目 标也必须更新，“更新”就是执行一遍规则中的**命令列表** 。

    命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ make 命令会为 Makefile 中的每个**以 TAB 开始的命令创建一个 Shell 进程去执行** 。

    在之前的代码中一共有 5 条规则，1~2 行为第一条规则，3~4 行为第二条规则，5~6 行为第三 条规则，7~8 行为第四条规则，10~12 为第五条规则，make 命令在执行这个 Makefile 的时候其执行步骤如下：

   **  首先更新第一条规则中的 main**，第一条规则的目标成为**默认目标** ，**只要默认目标更新了那么就完成了 Makefile 的工作** ，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行。

    第一条规则依赖于文件 main.o、input.o 和 calcu.o 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make 会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为**“gcc –c main.c”** ，这行命令很熟悉了 吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。

    最后一个规则目标是 clean， 它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令**“make clean”** ，**执行以后就会删除当前目录下所有的.o 文件以及 main** ，因此 clean 的功能就是完成**工程的清理** 。
</code></pre>
<p>我们在来总结一下 Make 的执行过程：</p>
<ol>
<li><p>make 命令会在当前目录下查找以 Makefile(makefile 其实也可以)命名的文件。</p>
</li>
<li><p>当找到 Makefile 文件以后就会<strong>按照 Makefile 中定义的规则去编译</strong> 生成最终的目标文件。</p>
</li>
<li><p>当发现目标文件<strong>不存在</strong> ，或者目标<strong>所依赖的文件比目标文件新</strong>(也就是最后修改时间比目标文件晚)的话就会<strong>执行后面的命令来更新目标</strong> 。</p>
<pre><code> **除了 Makefile 的“终极目标”所在的规则以外，其它规则的顺序在 Makefile 中是没有意义的** ，“终极目标”就是指在使用 make 命令的时候没有指定具体的目标时，make 默认的那个目标，它是 Makefile 文件中**第一个规则** 的目标，如果 Makefile 中的第一个规则有多个目标， 那么这些目标中的**第一个目标** 就是 make 的“终极目标”。
</code></pre>
</li>
</ol>
<h6 id="②Makefile-变量"><a href="#②Makefile-变量" class="headerlink" title="②Makefile 变量"></a>②Makefile 变量</h6><p>跟 C 语言一样 Makefile 也支持变量的，先看一下前面的例子：</p>
<pre><code> main: main.o input.o calcu.o
     gcc -o main main.o input.o calcu.o

    上述 Makefile 语句中，main.o input.o 和 calcue.o 这三个依赖文件，我们输入了两遍，我们 这个 Makefile 比较小，如果 Makefile 复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile 加入了**变量支持** 。Makefile 中的变量都是**字符串** ！**类似 C 语言中的宏** 。使用变量将上面的代码修改，修改以后如下所示：


#Makefile 变量的使用
objects = main.o input.o calcu.o
main: $(objects)
    gcc -o main $(objects)

    第 1 行是注释，Makefile 中可以写注释，**注释开头要用符号“#”** ，第 2 行我们定义了一个变量 objects， 并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行使用到了变 量 objects，Makefile 中**变量的引用方法是“$(变量名)”** ，比如本例中的“$(objects)”就是使用 变量 objects。

    在“示例代码中我们在定义变量 objects 的时候使用**“=”** 对其进行了赋值，Makefile 变量的赋值符还有其它两个**“:=”和“?=”** ，我们来看一下这三种赋值符的区别：
</code></pre>
<p><strong>1、赋值符“&#x3D;”</strong></p>
<pre><code>    使用“=”在给变量的赋值的时候，**不一定要用已经定义好的值，也可以使用后面定义的值** ，比如如下代码：


name = zzk
curname = $(name)
name = zuozhongkai

print:
	@echo curname: $(curname)

    我们来分析一下上述代码，第 1 行定义了一个变量 name，变量值为“zzk”，第 2 行也定义了一个变量 curname，curname 的变量值引用了变量 name，按照我们 C 写语言的经验此时 curname 的值就是“zzk”。第 3 行将变量 name 的值改为了“zuozhongkai”，第 5、6 行是输 出变量 curname 的值。在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf” 一样，第 6 行中的“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，**在命令前面加上“@”的话就不会输出命令执行过程** ，大家可以测试一下不加“@” 的效果。使用命令**“make print”** 来执行上述代码。借助另外一个变量，可以将变量的真实值推到后面去定义。也就是**变量的真实值取决于它所引用的变量的最后一次有效值** 。
</code></pre>
<p><strong>2、赋值符“:&#x3D;”</strong></p>
<pre><code>    修改上述代码第 2 行，将 其中的“=”改为“:=”。此时的 curname 是 zzk，不是 zuozhongkai 了。这是因为**赋值符“:=” 不会使用后面定义的变量** ，只能使用前面已经定义好的，这就是“=”和“:=”两个的区别。
</code></pre>
<p><strong>3、赋值符“?&#x3D;”</strong></p>
<pre><code>    **如果变量 curname 前面没有被赋值，那么此变量就是“zuozhongkai”** ， **如果前面已经赋过值了，那么就使用前面赋的值** 。
</code></pre>
<p><strong>4、变量追加“+&#x3D;”</strong></p>
<pre><code>    Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量**添加一些字符串进 去** ，此时就要使用到符号“+=”，比如如下所示代码：


    objects = main.o inpiut.o
    objects += calcu.o
</code></pre>
<p>一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此 变量 objects<br>变成了“main.o input.o calcu.o”，这个就是变量的追加。</p>
<h6 id="③Makefile-模式规则"><a href="#③Makefile-模式规则" class="headerlink" title="③Makefile 模式规则"></a>③Makefile 模式规则</h6><pre><code>    上述 Makefile 中第 3~8 行是将对应的.c 源文件编译为.o 文件，每一个 C 文件都要写一个对应的规则，如果工程中 C 文件很多的话显然不能这么做。为此，我们可以使用 Makefile 中的**模式规则** ，通过模式规则我们就可以**使用一条规则来将所有的.c 文件编译为对应的.o 文件** 。

    模式规则中，**至少在规则的目标定定义中要包涵“%”，否则就是一般规则** ，目标中的**“%” 表示对 文件名的匹配**，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾 的文件，**类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件** 。

    当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值，使用 方法如下：


%.o : %.c
    命令


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)

%.o : %.c
	#命令

clean:
	rm *.o 
	rm main

    修改以后的 Makefile 还不能运行，因为第 6 行的命令还没写，第 6 行的命令我们需要借助另外一种强大的变量—**自动化变量** 。
</code></pre>
<h6 id="④Makefile-自动化变量"><a href="#④Makefile-自动化变量" class="headerlink" title="④Makefile 自动化变量"></a>④Makefile 自动化变量</h6><pre><code>    上面讲的模式规则中，**目标和依赖都是一系列的文件** ，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而命令只有一行，如何通过一行命令来从不同的依赖文件中生成对应的目标呢？自动化变量就是完成这个功能的！所谓自动化变量就是这种变量会**把模式中所定义的一系列的文件自动的挨个取出** ，**直至所有的符合模式的文件都取完** ，自动化变量**只应该出现在规则的命令中** ，常用的自动化变量如表所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdafd022717f6cc1113bf86481167cbf.png"></p>
<pre><code>    表中的 7 个自动化变量中，常用的三种：**$@、$ &lt;和$^**，我们使用自动化变量来完 成“示例代码中的 Makefile，最终的完整代码如下所示：


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)

%.o : %.c
	gcc -c $&lt;
	
clean:
	rm *.o 
	rm main
</code></pre>
<h6 id="⑤Makefile-伪目标"><a href="#⑤Makefile-伪目标" class="headerlink" title="⑤Makefile 伪目标"></a>⑤Makefile 伪目标</h6><pre><code>    Makefile 有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而**伪目标不代表真正的目标名** ，在执行 make 命令的时候通过**指定这个伪目标来执行其所在规则的定义的命令** 。

    使用伪目标的主要是为了避免 Makefile 中定义的只**执行命令的目标 和工作目录下的实际文件出现名字冲突**，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面代码规则“clean”代码用来完成清理工程的功能。

    上述规则中并没有创建文件 clean 的命令，因此工作目录下永远都**不会存在文件 clean** ，当 我们输入**“make clean”** 以后，后面的“rm *.o”和“rm main”总是会执行。可是如果我们“手贱”，在工作目录下**创建一个名为“clean”的文件** ，那就不一样了，当执行“make clean”的 时候，**规则因为没有依赖文件，所以目标被认为是最新的，因此后面的 rm 命令也就不会执行** ， 我们预先设想的清理工程的功能也就无法完成。为了避免这个问题，我们可以将 clean 声明为 伪目标，声明方式如下：


.PHONY : clean


objects = main.o input.o calcu.o
main: $(objects)
	gcc -o main $(objects)
	
.PHONY : clean

%.o : %.c
	gcc -c $&lt;
	
clean:
	rm *.o 
	rm main

    上述代码第 5 行声明 clean 为伪目标，声明 clean 为伪目标以后不管当前目录下是否存在名为“clean”的文件，**输入 “make clean”的话规则后面的 rm 命令都会执行**。
</code></pre>
<h6 id="⑥Makefile-条件判断"><a href="#⑥Makefile-条件判断" class="headerlink" title="⑥Makefile 条件判断"></a>⑥Makefile 条件判断</h6><p>语法有两种如下：</p>
<pre><code>&lt;条件关键字&gt;
    &lt;条件为真时执行的语句&gt;
endif
以及：
&lt;条件关键字&gt;
    &lt;条件为真时执行的语句&gt;
else
    &lt;条件为假时执行的语句&gt;
endif

    其中条件关键字有 4 个：**ifeq、ifneq、ifdef 和 ifndef** ，这四个关键字其实分为两对、ifeq 与 ifneq、ifdef 与 ifndef，先来看一下 ifeq 和 ifneq，ifeq 用来判断是否相等，ifneq 就是判断是 否不相等，ifeq 用法如下：


ifeq (&lt;参数 1&gt;, &lt;参数 2&gt;)
ifeq ‘&lt;参数 1 &gt;’，‘&lt;参数 2&gt;’ 
ifeq “&lt;参数 1&gt;”，“&lt;参数 2&gt;”
ifeq “&lt;参数 1&gt;”，‘&lt;参数 2&gt;’
ifeq ‘&lt;参数 1&gt;’, “&lt;参数 2&gt;”

    上述用法中都是用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1” 和“参数 2”可以为函数返回值。ifneq 的用法类似，只不过 ifneq 是用来了比较“参数 1”和 “参数 2”是否不相等，如果不相等的话就为真。

    ifdef 和 ifndef 的用法如下：


ifndef &lt;变量名&gt;

    如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以 是一个函数的返回值。ifndef 用法类似，但是含义与 ifdef 相反。
</code></pre>
<h6 id="⑦Makefile-函数使用"><a href="#⑦Makefile-函数使用" class="headerlink" title="⑦Makefile 函数使用"></a>⑦Makefile 函数使用</h6><pre><code>    Makefile 支持函数，类似 C 语言一样，Makefile 中的函数是已经定义好的，我们直接使用， 不支持我们自定义函数。make 所支持的函数不多，但是绝对够我们使用了，函数的用法如下：


$(函数名 参数集合)
或者
$&#123;函数名 参数集合&#125;

    可以看出，**调用 函数和调用普通变量一样，使用符号“$”来标识**。参数集合是函数的多个参数，**参数之间以逗号“,”隔开** ，**函数名和参数之间以“空格”分隔开** ，函数的调用以“$” 开头。接下来我们介绍几个常用的函数，其它的函数大家可以参考《跟我一起写 Makefile》这份文档。
</code></pre>
<p><strong>1、函数 subst</strong></p>
<p>函数 subst 用来完成<strong>字符串替换</strong> ，调用形式如下：</p>
<pre><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)
</code></pre>
<p><strong>2、函数 patsubst</strong></p>
<p>函数 patsubst 用来完成<strong>模式字符串替换</strong> ，使用方法如下：</p>
<pre><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)


    此函数查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来  
</code></pre>
<p>替换掉，<pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换<br>后的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern><br>中的那个“%”所代表的字符串，比如：</pattern></replacement></replacement></pattern></p>
<pre><code>$(patsubst %.c,%.o,a.c b.c c.c)

    将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的 字符串为“a.o b.o c.o”。
</code></pre>
<p><strong>3、函数 dir</strong></p>
<p>函数 dir 用来获取目录，使用方法如下：</p>
<pre><code>$(dir &lt;names…&gt;

    此函数用来从文件名序列中提取出目录部分，返回值是文件名序列的目 录部分，比如：


$(dir &lt;/src/a.c&gt;)

    提取文件“/src/a.c”的目录部分，也就是“/src”。
</code></pre>
<p><strong>4、函数 notdir</strong></p>
<p>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：</p>
<pre><code>$(notdir &lt;names…&gt;)

    上个例子“dir”改成“notdir”结果是文件名“a.c”。
</code></pre>
<p><strong>5、函数 foreach</strong></p>
<p>foreach 函数用来完成循环，用法如下：</p>
<pre><code>$(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)

    此函数的意思就是把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;  
</code></pre>
<p>所包含的表达式。每次<text>都会返回一个字符串，循环的过程中，<text>中所包含的每个字<br>符串会以空格隔开，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串<br>将会是函数 foreach 函数的返回值。</text></text></text></p>
<p><strong>6、函数 wildcard</strong></p>
<pre><code>    通配符“%”只能用在规则中，只有在规则中它才会展开，**如果 在变量定义和函数使用时， 通配符不会自动展开，这个时候就要用到函数 wildcard**，使用方法如下：


$(wildcard PATTERN…)
</code></pre>
<p>比如：</p>
<pre><code>$(wildcard *.c)

    上面的代码是用来获取当前目录下所有的.c 文件，类似“%”。
</code></pre>
<h3 id="4-其他资料"><a href="#4-其他资料" class="headerlink" title="4.其他资料"></a>4.其他资料</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29235669" title="9个Linux系统常用监控命令">9个Linux系统常用监控命令<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://zhuanlan.zhihu.com/p/29235669</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/renfufei/article/details/105851728" title="Linux系统命令 - 查看内存使用情况">Linux系统命令 - 查看内存使用情况<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/renfufei/article/details/105851728</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131511658" title="图像识别小车（jetson nano部分）——电赛学习笔记（3）">图像识别小车（jetson nano部分）——电赛学习笔记（3）<img src="https://i-blog.csdnimg.cn/blog_migrate/003a2ce7eb50c2e24a8c624c260c5930.png" alt="icon-
default.png?t&#x3D;N7T8">https://blog.csdn.net/qq_32971095&#x2F;article&#x2F;details&#x2F;131511658</a></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133484963">https://blog.csdn.net/qq_32971095/article/details/133484963</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-title-link" itemprop="url">嵌入式Linux_Petalinux一——FPGA学习笔记＜？＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-01 19:39:59" itemprop="dateCreated datePublished" datetime="2023-10-01T19:39:59+08:00">2023-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="嵌入式Linux_Petalinux一——FPGA学习笔记＜？＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux_Petalinux%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">一.开发环境搭建</a></p>
<p><a href="about:blank#1.Ubuntu%20%E5%92%8C%20Windows%20%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0">1.Ubuntu 和 Windows<br>文件互传</a></p>
<p><a href="about:blank#1%E3%80%81%E5%BC%80%E5%90%AF%20Ubuntu%20%E4%B8%8B%E7%9A%84%20FTP%20%E6%9C%8D%E5%8A%A1">1、开启 Ubuntu 下的 FTP<br>服务</a></p>
<p><a href="about:blank#2%E3%80%81Windows%20%E4%B8%8B%20FTP%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85">2、Windows 下 FTP<br>客户端安装</a></p>
<p><a href="about:blank#2.Ubuntu%20%E5%92%8C%20Windows%20%E6%96%87%E4%BB%B6%E6%9C%AC%E5%9C%B0%E5%85%B1%E4%BA%AB">2.Ubuntu 和 Windows<br>文件本地共享</a></p>
<p><a href="about:blank#3.Ubuntu%20%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%20tftp%20%E6%9C%8D%E5%8A%A1%E5%99%A8">3.Ubuntu 系统搭建 tftp<br>服务器</a></p>
<p><a href="about:blank#4.Ubuntu%20%E4%B8%8B%20NFS%20%E5%92%8C%20SSH%20%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF">4.Ubuntu 下 NFS 和 SSH<br>服务开启</a></p>
<p><a href="about:blank#5.Source%20Insight%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">5.Source Insight<br>软件安装和使用</a></p>
<p><a href="about:blank#6.Visual%20Studio%20Code%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">6.Visual Studio Code<br>软件的安装和使用</a></p>
<p><a href="about:blank#7.SecureCRT%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">7.SecureCRT<br>软件安装和使用</a></p>
<p><a href="about:blank#8.Putty%20%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">8.Putty<br>软件的安装和使用</a></p>
<p><a href="about:blank#%E4%BA%8C.Petalinux%20%E7%9A%84%E5%AE%89%E8%A3%85">二.Petalinux<br>的安装</a></p>
<p><a href="about:blank#1.Petalinux%20%E7%AE%80%E4%BB%8B">1.Petalinux 简介</a></p>
<p><a href="about:blank#2.%E5%AE%89%E8%A3%85%C2%A0Petalinux">2.安装 Petalinux</a></p>
<p><a href="about:blank#1%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93%E4%BB%A5%E5%8F%8A%E8%BD%AF%E4%BB%B6">1、安装依赖库以及软件</a></p>
<p><a href="about:blank#2%E3%80%81%E4%BF%AE%E6%94%B9%20bash">2、修改 bash</a></p>
<p><a href="about:blank#3%E3%80%81%E5%AE%89%E8%A3%85%20Petalinux">3、安装 Petalinux</a></p>
<p><a href="about:blank#4%E3%80%81%E8%AE%BE%E7%BD%AE%20Petalinux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">4、设置 Petalinux<br>环境变量</a></p>
<p><a href="about:blank#5%E3%80%81Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%20JTAG%20cable%20%E9%A9%B1%E5%8A%A8">5、Linux 系统安装 JTAG cable<br>驱动</a></p>
<p><a href="about:blank#%E4%B8%89.Petalinux%20%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98">三.Petalinux<br>设计流程实战</a></p>
<p><a href="about:blank#1.Zynq%20UltraScale%2B%20MPSoC%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%A0%88%E6%A6%82%E8%BF%B0">1.Zynq UltraScale+ MPSoC<br>嵌入式软件栈概述</a></p>
<p><a href="about:blank#1%E3%80%81FSBL">1、FSBL</a></p>
<p><a href="about:blank#2%E3%80%81Platform%20Management%20Unit%20%28PMU%29%20Firmware">2、Platform Management Unit (PMU)<br>Firmware</a></p>
<p><a href="about:blank#3%E3%80%81ARM%20Trusted%20Firmware">3、ARM Trusted Firmware</a></p>
<p><a href="about:blank#4%E3%80%81U-Boot">4、U-Boot</a></p>
<p><a href="about:blank#5%E3%80%81Hypervisor%20%28Optional%EF%BC%8C%E5%8F%AF%E9%80%89%29">5、Hypervisor<br>(Optional，可选)</a></p>
<p><a href="about:blank#6%E3%80%81Linux">6、Linux</a></p>
<p><a href="about:blank#2.%E4%BD%BF%E7%94%A8%20Petalinux%20%E5%AE%9A%E5%88%B6%20Linux%20%E7%B3%BB%E7%BB%9F">2.使用 Petalinux 定制 Linux<br>系统</a></p>
<p><a href="about:blank#1%E3%80%81%E5%88%9B%E5%BB%BA%20Vivado%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0">1、创建 Vivado<br>硬件平台</a></p>
<p><a href="about:blank#2%E3%80%81%E8%AE%BE%E7%BD%AE%20Petalinux%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">2、设置 Petalinux<br>环境变量</a></p>
<p><a href="about:blank#3%E3%80%81%E5%88%9B%E5%BB%BA%20petalinux%20%E5%B7%A5%E7%A8%8B">3、创建 petalinux<br>工程</a></p>
<p><a href="about:blank#4%E3%80%81%E9%85%8D%E7%BD%AE%20petalinux%20%E5%B7%A5%E7%A8%8B">4、配置 petalinux<br>工程</a></p>
<p><a href="about:blank#5%E3%80%81%E9%85%8D%E7%BD%AE%20Linux%20%E5%86%85%E6%A0%B8">5、配置 Linux<br>内核</a></p>
<p><a href="about:blank#6%E3%80%81%E9%85%8D%E7%BD%AE%20Linux%20%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">6、配置 Linux<br>根文件系统</a></p>
<p><a href="about:blank#7%E3%80%81%E9%85%8D%E7%BD%AE%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6">7、配置设备树文件</a></p>
<p><a href="about:blank#8%E3%80%81%E7%BC%96%E8%AF%91%20Petalinux%20%E5%B7%A5%E7%A8%8B">8、编译 Petalinux<br>工程</a></p>
<p><a href="about:blank#9%E3%80%81%E5%88%B6%E4%BD%9C%20BOOT.BIN%20%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6">9、制作 BOOT.BIN<br>启动文件</a></p>
<p><a href="about:blank#10%E3%80%81%E5%88%B6%E4%BD%9C%20SD%20%E5%90%AF%E5%8A%A8%E5%8D%A1">10、制作 SD<br>启动卡</a></p>
<p><a href="about:blank#11%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%AE%BE%E7%BD%AE">11、开发板启动模式设置</a></p>
<hr>
<p>前置学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133484963" title="Linux系统——OS学习笔记＜1＞">Linux系统——OS学习笔记＜1＞</a></p>
<p>参考资料：正点原子《DFZU2EG_4EV MPSoC 之 Linux 驱动开发指南》</p>
<pre><code>     “PetaLinux 工具提供在 Xilinx 处理系统上定制、构建和调配嵌入式 Linux 解决方案所需的所有组件。该解决方案旨在提升设计生产力，可与 Xilinx 硬件设计工具配合使用，以简化针对 Versal、Zynq UltraScale MPSoC、Zynq 7000 SoC 和 MicroBlaze 的 Linux 系统开发。”
</code></pre>
<h2 id="一-开发环境搭建"><a href="#一-开发环境搭建" class="headerlink" title="一.开发环境搭建"></a>一.开发环境搭建</h2><pre><code>    要进行 ZYNQ MPSoC 开发肯定要先搭建好开发环境，我们在开始学习 STM32 的时候肯  
</code></pre>
<p>定需要安装一堆的软件，比如 MDK、IAR、串口调试助手等等，这个就是 STM32 的开发环境<br>搭建。同样的，要想在 Ubuntu 下进行 ZYNQ MPSoC 开发也需要安装一些软件，也就是网上<br>说的开发环境搭建，环境搭建好以后我们就可以进行开发了。环境搭建分为 Ubuntu 和 Windows，<br>因为我们最熟悉 Windows，所以代码编写、查找资料啥的肯定是在 Windows 下进行的。但是<br>Linux 开发又必须在 Ubuntu 下进行，所以还需要搭建 Ubuntu 下的开发环境。本章我们就分为<br>Ubuntu 和 Windows，讲解这两种操作系统下的环境搭建。</p>
<h3 id="1-Ubuntu-和-Windows-文件互传"><a href="#1-Ubuntu-和-Windows-文件互传" class="headerlink" title="1.Ubuntu 和 Windows 文件互传"></a>1.Ubuntu 和 Windows 文件互传</h3><p>Windows 和 Ubuntu 下的文件互传我们需要使用 FTP 服务，设置方法如下：</p>
<h4 id="1、开启-Ubuntu-下的-FTP-服务"><a href="#1、开启-Ubuntu-下的-FTP-服务" class="headerlink" title="1、开启 Ubuntu 下的 FTP 服务"></a>1、开启 Ubuntu 下的 FTP 服务</h4><p>打开 Ubuntu 的终端窗口，然后执行如下命令来安装 FTP 服务：</p>
<pre><code>sudo apt-get install vsftpd
</code></pre>
<p>等待软件自动安装，安装完成以后使用如下 VI 命令打开&#x2F;etc&#x2F;vsftpd.conf，命令如下：</p>
<pre><code>sudo vi /etc/vsftpd.conf
</code></pre>
<p>打开以后 vsftpd.conf 文件以后找到如下两行：</p>
<pre><code>local_enable=YES 
write_enable=YES
</code></pre>
<p>确保上面两行前面没有“#”，有的话就取消掉</p>
<h4 id="2、Windows-下-FTP-客户端安装"><a href="#2、Windows-下-FTP-客户端安装" class="headerlink" title="2、Windows 下 FTP 客户端安装"></a>2、Windows 下 FTP 客户端安装</h4><pre><code>    Windows 下 FTP 客户端我们使用 FileZilla。打开站点管理器，点击：文件-&gt;站点管理器。点击“新站点(N)”按钮来创建站点，新建站点以后就会在“我的站点”下出现新建的这个站点，站点的名称可以自行修改，比如我将新的站点命名为“Ubuntu”。选中新创建的“Ubuntu”站点，然后对站点的“常规”进行设置：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/02634e9c629de10763b97adf4cbd4ee5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7214388928d08a58386aaf640745d802.png"></p>
<pre><code>    如果要将 Windows 下的文件或文件夹拷贝到 Ubuntu 中，只需要在左侧的 Windows 区域选中要拷贝的文件或者文件夹，然后**直接拖到右侧** 的 Ubuntu 中指定的目录即可。 将 Ubuntu 中的文件或者文件夹拷贝到 Windows 中也是**直接拖放** 。
</code></pre>
<h3 id="2-Ubuntu-和-Windows-文件本地共享"><a href="#2-Ubuntu-和-Windows-文件本地共享" class="headerlink" title="2.Ubuntu 和 Windows 文件本地共享"></a>2.Ubuntu 和 Windows 文件本地共享</h3><pre><code>    Ubuntu 和 Windows 文件互传可以使用本地共享的方式。这种共享的方式极大的免除了不同系统文件 之间的文件复制和磁盘空间的双重占用。下面笔者将介绍如何使用 Vmware 虚拟机来实现 Ubuntu 和 Windows 文件之间的共享。

    在 Vmware 的菜单栏中，选择“设置(S)”，在弹出的菜单中，选择“选项”，在该界面中，单击“共享文件夹”，在右边界面中选择 “总是启用(E)”，添加共享的文件夹，默认勾选“启用此共享”。

    该文件夹在 Ubuntu 系统中对应的是**/mnt/hgfs/share/目录** ，我们在终端中输入命令：


ll /mnt/hgfs/share/
</code></pre>
<p>可以看到该文件夹为空。如果需要从 Ubuntu 系统向 Windows 传递文件，可 以用 cp 命令或 mv 命令文件到该目录。</p>
<h3 id="3-Ubuntu-系统搭建-tftp-服务器"><a href="#3-Ubuntu-系统搭建-tftp-服务器" class="headerlink" title="3.Ubuntu 系统搭建 tftp 服务器"></a>3.Ubuntu 系统搭建 tftp 服务器</h3><pre><code>    TFTP 作为一种**简单的文件传输协议** ，在嵌入式开发中会经常使用到，而且后面我们在**安装 Petalinux 工具时也会提示需要 tftp 服务** ，所以我们需要**在 Ubuntu 上搭建 TFTP 服务器** 。需要**安装 tftp-hpa（客户端软件包，如果不用可不装）和 tftpd-hpa 软件包** ，命令如下：


sudo apt install tftp-hpa tftpd-hpa

    TFTP 需要一个文件夹来存放文件，我们在根目录下新建一个/tftpboot 目录做为 TFTP 文 件存储目录，之所以使用该目录是因为后面使用的 Petalinux 工具默认使用该目录，省得我们 每次建 Petalinux 工程的时候手动修改。创建/tftpboot 目录命令如下：


sudo mkdir -p /tftpboot 
sudo chmod 777 /tftpboot

    这样笔者就在电脑上创建了一个名为 tftpboot 的目录(文件夹)，路径为/tftpboot。需要注意 的是我们要**给 tftpboot 文件夹权限，否则的话后面在使用过程中会遇到问题，所以使用了 chmod 777 命令** 。 最后配置 tftp。打开/etc/default/tftpd-hpa 文件，将其内容修改如下：


# /etc/default/tftpd-hp
                       
TFTP_USERNAME=&quot;tftp&quot;   
TFTP_DIRECTORY=&quot;/tftpbo
TFTP_ADDRESS=&quot;:69&quot;     
TFTP_OPTIONS=&quot;-l -c -s&quot;
</code></pre>
<p>最后输入如下命令，重启 tftp 服务器：</p>
<pre><code>sudo service tftpd-hpa restart
</code></pre>
<h3 id="4-Ubuntu-下-NFS-和-SSH-服务开启"><a href="#4-Ubuntu-下-NFS-和-SSH-服务开启" class="headerlink" title="4.Ubuntu 下 NFS 和 SSH 服务开启"></a>4.Ubuntu 下 NFS 和 SSH 服务开启</h3><pre><code>    后面进行 **Linux 驱动开发** 的时候**需要 NFS 启动** ，因此要先安装并开启 Ubuntu 中的 NFS 服务，使用如下命令安装 NFS 服务：


sudo apt install nfs-kernel-server
</code></pre>
<p>等待安装完成。安装完成以后在<strong>用户根目录</strong> 下创建一个名为“workspace&#x2F;nfs”的文件夹， 命令如下：</p>
<pre><code>cd
mkdir -p workspace/nfs
cd workspace/nfs
pwd
</code></pre>
<p>以后所有需要使用 nfs 的东西都放到这个“nfs”文件夹里面。</p>
<pre><code>    上面创建的 nfs 文件夹供 nfs 服务器使用，以后我们可以在开发板上**通过网络文件系统来访问 nfs 文件夹** 。

    使用前需要先**配置 nfs** 。NFS 允许挂载的目录及权限**在文件/etc/exports 中进行定义** ，使用 如下命令打开 nfs 配置文件/etc/exports，打开/etc/exports 以后在后面添加如下所示内容：


/home/&lt;用户名&gt;/workspace/nfs *(rw,sync,no_root_squash)


    * 代表允许所有的网络段访问，rw 是可读写权限，sync 是文件同步写入存储器，no_root_squash 是 nfs 客户端分享目录使用者的权限。如果客户端使用的是 root 用户，那么对于该共享目录而 言，该客户端就具有 root 权限。
</code></pre>
<p>重启 NFS 服务，使用如下命令：</p>
<pre><code>sudo systemctl start nfs-kernel-server.service
</code></pre>
<p>此时可以运行以下命令来显示共享的目录：</p>
<pre><code>showmount -e
</code></pre>
<p>在 nfs 运行的过程中，修改了&#x2F;etc&#x2F;exports 配置文件，可以使用 exportfs 命令使改动生效， 具体命令：</p>
<pre><code>sudo exportfs -rv

    开启 Ubuntu 的 SSH 服务以后我们就可以在 Windwos 下使用终端软件登陆到 Ubuntu，比 如使用 SecureCRT，**Ubuntu 下使用如下命令开启 SSH 服务** ：


sudo apt install openssh-server
</code></pre>
<p>上述命令安装 ssh 服务，ssh 的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config，使用默认配置即可。</p>
<h3 id="5-Source-Insight-软件安装和使用"><a href="#5-Source-Insight-软件安装和使用" class="headerlink" title="5.Source Insight 软件安装和使用"></a>5.Source Insight 软件安装和使用</h3><pre><code>    Source Insight 是一款功能强大的代码编辑、阅读工具，工作在 Windows 下，我们可以用 Source Insight 来进行代码编写和阅读，编写完成以后将代码拷贝到 Ubuntu 中去编译即可。
</code></pre>
<h3 id="6-Visual-Studio-Code-软件的安装和使用"><a href="#6-Visual-Studio-Code-软件的安装和使用" class="headerlink" title="6.Visual Studio Code 软件的安装和使用"></a>6.Visual Studio Code 软件的安装和使用</h3><pre><code>    Visual Stuio Code 和 Source Insight 一样，都是编辑器，Visual Studio Sode 本教程以后就简 称为 VSCode，VSCode 是微软出的一款编辑器，但是免费的。VSCode 有 Windows、Linux 和 macOS三个版本的，是一个跨平台的编辑器。
</code></pre>
<p>我们需要按照的插件有下面几个：</p>
<p>1)、C&#x2F;C++。</p>
<p>2)、C&#x2F;C++ Snippets，即 C&#x2F;C++重用代码块。</p>
<p>3)、C&#x2F;C++ Advanced Lint,即 C&#x2F;C++静态检测。</p>
<p>4)、Code Runner，即代码运行。</p>
<p>5)、Include AutoComplete，即自动头文件包含。</p>
<p>6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。</p>
<p>7)、One Dark Pro，VSCode 的主题。</p>
<p>8)、GBKtoUTF8，将 GBK 转换为 UTF8。</p>
<p>9)、ARM，即支持 ARM 汇编语法高亮显示。</p>
<p>10)、Chinese(Simplified)，即中文环境。</p>
<p>11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。</p>
<p>12)、compareit，比较插件，可以用于比较两个文件的差异。</p>
<p>13)、DeviceTree，设备树语法插件。</p>
<pre><code>    新建文件后，按下“Ctrl+Shift+P”打开搜索框，然后**输入“Edit configurations”， 选择“C/C++:Edit configurations…”。C/C++的配置文件是个 json 文件** ，json 中的变量“includePath”用于指定工程中的头文件路径，但是“stdio.h” 是 C 语言库文件，而**VSCode 只是个编辑器，没有编译器** ，所以肯定是没有 stdio.h 的，除非 我们自行安装一个编译器，比如 CygWin，然后**在 includePath 中添加编译器的头文件** 。这里我 们就不添加了，因为我们不会使用 VSCode 来编译程序，这里主要知道如何指定头文件路径就 可以了，后面有实际需要的时候再来讲。
</code></pre>
<h3 id="7-SecureCRT-软件安装和使用"><a href="#7-SecureCRT-软件安装和使用" class="headerlink" title="7.SecureCRT 软件安装和使用"></a>7.SecureCRT 软件安装和使用</h3><pre><code>    在后续的开发过程中我们需要在Windows下使用串口终端，用来查看信息以及进行操作。 常用的串口终端有 SecureCRT、Putty 和 MobaXterm。

    SecureCRT 功能很强大，支持 SSH，可以用来远程登陆；支持串口，可以用来作为 Linux 开发板的串口终端。我们用的最多的就是将 **SecureCRT 作为串口终端来使用** 。

    我们以串口连接为例讲解如何使用 SecureCRT，我们需要准备好一个能进行**串口通信** 的设 备，我们的 DFZU2EG_4EV MPSoC 开发板就可以。DFZU2EG_4EV MPSoC 开发板出厂已经 烧写了 Linux 系统，Linux 系统在运行的过程中会通过串口输出信息，**通过串口可以实现 Linux 命令行交互操作** ，就和 Ubuntu 里面的终端一样，使用方法如下：
</code></pre>
<p>打开 SecureCRT，然 后点击 File-&gt;Quick Connect…，按照下图所示进行设置：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/71d3ee33ee6a727e48d723243b0e893a.png"></p>
<pre><code>    左侧是会话列表，保存着历史会话，会显示出所有曾经连接的串口，这个在关闭 SecureCRT 以后会被保存起来，下次重新打开 SecureCRT 就可以直接使用这个串口会话连接进行快速连接。比如我们关闭 SecureCRT，在关闭 SecureCRT 之前要先关闭所有的会话(串口)，重新打开 SecureCRT。上图中重新打开的 SecureCRT 保存这上次关闭之前建立的会话(串口)“serial-com8”，通 过双击“serial-com8”可以重新连接会话(串口)，不需要再使用快速连接对话框进行连接设置。 开发板默认出厂烧写了 Linux 系统，所以如果连接上 SecureCRT 以后会将串口作为终端， 会输出 Linux 系统启动信息，并且可以通过 SecureCRT 来操作开发板中的 Linux 系统，此时 SecureCRT 就是开发板的终端，和 Ubuntu 中的终端一样。
</code></pre>
<p><strong>关于：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/451782049" title="SecureCRT
中如何配置颜色">SecureCRT 中如何配置颜色</a></strong></p>
<h3 id="8-Putty-软件的安装和使用"><a href="#8-Putty-软件的安装和使用" class="headerlink" title="8.Putty 软件的安装和使用"></a>8.Putty 软件的安装和使用</h3><pre><code>    Putty 和 SecureCRT 是类似的软件，都是用来作为 SSH 或者串口终端的，区别在于 SecureCRT 是付费软件，而 Putty 是免费的。虽然 Putty 没有 SecureCRT 功能强大，但是 Putty 用来作为嵌入式 Linux 的串口终端是绰绰有余的，而且**在 Ubuntu 下安装 Putty 十分方便** ，只需 一条命令即可：


sudo apt install putty


    使用 USB 线将开发板串口和电脑连接起来，打开 Putty 软件，打开以后是配置界面，如下 图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3df9f9690aa123582d4a68ed4dced51.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/68fe6694ea97c256c66129782272be07.png"></p>
<h2 id="二-Petalinux-的安装"><a href="#二-Petalinux-的安装" class="headerlink" title="二.Petalinux 的安装"></a>二.Petalinux 的安装</h2><pre><code>    安装 Petalinux 开发工具在 Ubuntu 操作系统中，在虚拟机中安装了 Ubuntu 18.04 64 位操作系统，这也是官方推荐的版本。
</code></pre>
<h3 id="1-Petalinux-简介"><a href="#1-Petalinux-简介" class="headerlink" title="1.Petalinux 简介"></a>1.Petalinux 简介</h3><pre><code>    Petalinux 工具是 Xilinx 公司推出的嵌入式 Linux 开发套件，包括了 **u-boot、Linux Kernel、 device-tree、rootfs 等源码和库** ，以及 **Yocto recipes** ，可以让客户很方便的生成、配置、编译及 自定义 Linux 系统。Petalinux 支持 Versal 、Zynq UltraScale+ MPSoC、Zynq-7000 SoC 以及 MicroBlaze，可与 Xilinx 硬件设计工具 Vivado 协同工作，大大简化了 Linux 系统的开发工作。
</code></pre>
<p>官方网站：[PetaLinux 工具 (xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/design-">https://china.xilinx.com/products/design-</a><br>tools&#x2F;embedded-software&#x2F;petalinux-sdk.html “PetaLinux 工具 (xilinx.com)“)</p>
<p>下载途径：[下载<br>(xilinx.com)](<a target="_blank" rel="noopener" href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-">https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-</a><br>design-tools&#x2F;2023-1.html “下载 (xilinx.com)“)</p>
<p><strong>注意 Petalinux 的版本 要求与 Vivado 的版本一致</strong></p>
<h3 id="2-安装-Petalinux"><a href="#2-安装-Petalinux" class="headerlink" title="2.安装 Petalinux"></a>2.安装 Petalinux</h3><pre><code>    首先将 petalinux 安装包文件 petalinux-v2019.2-final-installer.run 拷贝到 share 共享目录，，在 Ubuntu 系统中，打开终端，切换到 /mnt/hgfs/share/目录，可以看到 petalinux 的安装文件 petalinux-v2019.2-final-installer.run 已在该目录，可直接访问。
</code></pre>
<h4 id="1、安装依赖库以及软件"><a href="#1、安装依赖库以及软件" class="headerlink" title="1、安装依赖库以及软件"></a>1、安装依赖库以及软件</h4><pre><code>    Xilinx 提供了安装脚本 plnx-env-setup.sh。将下载后的脚本拷贝到 Ubuntu 虚拟机中，打开 Ubuntu Terminal 终端执行输入如下命令以 执行此脚本：


sudo ./plnx-env-setup.sh
</code></pre>
<p>如果上面的命令不行，可以使用下面的方式替代，对与 Ubuntu 而言，两种方式是等效的。</p>
<pre><code>sudo apt install iproute2 gawk python3 python build-essential gcc git make net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib automake zlib1g:i386 screen pax gzip cpio python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3
</code></pre>
<h4 id="2、修改-bash"><a href="#2、修改-bash" class="headerlink" title="2、修改 bash"></a>2、修改 bash</h4><pre><code>    Petalinux 工具需要主机系统的/bin/sh 是 bash，而 Ubuntu 默认的/bin/sh 是 dash，所以这里 需要进行更改，运行 sudo dpkg-reconfigure dash 命令，如下：


sudo dpkg-reconfigure dash
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/659079b3f0270a474f4242ced2ac97b8.png"></p>
<p>**选择“No”按下回车即可。  **</p>
<h4 id="3、安装-Petalinux"><a href="#3、安装-Petalinux" class="headerlink" title="3、安装 Petalinux"></a>3、安装 Petalinux</h4><pre><code>    安装 Petalinux 就要考虑安装位置了，对于 Petalinux 这种体积庞大的工具，我们将其放在 /opt 目录下。在/opt 目录下新建专门存放 Petalinux 的文件夹，如/opt/pkg/petalinux/2019.2，在 终端输入以下命令即可：


sudo chown -R $USER:$USER /opt
mkdir -p /opt/pkg/petalinux/2023.1

    **chown命令将/opt 目录的属主和属组更改为当前的用户名** ，如笔者的 Ubuntu 用户名为 cx， 执行的 chown 命令就相当于“sudo chown -R cx:cx /opt”，然后通过 mkdir 创建安装目录。现在我们将 petalinux 安装在/opt/pkg/petalinux/2023.1 目录下，在终端中输入如下命令：


./petalinux-v2023.1-05012318-installer.run -d /opt/pkg/petalinux/2023.1
</code></pre>
<p>运行上述命令后，需要等待一段时间，当出现“Press Enter to display the license agreements”<br>字样的时候，从显示的意思可以知道，让我们按下回车键显示软件许可协议，按下键盘上的回车键<br>Enter，这些内容如果你感兴趣可以看看，此处我们就不详细看了，直接按下键盘上的 Q 键退出， 回到之前的界面之后会出现一个选择项，询问我们是否接受<br>xilinx 最终用户协议。这个显然是没得选，必须接受，否则无法进行下面的安装；输入 y 按回车接受。除了 xilinx<br>最终用户协议之外，还有两个协议也需要大家接受，会依次显示在终端上，同理也是输入 Y 按下回车接受。接受所有协议之后 Petalinux<br>安装工具便会继续安装，直到安装完成。</p>
<h4 id="4、设置-Petalinux-环境变量"><a href="#4、设置-Petalinux-环境变量" class="headerlink" title="4、设置 Petalinux 环境变量"></a>4、设置 Petalinux 环境变量</h4><pre><code>    在正式使用 petalinux 工具之前，需要先运行 petalinux 安装目录下的 settings.sh 脚本文件 设置 petalinux 工作环境，settings.sh 脚本用于 bash，还有一个 settings.csh 用于 C shell。

    一般默认情况下，我们使用 bash作为登录 shell，所以 source 脚本文件 settings.sh对 petalinux 所需的运行环境进行配置，命令如下：


source settings.sh

    需要注意的是该命令**只对当前终端有效** ，重新打开终端后需要重新执行这一步。执行结果 如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/00f3abd28725993d07f8ef21603c139b.png"></p>
<p> 我们来验证下工作环境是否已设置，在终端输入如下命令：</p>
<pre><code>echo $PETALINUX
</code></pre>
<p>显示 Petalinux 的安装目录，表明工作环境已设置。现在可以使用 Petalinux 工具了。</p>
<pre><code>    鉴于每次打开终端使用 Petalinux 都需要设置相应的环境变量，我们为了方便，**将设置 Petalinux 环境变量的命令设置成别名**，这样我们使用起来就方便些。设置别名方法的很简单， 在终端输入如下命令：


echo &quot;alias sptl=&#39;source $PETALINUX/settings.sh&#39;&quot; &gt;&gt; ~/.bashrc


    以后我们打开终端后，**输入 sptl** 就可以设置 Petalinux 的环境变量了，无需输入长长的路 径。sptl 的记忆法是 Source PeTaLinux 的环境变量。提醒：在使用 linux 的时候要善用别名但不要滥用别名。
</code></pre>
<h4 id="5、Linux-系统安装-JTAG-cable-驱动"><a href="#5、Linux-系统安装-JTAG-cable-驱动" class="headerlink" title="5、Linux 系统安装 JTAG cable 驱动"></a>5、Linux 系统安装 JTAG cable 驱动</h4><pre><code>    在嵌入式开发中，我们都是通过在线 jtag 进行调试的，这种调试方式方便快捷，在使用 Petalinux 进行 Linux 开发中，其实也是可以使用 JTAG 的，不过对于 Linux 系统，**由于安装驱动程序需要 root 或 sudo 访问权限，因此从 Vivado 2015.4 版本开始，默认不安装 jtag 驱动。这 样 Vivado 安装程序和 Petalinux 安装程序可以在没有 root 或 sudo 特权的 Linux 系统上运行。** 这也导致了在 linux 系统中，jtag 驱动需要手动安装。

    下面我们介绍如何在 Ubuntu 主机中（其 他 Linux 系统同样适用）安装 jtag 驱动。 需要注意的是在安装 jtag 驱动之前，请**不要将 jtag 下载器连接到电脑** ，已经接到电脑的， 最好先拔掉。下面开始安装。

    在 Ubuntu 系统中，打开终端，以普通用户运行即可。进入到 petalinux 安装目录。可以看到有一个名为“tools”的目录，jtag 驱动程序在该目录下，我们输入以下命令进入 到 jtag 驱动程序所在位置：


cd tools/xsct/data/xicom/cable_drivers/lin64/install_script/install_drivers

    可以看到该目录下有一个名为“install_drivers”的文件，输入如下命令，以 root 权限执行该文件，安装 jtag 驱动程序：


sudo ./install_drivers

    可以看到 jtag 驱动安装成功。对于最下面一行的警告，如果已经拔掉 jtag 下载器与电脑的 连接就可以不用看。至此 jtag 驱动程序就安装完成了。

    下面说下在遇到 jtag 驱动问题时，**如何删除 jtag 驱动。注意如无特需情况，请不要执行下 面的命令：**


sudo rm -f /etc/udev/rules.d/52-xilinx-digilent-usb.rules
sudo rm -f /etc/udev/rules.d/52-xilinx-ftdi-usb.rules
sudo rm -f /etc/udev/rules.d/52-xilinx-pcusb.rules
</code></pre>
<h2 id="三-Petalinux-设计流程实战"><a href="#三-Petalinux-设计流程实战" class="headerlink" title="三.Petalinux 设计流程实战"></a>三.Petalinux 设计流程实战</h2><pre><code>    PetaLinux 工具提供了**在 Xilinx 处理系统上自定义、构建和部署嵌入式 Linux 解决方案** 所需的一切。该解决方案旨在提高设计生产力，可**与 Xilinx 硬件设计工具一起使用** ，以**简化针对 Zynq SoC 的 Linux 系统的开发** 。本章我们以使用 Petalinux 定制 Linux 系统为例，实战 Petalinux 的设计流程，看下 Petalinux 如何简化 Linux 系统的开发。
</code></pre>
<h3 id="1-Zynq-UltraScale-MPSoC-嵌入式软件栈概述"><a href="#1-Zynq-UltraScale-MPSoC-嵌入式软件栈概述" class="headerlink" title="1.Zynq UltraScale+ MPSoC 嵌入式软件栈概述"></a>1.Zynq UltraScale+ MPSoC 嵌入式软件栈概述</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41be0b13c8944f0eb38505481be59e1d.png"></p>
<pre><code>    在 Zynq UltraScale+ MPSoC 设备中，有一个 **BootROM** 用于设备的初始启动。配置和安全 部件 CSU(Configuration and Security Unit)处理器使用 BootROM 中的代码。在这个配置阶段， BootROM(CSU ROM 代码的一部分)**解释引导头部（boot header）来配置系统** ，并以安全或者非安全引导模式将处理系统(PS，processing system)的第一阶段**引导加载程序(FSBL，first-stage boot loader)** 代码加载到**片上 RAM(OCM，on-chip RAM)**中。引导头部定义了许多引导参数，包 括安全模式和应该执行 FSBL 的处理器。引导头部参数可以在 Zynq UltraScale+器件手册 [UG1085](https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/Fallback &quot;UG1085&quot;) 中找到。在启动过程中，CSU 还将 **PMU** 用户固件(PMU FW)加载到 PMU RAM 中， 与 PMU ROM 一起提供平台管理服务。对于基于 xilinx 的 FSBL 和系统软件，大多数系统中都 必须有 PMU FW。在 PMU 固件加载前加载 FBSL 是默认配置。有些系统会切换顺序，首先加 载 PMU 固件。

    在[Vitis开发二——FPGA学习笔记——二程序固化实验](https://blog.csdn.net/qq_32971095/article/details/136352300?spm=1001.2014.3001.5501 &quot;Vitis开发二——FPGA学习笔记——二程序固化实验&quot;)中也涉及到相关内容，不过产生的BOOT文件不涉及linux操作系统。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbd6bdbe41a447d061533a88e8bad8a9.png"></p>
<p>Boot Image Format with FSBL and PMU Firmware</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f4287d5b2c5f05a44d171346851eac3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2692d111454983b13f1ffa3594f56311.png"></p>
<p>可以参考《xilinx zynq soc与嵌入式Linux设计实战指南》——第三章 zynq启动流程及镜像制作</p>
<p>及[PMU Processor • Zynq UltraScale+ Device Technical Reference Manual<br>(UG1085)](<a target="_blank" rel="noopener" href="https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/PMU-">https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/PMU-</a><br>Processor “PMU Processor • Zynq UltraScale+ Device Technical Reference Manual<br>(UG1085)“)</p>
<h4 id="1、FSBL"><a href="#1、FSBL" class="headerlink" title="1、FSBL"></a>1、FSBL</h4><pre><code>    FSBL 是 Zynq UltraScale + MPSoC 的**第一阶段引导加载程序** ，由 BootROM 引导加载到片上 RAM 中并启动，用于**配置 FPGA** （使用 bitstream，如果存在的话）和**从非易失性 Flash(SD/eMMC/NAND/QSPI)加载裸机镜像或者操作系统的第二阶段引导加载程序镜像到内存(DDR/OCM)。**
</code></pre>
<h4 id="2、Platform-Management-Unit-PMU-Firmware"><a href="#2、Platform-Management-Unit-PMU-Firmware" class="headerlink" title="2、Platform Management Unit (PMU) Firmware"></a>2、Platform Management Unit (PMU) Firmware</h4><pre><code>    PMU 控制系统的上电、复位和监控系统内的资源。Zynq MPSoC 中的平台管理单元(PMU) 有一个带有 32KB ROM 和 128 KB RAM 的 Microblaze。启动时，ROM 被 PMU Boot ROM (PBR)预加载，PBR 用于执行预启动任务，进入服务模式。有关 **PMU、PBR 和 PMUFW 加载顺序** 的更多细节，请参阅 Zynq UltraScale+器件手册 UG1085 中的平台管理单元(第 6 章)。PMU RAM 可以在运行时加载固件(PMU Firmware)，并可用于扩展或定制 PMU 的功能。
</code></pre>
<p>PMU System Diagram</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/08e512168278cfd6995aa5bcc935df18.png"></p>
<p>官方给出PMU的用处：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e2c1939bb02498a21be1dc76171241a.png"></p>
<h4 id="3、ARM-Trusted-Firmware"><a href="#3、ARM-Trusted-Firmware" class="headerlink" title="3、ARM Trusted Firmware"></a>3、ARM Trusted Firmware</h4><pre><code>    ARM Trusted Firmware(ATF)为 ARMv8-A 架构的安全软件提供了参考，它提供了各种接 口标准的实现，如 PSCI(Power State Coordination Interface，电源状态协调接口)和用于与 Normal world software 接口的安全监控代码。
</code></pre>
<h4 id="4、U-Boot"><a href="#4、U-Boot" class="headerlink" title="4、U-Boot"></a>4、U-Boot</h4><pre><code>    U-Boot 是 **Universal Boot Loader** 的简称，是一个开源的、主要的引导加载程序，**用于嵌入 式设备中引导设备的操作系统内核** ，在 Linux 社区中经常使用。**Xilinx 在 Zynq Ultrascale+设备 中使用 U-Boot 作为 第二阶段引导加载程序**。
</code></pre>
<h4 id="5、Hypervisor-Optional，可选"><a href="#5、Hypervisor-Optional，可选" class="headerlink" title="5、Hypervisor (Optional，可选)"></a>5、Hypervisor (Optional，可选)</h4><pre><code>    **在 Zynq UltraScale+设备上** ，可以**使用 hypervisor 运行多个虚拟机** 。Zynq UltraScale+设备 上支持几种 hypervisor，该榜单可在 [Embedded Software EcoSystem](https://www.xilinx.com/products/design-tools/embedded-software.html#rtos &quot;Embedded Software EcoSystem&quot;) 上找到。
</code></pre>
<h4 id="6、Linux"><a href="#6、Linux" class="headerlink" title="6、Linux"></a>6、Linux</h4><pre><code>    Linux，全称 GNU/Linux，是一种免费使用和自由传播的类 UNIX 操作系统，是我们本开发指南的重点。

    Zynq UltraScale+ MPSoC 上电后，**首先由 BootROM 对 zynq 设备进行初始启动，然后引导加载 fsbl 到 OCM 并启动 fsbl；fsbl 启动后加载 PMU Firmware，然后加载 ARM Trusted Firmware，配置 DDR，最后将 uboot 加载到 DDR 并启动 uboot；uboot 启动后可选的加 载 hypervisor，并在 hypervisor 上运行 linux 系统，一般我们不使用 hypervisor，而是直接使用 uboot 加载 linux 系统镜像到 DDR 并启动 linux，至此整个 linux 系统启动完成。**

    综上，就是需要在 Zynq UltraScale+ MPSoC 运行 linux 系统所需要搭建的软件栈。如果这 些软件栈由我们一个个手工搭建，任务量极其庞大，所幸的是，**Xilinx 推出了 Petalinux 开发工 具，可以让我们方便快捷的完成这些软件栈的搭建，从而加快 linux 的使用和开发** 。

    注：上面介绍了那么多软件栈，并不需要我们全部了解。以 uboot 为分界线，uboot 以下 的是跟 zynq 芯片密切相关的，是很底层的内容，一般不需要额外配置，让 Petalinux 工具自动 适配即可。**从 uboot 开始，跟 zynq 芯片的关联就弱了很多，uboot 和 linux 内核可以适用与其 他芯片平台，其知识点是通用的，也是我们需要关注的。**
</code></pre>
<h3 id="2-使用-Petalinux-定制-Linux-系统"><a href="#2-使用-Petalinux-定制-Linux-系统" class="headerlink" title="2.使用 Petalinux 定制 Linux 系统"></a>2.使用 Petalinux 定制 Linux 系统</h3><h4 id="1、创建-Vivado-硬件平台"><a href="#1、创建-Vivado-硬件平台" class="headerlink" title="1、创建 Vivado 硬件平台"></a>1、创建 Vivado 硬件平台</h4><pre><code>    system_wrapper.xsa 文件，该文件包含着 Vivado 工程所对应的硬件平台信 息，Petalinux 根据这些信息来配置 fsbl、uboot、内核等。 将该文件拷贝到 Ubuntu 系统下。在 share 文件夹下创建一个 xsa 文 件夹，并将 system_wrapper.xsa 文件复制到该文件夹下。
</code></pre>
<h4 id="2、设置-Petalinux-环境变量"><a href="#2、设置-Petalinux-环境变量" class="headerlink" title="2、设置 Petalinux 环境变量"></a>2、设置 Petalinux 环境变量</h4><pre><code>source /opt/pkg/petalinux/2019.2/settings.sh
#或者
sptl
</code></pre>
<h4 id="3、创建-petalinux-工程"><a href="#3、创建-petalinux-工程" class="headerlink" title="3、创建 petalinux 工程"></a>3、创建 petalinux 工程</h4><pre><code>    为了方便工程的管理，我们在使用的用户的家目录下新建一个 workspace/petalinux 目录， 作为 petalinux 的工程目录。在终端中输入如下命令新建 workspace/petalinux 目录并切换到该目 录：


cd
mkdir -p workspace/petalinux/
cd workspace/petalinux/
</code></pre>
<p>现在我们创建一个名为“ALIENTEK-ZYNQ”的 Petalinux 工程，在终端中输入如下命令：</p>
<pre><code>petalinux-create -t project --template zynqMP -n ALIENTEK-ZYNQ

    template 参数表明创建的 petalinux 工程使用的平台模板，此处的 zynqMP 表明使用的是 zynqMP Soc 平台模板的 petalinux 工程，用于 Zynq UltraScale+ MPSoC 系列的芯片。name 参数 （此处简写为“-n”）后接的是 petalinux 工程名，如此处的“ALIENTEK-ZYNQ”
</code></pre>
<h4 id="4、配置-petalinux-工程"><a href="#4、配置-petalinux-工程" class="headerlink" title="4、配置 petalinux 工程"></a>4、配置 petalinux 工程</h4><pre><code>    首次配置 Petalinux 工程是将 xsa 文件导入到 Petalinux 工程中，Petalinux 工具会解析 xsa 文件并弹出配置窗口。在终端中输入如下命令配置 Petalinux 工程：


cd ALIENTEK-ZYNQ
petalinux-config --get-hw-description /mnt/hgfs/shared_folder/xsa/
</code></pre>
<p>弹出 petalinux 工程配置窗口，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a83dff710bfdce1cc89fd50c9b6dbfa8.png"></p>
<pre><code>    需要注意的是该窗口不可以使用鼠标操作，只能通过键盘操作，界面上方的英文就是简单 的操作说明，操作方法如下：

    通过键盘上的**“↑”和“↓”键来选择要配置的菜单** ，**按下“Enter”键进入子菜单** 。菜单中高亮的字母就是此菜单的**热键** ，在键盘上按下此高亮字母对应的键可以快速选中对应的菜单。选中子菜单以后**按下“Y”键就会将相应的配置选项写入配置文件中，菜单前面变为“ &lt; * &gt;”**。 **按下“N”键不编译相应的代码，按下“M”键就会将相应的代码编译为模块，菜单前面变为“ &lt; M &gt;”**。按两下“Esc”键退出，也就是返回到上一级，按下“?”键查看此菜单的帮助信 息，按下“/”键打开搜索框，可以在搜索框输入要搜索的内容。
</code></pre>
<p>在配置界面下方会有五个按钮，这五个按钮的功能如下：<br><Select>：选中按钮，和“Enter”键的功能相同，负责选中并进入某个菜单。<br><Exit>：退出按钮，和按两下“Esc”键功能相同，退出当前菜单，返回到上一级。<br><Help>：帮助按钮，查看选中菜单的帮助信息。<br><Save>：保存按钮，保存修改后的配置文件。<br><Load>：加载按钮，加载指定的配置文件。<br>        本实验我们无需更改该窗口的配置信息。不过由于该窗口菜单不多，我们就从上到下的简单地介绍下这些菜单。</Load></Save></Help></Exit></Select></p>
<pre><code>    首先按键盘上的下方向键移动到“Linux Components Selection”，然后按键盘上的“Enter” 进入子菜单，子菜单内容如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0f9a188e5df166fb919bd2fe2140b59.png"></p>
<pre><code>    括号里的“*”表示为已使能配置。前两个选项表示会**自动生成我们在《DFZU2EG_4EV MPSoC 之嵌入式 Vitis 开发指南》程序固化实验中的 fsbl.elf 文件和自动更新 ps_init** 。下面两个选项用来配置 u-boot 和 linux-kernel 的来源，本实验保持默认来源配置，不做改动，后面的实验需要更改的时候再做介绍。按键盘上的“Esc”按键连按两次退出该子菜单。

    “Auto Config Settings”菜单主要就是**选择是否使能 fsbl、pmufw、Device tree、Kernel 和 u-boot 的自动配置** ，默认为自动配置，无需更改
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5b1497c082712b5d5d6eeee59e31bfed.png"></p>
<pre><code>     其中**“SD/SDIO Settings”配置项用于配置开发板的首要启动媒介** ，即是从**SD 卡启动还是从 eMMC 启动** 。一般我们调试使用都 是通过 SD 卡启动，因为 SD 卡读写文件方便，从而方便调试；eMMC 一般是程序测试稳定后 上市时使用，不会像 SD 卡那样因碰摔造成的松动。对于 DFZU2EG_4EV MPSoC 开发板来说， 这里需要修改一下，因为 DFZU2EG_4EV MPSoC 开发板的 SD 卡接在 PS 的 SD1 控制器，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/612b60cb984a3d8cdfd6721695f4de26.png"></p>
<p>首先光标移动到该配置项按回车进入，如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/739a10b29b1a3f63cacb77f6a26d8cba.png"></p>
<pre><code>    在“Primary SD/SDIO”配置项中需要将其修改为 psu_sd_1。**psu_sd_1 对应的就是 SD 卡** 。 修改完成之后连按两次 ESC 键回到上一级菜单。

    在“Advanced bootable images storage Settings”菜单中可**配置启动引导镜像和内核镜像的存储媒介** ，默认为 Primary SD，这里保持默认即可。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/250ec972a312abf03c984011b05c5a97.png"></p>
<pre><code>    返回到主界面（按四次“ESC”按键），**设备树设置菜单“DTG Settings”和 ATF 配置菜 单“ARM Trusted Firmware Compilation Configuration”** 等一般保持默认即可。

    我们进入“Image Packaging Configuration”子菜单，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd7ba58cf04b6494b487a1ca6ac860e4.png"></p>
<pre><code>    第一个选项便是**根文件系统的类型的配置，默认为 INITRAMFS** ，一般默认即可，如果我们需要运行 Ubuntu 或 Debian 的 根文件系统时 ， 就需要配置成 **EXT(SD/eMMC/QSPI/SATA/USB)** ，**NFS 挂载启动需要配置成 NFS** 。另外从该界面我们可以看 到，有**“Copy final images to tftpboot”** 选项，**当在 Ubuntu 的根文件下创建一个名为 tftpboot 的文件夹时，工程生成镜像后会自动将相关文件复制到/tftpboot 目录中** 。

    回到主界面，“Firmware Version Configuration”可以用来修改定制的 linux 系统的主机名 和产品名，默认与该 Petalinux 工程同名，如果需要可修改。

    “Yocto Settings”进行与 Yocto 相关的设置，这里就不做介绍了，一般保持默认即可。

    按键盘上的右方向键（即右箭头），移动到底部的“Save”，按键盘上的“Enter”键， 进入如下图所示的保存配置文件界面：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3399fe22dabcc8eaa76210724169701f.png"></p>
<p>按键盘上的“Enter”键确认，进入下图所示界面：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87556f5dc05d0572c4cca94feb61c9f1.png"></p>
<pre><code>    再次按键盘上的“Enter”键确认，返会到原界面，按两次键盘上的“Esc”退出配置窗口。 如果后面想重新配置，只需输入“petalinux-config”命令即可重新配置。

    这一步可能需要几分钟才能完成。这是因为 PetaLinux 会根据“Auto Config Settings ---&gt;‖ 和―Subsystem AUTO Hardware Settings ---&gt;‖来解析 xsa 文件，以获取更新设备树、U-Boot 配置 文件和内核配置文件所需的硬件信息。等待一段时间后，完成 petalinux 工程的配置，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cf586be08fbacafa3baab0d324db1191.png"></p>
<h4 id="5、配置-Linux-内核"><a href="#5、配置-Linux-内核" class="headerlink" title="5、配置 Linux 内核"></a>5、配置 Linux 内核</h4><p>现在我们开始定制 Linux 内核，在终端输入如下命令：</p>
<pre><code>petalinux-config -c kernel

    等一段时间后会在终端中创建一个名为“linux-xlnx Configuration”的标签页，也就是 Linux 内核的配置界面，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd81a7ed1a3fb7ed7810ece777525c84.png"></p>
<pre><code>    可以看到 Petalinux 默认使用的**内核版本为 4.19.0** ，当然也可以换成其它版本的内核,不过 修改起来比较麻烦，Petalinux 对内核版本有要求，读者如需使用其他的内核版本可以在网上查 找关于 Petalinux 使用非默认内核版本的方法。一般使用默认内核版本就可以了。

    这里使用的内核 Xilinx 官方已经做好了基础配置，如无特定需求，无需更改。另外关于 Linux 内核的配置在后面的 Linux 内核移植章节进行讲解，此处就不多做介绍了。这里采用 Xilinx 官方的默认配置即可，保存配置并退出。
</code></pre>
<h4 id="6、配置-Linux-根文件系统"><a href="#6、配置-Linux-根文件系统" class="headerlink" title="6、配置 Linux 根文件系统"></a>6、配置 Linux 根文件系统</h4><p>在终端输入下面的命令可配置根文件系统，如果不需要配置可不执行该命令：</p>
<pre><code>petalinux-config -c rootfs
</code></pre>
<p>下图就是根文件系统的配置界面：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a0d6802881da29584983e23d05d264c0.png"></p>
<pre><code>    默认配置可满足一般使用，也可以根据需求来定制根文件系统，本实验保持默认配置。需要说明的是**“PetaLinux RootFS Settings”可以用来设置 root 用户的密码，默认为“root”** 。后面登录的时候会用到。 保存配置并退出。
</code></pre>
<h4 id="7、配置设备树文件"><a href="#7、配置设备树文件" class="headerlink" title="7、配置设备树文件"></a>7、配置设备树文件</h4><pre><code>    设备树的概念源自于 Linux 内核当中，当然其实在 U-Boot 当中也已经使用了。如果需要配置设备树，可以编辑当前 petalinux 工程目录下的 **project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi** 文件。

    我们可以打开这个文件进行编辑，将一些简单外设添加到系统当中，譬如按键、led 和 IIC 设备。设备树用于保存 Linux 系统中的各种设备信息，内核在启动过程当中会去解析设备树文 件，获取设备所需的配置信息完成设备的初始化工作。

    **设备树的概念以及相关配置、语法涉及到了 Linux 内核驱动相关知识** ，并不是本篇学习的 重点，所以这里并不会去深入给大家介绍，将会**在 Linux 驱动部分** 的章节做详细解说。
</code></pre>
<p>使用 vi 命令打开 system-user.dtsi 文件，如下所示：</p>
<pre><code>vi project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi
</code></pre>
<p>默认的文件内容如下，可见该文件需要我们自己手动配置。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c470de2e4f70cee868c21189f201842.png"></p>
<pre><code>/include/ &quot;system-conf.dtsi&quot;
#include &lt;dt-bindings/gpio/gpio.h&gt;
#include &lt;dt-bindings/input/input.h&gt;
/ &#123;
	model = &quot;Alientek Zynq MpSoc Development Board&quot;;
	
	leds &#123;
		compatible = &quot;gpio-leds&quot;;
		gpio-led0 &#123;
			label = &quot;ps_led1&quot;;
			gpios = &lt;&amp;gpio 38 GPIO_ACTIVE_HIGH&gt;;
			linux,default-trigger = &quot;timer&quot;;
		&#125;;
		gpio-led1 &#123;
			label = &quot;ps_led2&quot;;
			gpios = &lt;&amp;gpio 39 GPIO_ACTIVE_HIGH&gt;;
			default-state = &quot;on&quot;;
		&#125;;
		gpio-led2 &#123;
			label = &quot;pl_led1&quot;;
			gpios = &lt;&amp;axi_gpio_0 0 0 GPIO_ACTIVE_HIGH&gt;;
			linux,default-trigger = &quot;timer&quot;;
		&#125;;
		gpio-led3 &#123;
			label = &quot;pl_led2&quot;;
			gpios = &lt;&amp;axi_gpio_0 1 0 GPIO_ACTIVE_HIGH&gt;;
			default-state = &quot;on&quot;;
		&#125;; 
	&#125;;
	
	keys &#123;
		compatible = &quot;gpio-keys&quot;;
		autorepeat;
		gpio-key,wakeup;
		
		gpio-key1 &#123;
			label = &quot;ps_key1&quot;;
			gpios = &lt;&amp;gpio 40 GPIO_ACTIVE_LOW&gt;;
			linux,code = &lt;KEY_UP&gt;;
		&#125;;
			gpio-key2 &#123;
			label = &quot;ps_key2&quot;;
			gpios = &lt;&amp;gpio 41 GPIO_ACTIVE_LOW&gt;;
			linux,code = &lt;KEY_DOWN&gt;;
		&#125;;
			gpio-key3 &#123;
			label = &quot;pl_key1&quot;;
			gpios = &lt;&amp;gpio 78 GPIO_ACTIVE_LOW&gt;;
			linux,code = &lt;KEY_LEFT&gt;; 
		&#125;;
			gpio-key4 &#123;
			label = &quot;pl_key2&quot;;
			gpios = &lt;&amp;gpio 79 GPIO_ACTIVE_LOW&gt;;
			linux,code = &lt;KEY_RIGHT&gt;; 
		&#125;;
	&#125;;
&#125;;
	
&amp;gem3 &#123;
	phy-handle = &lt;&amp;ethernet_phy&gt;;
	local-mac-address = [00 0a 35 00 1e 53];
	ethernet_phy: ethernet-phy@7 &#123; 
		reg = &lt;0x7&gt;;
	&#125;;
&#125;;

&amp;gem0 &#123;
	psu_ethernet_0_mdio: mdio &#123;
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;0&gt;;
		phy1:phy@4 &#123;
			reg = &lt;0x4&gt;; /* YT8521 phy address */
		&#125;;
		gmii_to_rgmii_0: gmii_to_rgmii_0@0 &#123;
			compatible = &quot;xlnx,gmii-to-rgmii-1.0&quot;;
			phy-handle = &lt;&amp;phy1&gt;;
			reg = &lt;0&gt;;
		&#125;;
	&#125;;
&#125;;

&amp;sdhci0 &#123;
	mmc-hs200-1_8v;
	bus-width = &lt;0x8&gt;;
	non-removable;
&#125;;

&amp;sdhci1 &#123;
	disable-wp;
	no-1-8-v;
&#125;;

&amp;i2c0 &#123;
	clock-frequency = &lt;400000&gt;;
	eeprom@50 &#123;
		compatible = &quot;24c64&quot;;
		reg = &lt;0x50&gt;;
		pagesize = &lt;32&gt;;
	&#125;;
&#125;;

&amp;dwc3_0 &#123;
	dr_mode = &quot;host&quot;;
	maximum-speed = &quot;super-speed&quot;;
&#125;;

&amp;usb0 &#123;
	dr_mode = &quot;host&quot;;
&#125;;

    设备树文件当中配置了 4 个 gpio led 灯，4 个按键、i2c0 和 usb0，以及 PS 和 PL 的以太网。 下面简单的讲解下 gpio led 的配置。

    4 个 gpio led 灯分别对应开发板的 4 个 led 灯，配置信息主要包括 **compatible（用于与内核 驱动匹配的名字）、label（名字）、gpios（对应的 GPIO 管脚）、默认状态以及触发状态** 。 例如 linux,default-trigger = &quot; timer &quot;表示默认的触发状态是 timer 模式，也可以改为 heartbeat 模式，可以用来判断系统是否还在运行。除此之外，还有其他一些内核定义好的触发状态； default-state = &quot;on&quot;表示默认 led 灯是亮着的；gpios = 表示该 led 的控制管脚是 gpio_38，GPIO_ACTIVE_HIGH 表示高电平有效（也就是高电平的时候 led 灯才会亮）。
</code></pre>
<h4 id="8、编译-Petalinux-工程"><a href="#8、编译-Petalinux-工程" class="headerlink" title="8、编译 Petalinux 工程"></a>8、编译 Petalinux 工程</h4><p>现在我们就可以编译整个 Petalinux 工程了，在终端输入如下命令：</p>
<pre><code>petalinux-build

    该命令将**生成设备树 DTB 文件、fsbl 文件、U-Boot 文件，Linux 内核和根文件系统映像** 。 编译完成后，生成的映像将**位于工程的 images 目录下** 。需要说明的是 fsbl、U-Boot 这两个我们在工程中并没有配置，这是因为 Petalinux 会根据 xsa 文件和配置 petalinux 工程**自动配置 fsbl 和 uboot** ，如无特需要求，不需要再手动配置。
</code></pre>
<p>执行结果如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42ccb5a43617856eaa2539ffecdf6cd.png"></p>
<h4 id="9、制作-BOOT-BIN-启动文件"><a href="#9、制作-BOOT-BIN-启动文件" class="headerlink" title="9、制作 BOOT.BIN 启动文件"></a>9、制作 BOOT.BIN 启动文件</h4><pre><code>    Petalinux 提供了 petalinux-package 命令将 PetaLinux 项目打包为适合部署的格式，其中 “petalinux-package --boot”命令生成可引导映像，该映像可直接与 Zynq 系列设备（包括 Zynq-7000 和 Zynq UltraScale + MPSoC）或基于 MicroBlaze 的 FPGA 设计一起使用。对于 Zynq 系列设备，可引导格式为 BOOT.BIN，可以从 SD 卡引导启动。对于基于 MicroBlaze 的设计， 默认格式为 MCS PROM 文件，适用于通过 Vivado 或其他 PROM 编程器进行编程。

    ZYNQ 的启动文件 BOOT.BIN 一般包含 fsbl 文件、bitstream 文件和 uboot 文件。使用下面 的命令可生成 BOOT.BIN 文件：


petalinux-package --boot --fsbl --fpga --u-boot --force

    选项“--fsbl”用于指定 fsbl 文件所在位置，后面接文件对应的路径信息，如果不指定文 件位置，默认对应的是 images/linux/zynqmp_fsbl.elf；选项“--fpga”用于指定 bitstream 文件所 在位置，后面接该文件对应的路径信息，默认对应的是 images/linux/system.bit，实际可能有区 别；选项“--u-boot”用于指定 U-Boot 文件所在位置，后面接该文件所在路径信息，默认为 images/linux/u-boot.elf。这里笔者均没有指定对应的文件的路径信息，那么 Petalinux 会自动使用默认文件。
</code></pre>
<p>执行结果如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bab0f3bbb3cedfb9db39f0ebb9722b0.png"></p>
<pre><code>    可以看到 Petalinux **自动将 PMU（Platform Management Unit） firmware 文件 pmufw.elf 和 ATF（Arm trusted firmware）文件 bl31.elf 包含进 BOOT.BIN** 。

    生成的 BOOT.BIN 文件放在 Petalinux 工程的 **images/linux 目录下** ，上一小节编译 Petalinux 工程生成的文件同样存放在 images/linux 目录下，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/84819ba0e2bd27d842fded323f1ab75c.png"></p>
<h4 id="10、制作-SD-启动卡"><a href="#10、制作-SD-启动卡" class="headerlink" title="10、制作 SD 启动卡"></a>10、制作 SD 启动卡</h4><pre><code>    如果使用 SD 卡引导 linux系统启动，一般需要在 SD 卡上有 2 个分区。**一个分区使用 FAT32 文件系统，用于放置启动镜像文件（如 BOOT.BIN，linux 镜像等），另一分区使用 EXT4 文件系统，用于存放根文件系统**。

    需要说明的是在配置 petalinux 工程中，“Image Packaging Configuration”子菜单根文件系统的类型的配置使用的是默认的 **INITRAMFS** ，所以**只需要一个使用 FAT32 文件系统** 的分区就可以了。**当设置为“EXT”则需要另一个存放根文件系统的分区** 。

    

    先讲解 SD 卡的分区和格式化，然后说明将哪些文件复制到 SD 卡中。 注：在使用 SD 卡前需要先将 sd 卡中的数据做备份，否则会丢失 SD 卡中的数据。        

    将 SD 卡插入到读卡器中、并将读卡器插入电脑并连接到 Ubuntu 系统，**在 Ubuntu 系统中 找到 SD 卡所对应的设备节点** ，笔者插入的 SD 卡对应的设备节点为/dev/sdc。在终端中输入如 下命令：


umount /dev/sdc*
sudo fdisk /dev/sdc
</code></pre>
<p>输入“p”执行结果如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f484804a452873f0fe3ee8feca88b623.png"></p>
<pre><code>    可以看到当前的分区表，有一个 FAT32 的分区。在开始新分区之前需要将以前的分区删 除，键入“d”，删除该分区，再次键入“d”时会出现下图所示的红色字体提示，表明已无存 在的分区。如果 SD 卡存在多个分区，需要全部删除，存在多个分区的情况下，键入“d”时 会提示选择需要删除的分区编号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e9aa6374c3a77fca52b1d9d384269193.png"></p>
<pre><code>    下面开始新建分区。输入“n”创建一个新分区。通过选择&#39;p&#39;使其为主，使用默认分区号 1 和第一个扇区 2048。设置最后一个扇区，也就是设置第一个分区的大小，一般设置 500M 足 够了，通过输入“+ 500M”，为该分区预留 500MB，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8afd8a1d3ce98b0b1b82e824a6d6de0c.png"></p>
<p>现在设置分区类型，输入“t”，然后输入“c”，设置为“W95 FAT32 (LBA)”，如下图 所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b11e58ae1db75c75fd7ad406c31468e5.png"></p>
<p>输入“a”，设为引导分区，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3125a80ec08f73e61b9b25c76bf4639.png"></p>
<p>第一个分区就创建好了，开始创建第二个分区。</p>
<p>通过键入“n”来创建根文件系统分区。后面一路默认就可以了，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba3bcfc72b47d681b7789eff23bc5737.png"></p>
<pre><code>    如果现在输入“p”检查分区表，会看到刚刚创建的 2 个分区。如果没问题，键入“w” 以写入到 SD 卡并退出。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42da38677d629d0ddd576397d6829da6.png"></p>
<p>完成了分区创建后，就可以格式化分区了。在终端输入如下命令：</p>
<pre><code>sudo mkfs.vfat -F 32 -n boot /dev/sdc1
sudo mkfs.ext4 -L rootfs /dev/sdc2

    将第一个分区格式化成 FAT32 分区并命名为 boot，将第二个分区格式化成 ext4 分区并命 名为 rootfs。执行结果如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6cb68099ed50588483a706cd2d4037fc.png"></p>
<pre><code>    格式化分区之后就可以挂载分区了（重新插拔读卡器或者使用 mount 命令进行挂载）。挂 载完成后，我们将该工程 image/linux 目录下的 BOOT.BIN 和 image.ub 文件拷贝到名为 boot 的分区也即/dev/sdc1 分区中。然后就可以卸载 SD 卡了。
</code></pre>
<h4 id="11、开发板启动模式设置"><a href="#11、开发板启动模式设置" class="headerlink" title="11、开发板启动模式设置"></a>11、开发板启动模式设置</h4><pre><code>    将 SD 卡插入 SD 卡槽，接下来将启动模式开关 BOOT MODE 的四个开关的第二个与第四个开关拨到下面（置为 OFF），即设置为从 SD 卡启动。打开 MobaXterm 串口上位机或其它串口上位机。上位机打印 Linux 启动信息如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/74a3e0bd0b3903e51125cc56adb311cd.png"></p>
<pre><code>    停留在登录处，此处使用 root 用户登录，登录密码为“root”（去掉双引号），登录进去 后，界面如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1213533746cf2f88aa42270ade1e6f7.png"></p>
<pre><code>    如果我们把视线移到开发板，会看到板上的 LED 灯全都是亮的，其中，底板上的 PL_LED1 和 PS_LED1 同频闪烁，这是设备树配置文件产生的结果。

    Petalinux 的功能远不止如此，其他功能读者有兴趣可进行探索，建议参考 ug1144 参考 手册，也就是 Xilinx 官方编写的 PetaLinux 工具使用说明文档。
</code></pre>
<p><strong>支持文档</strong> ：[Xilinx Wiki - Confluence (atlassian.net)](<a target="_blank" rel="noopener" href="https://xilinx-/">https://xilinx-</a><br>wiki.atlassian.net&#x2F;wiki&#x2F;spaces&#x2F;A&#x2F;overview “Xilinx Wiki - Confluence<br>(atlassian.net)“)</p>
<pre><code>    特别说明：以后我们使用主机终端指代电脑上 Ubuntu 系统的终端，串口终端指代通过串 口线连接到开发板显示在串口上位机中的终端。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133468006">https://blog.csdn.net/qq_32971095/article/details/133468006</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">边缘检测——Matlab实现计算机视觉＜1＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-29 22:26:50" itemprop="dateCreated datePublished" datetime="2023-09-29T22:26:50+08:00">2023-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="边缘检测——Matlab实现计算机视觉＜1＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/09/29/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94Matlab%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9C1%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%BD%9C%E4%B8%9A%E6%A6%82%E8%BF%B0%EF%BC%9A">作业概述：</a></p>
<p><a href="about:blank#%E4%B8%80.%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Sobel%E7%AE%97%E5%AD%90">一.一阶导数算子——Sobel算子</a></p>
<p><a href="about:blank#%E4%BA%8C.%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E2%80%94%E2%80%94Canny%E7%AE%97%E5%AD%90">二.二阶导数算子——Canny算子</a></p>
<p><a href="about:blank#%E9%99%84%E5%BD%95%EF%BC%9A">附录：</a></p>
<p><a href="about:blank#1.%E4%BD%BF%E7%94%A8%E7%9A%84sobel%E7%AE%97%E5%AD%90">1.使用的sobel算子</a></p>
<p><a href="about:blank#2.%E4%BD%BF%E7%94%A8%E7%9A%845*5%E9%AB%98%E6%96%AF%E5%B9%B3%E6%BB%91%E6%A8%A1%E7%89%88">2.使用的5*5高斯平滑模版</a></p>
<p><a href="about:blank#3.%E6%BA%90%E4%BB%A3%E7%A0%81">3.源代码</a></p>
<hr>
<p>西安电子科技大学_计算机视觉_作业一_边缘检测</p>
<h2 id="作业概述："><a href="#作业概述：" class="headerlink" title="作业概述："></a>作业概述：</h2><p>作业 1：边缘检测 编程语言：Matlab（推荐） 或 Python（可能需要使用 OpenCV）</p>
<p>题目内容：</p>
<p>自选一张图像，编程实现以下操作：</p>
<p>• 分别采用 Sobel 算子和 Canny 算子滤波，进行边缘提取；</p>
<p>• 显示原始图像以及不同滤波器滤波后的结果</p>
<p>• 对于 Sobel 滤波结果，显示 x 方向的梯度、y 方向的梯度、梯度幅度、梯 度角度等</p>
<p>• 对于 Canny 算子滤波，显示滤波后边缘检测结果 并分析不同滤波结果的差异。</p>
<p>说明：</p>
<p>（1）基于原理，自行实现，进行计算（禁止使用自带函数进行滤波）。各种滤 波函数应进行封装，并在统一的 test 文件（test.m or<br>test.py）中调用使用。</p>
<p>（2） 所得各图像，按照子图样式显示(subplot)，并标注(title)</p>
<p>（3） 打包文件夹，包含代码和文档，文档中应包含上述结果的截图及最终分 析。</p>
<p>要求：内容完备（包含计算过程），结构清晰、排版美观。</p>
<h2 id="一-一阶导数算子——Sobel算子"><a href="#一-一阶导数算子——Sobel算子" class="headerlink" title="一.一阶导数算子——Sobel算子"></a>一.一阶导数算子——Sobel算子</h2><p>通过求导可以得到边缘，边缘像素变化快，导数绝对值大。在离散点中则使用差分近似，通过与特定的卷积核卷积实现差分运算，并近似出该点导数。</p>
<p>而Sobel算子分为x轴方向和y轴方向，分别卷积获得各像素点x、y轴梯度x_g和y_g。梯度幅值用x_g和y_g的2-范数（平方和开根）求得（也可用1-范数[绝对值求和]近似，减少运算量），相位用arctan求得。</p>
<p><strong>测试结果：</strong></p>
<p>原图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f089df392b290c82c2217105c8da4e7f.jpeg"></p>
<p>sobel滤波：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8b9d8d83a6334aa1992c110a768b94f4.jpeg"></p>
<p>x方向梯度：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e38d99b56bbf67908f656b8eadabd2f.jpeg"></p>
<p>y方向梯度：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/087357e370b158b125a780536caff592.jpeg"></p>
<p>从图中可以清晰看到x轴方向和y轴方向的Sobel算子检测结果的差异。梯度的幅度和相位保存在mat文件中。</p>
<h2 id="二-二阶导数算子——Canny算子"><a href="#二-二阶导数算子——Canny算子" class="headerlink" title="二.二阶导数算子——Canny算子"></a>二.二阶导数算子——Canny算子</h2><p>Canny边缘检测算法包括以下步骤[1]：</p>
<p>1.高斯平滑，滤除噪声</p>
<p>2.计算梯度强度和方向</p>
<p>3.应用非极大值抑制法（Nom-Maximum Suppression，NMS），以消除杂散效应</p>
<p>4.应用滞后阈值法检测边缘</p>
<p>（5.边缘跟踪得到单像素宽度的边缘图像）</p>
<p>这里主要说明第3步：</p>
<pre><code>    图像梯度矩阵中的元素值大，不能直接用来判断该点为边缘。NMS可以剔除伪边缘信息。如果该像素满足梯度局部最大值，则判断该像素为边缘，并对其余像素的相关信息进行抑制。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ca59c955dc405d499ac1b357d0cce8c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e8cafc9ef237158894971f55f7c810c.jpeg"></p>
<pre><code>    中心点周围有8个领域点，但做中心点梯度方向的直线的交点并不一定的8-领域点，根据交点所在的区域可以将领域划分为4块，交点PM、PN的值通过线性插值计算。

    最后放大保留下来的像素点，这里简单地将满足双阈值间的点灰度设置为255。
</code></pre>
<p><strong>测试结果：</strong></p>
<p>高斯平滑：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9399bb1b0692b68d6e2be51c27872fb9.jpeg"></p>
<p>高斯平滑后sobel滤波：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f203482fda90f8be278e727cc58328f0.jpeg"></p>
<p>非极大值抑制：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/622487c3dba1ca0f1f6324d30ded53d1.jpeg"></p>
<p>双阈值处理：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/07e60e31a5360caee06a12687e923136.jpeg"></p>
<p>可以通过调整双阈值来调整最终结果保留细节的多少</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb56bf290e418556ec6cdf1684206f85.jpeg"></p>
<h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><h3 id="1-使用的sobel算子"><a href="#1-使用的sobel算子" class="headerlink" title="1.使用的sobel算子"></a>1.使用的sobel算子</h3><p>s_x&#x3D;1&#x2F;8*[1,0,-1;2,0,-2;1,0,-1];</p>
<p>s_y&#x3D;1&#x2F;8*[-1,-2,-1;0,0,0;1,2,1];</p>
<h3 id="2-使用的5-5高斯平滑模版"><a href="#2-使用的5-5高斯平滑模版" class="headerlink" title="2.使用的5*5高斯平滑模版"></a>2.使用的5*5高斯平滑模版</h3><p>gs&#x3D;1&#x2F;159*[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];</p>
<h3 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3.源代码"></a>3.源代码</h3><pre><code>function []=Sobel_Canny_Filter(Src_img)
%% 输入参数：同路径下照片名。使用举例：Sobel_Canny_filter(&#39;Test.jpg&#39;)

%%  一阶导数——Sobel算子。
F=imread(Src_img);
f=double(rgb2gray(F));
[row,col]=size(f);

%   Sobel核处理结果
X_grad=zeros(row,col);
Y_grad=zeros(row,col);
S_dir=zeros(row,col);
Output_img=zeros(row,col);

%   Sobel核
s_x=[1,0,-1;2,0,-2;1,0,-1];
s_y=[-1,-2,-1;0,0,0;1,2,1];

for i=2:row-1
    for j=2:col-1
        %   卷积运算
        fx=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];
        fy=[f(i-1,j-1),f(i-1,j),f(i-1,j+1);f(i,j-1),f(i,j),f(i,j+1);f(i+1,j-1),f(i+1,j),f(i+1,j+1)];
        Sx=0.125*s_x.*fx;
        Sy=0.125*s_y.*fy;
        x_g=sum(Sx,&#39;all&#39;);
        y_g=sum(Sy,&#39;all&#39;);
        
        %   关键数值求解
        S_dir(i,j)=atan2(y_g,x_g);        
        A=sqrt(x_g^2+y_g^2);
        X_grad(i,j)=abs(x_g);
        Y_grad(i,j)=abs(y_g);
        Output_img(i,j)=A;
    end
end

%%   绘图
figure(8);

%   原图
subplot(2,4,1);
imshow(F);
title(&#39;source&#39;);

%   sober滤波后图
subplot(2,4,2);
imshow(Output_img,[]);
title(&#39;sobel-filter&#39;);
imwrite(uint8(Output_img),&#39;sobel_filter.jpg&#39;);

%   x方向梯度
subplot(2,4,3);
imshow(X_grad,[]);
title(&#39;x-grad&#39;);
imwrite(uint8(X_grad),&#39;X_grad.jpg&#39;);

%   y方向梯度
subplot(2,4,4);
imshow(Y_grad,[]);
title(&#39;y-grad&#39;);
imwrite(uint8(Y_grad),&#39;Y_grad.jpg&#39;);

%   保存梯度的幅度和相位
save(&#39;Amplitude.mat&#39;,&quot;A&quot;);
save(&#39;dir.mat&#39;,&quot;S_dir&quot;);

%% 二阶导数——Canny算子。
%%   高斯滤波  
Gs=zeros(row,col);
Gs_sobel=zeros(row,col);
Canny_temp=zeros(row,col);
Canny=zeros(row,col);
%   5*5高斯核
gs=[2,4,5,4,2;4,9,12,9,4;5,12,15,12,5;4,9,12,9,4;2,4,5,4,2];
for i=3:row-2
    for j=3:col-2
        gg=[f(i-2,j-2),f(i-2,j-1),f(i-2,j),f(i-2,j+1),f(i-2,j+2);f(i-1,j-2),f(i-1,j-1),f(i-1,j),f(i-1,j+1),f(i-1,j+2);f(i,j-2),f(i,j-1),f(i,j),f(i,j+1),f(i,j+2);f(i+1,j-2),f(i+1,j-1),f(i+1,j),f(i+1,j+1),f(i+1,j+2);f(i+2,j-2),f(i+2,j-1),f(i+2,j),f(i+2,j+1),f(i+2,j+2)];
        s_g=gs.*gg/159;
        Gs(i,j)=sum(s_g,&#39;all&#39;);
    end
end

%%   高斯平滑
for i=3:row-2
    for j=3:col-2
        gsx=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];
        gsy=[Gs(i-1,j-1),Gs(i-1,j),Gs(i-1,j+1);Gs(i,j-1),Gs(i,j),Gs(i,j+1);Gs(i+1,j-1),Gs(i+1,j),Gs(i+1,j+1)];
        Sx=0.125*s_x.*gsx;
        Sy=0.125*s_y.*gsy;
        gsx_g=sum(Sx,&#39;all&#39;);
        gsy_g=sum(Sy,&#39;all&#39;);
        
        GSS_dir(i,j)=atan(gsx_g/gsy_g);        
        GSA=sqrt(gsx_g^2+gsy_g^2);
        GSX_grad(i,j)=abs(x_g);
        GSY_grad(i,j)=abs(y_g);
        Gs_sobel(i,j)=GSA;
    end
end

%%   高斯平滑后sobel滤波
for i=3:row-2
    for j=3:col-2
        k=abs(tan(GSS_dir(i,j)));
        %   非极大值抑制
        %   判断领域点(非8-领域点可划分为4部分)并进行相应线性插值并判断是否为局部大优点（进行保留）
        if (GSS_dir(i,j)&gt;=0 &amp;&amp; GSS_dir(i,j)&lt;pi/4) || (GSS_dir(i,j)&gt;=-pi &amp;&amp; GSS_dir(i,j)&lt;-3*pi/4)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j+1)+(Gs_sobel(i+1,j+1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j-1)+(Gs_sobel(i-1,j-1)-Gs_sobel(i-1,j))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end        
        elseif (GSS_dir(i,j)&gt;=pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi/2) || (GSS_dir(i,j)&gt;=-3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;-pi/2)
            if Gs(i,j) &gt;= (Gs_sobel(i-1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i-1,j-1))/k) &amp;&amp; Gs_sobel(i,j) &gt;= (Gs_sobel(i+1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i+1,j+1))/k)
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        elseif (GSS_dir(i,j)&gt;=pi/2 &amp;&amp; GSS_dir(i,j)&lt;3*pi/4) || (GSS_dir(i,j)&gt;=-pi/2 &amp;&amp; GSS_dir(i,j)&lt;-pi/4)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i,j-1)-Gs_sobel(i+1,j-1))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i,j+1)-Gs_sobel(i-1,j+1))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        elseif (GSS_dir(i,j)&gt;=3*pi/4 &amp;&amp; GSS_dir(i,j)&lt;pi) || (GSS_dir(i,j)&gt;=-pi/4 &amp;&amp; GSS_dir(i,j)&lt;0)
            if Gs_sobel(i,j) &gt;= Gs_sobel(i+1,j-1)+(Gs_sobel(i+1,j-1)-Gs_sobel(i+1,j))/k &amp;&amp; Gs_sobel(i,j) &gt;= Gs_sobel(i-1,j+1)+(Gs_sobel(i-1,j+1)-Gs_sobel(i-1,j))/k
             Canny_temp(i, j) = Gs_sobel(i, j);
            end
        end
    end
end

%%   双阈值变换
lowTh  = 0.02 *max(max(Canny_temp));%高阈值
higtTh = 1 *max(max(Canny_temp));%低阈值

for i = 3 : row-2
    for j = 3 : col-2
        %   灵活设置保留值
        if Canny_temp(i,j) &gt;=lowTh &amp;&amp; Canny_temp(i,j) &lt;= higtTh
            %Canny(i,j) = Canny_temp(i,j);
            Canny(i,j) = 255;
        end
    end
end

%% 绘图
%   高斯平滑结果
subplot(2,4,5);
imshow(Gs,[]);
title(&#39;gauss-filter&#39;);
imwrite(uint8(Gs),&#39;gauss_filter.jpg&#39;);

%   高斯平滑后sobel滤波结果
subplot(2,4,6);
imshow(Gs_sobel,[]);
title(&#39;gauss-sobel-filter&#39;);
imwrite(uint8(Gs_sobel),&#39;Gs_sobel_filter.jpg&#39;);

%   非极大值抑制后结果
subplot(2,4,7);
imshow(Canny_temp,[]);
title(&#39;Canny-temp&#39;);
imwrite(uint8(Canny_temp),&#39;Canny_temp.jpg&#39;);

%   阈值间处理
subplot(2,4,8);
imshow(Canny,[]);
title(&#39;Canny-filter&#39;);
imwrite(uint8(Canny),&#39;Canny_filter.jpg&#39;);

%保存结果
saveas(8,&#39;result.jpg&#39;);
 
end
</code></pre>
<p>参考文献</p>
<p>[1]柳林.基于OpenCV的数字图像处理技术[M].杭州:浙江大学出版社，2020：202-203.</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133420554">https://blog.csdn.net/qq_32971095/article/details/133420554</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/" class="post-title-link" itemprop="url">Vitis开发一——FPGA学习笔记＜8＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-25 21:52:25" itemprop="dateCreated datePublished" datetime="2023-09-25T21:52:25+08:00">2023-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="Vitis开发一——FPGA学习笔记＜8＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/09/25/Vitis%E5%BC%80%E5%8F%91%E4%B8%80%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C8%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.Hello%20World%20%E5%AE%9E%E9%AA%8C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">一.Hello World 实验
</a></p>
<p><a href="about:blank#1.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">1.硬件设计</a></p>
<p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p>
<p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p>
<p><a href="about:blank#%3C1%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20UART">&lt;1&gt;配置 PS 的<br>UART</a></p>
<p><a href="about:blank#%3C2%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%20DDR4%20%E6%8E%A7%E5%88%B6%E5%99%A8">&lt;2&gt;配置 PS 的 DDR4<br>控制器</a></p>
<p><a href="about:blank#%3C3%3E%E9%85%8D%E7%BD%AE%20PS%20%E7%9A%84%E6%97%B6%E9%92%9F">&lt;3&gt;配置 PS<br>的时钟</a></p>
<p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL%20%E6%A8%A1%E5%9D%97">step3：生成顶层 HDL<br>模块</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#2.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.软件设计</a></p>
<p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p>
<p><a href="about:blank#3.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">3.下载验证</a></p>
<p><a href="about:blank#step6%EF%BC%9A%E6%9D%BF%E7%BA%A7%E9%AA%8C%E8%AF%81">step6：板级验证</a></p>
<p><a href="about:blank#%E4%BA%8C.GPIO%20%E4%B9%8B%20MIO%20%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">二.GPIO 之 MIO 控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4">2.实验步骤</a></p>
<p><a href="about:blank#3.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.硬件设计</a></p>
<p><a href="about:blank#step1%EF%BC%9A%E5%88%9B%E5%BB%BA%20Vivado%20%E5%B7%A5%E7%A8%8B">step1：创建 Vivado<br>工程</a></p>
<p><a href="about:blank#step2%EF%BC%9A%E4%BD%BF%E7%94%A8%20IP%20Integrator%20%E5%88%9B%E5%BB%BA%20Processing%20System">step2：使用 IP Integrator 创建 Processing<br>System</a></p>
<p><a href="about:blank#step3%EF%BC%9A%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%20HDL">step3：生成顶层<br>HDL</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#4.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">4.软件设计</a></p>
<p><a href="about:blank#step5%EF%BC%9A%E5%9C%A8%20Vitis%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B">step5：在 Vitis<br>中创建应用工程</a></p>
<p><a href="about:blank#5.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">5.下载验证</a></p>
<p><a href="about:blank#%E4%B8%89.GPIO%20%E4%B9%8B%20EMIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">三.GPIO 之 EMIO 按键控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#step4%EF%BC%9A%E7%94%9F%E6%88%90%20Bitstream%20%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%20Hardware">step4：生成 Bitstream 文件并导出<br>Hardware</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#%E5%9B%9B.GPIO%E4%B9%8BMIO%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C">四.GPIO之MIO按键中断实验</a></p>
<p><a href="about:blank#%C2%A01.%E7%AE%80%E4%BB%8B"> 1.简介</a></p>
<p><a href="about:blank#%3C1%3E.%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B">&lt;1&gt;.处理器中断类型</a></p>
<p><a href="about:blank#%3C2%3E%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8GIC">&lt;2&gt;中断控制器GIC</a></p>
<p><a href="about:blank#%3C3%3EGPIO%20%E7%9A%84%20MIO%20%E7%9A%84%E4%B8%AD%E6%96%AD">&lt;3&gt;GPIO 的 MIO<br>的中断</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#%E4%BA%94.AXI%20GPIO%20%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%20LED%20%E5%AE%9E%E9%AA%8C">五.AXI GPIO 按键控制 LED<br>实验</a></p>
<p><a href="about:blank#1.%E7%AE%80%E4%BB%8B">1.简介</a></p>
<p><a href="about:blank#2.%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">2.硬件设计</a></p>
<p><a href="about:blank#step2%3Avivado%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0">step2:vivado硬件平台</a></p>
<p><a href="about:blank#3.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">3.软件设计</a></p>
<p><a href="about:blank#4.%E8%A1%A5%E5%85%85">4.补充</a></p>
<hr>
<h2 id="一-Hello-World-实验"><a href="#一-Hello-World-实验" class="headerlink" title="一.Hello World 实验"></a>一.Hello World 实验</h2><pre><code>    在MPSOC开发板上搭建MPSOC嵌入式最小系统，并使用串口打印“Hello World” 信息。通过本次实验我们将了解 **MPSOC 嵌入式系统的开发流程** ，熟悉 **MPSOC 嵌入式最小系统的搭建**。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/66ab6afbb3d420e1b7089143e4466727.png"></p>
<pre><code>    如上图所示，开发流程大体可以分为 6 步。其中 step1 至 step4 为硬件设计部分，在 Vivado 软件中实现； step5 为软件设计部分，在 Vitis 软件中实现；step6 为功能的验证。复杂的程序还涉及 Debug，这个也是在 Vitis 软件中实施。

    嵌入式最小系统的概念包括以下两个方面：一、它是使系统正常工作的最小条件；二、它是其他系统建立的基础。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d830912c59cd7970e89dc798be2e099d.png"></p>
<pre><code>    以 ARM Cortex 为核心、DDR 为内存，加上传输信息使用的 UART 串口就构成了 MPSOC 嵌入式最小系统。可以看到，这个最小系统只包括了 MPSOC 中的 PS 部分。
</code></pre>
<h3 id="1-硬件设计"><a href="#1-硬件设计" class="headerlink" title="1.硬件设计"></a>1.硬件设计</h3><h4 id="step1：创建-Vivado-工程"><a href="#step1：创建-Vivado-工程" class="headerlink" title="step1：创建 Vivado 工程"></a><strong>step1：创建 Vivado 工程</strong></h4><pre><code>    注意project type界面选择rtl project并且“Do not specify sources at this time”；器件型号选择“xczu2eg-sfvc784-2-i”；
</code></pre>
<h4 id="step2：使用-IP-Integrator-创建-Processing-System"><a href="#step2：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a><strong>step2：使用 IP Integrator 创建 Processing System</strong></h4><pre><code>    在左侧导航栏（**Flow Navigator）** 中，单击 **IP Integrator** 下的 **Create Block Design** ；接下来在 Diagram 窗口中给设计添加 IP。点击上图中箭头所指示的加号(两个任选一个)“+”，会 打开 IP 目录（IP Catalog）。也可以通过快捷键 Ctrl + I，或者右键点击 Diagram 工作区中的空白位置，然后选择“ADD IP”；打开 IP 目录后，在搜索栏中键入“ZYNQ”，找到并双击**“Zynq UltraScale+MPSOC”** ，将 Zynq UltraScale+MPSOC IP 添加到设计中。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff638c73b44ed84dd4f13a3e9db79fab.png"></p>
<pre><code>    双击所添加的 Zynq UltraScale+MPSOC 模块，进入处理系统的配置界面。界面左侧为页面导航面板， 右侧为配置信息面板。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac3239cf0f859b989c7d926f407b66f5.png"></p>
<p>下面我们简要地介绍一下页面导航面板中各个页面的作用：</p>
<p><strong>PS UltraScale+ Block Design</strong> 页面显示了 zynq 硬核的整体架构图，其中绿色部分是可配置模块，可以点<br>击进入相应的编辑界面进行配置，当然也可以在左侧导航栏选择相应的编辑界面。</p>
<p><strong>I&#x2F;O Configuration</strong> 页面可以选择不同的 I&#x2F;O 外设并进行相应的配置。</p>
<p><strong>Clock Configuration</strong> 页面分为 Input Clocks 和 Output Clocks 两个标签页，用来配置 PS<br>输入时钟、外设 时钟，以及 DDR 和 CPU 时钟等。</p>
<p><strong>DDR Configuration</strong> 页面用于设置 DDR 控制器配置信息。</p>
<p><strong>PS-PL Configuration</strong> 用于 PS 和 PL 交互的相关配置，包括常用的中断、复位信号和数据接口。</p>
<h5 id="配置-PS-的-UART"><a href="#配置-PS-的-UART" class="headerlink" title="&lt;1&gt;配置 PS 的 UART"></a>&lt;1&gt;配置 PS 的 UART</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00b2930a9fea37d61d892e33ef7cfc19.png"></p>
<pre><code>    点击导航面板中 I/O Configuration，PS 和外部设备之间的连接主要是通过复用的输入/输出**（Multiplexed Input/Output，MIO）** 来实现的。**BANK501 中的 MIO42 和 MIO43 被用作 UART 串口通信的引脚，并最终与开发板上的 USB 转串口芯片 CH340 连接** 。因此，为了实现串口 通信的功能，我们需要在 PS 中将 MIO42 和 MIO43 配置成 UART0 模块的接口引脚。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9253bb0e6120f4d7752df56866af224e.png"></p>
<h5 id="配置-PS-的-DDR4-控制器"><a href="#配置-PS-的-DDR4-控制器" class="headerlink" title="&lt;2&gt;配置 PS 的 DDR4 控制器"></a>&lt;2&gt;配置 PS 的 DDR4 控制器</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/86cb4773d4bce9fa668f8588f3fc7151.png"></p>
<h5 id="配置-PS-的时钟"><a href="#配置-PS-的时钟" class="headerlink" title="&lt;3&gt;配置 PS 的时钟"></a>&lt;3&gt;配置 PS 的时钟</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dde78d189b9ec8cdb96dfb848af3aee2.png"></p>
<pre><code>    点击左侧 Clock Configuration 打开时钟配置页面，该界面主要是配置 MPSOC PS 中的时钟频率。比如 输入时钟默认是 33.33333Mhz，这与我们开发板上的 PS 端输入时钟频率相同。对于 CPU 的时钟、DDR 的 时钟以及其它外设的时钟，我们直接保持默认设置即可。

    因为本实验是**搭建 MPSOC 的嵌入式最小系统，只需要使用 MPSOC 中的 PS 端。因此我们将 PS 中与 PL 端交互的接口信号移除。**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b22291cae6354b595278fd575ac76.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcbef3d3c3dcc0ebeb8c1b682b5ff426.png"></p>
<pre><code>    返回到 Vivado 界面后，在 Diagram 中可以看到 ZYNQ UltraScale+ MPSOC IP 模块变化，该模块少了四组接口，这正是因为我们在配置该 IP 核的过程中**移除了与 PL 相关的接口信号** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df81e05298566f091c3790ff47385a18.png"></p>
<p>点击下图中箭头所指示的按钮“validate design”，对我们配置的 IP 核进行验证</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/77b0703425768c83045ffcca779129a2.png"></p>
<h4 id="step3：生成顶层-HDL-模块"><a href="#step3：生成顶层-HDL-模块" class="headerlink" title="step3：生成顶层 HDL 模块"></a><strong>step3：生成顶层 HDL 模块</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/073a28eee47c2b6b618081420d2e35e3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4d2b3b14a1a9f8a64a8dfe31c7a52bdf.png"></p>
<pre><code>    在对话框中，Synthesis Options 选择 Out of context per IP，这里我们保持默认；Run Setings 用于设置生 成过程中要使用的处理器的线程数，进行多线程处理，保持默认或设置为个人电脑处理器最大可使用线程 数都可以，一般选择最大可使用线程数。然后点击“Generate”来生成设计的综合、实现和仿真文件。

    在“Generate”过程中会为设计生成所有需要的输出结果。比如 Vivado 工具会自动生成处理系统的 XDC 约束文件，因此我们不需要手动对 MPSOC PS 引出的接口（DDR 和 FIXED_IO）进行管脚分配。

    Generate 完成后，在弹出的对话框中点击“OK”。

    在 Sources 窗口中，点击“IP Source”标签页，可以看到 Generate 过程生成的输出结果。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9460672d014aabbdfd341cc584c1458e.png"></p>
<p>在“Hierarchy”标签页再次右键点击 system.bd，然后选择“Create HDL Wrapper”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/096595aeafc1562dc64f78ee57d7a9d6.png"></p>
<p>在弹出的对话框中确认勾选“Let Vivado manage wrapper and auto-update”，然后点击“OK”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/04b4162c472bae880b5b708ef1df3bff.png"></p>
<pre><code>    design_1_wrapper.v 为创建的 Verilog 文件，箭头所指的“品”字形图标指示当前模块为顶层模块。该模 块使用 Verilog HDL 对设计进行封装，主要完成了对 block design 的例化，大家也可以双击打开该文件查看 其中的内容。

    另外我们勾选了“Let Vivado manage wrapper and auto-update”，这样我们在修改了 Block Design 之后就不需要再重新生成顶层模块，**Vivado 工具会自动更新该文件** 。
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware"><a href="#step4：生成-Bitstream-文件并导出-Hardware" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    **如果设计中使用了 PL 的资源，则需要添加引脚约束并对该设计进行综合、实现并生成 Bitstream 文件。** 本次实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需将硬件导出。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/84d183341bcdf40ec8db6c00d6a74a7d.png"></p>
<pre><code>    在弹出的对话框中，因为没有生成 bitstream 文件，所以无需勾选“Include bitstream”，直接点击“OK” 按钮。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/552ed376805a0dbd4f0ec780a3273a85.png"></p>
<pre><code>    上图中，XSA file name 一栏是产生的硬件信息文件的文件名，这里我们保持默认。Export to 后面的路 径是生成的包含硬件信息文件的路径，生成的文件如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b2274963b330c10cb807b4ed637907e.png"></p>
<p>新建 vitis 文件夹，将xsa文件移入备用，后续作为 vitis 软件开发存储路径。</p>
<p>在菜单栏中选择 T<strong>ools &gt; Launch Vitis，启动 Vitis 开发环境</strong>。如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3a4c3976d15c6c83da2f8fb04b618df2.png"></p>
<p>在弹出的对话框中，<strong>我们将工程路径指定到新建的 vitis 文件夹下</strong> ，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d79b59e6a49e77327e778f9e71f0ab45.png"></p>
<pre><code>    到这里，我们已经完成了 MPSOC 嵌入式系统的硬件设计部分。接下来需要到 Vitis 软件中进行应用程 序开发，也就是软件设计部分。
</code></pre>
<h3 id="2-软件设计"><a href="#2-软件设计" class="headerlink" title="2.软件设计"></a>2.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程"><a href="#step5：在-Vitis-中创建应用工程" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><p>在菜单栏选择 File &gt; New &gt; Application Project, 新建一个 vitis 应用工程</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f33bd6da382274b4e043b9c2b8bd96fb.png"></p>
<p>在弹出的对话框中，输入工程名“hello_world”，其它选项保持默认，点击“Next”，如下图 所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0198478b7f07905b054d257837434c1a.png"></p>
<p>打开 Create a new platform from hardware(XSA)标签页，<strong>点击“+”添加 xsa 文件</strong> ，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca8dc52ec3036fad0de51d0e881659c.png"></p>
<p>添加之前生成的xca文件，添加 xsa 文件后后点击 next。</p>
<p>在弹出的页面中有一个 Generate boot components 选项，如果勾选，软件会自动生成 fsbl 工程，这 里我们选择默认勾选，然后点击<br>next，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/288d2ba5ef4342f13cc8d63a597b4e5b.png"></p>
<p>在弹出的工程模板选择页面里，我们选择已有的 Hello World 模板，然后点击 Finish</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbca540ff2514ca9d5a8846fed7eee51.png"></p>
<pre><code>    工程建立完成后的页面如下图所示，我看可以看到生成了两个工程，一个是硬件平台工程，即 **platform 工程** ，一个是**应用工程** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/117f8abd36ad2af8f6b1d02788b749e6.png"></p>
<pre><code>    双击打开 hello_world/src 工程目录下 helloworld.c 文件，可以看到源代码。

    可以看到程序中主函数调用了 3 个函数，分别是 **init_platform()、cleanup_platform()和 print()** 函数。我们将鼠标停留在各个函数名上，vitis 就会显示该函数的声明。如果想查看函数的定义，可以**按住 Ctrl 键不放， 用鼠标点击相应的函数，就会跳转到其定义的地方** 。

    可以看到 init_platform 函数的作用是使能 caches 和初始化 uart；cleanup_platform 函数的作用是取消使 能 caches。实际上这两个函数在该工程中并没有启动任何作用，因为这两个函数是针对于特定平台如 Microblaze 的，对于我们使用的 MPSOC 平台而言是不起作用的，所以 main 函数中只需包含第 9 行的 print 语句就可以了，出于平台的通用性和可移植性，此处我们保留这两个函数。

    另外需要注意程序中打印字符串“Hello World”使用的是 **print()** 函数，而不是 C 语言里的 **printf()** 函数。 print()函数是 Xilinx 定义的一个用于打印字符串的函数，调用该函数需要包含头文件**“xil_printf.h”。**
</code></pre>
<p>选中应用工程，右键 Build Project 对工程进行编译。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/27b2222431094b40193d6127c4c5b66c.png"></p>
<pre><code>    编译进度可以在工具下方的控制台面板（Console）中进行查看，编译完成后显示“Finished building： hello_world.elf”，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bfb4630e5ba6a99f44351730d5dd7bde.png"></p>
<h3 id="3-下载验证"><a href="#3-下载验证" class="headerlink" title="3.下载验证"></a>3.下载验证</h3><pre><code>    首先我们将下载器与 MPSOC 开发板上的 **JTAG 接口连接** ，下载器另外一端与电脑连接。使用 USB 连接线将开发板 **USB_UART ( PS_PORT)**接口与电脑连接，用于串口通信。接下来将开发板上四个启动模式开关均置为 ON，即**设置为 JTAG 模式** 。最后连接开发板电源给开发板上电。

    注意第一次连接开发板 USB_UART 接口时，需要安装 CH340 驱动(USB 串口驱动)。
</code></pre>
<h4 id="step6：板级验证"><a href="#step6：板级验证" class="headerlink" title="step6：板级验证"></a>step6：板级验证</h4><pre><code>    在 Vitis 软件的下方，找到 Terminal 窗口。如果界面中没有找到该窗口，或者操作过程中把该窗口 给关闭了，则可以通过在菜单栏中选择 Window &gt; Show View &gt; Other，在 Show View窗口中搜索添加 Terminal。
</code></pre>
<p>添加 Terminal 后如下图所示，点击箭头处的图标对串口进行设置。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/170e4143f360ea63e740c76d3b806da9.png"></p>
<p>在弹出的窗口中，Choose terminal 一栏中，下拉选择 Serial Terminal<br>串口终端，选择串口终端后，接下来需要对串口设置。这里设置波特率为 “115200”，数据位为 8 位，停止位为 1 位，然后点击 OK，如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3f622888054796bdd0a2450834d5f07b.png"></p>
<p>配置完成，连接成功后如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fee5583261c8e02c05908b44d905ac77.png"></p>
<p>右键 hello_world 工程，选择**“Run As”** ，选择**“Run Confagurations…”** ， 下载程序：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7378853644c71f828f51c56cf93f0dbc.png"></p>
<pre><code>    在打开的下载页面中，没有出现下载选项，这时需要双击左侧列表中 Single Application Debug 一项，双击后，该项下面出现新的项 Debugger_hello_world-default，同时在右侧出现的页面中选择 Target Setup 标签 页，**勾选复位** ，然后点击 run 下载程序，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ac2948aee4eca8357489df5e2904f51.png"></p>
<pre><code>    下载完成后，应用程序会将字符串“Hello World”通过 MPSOC PS 端的串口模块发送出去。在 Terminal 窗口可以看到上位机接收到的字符串，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1069bf74b114b8f0a8ecf6565c000d3c.png"></p>
<h2 id="二-GPIO-之-MIO-控制-LED-实验"><a href="#二-GPIO-之-MIO-控制-LED-实验" class="headerlink" title="二.GPIO 之 MIO 控制 LED 实验"></a>二.GPIO 之 MIO 控制 LED 实验</h2><pre><code>    GPIO 可以通过 **MIO** 连接到 **PS** 端的引脚，也可以通过 **EMIO** 连接到 **PL** 。本章将介绍如何使用 GPIO 外设通过 MIO 控制 PS 端的 LED。
</code></pre>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    MPSOC 分为 PS 和 PL 两部分，那么器件的引脚（Pin）资源同样也分成了两部分。MPSOC PS 中的外设可以通过 MIO（Multiuse I/O，多用输入/输出）模块连接到 PS 端的引脚上，也可以通过 EMIO 连接到 PL 端的引脚。MPSOC 系列芯片一般有 78 个 MIO。

    图是 GPIO 的框图，从中我们可以看到 GPIO 分为 6 个 Bank，其中 **Bank0、Bank1 和 Bank2 连接到 MIO；而 Bank3、Bank4 和 Bank5 连接到 EMIO** 。Bank0、Bank1 和 Bank2 分别有 26bit，总共 78bit，也就是说有 78 个 MIO。Bank3、Bank4 和 Bank5 分 别有 32bit，也就是说 PS 端可以使用 96 个 EMIO。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32042201490b2369989d7e8ca0fac313.png"></p>
<pre><code>    PS 所有的外设都可以通过 MIO 访问，这些外设也是与 MIO 进行连接，每个 MIO 虽然可以独立控制， 以及独立驱动单个引脚的外设，但对于 QSPI、USB、以太网等这些外设，对于 MIO 的连接有着特殊的要求， 如图 2.1.2 所示，对于以太网而言，要与 MIO26~37、MIO38~49、MIO52~63 和 MIO64~75 引脚连接，而且 以太网与 MIO26 连接的引脚只能作为以太网的 tx_clk 使用，可见当其作为以太网的接口引脚时，相应的 MIO 的功能就已经确定下来了。从图中 MIO 一览表中我们可以看到 **MIO 一但选定，引脚位置就已经确定下来了，不需要添加引脚约束** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/caa5d520533e9acf50023b1178d6daab.png"></p>
<pre><code>    MIO 与 PS 是如何连接的？ 图展示 PS 的 IO 外设。PS 外设的大多数 I/O 信号可以通过 MIO 路由到 PS 引脚，或通过 EMIO 路由到 PL 引脚。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/287affef4a19c843b014f61d1d6bdd42.png"></p>
<pre><code>    这里我们重点介绍外设系统图中箭头所指的部分。**PS 通过 APB 总线对 控制、状态寄存器的读写实现对 GPIO 的驱动**，具体可以参见下图。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6a0f8cbf358581c776ffb063389cf74.png"></p>
<pre><code>    左边的一列是寄存器，上半部分是关于中断的，这部分我们在涉及到中断的时候会讲解，这里 我们重点介绍下红色框圈出的下半部分。

    **DATA_RO** 是数据只读寄存器，通过该寄存器能够观察器件引脚上的值。如果 GPIO 信号配置为**输出** ， 则通常会反映输出上驱动的值，**写入此寄存器将被忽略** 。

    **DATA** 是**数据寄存器** ，该寄存器控制 GPIO 信号**配置为输出时要输出的值** 。该寄存器的所有 **32 位** 都是一次写入的。读取该寄存器返回写入 **DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;** 的先前值，它不会返回器件引脚上的当前值。

    MASK_DATA_LSW 和 MASK_DATA_MSW 是**数据掩码寄存器** ，该寄存器使软件能够有选择地一次更改所需的输出值。可以写入最多 16 位的任意组合，MASK_DATA_LSW 控制 Bank 的低 16 位， MASK_DATA_MSW 控制高 16 位。未写入的那些位保持不变并保持其先前的值。读取该寄存器返回写入 DATA 或 MASK_DATA_ &#123;LSW，MSW&#125;的先前值;它不会返回器件引脚上的当前值。该寄存器避免了对未更改位的读-修改-写序列的需要。 **DIRM** 是**方向模式寄存器** ，用于控制 I/O 引脚是用作**输入还是输出** 。当 **DIRM [x] == 0** 时，**输出驱动器被禁用** ，该引脚作为**输入引脚** 使用。 **OEN** 是使能**输出寄存器** 。将 I/O 配置为输出时，该寄存器控制是否启用输出。**禁用输出时，引脚为 3 态** 。当 **OEN [x] == 0** 时，**输出被禁用** 。

    从这些寄存器中我们可以看到，如果配置引脚为输出，不仅需要**设置方向，还要使能输出** 。关于这些寄存器的具体介绍，可参考 ug1085 手册。需要说明的是我们在程序中操作 MIO 时直接调用 **Xilinx 官方提供的函数** 即可，无需直接操作这些寄存器。

    另外需要说明的是 MIO 信号对 PL 部分是不可用的，所以**对 MIO 的操作是纯 PS 的操作** ，且每个 GPIO 都可独立动态编程为输入、输出或中断检测。

    **从上面看出，Zynq  的 PS 部分就像 stm32 一样，本质都是配置外设的寄存器，利用开发商或者其他提供的友好接口的库函数对寄存器进行配置开发。 stm32 使用 ARM公司提供的cortex-M3内核，通过下载器将机器码下载至存储器代码段。**
</code></pre>
<p>**         此时再回过头来看 stm32 的 SoC 架构和总线系统相比 Zynq 的也容易看了许多，之后再看stm32<br>的数据手册也多了一些理解。还有之后的 stm32 的学习，可以使用 keil5 的调试功能，检查各个寄存器的值和执行的汇编语言，从而更深层面了解微机原理和<br>CPU 的运作。**</p>
<h3 id="2-实验步骤"><a href="#2-实验步骤" class="headerlink" title="2.实验步骤"></a>2.实验步骤</h3><pre><code>    本章的实验任务是使用 GPIO 通过 MIO 控制 PS 端 LED 的亮灭，实现 LED 闪烁的效果。

    从实验任务我们可以画出如下的系统框图，DDR4 中**存放和运行程序** 、UART 打印信息、MIO 驱动 LED 外设。虽然本实验可以不需要 UART，不过为了方便打印一些信息，此处我们加上 UART。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/15845bb43a515dafb87742974f7da7e1.png"></p>
<p><strong>注意养成绘制系统框图的习惯，帮助理解系统架构</strong></p>
<h3 id="3-硬件设计"><a href="#3-硬件设计" class="headerlink" title="3.硬件设计"></a><strong>3.硬件设计</strong></h3><h4 id="step1：创建-Vivado-工程-1"><a href="#step1：创建-Vivado-工程-1" class="headerlink" title="step1：创建 Vivado 工程"></a>step1：创建 Vivado 工程</h4><pre><code>    此处介绍如何在**先前工程的基础上继续实验** 而不破坏先前的工程。

    先打开《第一章 Hello World》实验的 Vivado 工程，打开后选择菜单栏的 File-&gt; Project-&gt;**Save As...。** 在弹出的另存为界面中可以输入新的工程名或更改保存位置，此处我们输入新的工程名“gpio_mio”， 工程位置保持默认即可，然后**取消勾选 Include run results** ，最后点击“OK”。（ _注意：文件所在路径不能过长，最多280个字符，如果保存失败修改存储路径；**另外之前的“Creat_Block_Design”之所以选择默认的“design_1”而不是特定的“hello_world”是因为这个名字设定之后便不可修改，另存之后仍是之前的名字**_ ）
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a300da9bfaa27e3b089ee32f0c5ce58e.png"></p>
<h4 id="step2：使用-IP-Integrator-创建-Processing-System-1"><a href="#step2：使用-IP-Integrator-创建-Processing-System-1" class="headerlink" title="step2：使用 IP Integrator 创建 Processing System"></a>step2：使用 IP Integrator 创建 Processing System</h4><pre><code>    在 Flow Navigator 中，点击 IP INTEGRATOR 下的 Open Block Design，在打开的下图 Diagram 窗口，双击打开 Zynq UltraScale+ MPSOC 重定义窗口。

    在下图所示的重定义窗口，点击左侧的 I/O Configuration，在右侧的界面中展开 Low Speed，展开 I/O Peripherals，展开 GPIO，然后**勾选 GPIO0 MIO 和 GPIO1 MIO** 。另外开发板上的 Bank0 即原理图中的 BANK500 为 1.8V，所以我们将 5 处的 **Bank0、6 处的 bank2 电压设置为 LVCOMS 1.8V** ，最后点击 OK。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/22d22a4f6b00a858b25620f9107a6e89.png"></p>
<pre><code>    实际用到的 GPIO_MIO 与原理图相关。为了方便大家的查找和使用，MPSOC PS 端 IO 引脚分配我们都列在了资料盘开发板原理图文件夹下的 IO 引脚分配总表中，我们摘录部分如下图
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/06d6440e02418eff773e87c0e910e21a.png"></p>
<p>按 Ctrl+S 快捷键保存 Diagram。</p>
<h4 id="step3：生成顶层-HDL"><a href="#step3：生成顶层-HDL" class="headerlink" title="step3：生成顶层 HDL"></a>step3：生成顶层 HDL</h4><pre><code>    在弹出的下图中，Synthesis Options 选择 Global，Run Setings 保持默认选择，然后点击 Generate。
</code></pre>
<p>注意与实验一区别，实验一是“Out of context per IP”，这里是“Global”。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/789eafaaea99b49efbeba278724a37c7.png"></p>
<pre><code>    创建顶层 HDL Wrapper 因为我们在创建 Hello World 实验时创建顶层 HDL Wrapper 使用的是下图所示的 Let Vivado manage wrapper and auto-update选项，所以此处无**需再创建顶层HDL Wrapper** ，Vivado会**自动更新** 顶层HDL Wrapper。 此时第三步完成。
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware-1"><a href="#step4：生成-Bitstream-文件并导出-Hardware-1" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    由于本实验未用到 PL 部分，所以无需生成 Bitstream 文件，只需导出 hardware 即可。步骤和实验一相同。
</code></pre>
<h3 id="4-软件设计"><a href="#4-软件设计" class="headerlink" title="4.软件设计"></a>4.软件设计</h3><h4 id="step5：在-Vitis-中创建应用工程-1"><a href="#step5：在-Vitis-中创建应用工程-1" class="headerlink" title="step5：在 Vitis 中创建应用工程"></a>step5：在 Vitis 中创建应用工程</h4><pre><code>    基本与实验一相同。工程名改为“gpio_mio”；选择工程模版“Empty Application”，本章将自行创建工程文件，故选择空模板，然后点击“Finish” 按钮，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff2d68a7c22fa4b09d43e81130318de6.png"></p>
<pre><code>    双击硬件平台目录下 **platform.spr** 文件，找到点击板级支持包“Board_Support_Package”，点击展开 “Peripheral Drivers”，右侧有相关文档和示例。找到 GPIO，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f3d3d587cd53c95f702a694e8f53a48.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/50988f6dd1c1fbc068ae09865a09fcab.png"></p>
<pre><code>    点击 **Documentation** 将在浏览器窗口打开 GPIO 的 API 文档，里面有关于 GPIO 的详细信息，想了解 GPIO 的，可以仔细浏览其中的信息。

    导入示例。如果我们点击 I**mport Examples（Documentation 旁边的按钮）** ，会弹出下图所示的导入示例界面，关于 GPIO 有两个示 例，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f685cd0fd33c4130ea055d933944d57.png"></p>
<pre><code>    这两个示例的介绍可以在刚才打开的**API 文档** 中看到。在 API 文档中点击左侧的 **Examples** ，右侧出现 这两个示例的介绍信息，如图所示： xgpiops_intr_example.c 包含有关如何**直接使用 XGpiops** 驱动程序的示例。此示例显示了**中断模式下驱动程序** 的用法，并使用 GPIO 的中断功能检测按钮事件，根据输入控制 LED 输出。xgpiops_polled_example.c 同样包含有关如何直接使用 XGpiops 驱动程序的示例。此示例提供了用于**读取/写入各个引脚** 的 API 的用法。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8162740976bf76b39eb8589e7b500a26.png"></p>
<pre><code>    们因为本实验暂未使用到中断，所以应该选择 xgpiops_polled_example 示例。选择 好示例后，点击“OK”按钮。

    在 **Explorer 中，新增了 xgpiops_polled_example_1 目录** ，我们打开其 src 目录下的 xgpiops_polled_example.c 文件。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/072ba1557df31687c6828beaba8efd56.png"></p>
<pre><code>    显示行数。此处我们说一下如何显示代码的行数，在下图所示的 **1 处箭头** 所指的上或下方点击鼠标右键，在弹出的菜单中选择 2 处的 **Show Line Numbers** ，就会显示代码的行数。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b9b755efab66ebd848ace23a8d60d223.png"></p>
<pre><code>    xgpiops_polled_example.c 文件有四个函数，其中 **GpioInputExample** 函数由于我们本实验只用 MIO 输出所以未用到。该文件代码虽然是为特定开发板使用的，不过我们稍作修改也可以拿来使用。有两个 LED 分别接到 PS 的 MIO38 和 MIO39，这里我们使用 PS_LED1，即连接 MIO38。 我们修改该文件第 193 行的 Output_Pin 为 38，保存该文件，然后编译，编译完成后下载到开发板会看到板 上的 LED1 灯闪烁，闪烁时间约为 2 秒，随后 LED 灯熄灭。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e37cf706e4506426aa0b2ecddfaba1b7.png"></p>
<pre><code>    现在我们自己动手写一个驱动 MIO 的代码。

    新建源文件。首先我们在 **gpio_mio/src** 目录上右键，选择 **New- &gt; File**，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/96a7b91131fcef0da025feaca171ac69.png"></p>
<pre><code>    在添加源文件界面中，File name 一栏我们输入文件名“main.c”，然后点击“Finish”按钮。输入源代码。我们在新建的 main.c 文件中输入以下代码：


#include &quot;xparameters.h&quot; //器件参数信息
#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义
#include &quot;xil_printf.h&quot; //包含 print()函数
#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数
#include &quot;sleep.h&quot; //包含 sleep()函数

//宏定义 GPIO_DEVICE_ID
#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
//连接到 MIO 的 LED
#define MIOLED0 38 //连接到 MIO38
#define MIOLED1 39 //连接到 MIO39

 XGpioPs Gpio; // GPIO 设备的驱动程序实例

 int main()
 &#123;
	int Status;
	XGpioPs_Config *ConfigPtr;
	
	print(&quot;MIO Test! \n\r&quot;);
	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
	Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);
	
	if (Status != XST_SUCCESS)&#123;
		return XST_FAILURE;
	&#125;
	//设置指定引脚的方向：0 输入，1 输出
	XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);
	XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED1, 1);
	//使能指定引脚输出：0 禁止输出使能，1 使能输出
	XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);
	XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED1, 1);
	
	while (1) &#123;
		XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); //向指定引脚写入数据：0 或 1
		XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x0);
		sleep(1); //延时 1 秒
		XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x1);
		XGpioPs_WritePin(&amp;Gpio, MIOLED1, 0x1);
		sleep(1);
	&#125;
	return XST_SUCCESS;
 &#125;


    该代码实现了 LED 灯每隔 1 秒闪一次的功能。

    代码第 8 行我们宏定义了 **GPIO_DEVICE_ID** ，使其为 **XPAR_XGPIOPS_0_DEVICE_ID** ，如果在 Vitis 软件中，按住 Ctrl 键不放，将鼠标移动到 XPAR_XGPIOPS_0_DEVICE_ID 上，当鼠标变成手指状时，单击 鼠标左键，会自动跳转到 **xparameters.h** 文件中，该文件定义了各个外设的基地址、器件 ID、中断等，我们 这里重新宏定义 XPAR_XGPIOPS_0_DEVICE_ID 是为了以后方便修改。

    代码第 10 行宏定义了 **MIOLED0** ，其值为 38，因为其连接到 PS 的 MIO38 引脚。一般对于这种 MIO 的 使用，驱动某一引脚，在代码中使用该引脚对应的 MIO 数字标号即可。

    代码第 21 行至 26 行是**获取 GPIO 的 ID 和基址信息并初始化其配置** ，以及判断是否初始化成功。代码第 28 行的 **XGpioPs_SetDirectionPin** 和 31 行 **XGpioPs_SetOutputEnablePin** 函数分别是设置 **GPIO 的方向（输 入还是输出）** 函数和**使能输出函数** ，代码第 35 行的 **XGpioPs_WritePin** 是向指定 **GPIO 引脚写入数据的函数** ， 关于这三个函数的具体使用可以查看其定义。查看其定义的简便方法是在 VITIS 软件中，按住 Ctrl 键不放， 将鼠标移动到想查看定义的函数名上，当鼠标变成手指状时，单击鼠标左键，即可跳转到定义或声明的地方。

    代码第 37 和第 40 行的 sleep 函数为秒延时函数，延时 m 秒就使用 sleep(m)语句。还有一个微秒延时函数 usleep(m)，延时 m 微秒。

    编译工程。保存 main.c 文件，右键点击应用工程 gpio_mio，在弹出的菜单中选择 **Build Project** ， 如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9e8f14d55907d0b645cf585020c1c212.png"></p>
<p>编译完成后，生成 elf 文件，</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4acd636a64b21b3d624d428a56fa75bb.png"></p>
<h3 id="5-下载验证"><a href="#5-下载验证" class="headerlink" title="5.下载验证"></a>5.下载验证</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fc2a33922f6e87d7a4af525f2d2b3bed.png"></p>
<h2 id="三-GPIO-之-EMIO-按键控制-LED-实验"><a href="#三-GPIO-之-EMIO-按键控制-LED-实验" class="headerlink" title="三.GPIO 之 EMIO 按键控制 LED 实验"></a>三.GPIO 之 EMIO 按键控制 LED 实验</h2><pre><code>    PS 和外部设备之间的通信主要是通过**复用的输入/输出（Multiplexed Input/Output，MIO）** 实现的。除此之外，PS 还可以通过扩展的**MIO（Extended MIO，EMIO）** 来实现与外部设备的连接。**EMIO 使用了 PL 的 I/O 资源** ，当 PS 需要扩展**超过 78 个引脚的时候可以用 EMIO** ，也可以用它来**连接 PL 中实现的 IP 模块** 。
</code></pre>
<h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    在大多数情况下，PS 端经由 EMIO 引出的接口会直接连接到 PL 端的器件引脚上，**通过 IO 管脚约束来指定所连接 PL 引脚的位置** 。通过这种方式，EMIO 可以为 PS 端实现**额外的 96 个输入引脚或 96 个带有输出使能的输出引脚** 。EMIO 还有一种使用方式，就是**用于连接 PL 内实现的功能模块（IP 核）** ，此时 PL 端 的 IP 作为 PS 端的一个外部设备。

    本章的实验任务是使用 MPSOC 开发板上的两个 **PS 端按键控制 PL 端 LED 亮灭** ，**两个 PL 端按键去控 制 PS 端 LED 的亮灭** 。
</code></pre>
<h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b00b29d17bda34dc8e2021d19b3da5c7.png"></p>
<pre><code>    在配置界面中，点击左侧的 I/O Configuration。然后在右侧展开 GPIO 一栏，勾选 GPIO EMIO，并设置**位宽为 4** 。该设置将通过 EMIO 扩展一个 4 位的 GPIO 接口信号，此信号将用于连接 PL 端的引脚。注意这里 GPIO0 和 GPIO1 已经勾选。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f91ebcf53451f5c237c47a5fee50e1a7.png"></p>
<pre><code>    完成配置后，点击右下角的“OK”按钮。然后在 Diagram 窗口中可以看到 Zynq UltraScale+ MPSoC 多 了一个 GPIO_0 端口，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6db0239064ee56374c85381472489777.png"></p>
<pre><code>    将光标移动到上图中箭头所指示的位置，会发现光标变成了铅笔的样式。点击选中该端口，然后点击 鼠标右键，在弹出的列表中选择“**Make External** ”。点击选中该接口，在左侧 External Interface Properties 一栏中将该接口的名称修改为 GPIO_EMIO。如下 图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/87308bc75d7d72d6921777208d4fd904.png"></p>
<pre><code>    在 Sources 窗口中展开 Design Sources，然后右键点击 design_1_wrapper 下的 design_1.bd，在弹出 的菜单中选择 Generate Output Products（在之前的实验中，我们创建顶层模块时选择了“Let Vivado manage wrapper and auto-update”选项，所以 此处无需再创建顶层 HDL Wrapper，Vivado 会自动更新顶层 HDL Wrapper。）
</code></pre>
<h4 id="step4：生成-Bitstream-文件并导出-Hardware-2"><a href="#step4：生成-Bitstream-文件并导出-Hardware-2" class="headerlink" title="step4：生成 Bitstream 文件并导出 Hardware"></a>step4：生成 Bitstream 文件并导出 Hardware</h4><pre><code>    在左侧**Flow Navigator 导航栏** 中找到 **RTL ANALYSIS** ，点击该选项中的“**Open Elaborated Design** ”。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed28803feaff06157fb29b7ac79959b0.png"></p>
<p>注意：如果出现闪退<a target="_blank" rel="noopener" href="https://blog.csdn.net/RERERERDFDSDSDSD/article/details/104838513?spm=1001.2014.3001.5506" title="Vivado RTL 闪退问题的解决办法">Vivado RTL<br>闪退问题的解决办法</a></p>
<pre><code>    在 ELABORATED DESIGN 界面下方找到 I/O Ports 窗口。如果没有找到 I/O Ports 一栏则通过在菜单栏 中点击 Layout，然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 窗口中对 PL 部分的接口进行管 脚分配。PS 端的管脚约束文件，在图 3.3.12 中选择“Generate Output Products”之后，Vivado 工具会自动创建。

    在本次实验中，EMIO 扩展了四个 GPIO 的接口信号，即上图中的 GPIO_EMIO_tri_io[0]， GPIO_EMIO_tri_io[1]，GPIO_EMIO_tri_io[2]，GPIO_EMIO_tri_io[3]。这里，我们将 GPIO_EMIO_tri_io[0] 接到 PL_KEY1 引脚，GPIO_EMIO_tri_io[1]接到 PL_KEY2 引脚，GPIO_EMIO_tri_io[2]接到 PL_LED1 引脚， GPIO_EMIO_tri_io[3]接到 PL_LED2 引脚。 查看原理图可知，这四个引脚的管脚约束分别是，PL_KEY1 为 AD11，PL_KEY2 为 AD10，PL_LED1 为 AE10，PL_LED2 为 AF10，且都在 BANK44 上，该 BANK 电压为 3.3V。接下来在软件中进行管脚分配， I/O Std 一列对应的电平也需要修改。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae0e2d2e82480a55119adb7ff3b0fcb2.png"></p>
<pre><code>    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“pin”，最后点击“OK”。

    在左侧Flow Navigator 导航栏中找到PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 然后在连续弹出的对话框中依次点击“YES”、“OK”。此时，Vivado 工具开始对设计进行综合、实现、并生 成 Bitstream 文件。生成 Bitstream 完成后，在弹出的对话框中选择“Open Implemented Design”。点击“OK”，如果弹出对话框提示关闭 Elaborated Design，则点击“YES”。 在 IMPLEMENTED DESIGN 界面我们可以查看设计对 PL 资源的使用情况。在左侧 Flow Navigator 导 航栏中找到 **IMPLEMENTATION** ，点击该选项中的“**Report Utilization** ”，然后在弹出的对话框中点击“OK”。

    在界面下方的 Utilization 标签页中，选择左侧的 Summary，然后在右侧会以表格和柱状图两种方式显 示当前 PL 资源的使用情况。在我们本次实验中，只消耗了 PL 端 4 个 LUT 和 4 个 IO 资源，这个 IO 就是 PS 通过 EMIO 扩展 GPIO 接口信号时所使用的 PL 引脚。如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/36d3b2fa130b81b99840523163257bd8.png"></p>
<pre><code>    在菜单栏中选择 File &gt; Export &gt; Export hardware。 在弹出的对话框中，**勾选“Include bitstream”** ，然后点击“OK”按钮。在此处需要注意，如果我们的设计使用了 PL 的资源，比如使用了 PL 的引脚，或者在 PL 内实现了部 分功能模块，那么我们就需要生成 Bitstream 文件，并在导出硬件的时候包含该文件。
</code></pre>
<h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot; 
#define GPIOPS_ID XPAR_XGPIOPS_0_DEVICE_ID //PS 端 GPIO 器件 ID

#define MIO_LED1 38 //PS_LED1 连接到 MIO38
#define MIO_LED2 39 //PS_LED2 连接到 MIO39
#define MIO_KEY1 40 //PS_KEY1 连接到 MIO40
#define MIO_KEY2 41 //PS_LEY2 连接到 MIO41
#define EMIO_KEY1 78 //PL_KEY1 连接到 EMIO0
#define EMIO_KEY2 79 //PL_KEY2 连接到 EMIO1
#define EMIO_LED1 80 //PL_LED1 连接到 EMIO2
#define EMIO_LED2 81 //PL_LED2 连接到 EMIO3

int main()
&#123;
	printf(&quot;EMIO TEST!\n&quot;);
	
	XGpioPs gpiops_inst; //PS 端 GPIO 驱动实例
	XGpioPs_Config *gpiops_cfg_ptr; //PS 端 GPIO 配置信息
	
	//根据器件 ID 查找配置信息
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	//初始化器件驱动
	XGpioPs_CfgInitialize(&amp;gpiops_inst,gpiops_cfg_ptr,gpiops_cfg_ptr-&gt;BaseAddr);
	
	//设置 LED 为输出
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED1, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED2, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED1, 1);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_LED2, 1);
	//使能 LED 输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED1, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED2, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED1, 1);
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, EMIO_LED2, 1);
	
	//设置 KEY 为输入
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY1, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_KEY2, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY1, 0);
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, EMIO_KEY2, 0);
	
	//读取按键状态，控制 LED 亮灭
	while(1)&#123;
		XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED1,
		~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY1));
		
		XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED2,
		~XGpioPs_ReadPin(&amp;gpiops_inst, EMIO_KEY2));
		
		XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED1,
		~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY1));
		
		XGpioPs_WritePin(&amp;gpiops_inst, EMIO_LED2,
		~XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2));
	
	&#125;
	
	return 0;
&#125;


    在代码的第 7 至 10 行，我们指定了 PS 端输出 LED 和输入 KEY 的 MIO 编号，这些编号可以从 MPSOC 开 发板的原理图中查到。在代码的 11 至 14 行指定了 PL 端 LED 和按键 KEY 的 EMIO 编号。

    在本章的简介部分我们提到过，MPSOC 的 GPIO 被分成了 6 组，其中通过 EMIO 扩展的 GPIO 接口位于 BANK3 至 BANK5 中。在本次实验中我们通过 EMIO 扩展了 4 个 GPIO 信号，即 BANK3 的 EMIO0，EMIO1，EMIO2，EMIO3，由于 GPIO 的 BANK0，BANK1，BANK2 分别有 26 个信号，即 MIO 共有 78 个信号，**所以 BANK3 的 EMIO0 是第 79 个信号，编号为 78（从 0 开始编号）。**

    我们按住 Ctrl 键，然后点击代码开头处所引用的头文件“xgpiops.h”以打开该文件。在 xgpiops.h 文件第 162 行给出了 MPSOC 器件 GPIO 最大的引脚数目，共 174 个，分别位于 6 个 Bank 中。在下面的注释中则分别列出了各 Bank 的引脚编号范围，同样可以看到 Bank3 的第一个引脚编号为 78。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a05a2ccf9124d96bc86553e3879682d.png"></p>
<h2 id="四-GPIO之MIO按键中断实验"><a href="#四-GPIO之MIO按键中断实验" class="headerlink" title="四.GPIO之MIO按键中断实验"></a>四.GPIO之MIO按键中断实验</h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="处理器中断类型"><a href="#处理器中断类型" class="headerlink" title="&lt;1&gt;.处理器中断类型"></a>&lt;1&gt;.处理器中断类型</h4><p>• 可屏蔽中断（Maskable Interrupts，IRQ)</p>
<p>• 不可屏蔽中断（Non-Maskable Interrupts，NMI)</p>
<p>• <strong>处理器间中断（Inter-Processor Interrupts，IPI)</strong><br>：—在多处理器系统中，一个处理器可能需要中断另一个处理器的操作。在这种情况下，就会产生一个 IPI，以便于处理器间通信或同步。</p>
<h4 id="中断控制器GIC"><a href="#中断控制器GIC" class="headerlink" title="&lt;2&gt;中断控制器GIC"></a>&lt;2&gt;中断控制器GIC</h4><pre><code>    ARM SOC 系统中 CPU 的中断信号仲裁器件：**GIC** （**general interrupt controller** ， 通用中断控制器） _**【功能和结构上类似于《微机原理》中的可编程中断控制器8259】**_


    当对应的中断源有效时，GIC 根据该中断源的配置，决定是否将该中断信号，发送给 CPU。如果有多 个中断源有效，那么 GIC 还会进行仲裁，选择最高优先级中断，发送给 CPU。 当 CPU 接受到 GIC 发送的中断，通过读取 GIC 的寄存器，就可以知道中断的来源来自于哪里，从而可以做相应的处理。 当 CPU 处理完中断之后访问 GIC 的寄存器，该中断处理完毕。GIC 接受到该信息后，将该中断源取消，避免又重新发送该中断给 CPU 以及允许中断抢占。

    Zynq Ultrascale+ MPSOC 包含两个中断控制器(GIC)，分别是符合 GICv2 架构规范的 Arm GIC-400 通用中断控制器 APU GIC 和符合 GICv1 架构规范的 Arm PL-390 通用中断控制器(PL390)。中断控制器框图如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/afde86e7494ef3caa5c1ecc3c4445dc8.png"></p>
<p>上图中 GIC-400 是 APU 中断控制器，其功能划分如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/796c758bb3becf08035866a7a7deb2c8.png"></p>
<p>详细功能：  </p>
<pre><code>    APU 中断控制器被分为两部分，第一部分是分发器(Distributor)，用来登记传送进来的中断并对它们进行排序，然后将中断送到正确的目标 CPU。distributor 对中断提供以下的功能：

–全局中断使能 –每个中断的使能 –中断的优先级 –中断的分组 –中断的目的 core –中断触发方式 –对于 SGI 中断，传输中断到指定的 core –每个中断的状态管理 –提供软件，可以修改中断的 pending 状态

    中断控制器第二部分(CPU Interface)和每个 CPU 的中断线连接，用来触发相关 Cortex-A53 的中断。 cpu interface 提供了一下的功能：

–将中断请求发送给 cpu –对中断进行认可（acknowledging an interrupt） –中断完成识别(indicating completion of an interrupt) –设置中断优先级屏蔽 –定义中断抢占策略 –决定当前处于 pending 状态最高优先级中断

     每个 Cortex-A53 有**四个中断线** 作为输入，分别是**普通优先级中断 nIRQ，高优先级（或快速）中断 nFIQ， 普通优先级虚拟中断 nVIRQ，高优先级（或快速）虚拟中断 nFIQ**

    APU 中断控制器处理三种类型中断：1**6 个软件产生的中断(SGI)，7 个私有外设中断(PPI)，92 个共享外设中断(SPI)**

    每个 CPU 都可以使用软件生成的中断来中断自身、另一个 CPU 或同时中断两个 CPU。有 16 个软件生成中断，具体见表。向软件产生的中断寄存器（GICD_SGIR）写入 SGI 中断编号并指定目标 CPU（或 两个 CPU），就产生了一个 SGI。该写操作通过 CPU 自己的专用（私有）总线进行。**每个 CPU 都有自己 的一组 SGI 寄存器** ，用于生成 16 个软件生成的中断中的一个或多个。所有的 SGI 都是边沿触发的，且其敏感性类型是固定的，不能修改。  
    每个 CPU 核连接到了一个有七个外设中断的私有组上，这七个外设中断见表。需要注意的是：**来自 PL 的快速中断（FIQ）信号和中断（IRQ）信号** 在发送给中断控制器之前，会在传输给 PS 的时候被**反转** 。因此，这些信号因此**在 PL 内低电平有效，在 PS-PL 接口处高电平有效** 。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc3fc6a7da9253c672f49890520b37d4.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fa3a98c687d4b1476298098bdd3e11d.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/232e30f977e6357aeb48fc33afd0f8a4.png"></p>
<pre><code>    共享外设中断(SPI)是一种可以被分配器路由到任意指定处理器的外设中断。这些送到 GIC 的线性中断源来自各种中断源。

    所有的中断请求，**无论是 PPI、SGI 还是 SPI，都分配了一个唯一的 ID 编号，以用于中断控制器的仲裁。**

    中断分配器具有中断、处理器和活跃信息的中央列表，并负责触发 CPU 的软件中断。为了给每个处理器提供单独的副本，SGI 和 PPI 分派器寄存器是分组的。硬件确保针对**多个 CPU 的中断同一时间只能被一个 CPU 获取** 。
</code></pre>
<p>RPU 中断控制器框图如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be784b536668403f3377da54da3b1333.png"></p>
<h4 id="GPIO-的-MIO-的中断"><a href="#GPIO-的-MIO-的中断" class="headerlink" title="&lt;3&gt;GPIO 的 MIO 的中断"></a>&lt;3&gt;GPIO 的 MIO 的中断</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/adf3469ae6c2d955307f37538bd069af.png"></p>
<p>寄存器说明：</p>
<pre><code>INT_MASK：这个寄存器是只读的，显示哪些位当前被屏蔽，哪些位未被屏蔽/启用。
INT_EN：向该寄存器的任何位写入 1，可以启用/解除中断信号的掩码。从该寄存器读取将返回一个不
可预测的值。
INT_DIS：向该寄存器的任何位写入 1 都会屏蔽该中断信号。从该寄存器读取会返回不可预测的值。
INT_STAT：该寄存器显示是否发生了中断事件。将 1 写入该寄存器中的某个位可清除该位的中断状态。
将 0 写入该寄存器中的某个位将被忽略。
INT_TYPE：该寄存器控制中断是边沿敏感还是电平敏感。
INT_POLARITY：该寄存器控制中断是低电平有效还是高电平有效（或下降沿敏感或上升沿敏感）。
INT _ANY：如果 INT_TYPE 设置为边沿敏感，则该寄存器在上升沿和下降沿都会启用中断事件。如果
INT_TYPE 设置为电平敏感，则忽略该寄存器。

    如果检测到中断，中断检测逻辑将 GPIO 的 **INT_STAT** 状态设置为真。如果中断未屏蔽，则 中断传输到一个或电路（图中未画出）。该或电路将**四个 BANK 中所有 GPIO 的所有中断组合成一个输出 （IRQ ID＃48）**到中断控制器。如果中断被禁止（屏蔽），则 INT_STAT 状态将保持直到被清除，但它**不会传输到中断控制器** ，除非稍后写入**INT_EN** 以禁用屏蔽。

    如果 GPIO 中断是边沿触发的，则 INT 状态由检测逻辑锁存。通过**向 INT_STAT 寄存器写入 1 来清除 INT 锁存器** 。对于电平触发的中断，必须**清零 GPIO 中断输入源** ，以清除中断信号。或者，软件可以使用 **INT_DIS 寄存器屏蔽该输入** 。

    **如果 INT_STAT = 1 且 INT_MASK = 0，则该中断信号有效。**
</code></pre>
<h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d39702d5ebb5e0669f52c86ede2c349.png"></p>
<p>沿用二中使用的硬件平台</p>
<h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>导入硬件平台后在选择模版时选择**“Empty Application”**<strong>自行创建工程文件</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a45e282be5173c86ff34d81074f56dba.png"></p>
<p> 添加main.c文件后输入代码：</p>
<pre><code>/***************************** Include Files *********************************/

#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xplatform_info.h&quot;
#include &lt;xil_printf.h&gt;
#include &quot;sleep.h&quot;

/************************** Constant Definitions *****************************/

//以下常量映射到xparameters.h文件
#define GPIO_DEVICE_ID      XPAR_XGPIOPS_0_DEVICE_ID      //PS端GPIO器件ID
#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID  //通用中断控制器ID
#define GPIO_INTERRUPT_ID   XPAR_XGPIOPS_0_INTR           //PS端GPIO中断ID

//定义使用到的MIO引脚号
#define KEY  40         //PS_KEY1 连接到 MIO40
#define LED  38         //PS_LED1 连接到 MIO38
#define LED2 39         //PS_LED2 连接到 MIO39

/************************** Function Prototypes ******************************/

static void intr_handler(void *callback_ref);
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId);

/**************************Global Variable Definitions ***********************/

XGpioPs gpio;   //PS端GPIO驱动实例
XScuGic intc;   //通用中断控制器驱动实例
u32 key_press;  //KEY按键按下的标志
u32 key_val;    //用于控制LED的键值




/************************** Function Definitions *****************************/

int main(void)
&#123;
    int status;
    XGpioPs_Config *ConfigPtr;     //PS 端GPIO配置信息

    xil_printf(&quot;Gpio interrupt test \r\n&quot;);

    //根据器件ID查找配置信息
    ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
    if (ConfigPtr == NULL) &#123;
        return XST_FAILURE;
    &#125;
    //初始化Gpio driver
    XGpioPs_CfgInitialize(&amp;gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);


    //设置KEY所连接的MIO引脚的方向为输入
    XGpioPs_SetDirectionPin(&amp;gpio, KEY, 0);
    //设置LED所连接的MIO引脚的方向为输出并使能输出
    XGpioPs_SetDirectionPin(&amp;gpio, LED, 1);
    XGpioPs_SetOutputEnablePin(&amp;gpio, LED, 1);
    XGpioPs_WritePin(&amp;gpio, LED, 0x0);
    //设置LED2连接的MIO引脚方向为输出并使能输出
    XGpioPs_SetDirectionPin(&amp;gpio, LED2, 1);
    XGpioPs_SetOutputEnablePin(&amp;gpio, LED2, 1);
    XGpioPs_WritePin(&amp;gpio, LED2, 0x0);             //PS_LED2默认关闭；


    //建立中断,出现错误则打印信息并退出
    status = setup_interrupt_system(&amp;intc, &amp;gpio, GPIO_INTERRUPT_ID);
    if (status != XST_SUCCESS) &#123;
        xil_printf(&quot;Setup interrupt system failed\r\n&quot;);
        return XST_FAILURE;
    &#125;


    //中断触发时，key_press为TURE，延时一段时间后判断按键是否按下，是则反转LED
    while (1) &#123;
        if (key_press) &#123;
            usleep(20000);
            if (XGpioPs_ReadPin(&amp;gpio, KEY) == 0) &#123;
                key_val = ~key_val;
                XGpioPs_WritePin(&amp;gpio, LED, key_val);
            &#125;
            key_press = FALSE;
            XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断
            XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断
        &#125;
    &#125;
    return XST_SUCCESS;
&#125;
</code></pre>
<p>中断服务程序：</p>
<pre><code>//中断处理函数
//  @param   CallBackRef是指向上层回调引用的指针
static void intr_handler(void *callback_ref)
&#123;
    XGpioPs *gpio = (XGpioPs *) callback_ref;

    //读取KEY按键引脚的中断状态，判断是否发生中断
    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;
        key_press = TRUE;
        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断
    &#125;
&#125;
</code></pre>
<p>**         由于所有 GPIO 共享相同的中断，因此软件必须同时考虑 INT_MASK 和 INT_STAT 以确定哪个 GPIO<br>导致中断**。这与stm32单片机每个端口使用一个中断号是不同的，<strong>因此中断服务程序也有很大区别</strong> 。</p>
<p>中断配置：</p>
<pre><code>//建立中断系统，使能KEY按键的下降沿中断
//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针
//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针
//  @param   GpioIntrId是Gpio中断ID
//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILURE
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)
&#123;
    int status;
    XScuGic_Config *IntcConfig;     //中断控制器配置信息

    //查找中断控制器配置信息并初始化中断控制器驱动
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == IntcConfig) &#123;
        return XST_FAILURE;
    &#125;
    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,
            IntcConfig-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS) &#123;
        return XST_FAILURE;
    &#125;


    //设置并使能中断异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);
    Xil_ExceptionEnable();
    //为中断设置中断处理函数
    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,
            (Xil_ExceptionHandler) intr_handler, (void *) gpio);
    if (status != XST_SUCCESS) &#123;
        return status;
    &#125;
    //使能来自于Gpio器件的中断
    XScuGic_Enable(gic_ins_ptr, GpioIntrId);
    //设置KEY按键的中断类型为下降沿中断
    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);
    //使能按键KEY中断
    XGpioPs_IntrEnablePin(gpio, KEY);

    return XST_SUCCESS;
&#125;
</code></pre>
<p> <strong>类比stm32的中断配置过程</strong> ：</p>
<pre><code>	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource13);
	
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line = EXTI_Line13;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_Init(&amp;EXTI_InitStructure);
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
	NVIC_Init(&amp;NVIC_InitStructure);
</code></pre>
<h2 id="五-AXI-GPIO-按键控制-LED-实验"><a href="#五-AXI-GPIO-按键控制-LED-实验" class="headerlink" title="五.AXI GPIO 按键控制 LED 实验"></a>五.AXI GPIO 按键控制 LED 实验</h2><pre><code>    在 PL 端**调用 AXI GPIO IP 核** ，并通过 AXI4-Lite 接口实现 PS 与 **PL 中 AXI GPIO 模块**的通信。
</code></pre>
<h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>    AXI GPIO IP 核为 AXI 接口提供了一个通用的输入/输出接口。与 PS 端的 GPIO 不同，AXI GPIO 是一个软核（Soft IP），即 MPSOC 芯片在出厂时并不存在这样的一个硬件电路，而是由用户通过配置 PL 端的逻辑资源来实现的一个功能模块。而 PS 端的 GPIO 是一个硬核（Hard IP），它是一个生产时在硅片中实现的功能电路。

    AXI GPIO 可以配置成**单通道或者双通道** ，每个通道的**位宽** 可以单独设置。另外通过打开或者关闭三态缓冲器，AXI GPIO 的端口还可以被动态地配置成**输入或者输出接口** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcfd77f0e7a867a66966b28080460fab.png"></p>
<pre><code>    从图中可以看到，模块的左侧实现了一个 _**32 位的 AXI4-Lite 从接口**_ ，用于主机访问 AXI GPIO 内部各通道的寄存器。当右侧接口输入的信号发生变化时，模块还能向主机产生中断信号。不过只有在配置 IP 核时选择“使能中断”，才会启用模块的中断控制功能。
</code></pre>
<h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>系统框图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c51cad0adcbc38820dac88214135fe29.png"></p>
<pre><code>    在图中，PS 端的 M_AXI_HPM 作为主端口，与 PL 端的 AXI GPIO IP 核以 AXI4-Lite 总线相连接。 其中，**AXI 互联 IP（AXI Interconnect）用于连接 AXI 存储器映射（memory-mapped）的主器件和从器件** 。 
</code></pre>
<h4 id="step2-vivado硬件平台"><a href="#step2-vivado硬件平台" class="headerlink" title="step2:vivado硬件平台"></a>step2:vivado硬件平台</h4><p>增加PS到PL的全局复位信号及axi接口：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a6dafe34ae5d0e1778d7f04193aecdad.png"></p>
<p>增加PS到PL的时钟：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe48d12f2f77f094e6b3719c06695d57.png"></p>
<p>在二的基础上增加PL端中断及PS段端口，如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/39009b1c2ebe277967b7791935f49940.png"></p>
<pre><code>    另外我们还要用到 PS 端的 LED，因此需要在 I/O Configuration 界面勾选“GPIO1 MIO”，并设置 Bank0， Bank2 电压为 1.8V
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ae3c0baeb2513a1632d8da9312b1247.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f44edc425ad3ffe47efb17b246ba2931.png"></p>
<pre><code>    **M_AXI_HPM0_LPD 是通用（General Purpose）AXI 接口** ，它包含了一组信号。首字母 M 表示 PS 作 为主机（Master），PL 中的外设作为从机（Slave）。而左侧的 **maxihpm0_lpd_aclk 是这个接口的全局时钟信号** ，它是一个输入信号，M_AXI_HPM0_LPD 接口的所有信号都是在这个全局时钟的上升沿采样的。

    **pl_clk0 是 PS 输出的时钟信号** ，它将作为 PL 中外设模块的时钟源。在配置 MPSOC 的时候，该时钟默认为 100MHz。

    **pl_resetn0 是由 PS 输出到 PL 的全局复位信号** ，低电平有效。

   **  pl_ps_irq0[0:0]是由 PL 输出到 PS 的中断信号**。

    接下来我们要在 Block Design 中**添加 PL 端的 AXI GPIO IP 核** ，在 Diagram 窗口空白位置右击，然后选 择“Add IP”。在弹出的 IP 目录中搜索“AXI GPIO”，最后双击搜索结果中的“AXI GPIO”将其添加到设计中。
</code></pre>
<p>并双击进行配置：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b35bda5f46246c70ce0f5d793b90b9d0.png"></p>
<pre><code>    GPIO **接口的位宽“GPIO Width”，最大可以支持 32 位** 。这里我们只需要连接一个按键，因此将其设置为 1。另外我们还需要使能其中断功能， 所以需要勾选“Enable Interrupt”。

    我们也可以通过勾选图中的“All Inputs”或者“All Outputs”将 GPIO 指定为输入或者输出接口。这两个选项默认是没有勾选的，这样我们**可以在程序中将其动态地配置成输入或者输出接口** 。

    箭头 1 所指示的参数“**Default Tri State Value** ”，它配置 GPIO **默认情况下的输入输出模式** ，当其为 0xFFFFFFFF 时，表明 GPIO 所有的位默认为输入模式。

    另外勾选箭头 2 所指示的选项可以使能 GPIO 通道 2，GPIO 2 的配置与 GPIO 完全相同。该选项默认没有勾选，即该 IP 工作在单通道模式下。

    按住左键将中断接口“ip2intc_irpt”与 Zynq UltraScale+ MPSOC 的中断接口“pl_ps_irq0[0:0]”连接起来。鼠标指针放到 GPIO 接口上，右击选择 Make External。修改 AXI GPIO IP 核引出的 GPIO 端口的名称。点击引出的 GPIO_0 端口，在左侧外部端口属性一栏中 将其名称修改为“AXI_GPIO_KEY”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a865cb250e683464ce34579721b2fe85.png"></p>
<pre><code>    接下来点击上图中箭头所指示的 _**Run Connection Automation**_ ，在弹出的对话框左侧确认勾选 All Automation，下面列出了会自动连接的模块及其接口，点击“OK”，工具会自动连接 AXI GPIO IP 核的 S_AXI 接口。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd461f7dc04e37cc5487f425c7087cd8.png"></p>
<pre><code>    从上图中可以看到，在执行了自动连接之后，工具自动添加了两个 IP 核，分别是 **AXI 互联（AXI Interconnect）和处理器系统复位（Processor System Reseet）** 。AXI Interconnect IP 核用于将一个（或多个）AXI 存储器映射的主器件连接到一个（或多个）存储器映射的从器件。

    Processor System Reseet IP 核为整个处理器系统提供复位信号。它会处理输入端的各种复位条件，并在输出端产生相应的复位信号。在本次实验中，Processor System Reseet 接收 Zynq UltraScale+ MPSOC 输出的异步复位信号 pl_resetn0，然后**产生一个同步到 PL 时钟源 pl_clk0 的复位信号 peripheral_aresetn** ，用于**复位 PL 端的各外设模块** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d9347dbf7aa03eedbecec9d3a0b63a8.png"></p>
<pre><code>    可以看到 PL端所有外设模块的时钟接口都连接到了 Zynq UltraScale+ MPSOC 输出的时钟信号 pl_clk0 上。需要注意的是，该时钟同样连接到了 PS 端 maxihpm0_pld_aclk 端口，作为M_AXI_HPM0_LPD 接口的全局时钟信号。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a54df03d0cedfd028171a2669e7ce9ea.png"></p>
<pre><code>    在 Diagram 窗口空白处右击，然后选择**“Validate Design”** 验证设计。验证完成后弹出对话框提示“Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键 “Ctrl + S”保存设计。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d026edbf7c4ce40cb984637584191f12.png"></p>
<pre><code>    接下来在**Source 窗口中右键点击 Design Source 设计文件“design_1.bd”** ，然后依次执行**“Generate Output Products”和“Create HDL Wrapper”** 。 

    在左侧 Flow Navigator 导航栏中找到 **RTL ANALYSIS** ，点击该选项中的“Open Elaborated Design”。然 后在菜单栏中点击 Layout，在下拉列表中选择 **I/O Planning** 以打开 I/O Ports 窗口。我们将在 I/O Ports 窗口 中对 AXI GPIO 引出的接口 AXI_GPIO_KEY 进行管脚分配
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/10d614749b63a945e72f6d57f7e76e21.png"></p>
<pre><code>    管脚分配完成后按快捷键 Ctrl+S 保存管脚约束，在弹出的窗口中输入引脚约束文件名，然后点击 “OK”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0073c6eb2211efe47db4fdc9665158ad.png"></p>
<pre><code>     最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”，在弹出的窗口中点击“OK”，对设计进行综合、实现、并生成 Bitstream 文件。Bitstream 文件生成后，会弹出 Bitstream Generation Completed 对话框，这里直接点击取消。 

    在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”

    新建 vitis 文件夹，将产生的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境...
</code></pre>
<h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    创建vitis工程“axi_gpio”，新建main.c文件内容如下：


#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xgpio.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;sleep.h&quot;

//宏定义
#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID
#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID
#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID
#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID

#define MIO_LED      38                           //PS_LED1 连接到  MIO38
#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1
#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义

//函数声明
void instance_init();                             //初始化器件驱动
void axi_gpio_handler(void *CallbackRef);         //中断服务函数

//全局变量
XScuGic            scugic_inst;                   //中断控制器    驱动实例
XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息
XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例
XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息
XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例

int led_value = 1;                                //LED显示状态

int main()
&#123;
	printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);

	//初始化各器件驱动
	instance_init();

	//配置PS GPIO
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出
	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED

	//配置PL AXI GPIO
	XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断

    //设置中断优先级和触发类型(高电平触发)
    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
    //关联中断ID和中断处理函数
    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);
    //使能AXI GPIO中断
    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    		(Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);
    Xil_ExceptionEnable();

    while(1);

    return 0;
&#125;

//初始化各器件驱动
void instance_init()
&#123;
	//初始化中断控制器驱动
	scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);
	XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);

	//初始化PS端  GPIO驱动
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);

	//初始化PL端  AXI GPIO驱动
	XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);
&#125;

//PL端  AXI GPIO 中断服务(处理)函数
void axi_gpio_handler(void *CallbackRef)
&#123;
	int key_value = 1;
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	print(&quot;Interrupt Detected!\n&quot;);
	XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能
    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据
    if(key_value == 0)&#123;                                     //判断按键按下
    	led_value = ~led_value;
    	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态
    &#125;
    sleep(1);                                               //延时1s 按键消抖
    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断
    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断
&#125;

    在配置 PL 端 AXI GPIO 时，我们需要使能其中断功能，包括 AXI GPIO 通道 1 的中断和全局中断。

    配置 GIC时，每一个中断源都有自己唯一的标识——中断号（ID），具体的数值可以在头文件 xparameters.h 中查看。其中由 PL 产生的**共享外设中断（SPI）共 16 个** ，中断 ID 分别为 121 到 128，以及 136 到 143。我们在程序第 14 行定义了一个宏 **GPIO_INT_ID，用于标识 AXI GPIO 的中 断 ID，它的值为 121** 。

    配置 GIC 首先需要**设置中断 ID 所代表的中断源的优先级和触发类型** 。中断优先级共分为 **32 个等级** ，0 代表最高优先级，0xF8（10 进制数 248）代表最低优先级，各优先级之间的**步进值为 8** 。也就是说，支持的 优先级分别为 0、8、16、32...248。中断触发类型分为高**电平敏感类型** 和**上升沿敏感类型** 。AXI GPIO 在检测到输入接口的信号发生改变时，会产生一个电平类型的中断请求，高有效，因此将中断源 AXI GPIO 的触发类型设置为高电平敏感类型。

    然后还需要将中断 ID 与其中断服务函数关联起来。中断服务函数 axi_gpio_handler()是需要我们自己编写的，用于响应和处理 AXI GPIO 中断的函数。除此之外，还要调用函数 XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID)来使能中断 ID 所对应的中断源。

    最后我们需要初始化并设置 ARM 处理器的异常处理功能，如程序第 57 至 61 行所示。ARM 处理器支 持 7 种异常情况：复位、未定义指令、软件中断、指令预取中止、数据中止、中断请求（IRQ）和快速中断请求（FIQ）。每种异常也都有自己的 ID 标识，其中 XIL_EXCEPTION_ID_INT 用于标识中断请求（IRQ） 异常。我们通过调用函数 Xil_ExceptionRegisterHandler( XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler) XScuGic_InterruptHandler, &amp;scugic_inst )来给 IRQ 异常注册处理程序，它会将中断控制器 GIC 的中断处理程序与 ARM 处理器中的硬件中断处理逻辑连接起来。另外还要通过 Xil_ExceptionEnable( )函数使能 IRQ 异常。
</code></pre>
<h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><pre><code>    本章节需重点理解MPSOC的内部硬件结构，重点理解GIC的工作原理以及各类器件、中断ID的含义，进而才能看懂代码部分的配置过程。查阅官方支持文档《ug1085-zynq-ultrascale-trm.pdf》，补充以下内容：
</code></pre>
<p>除了APU GIC和RPU GIC，还有中断处理器件GIC proxy</p>
<ul>
<li><pre><code>  The **PMU** uses the **GIC proxy** interrupts when the RPU and APU cannot service an interrupt because the processor is powered down. The GIC proxy is a Xilinx architecture for the PMU external interrupt controller and is controlled by the PMU.
</code></pre>
</li>
</ul>
<p>（PMU作用：the platform measurement unit (PMU) processor for power, error<br>management, and execution of an optional software test library (STL) for<br>functional safety applications.）</p>
<ul>
<li><pre><code>   There are **148 system interrupts **that connect to **each GIC** , the GIC proxy interrupt structure, and the PL fabric. The system interrupts are normally handled by the RPU or APU MPCores. The user firmware in the PMU can process system interrupts in the absence of an RPU or APU. The CSU does not connect to the system interrupts.
</code></pre>
</li>
<li><pre><code>   GIC功能：
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5981c4c11abe191bf657a9eaeb5c5fb6.png"></p>
<p>另外APU和RPU的GIC分别有各自特殊功能</p>
<ul>
<li><pre><code>   系统中断：

  The table lists the IRQ numbers for the RPU and APU interrupt controllers, as well as the GIC proxy bit assignments.（部分如下，总共148个：40~187）
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/052ea371c37f250ed9ee30b7a3920bba.png"></p>
<p>包含中断号、位的分配信息等</p>
<ul>
<li><pre><code>   中断控制器框图解析（图见四—1.简介）

  The **shared peripheral interrupts （SPI）** are generated from various subsystems that include the _**I/O peripherals in the PS and logic in the PL.（SPI来源）**_
</code></pre>
</li>
</ul>
<p><strong>——RPU GIC Interrupt Controller</strong></p>
<pre><code>    There are **two interfaces** between the **RPU MPCore** and the **RPU GIC.**

    • Distributor interface is used to **assign the interrupts** to each of the Cortex-R5F MPCore processors.

    • CPU interface with a separate set of **4 KB memory-mapped registers** for each CPU. This provides protection **against unwanted accesses by one CPU to interrupts that are assigned to the other.**

    The **APU MPCores** processors access the RPU_GIC interrupt controller (Figure 13-2) **through their peripheral interface.**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e56a76baae5943bc6ec5fd907725da9.png"></p>
<pre><code>     *        三种中断：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a019922da4e97554d75c88ffb2c3443.png"></p>
<p>软件中断的触发为边沿且无法更改。触发方式为将SGI interrupt number写入寄存器PL390.enable_sgi_control<br>(ICDSGIR)中，通过读取interrupt acknowledge寄存器PL390.control_n_int_ack_n<br>(ICCIAR)或写入interrupt clear-pending寄存器PL390.enable_sqi_pending (ICDICPR)结束中断。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/010b0f0d542bdc1c62b77a0dbec31a48.png"></p>
<pre><code>    *        优先次序 Interrupt Prioritization

    All of the **SGI and SPI interrupt** requests are assigned a unique ID number. The controller uses the ID number to arbitrate. The interrupt distributor holds the list of pending interrupts for each CPU and then selects the highest priority interrupt before issuing it to the CPU interface. Interrupts of equal priority are resolved by selecting **the lowest ID**.
</code></pre>
<p><strong>——APU GIC Interrupt Controller</strong></p>
<pre><code>    The APU uses an external GICv2 controller as a central resource to support and manage interrupts. There are **peripheral interrupts, software generated interrupts, and virtual interrupts.**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db6aa664b84592fa37a46fe03ff62b69.png"></p>
<pre><code>    *        Virtual Interrupt

    A virtual interrupt targets a **virtual machine** running on a processor and is typically signaled to the processor by the connected virtual CPU interface.（和虚拟机相关，详见文档）
</code></pre>
<ul>
<li><pre><code>   Interrupt Architecture

  The interrupt architecture includes eleven sets of registers with six registers per set. Each set is divided between **sending an interrupt (TRIG and OBS) and receiving an interrupt (ISR, IMR, IER, and IDR).（中断过程通过读写寄存器操作）**
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/55ac29cbbb0817418efc8baab3e18d99.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/63fb614cb09abdfa5dffa67bee11f4b5.png"></p>
<ul>
<li><pre><code>   Determine the Source of Interrupt（确定中断源）

  A processing unit reads its i**nterrupt status (ISR) and mask (IMR)** registers **to determine the source that caused the IRQ interrupt.** Once serviced, the ISR can be cleared by writing the data that was read from this register. The bits that were set are cleared while preserving any bits that got set after the read took place, which helps to eliminate missed interrupts
</code></pre>
</li>
<li><pre><code>   示例代码：
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/33f967286bcd5984c9f582d9fd3a340d.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133275810">https://blog.csdn.net/qq_32971095/article/details/133275810</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/" class="post-title-link" itemprop="url">Zynq简介——FPGA学习笔记＜7＞</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-24 10:37:56" itemprop="dateCreated datePublished" datetime="2023-09-24T10:37:56+08:00">2023-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          
            <span id="/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/" class="post-meta-item leancloud_visitors" data-flag-title="Zynq简介——FPGA学习笔记＜7＞" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/09/24/Zynq%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C7%EF%BC%9E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.xilinx%C2%A0Zynq%20UltraScale%2B%20MPSoC%C2%A0">一.xilinx Zynq UltraScale+ MPSoC
</a></p>
<p><a href="about:blank#1.MPSoC%20%E7%AE%80%E4%BB%8B">1.MPSoC 简介</a></p>
<p><a href="about:blank#2.FPGA%E7%AE%80%E4%BB%8B">2.FPGA简介</a></p>
<p><a href="about:blank#3.MPSoC%20PL%20%E7%AE%80%E4%BB%8B">3.MPSoC PL 简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E5%8F%AF%E7%BC%96%E7%A8%8B%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83">（1）可编程输入&#x2F;输出单元</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83">（2）基本可编程逻辑单元</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9D%97%20RAM">（3）嵌入式块<br>RAM</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%B8%83%E7%BA%BF%E8%B5%84%E6%BA%90">（4）丰富的布线资源</a></p>
<p><a href="about:blank#%EF%BC%885%EF%BC%89%E5%BA%95%E5%B1%82%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83">（5）底层嵌入功能单元</a></p>
<p><a href="about:blank#%EF%BC%886%EF%BC%89%E5%86%85%E5%B5%8C%E4%B8%93%E7%94%A8%E7%A1%AC%E6%A0%B8">（6）内嵌专用硬核</a></p>
<p><a href="about:blank#4.MPSoC%20PS%20%E7%AE%80%E4%BB%8B">4.MPSoC PS 简介</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89APU%EF%BC%88Application%20Processing%20Unit%EF%BC%89">（1）APU（Application Processing<br>Unit）</a></p>
<p>[（2）RPU（Real-Time Processing<br>Unit）](about:blank#%EF%BC%882%EF%BC%89RPU%EF%BC%88Real-<br>Time%20Processing%20Unit%EF%BC%89)</p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89GPU%EF%BC%88Graphics%20Processing%20Unit%EF%BC%89">（3）GPU（Graphics Processing<br>Unit）</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89DDR%20Memory%20Controller">（4）DDR Memory<br>Controller</a></p>
<p><a href="about:blank#%EF%BC%885%EF%BC%89PMU%EF%BC%88Platform%20Management%20Unit%EF%BC%89">（5）PMU（Platform Management<br>Unit）</a></p>
<p>[（6）High-Speed Connect Zynq](about:blank#%EF%BC%886%EF%BC%89High-<br>Speed%20Connect%20Zynq)</p>
<p><a href="about:blank#%EF%BC%887%EF%BC%89%E6%99%AE%E9%80%9A%E5%A4%96%E8%AE%BE%E6%8E%A7%E5%88%B6%E5%99%A8">（7）普通外设控制器</a></p>
<p>[（8）PS-PL AXI 接口](about:blank#%EF%BC%888%EF%BC%89PS-<br>PL%20AXI%20%E6%8E%A5%E5%8F%A3)</p>
<p><a href="about:blank#5.DFZU2EG%20MPSoc%20%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90">5.DFZU2EG MPSoc<br>硬件连接资源</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89IO%20%E5%88%86%E9%85%8D">（1）IO 分配</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E7%94%B5%E6%BA%90%E7%B3%BB%E7%BB%9F">（2）电源系统</a></p>
<p><a href="about:blank#%EF%BC%883%EF%BC%89%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">（3）启动模式</a></p>
<p><a href="about:blank#%EF%BC%884%EF%BC%89%E5%85%B6%E4%BB%96%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90">（4）其他硬件资源</a></p>
<p><a href="about:blank#6.%E5%85%B6%E4%BB%96">6.其他</a></p>
<p><a href="about:blank#%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">（1）注意事项</a></p>
<p><a href="about:blank#%EF%BC%882%EF%BC%89%E5%AD%A6%E4%B9%A0%20MPSoC%20%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%EF%BC%9A">（2）学习 MPSoC<br>基本方法：</a></p>
<hr>
<p>官网介绍：</p>
<p>[Zynq UltraScale+ MPSoC](<a target="_blank" rel="noopener" href="https://china.xilinx.com/products/silicon-">https://china.xilinx.com/products/silicon-</a><br>devices&#x2F;soc&#x2F;zynq-ultrascale-mpsoc.html “Zynq UltraScale+ MPSoC”)  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xilinx/PYNQ" title="Xilinx&#x2F;PYNQ: Python Productivity
for ZYNQ (github.com)">Xilinx&#x2F;PYNQ: Python Productivity for ZYNQ<br>(github.com)</a>  </p>
<p><a target="_blank" rel="noopener" href="http://www.pynq.io/" title="PYNQ -
Python productivity for Zynq - Home">PYNQ - Python productivity for Zynq - Home</a></p>
<p>参考书目：《正点原子 DFZU2EG&#x2F;4EV MPSoc 之 FPGA 开发指南》</p>
<h2 id="一-xilinx-Zynq-UltraScale-MPSoC"><a href="#一-xilinx-Zynq-UltraScale-MPSoC" class="headerlink" title="一.xilinx Zynq UltraScale+ MPSoC"></a>一.xilinx Zynq UltraScale+ MPSoC</h2><pre><code>    Zynq UltraScale+ MPSoC 是赛灵思推出的首款真正全可编程（All Programmable）异构多核处理 SoC 芯片。包含 **PS（Processing System，处理器系统）** 和**PL（Programmable Logic，可编程逻辑）** 两部分。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器、双核 Arm Cortex-R5F 实时处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件** ，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。这款芯片采用台积电公司 (TSMC) 新一代 16nm FinFET 工艺制程，它包含一个可扩展的 32 位或 64 位多处理器 CPU、用于实时处理图形和视频的专用硬化引擎、先进的高速外设，以及可编程逻辑，可用于汽车驾驶员辅助与安全、无线和有线通信、数据中心以及连接与控制等多种应用领域。

    Zynq UltraScale+ MPSoC 系列产品分三种类型，分别是 **CG 型器件、EG 型器件和 EV 型器件** 。其中 CG 型器件集成了由双核 Arm Cortex-A53 和双核 Arm Cortex-R5F 组成的 64 位处理系统；EG 型器件集成 了四核 Arm Cortex-A53 和双核 Arm Cortex-R5F，除此之外 EG 型器件还集成了 Arm Mali-400 MP2 （GPU）用来专门进行图像处理操作；而 EV 型器件在 EG 型器件的基础上再次增加了 H.264/H.265 视频编解码器（VCU）用来专门进行视频处理操作，它可以支持 60 帧每秒(fps)的速率同时进 行 4Kx2K 的编码和解码(约 6 亿像素/秒)或 15 帧每秒 8Kx4K 的编码解码。
</code></pre>
<h3 id="1-MPSoC-简介"><a href="#1-MPSoC-简介" class="headerlink" title="1.MPSoC 简介"></a>1.MPSoC 简介</h3><pre><code>    Xilinx 公司的 FPGA 芯片主要分为两大类，FPGA 和 SoC（System on Chip，片上处理系统），其中 FPGA 芯片只包含了可编程逻辑部分，而不包含处理器，如常见的 Spartan 系列、Artix 系列、Kintex 系列和 Virtex 系列。

    每一个系列又根据制造工艺和架构的不同，分为 6 系列（45nm）、7 系列（28nm）、UltraScale（20nm） 和 UltraScale+（16nm），以提供不同的性能和功耗比。

    Xilinx 的 SoC 是将可编程逻辑部分和处理器单元以及常见处理器外设封装在一起，集成到单颗芯片中， 并命名为“ZYNQ”，同样分为不同的系列，如 Zynq-7000（28nm）、Zynq UltraScale+ MPSoC（16nm）、 Zynq UltraScale+ RFSoC（16nm），如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/60b09a0ae2714b38a861d02d63e5efb1.png">​</p>
<pre><code>    Zynq7000 系列组合了一个双核 Arm Cortex-A9 处理器和一个传统的现场可编程门阵列（FPGA）逻辑部件。由于该器件的可编程逻辑部分基于 Xilinx 28nm 工艺的 7 系列 FPGA，因此该系列产品的名称中添加了 “7000”，以保持与 7 系列 FPGA 的一致性，同时也方便日后本系列新产品的命名。

    Zynq UltraScale+ MPSoC 的系统级性能功耗比相对 Zynq-7000 SoC 系列提升高达 5 倍。Zynq UltraScale+ MPSoC 整合了一个**双核或四核 Cortex-A53 处理器** 、**双核 Arm Cortex-R5F 实时处理器** 和一个传统的现场可编程门阵列（FPGA）逻辑部件，该器件的可编程逻辑部分基于 Xilinx 16nm FinFET+工艺的 UltraScale+系列 FPGA。

    Zynq UltraScale+ MPSoC 部分系列的产品，还包含了**Arm Mail-400MP2（GPU）** 和 H.264/H.265 视频编 解码器，可提供原生 UltraHD 压缩及专用引擎，满足动态电源管理与安全配置需求，可以说是对 ZYNQ 7000 的升级版本。Zynq UltraScale+ MPSoC 非常适用于 5G 无线基础设施、面向数据中心和有线通信的软件定义网络、新一代汽车驾驶员辅助系统和无人驾驶系统 (ADAS)、工业物联网系统 (IIoT)、超高清和超高画质摄像机、航空电子以及便携式软件定义无线电等各种应用。

    Zynq UltraScale+ RFSoC 在 SoC 架构中集成数千兆采样 RF 数据转换器和软判决前向纠错 (SD-FEC)。 配有 ARM Cortex-A53 处理子系统和 UltraScale +可编程逻辑，该系列是业界唯一单芯片自适应射频平台。 Zynq UltraScale+ RFSoC 系列可为模拟、数字和嵌入式设计提供适当的平台，从而可简化信号链上的校准和 同步。多代产品系列包含广泛的器件类型，具有不同的直接 RF 性能，可满足各种频谱需求和使用案例。

    Zynq UltraScale+ MPSoC 产品在单个设备中集成了功能丰富的**嵌入式处理系统(PS)和可编程逻辑(PL) UltraScale+架构** ，并且还包括片上存储器、多端口外部存储器接口以及丰富的外设连接接口集等等。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1885099ee6dfb7367468dd7d96d6923.png">​</p>
<pre><code>    Zynq UltraScale+ MPSoC除了嵌入式处理系统功能强大外，它还包含了可编程逻辑(PL) UltraScale+架构， 能够灵活的去编辑我们想要的逻辑运算，实现各种各样的复杂功能。从**本质上来讲，它还是一个片上处理系统（System on Chip，SoC）** 。
</code></pre>
<p>注：板上系统 （System-on-a-Board）示意图如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1b104c9b15be132b83147ceabf67924e.png"></p>
<p>​</p>
<p>而片上系统（System-on-<br>Chip）指的是在单个硅芯片就可以实现整个系统的功能。<strong>在一个芯片里就实现了存储、处理、逻辑和接口等各个功能模块，而不是像板上系统那样，需要用几个不同的物理芯片来实现。</strong></p>
<pre><code>    在过去，SoC 这个术语常用于指**专用集成电路（Application Specific Integrated Circuit，ASIC）** 。基于 ASIC 的 SoC 的代表性例子包括在 PC、平板和智能手机上使用的处理器，如华为旗舰手机中的麒麟系列芯片。这些处理器典型地是由至少两个处理器核、存储器、图形处理器、接口和其他功能模块组合起来的。 基于 ASIC 的 SoC 的主要缺点有两个：
</code></pre>
<p>1、开发周期长且成本巨大；</p>
<p>2、缺乏灵活性。</p>
<pre><code>    开发 ASIC 时不可重 用的工程投入是巨大的，使得这种 SoC 类型只适合于**大批量而且寿命有限** 的产品中。 ASIC SoC 的局限性导致它们不适用于很多应用，特别是当快速投入市场能力、灵活性和升级能力已 经成为重要的关键因素。对于小批量或中批量的产品，ASIC SoC 也不是好的解决方案。

    可编程片上系统**（SOPC，System-on-Progammable-Chip）** 为上述应用提供了一个更灵活的解决方案： 一种在可编程、可重新配置的芯片上实现的 SoC。可编程的芯片指的就是 FPGA。FPGA 天生的灵 活性使其可以被随心所欲地重新配置，以实现不同系统的功能，包括嵌入式处理器。和使用 ASIC 来实现 SoC 相比，FPGA 能构成更为基础灵活的平台，方便系统的升级。

    与基于 ASSP 的固定 SoC 解决方案不同，Zynq UltraScale+ MPSoC 能通过灵活的 **32 或 64 位数据宽度** 的处理系统提供最大的可扩展性。它能将关键应用（例如图形和视频管线）分配给专用处理模块来处理，并通过有效的电源域 (power domain) 和电源孤岛 (power island) 来开启和关闭模块。Zynq UltraScale+ MPSoC 提供多种互连选项、DSP 模块以及可编程逻辑选择，因而具备整体灵活性，可满足 用户的各种 应用需求。该产品系列具备出色可扩展性，使设计人员能够利用单个平台和行业标准工具开发出低成本以 及高性能应用。
</code></pre>
<h3 id="2-FPGA简介"><a href="#2-FPGA简介" class="headerlink" title="2.FPGA简介"></a>2.FPGA简介</h3><pre><code>    可编程逻辑器件（Programmable Logic Device，PLD），目前常见的 PLD 大体上可以分为 **SPLD（simple PLD，简单 PLD）、CPLD（complex PLD，复杂 PLD）和 FPGA（field-programmable gate array，现场可编程门阵列）** 。SPLD 中又可分为 PLA、PAL 和 GAL 几种类型。FPGA 也是一种可编程逻辑器件，但由于在电路结构上与早期已经广为应用的 PLD 不 同，所以采用 FPGA 这个名称，以示区别。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1560887deaa66558322d142f691a7c4.png"></p>
<pre><code>    通过扩展 SPLD 的概念就可以得到 CPLD。CPLD 是复杂可编程逻辑器件，相当于将**多个 PAL 用可编程互联阵列（Programmable Interconnect Array，PIA）连接** 起来，形成一个大的 PLD，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/51b23c0e4eccaa6ca1148046910d0d8c.png"></p>
<pre><code>    上图中的 Logic block（逻辑块）通常被称为逻辑阵列模块，或者**LAB（Logic Array Block）** 。每个 LAB 相当于一个 PAL 电路，不同型号的 CPLD 器件可以包含十几个甚至上百个 LAB。通过 PIA 将这些 LAB 连接起来，就可以构成规模更大的逻辑电路了。另外，在 PAL 中，I/O 管脚是直接连接到逻辑的。而在 CPLD 中，I/O 管脚是通过 PIA 从器件的主要逻辑中分离出来的。I/O 管脚有它自己的控制逻辑，I/O 控 制单元可以根据需要将相应的引脚设置成输入、输出或双向工作模式。

    CPLD 相对于 SPLD 最大的优势就是拥有更大的逻辑资源和布线的可能性。CPLD 中 LAB 逻辑和 PIA 是完全可编程的，使得它具有在单芯片中非凡的设计灵活性。CPLD 的 I/O 特性和功能也远比 SPLD 中简 单的 I/O 更有价值。

    FPGA 由许多“可配置逻辑模块”（Configurable Logic Block，CLB）、输入/输出单元（I/O Block， IOB）和分布式的可编程互联矩阵（Programmable Interconnection Matrix，PIM）组成。在 FPGA 中，CLB 被布置成阵列的形式，如图 1.2.7 所示。可编程的布线资源分布在 CLB 与 CLB 之间，像大城市的街道一 样纵横联接。这些布线资源分为行互联和列互联，可以跨过整个器件，也可以是局部 CLB 之间的互联。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b1f8eacf99307c89a4e2491e222287e7.png"></p>
<pre><code>    我们将图进行对比可以发现，FPGA 中的布线资源看上去似乎比 CPLD 中的互联阵列更简单，但它实际上提供了更大的功能性和连通性。FPGA 中的布线资源使得器件中所有的逻辑资源都可 以与芯片内其他资源进行通信，这种结构可以实现更大容量、低成本的逻辑器件。

    在前面所讲的各种 SPLD 和 CPLD 电路中，都采用了与或逻辑阵列加上输出逻辑单元的结构形式。而 FPGA 则采用了完全不同的电路结构形式（查找表，LUT）
</code></pre>
<h3 id="3-MPSoC-PL-简介"><a href="#3-MPSoC-PL-简介" class="headerlink" title="3.MPSoC PL 简介"></a>3.MPSoC PL 简介</h3><pre><code>    Zynq UltraScale+ MPSoC PL 部分等价于 FPGA，因此我们将首先介绍 FPGA 的架构。

    简化的 FPGA 基本结构由 6 部分组成，分别为可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核等，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/278fa7234a1f4ee107063ffe158ca141.png"></p>
<h4 id="（1）可编程输入-输出单元"><a href="#（1）可编程输入-输出单元" class="headerlink" title="（1）可编程输入&#x2F;输出单元"></a>（1）可编程输入&#x2F;输出单元</h4><pre><code>    目前大多数 FPGA 的 I/O 单元被设 计为可编程模式，即通过软件的灵活配置，可以适配不同的电气标准与 I/O 物理特性；可以调整**匹配阻抗特性、上下拉电阻、以及调整驱动电流的大小** 等。         FPGA 支持的 I/O 电气标准有 LVTTL，LVCMOS，SSTL，HSTL，LVDS，LVPECL 和 PCI 等。一些高端 FPGA 通过 DDR 寄存器 技术，甚至可以支持高达 2Gbit/s 的数据数率。

    Zynq UltraScale+ MPSoC 上的通用输入/输出功能（IOB）合起来被称作 SelectIO 资源，每个 I/O 都是可配置的，**可以遵循多种 I/O 标准** 。I/O 分为**高范围(HR，high-range)、高性能(HP)和高密度(HD)** 三种类型。其中 HR 类型提供最广泛的电压支持，**从 1.2V 到 3.3V** 。HP 类型支持 1.0V 到 1.8V 它对性能操作进行了优化。HD 类型的 IO 一般一个 BANK 上由 24 个 IO 组成，能提供从 1.2V 到 3.3V 的电压支持。

    所有的 I/O 引脚都封装在 BANK 中，每个 BANK 上可以封装 52 个 HP 引脚，或者 52 个 HR 引脚，或 者 24 个 HD 引脚。每个 BANK 有一个公共的 VCCO 输出缓冲器电源，除了给输出缓冲器供电外也可以为 输入缓冲器供电。此外，HR BANK 可以一分为二，这两部分各自都有自己的 VCCO 供电。一些单端输入缓冲器需要一个内部产生的或外部应用的参考电压(VREF)。VREF 引脚可以直接连接 PCB，或者从 FPGA 内 部产生。
</code></pre>
<p>**         所有输入和输出 IO 可以配置为组合型（wire）或注册型（reg）<strong>。所有输入和输出</strong>均支持 DDR (Double data<br>rate)** 。任何输入或输出都可以单独延迟高达 1,250ps，<strong>分辨率为 5-15ps</strong> ，这种延迟被称为<strong>IDELAY 和 ODELAY</strong><br>。我们可以通过增减 IODELAY 的延迟步进进而调整 IODELAY 的延迟时间，也可以将 IODELAY 级联在一起，使单个方向上的延迟量增加一倍。</p>
<pre><code>    Zynq UltraScale+ MPSoC 的 IO 资源还支持串并转换。每个 I/O 引脚拥有一个 IOSERDES(ISERDES 和 OSERDES)，能够执行 2、4 或 8 位可编程宽度的串行到并行或并行到串行转换。
</code></pre>
<h4 id="（2）基本可编程逻辑单元"><a href="#（2）基本可编程逻辑单元" class="headerlink" title="（2）基本可编程逻辑单元"></a>（2）基本可编程逻辑单元</h4><pre><code>    基本可编程逻辑单元是可编程逻辑的主体，可以根据设计灵活地改变其内部连接与配置，完成不同的逻 辑功能。FPGA 一般是基于 SRAM 工艺的，其基本可编程逻辑单元几乎都是由**查找表（LUT，Look Up Table） 和寄存器（Register）** 组成。Xilinx UltraScale 系列 FPGA 内部查找表可以配置为带有**一个输出的 6 输入 LUT** ， 或者**两个带有独立输出但共用输入的 5 输入 LUT** ，查找表一般完成纯组合逻辑功能。FPGA 内部寄存器结构相当灵活，**可以配置为带同步/异步复位或置位的时钟使能触发器，也可以配置成锁存器** ，FPGA 依赖寄 存器完成同步时序逻辑设计。 一般来说，比较经典的基本可编程逻辑单元的配置是一个寄存器加一个查找表，但是不同厂商的寄存器 与查找表也有一定的差异，而且寄存器与查找表的组合模式也不同。当然这些可编程逻辑单元的配置结构随着器件的不断发展也在不断更新，最新的一些可编程逻辑器件常常根据需求设计新的 LUT 和寄存器的配置比率，并优化其内部的连接构造。 例如，Altera 可编程逻辑单元通常被称为 LE（Logic Element），由一个寄存器加一个 LUT 构成。Altera 大多数 FPGA 将 **10 个 LE 有机地组合在一起，构成更大的功能单元——逻辑阵列模块（LAB，Logic Array Block）** 。LAB 中除了 LE 还包含 LE 之间的进位链，LAB 控制信号，局部互联线资源，LUT 级联链，寄存器级联链等连线与控制资源。 Xilinx UltraScale 系列 FPGA 中的可编程逻辑单元叫 **CLB（Configurable Logic Block，可配置逻辑块）** 每个 CLB 包含一个逻辑运算片（**每个逻辑运算片包含 8 个 LUT 16 个寄存器** ）。逻辑运算片有两种类型， 分别是 SLICEL 和 SLICEM。SLICEM 中的 LUT 可以配置为 64 位 RAM、32 位移位寄存器(SRL32)或两个 16 位移位寄存器。与上一代 Xilinx 设备中的 CLB 相比，UltraScale 体系结构中的 CLB 增加了路由和连接 性。并且 UltraScale 的 CLB 还有额外的控制信号去使能更大的寄存器封装，可以提高设备的利用率。
</code></pre>
<p><strong>注：xilinx新一代 UltraScale 结构可参考《xilinx FPGA 权威设计指南》</strong></p>
<h4 id="（3）嵌入式块-RAM"><a href="#（3）嵌入式块-RAM" class="headerlink" title="（3）嵌入式块 RAM"></a>（3）嵌入式块 RAM</h4><pre><code>    目前大多数 FPGA 都有内嵌的**块 RAM（Block RAM）** ，FPGA 内部嵌入可编程 RAM 模块，大大地拓展了 FPGA 的应用范围和使用灵活性。不同器件商或不同器件族的内嵌块 RAM 的结构不同，Lattice 常用的 块 RAM 大小是 9Kbit；Altera 的块 RAM 最灵活，一些高端器件内部同时含有 3 种块 RAM 结构，分别是 M512 RAM，M4K RAM，M9K RAM。 每个基于 UltraScale 架构的设备都包含大量的 36Kb 块 RAM（Block RAM，简称 BRAM），可以配置 为一个 36Kb RAM 或两个独立的 18Kb RAM；每个块 RAM 都有两个完全独立的端口，且每个端口都可以读写数据，读写数据由时钟进行控制。每个块 RAM 列中有一个使能信号，这个信号能够让垂直相邻的块 RAM 之间级联，这样就可以创建大型、快速的存储阵列或者创建 FIFO，而且大大降低了功耗。 对于 RAM 来说，所有输入的数据、地址、时钟使能信号和写入使能都会被寄存。比如说输入一个地址 数据，这个地址数据就会被锁定(除非地址锁关闭)寄存，在下一次操作来临之前，地址寄存器的值是不会发生改变的。在写操作期间，也可以输出数据，输出的数据可以是先前存储的数据也可以是新写入的数据，当然在写操作期间也可以不输出数据。对于在设计中未使用的块 RAM 会**自动关闭，以减少总功耗** 。在每个块 RAM 上还具有额外的引脚来控制动态功率的门控特性。 对于 Xilinx UltraScale 系列 FPGA 来说，除了具有 BRAM 资源外，还有一种 **UltraRAM** 资源。UltraRAM 是一种高密度、双端口、同步内存块，用于一些 UltraScale+系列器件。这两个端口共用同一个时钟，可以处理 **4K x 72 位** 的数据，每个端口都可以独立地对内存数组进行读写操作。UltraRAM 支持两种类型的写操作方案，第一种模式与块 RAM 写操作模式一致；第二种模式允许控制数据的奇偶字节写入。多个 UltraRAM块可以级联在一起创建更大的内存阵列。UltraRAM 可以用专用的路径使整个列的存储区域连接在一起，这 使得 UltraRAM 成为替代 SRAM 等外部存储器的理想解决方案，它可以灵活的支持级联从 288Kb 到 36Mb 的存储空间，用以满足许多不同的内存需求。
</code></pre>
<h4 id="（4）丰富的布线资源"><a href="#（4）丰富的布线资源" class="headerlink" title="（4）丰富的布线资源"></a>（4）丰富的布线资源</h4><pre><code>    布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速 度。FPGA 芯片内部有着丰富的布线资源，这些布线资源根据工艺、长度、宽度和分布位置的不同而划分为 4 类不同的类别：

    第一类是**全局布线资源** ，用于芯片内部**全局时钟和全局复位/置位** 的布线；

    第二类是**长线资源** ，用以完成芯片 **Bank 间的高速信号和第二全局时钟信号的布线** ；

    第三类是**短线资源** ，用于完成基本逻辑单元之间的逻辑互连和布线；

    第四类是分布式的布线资源，用于专有时钟、复位等控制信号线。

    在实际中设计者不需要直接选择布线资源，布局布线器可自动地根据输入逻辑网表的拓扑结构和约束条件选择布线资源来连通各个模块单元。从本质上讲，布线资源的使用方法和设计的结果有直接的关系。
</code></pre>
<h4 id="（5）底层嵌入功能单元"><a href="#（5）底层嵌入功能单元" class="headerlink" title="（5）底层嵌入功能单元"></a>（5）底层嵌入功能单元</h4><pre><code>    底层**嵌入功能单元** 的概念比较笼统，这里我们指的是那些通用程度较高的嵌入式功能模块，比如 **PLL （Phase Locked Loop）、DLL（Delay Locked Loop）、DSP、CPU** 等。随着 FPGA 的发展，这些模块被越来 越多地**嵌入到 FPGA 的内部** ，以满足不同场合的需求。 目前大多数 FPGA 厂商都在 FPGA 内部**集成了 DLL 或者 PLL 硬件电路** ，用以完成时钟的高精度、低抖动的倍频、分频、占空比调整、相移等功能。目前，高端 FPGA 产品集成的 DLL 和 PLL 资源越来越丰富， 功能越来越复杂，精度越来越高。 另外，越来越多的高端 FPGA 产品将包含 DSP 或 CPU 等**硬核** ，从而 FPGA 将由传统的硬件设计手段逐步过渡到系统级设计平台。例如 Altera 的 Stratix IV、Stratix V 等器件内部集成了 DSP 核；Xilinx 的 Virtes II 和 Virtex II pro 系列 FPGA 内部集成了 Power PC450 的处理器。FPGA 内部嵌入 DSP 或 CPU 等处理器， 使 FPGA 在一定程度上具备了实现软硬件联合系统的能力，FPGA 正逐步成为 SOPC 的高效设计平台。
</code></pre>
<h4 id="（6）内嵌专用硬核"><a href="#（6）内嵌专用硬核" class="headerlink" title="（6）内嵌专用硬核"></a>（6）内嵌专用硬核</h4><pre><code>    这里的**内嵌专用硬核** 与前面的底层嵌入单元是有区分的，这里讲的内嵌专用硬核主要指那些**通用性相对较弱** ，不是所有 FPGA 器件都包含硬核。 在 ZYNQ UltraScale 的 PL 端和 PS 端各有一个**系统监视模块——System Monitors** ，它就是一个硬核。 System Monitors 包含一个模数转换器（ADC），一个模拟多路复用器，片上温度和片上电压传感器等。我们可以利用这个模块监测芯片温度和供电电压，也可以用来测量外部的模拟电压信号。
</code></pre>
<h3 id="4-MPSoC-PS-简介"><a href="#4-MPSoC-PS-简介" class="headerlink" title="4.MPSoC PS 简介"></a>4.MPSoC PS 简介</h3><pre><code>    MPSoC 实际上是 一个以处理器为核心的系统，**PL 只是它的一个外设** 。MPSoC 系列的亮点在于它**包含了完整的 ARM 处理器系统** ，且处理器系统中集成了内存控制器和大量的外设，使 **Cortex-A53 处理器可以完全独立于可编程逻辑单元** 。而且实际上在 MPSoC 中，**PL 和 PS 两部分的供电电路是独立的** ，这样 PS 或 PL 部分不被使用的话就可以被断电。

    在前面我们介绍 SOPC 时提到过，FPGA 可以用来搭建嵌入式处理器，像 **Xilinx 的 MicroBlaze 处理器 或者 Altera 的 Nios II 处理器** 。像这种使用 FPGA 的可编程逻辑资源搭建的处理器我们称之为“**软核”处理器** ，它的优势在于**处理器的数量以及实现方式的灵活性** 。

    而 MPSoC 中集成的是一颗**“硬核”处理器** ，它是硅芯片上专用且经过优化的硬件电路，硬核处理器的优势是它可以获得相对**较高的性能** 。另外，MPSoC 中的硬件处理器和软核处理器并不冲突，我们完全可以**使用 PL 的逻辑资源搭建一个 Microblaze 软核处理器** ，**来和 ARM 硬核处理器协同工作** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/064f01639500be171eeaf8ff627142be.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6e7b726f843d04b79e0d395bc15ad1fb.png"></p>
<pre><code>    从上面的结构图中可以很清楚的看到 MPSoC 的结构，它分为 PS 和 PL 两部分。在 PS 部分中它主要由 Arm Cortex-A53（APU 共 4 个核）、Arm Cortex-R5F（RPU 共两个核）以及 Arm Mali-400 MP2（GPU）三 种内核处理器构成，并且还包括 DDR 控制单元、平台管理单元、高速外设控制器以及普通外设控制器等外设组成。
</code></pre>
<h4 id="（1）APU（Application-Processing-Unit）"><a href="#（1）APU（Application-Processing-Unit）" class="headerlink" title="（1）APU（Application Processing Unit）"></a>（1）APU（Application Processing Unit）</h4><p>APU 主要是由两个或者四个 ARM 处理器核组成的，Cortex-A53 核心是基于 Arm-v8A 架构的 32 位&#x2F;64<br>位应用程序处理器，拥有极佳的性能&#x2F;功率比，每一个 Cortex-A53 核心拥有 32KB 指令和数据 L1 缓存，具 有奇偶校验、ECC 保护、NEON<br>SIMD 引擎、单精度和双精度浮点单元。除了这些模块，APU 还有一个 snoop 控制单元以及一个带 ECC 保护的 1MB L2<br>缓存，这样的设计可以更好的提高系统级的性能。该 APU 还具有 内置的中断控制器支持虚拟中断。</p>
<p>它的结构框图如下所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/106eae5a24e0a7fb2a345b01badee237.png"></p>
<h4 id="（2）RPU（Real-Time-Processing-Unit）"><a href="#（2）RPU（Real-Time-Processing-Unit）" class="headerlink" title="（2）RPU（Real-Time Processing Unit）"></a>（2）RPU（Real-Time Processing Unit）</h4><pre><code>    PS 中的 RPU 包含一个双核 Arm Cortex-R5F 处理器，Cortex-R5F 是 32 位实时处理器，它是基于 Arm-v7R 架构的处理器内核。每个 Cortex-R5F 核都有 32KB 的指令和数据缓存（L1），除了 L1 缓存，每个 Cortex-R5F 核心还具有 128KB 的紧耦合内存(TCM)接口，用于实时单周期访问。RPU 还有一个专用的中断控制器。 两个 RPU 既可工作在独立模式，也可以工作在同步模式。在独立模式中两个处理器都是独立运行的；在同步模式下，它们彼此并行运行，逻辑资源也会综合到一起，并且 TCM 资源也整合成 256KB。RPU 还可以通过 **AXI-4 端口** 与 PS 端的 LPD 区域进行通信或者与 PL 端进行低延迟通信。支持实时 DEBUG 和信号跟踪， 每个内核还具有一个嵌入式跟踪宏单元(ETM)方便 Arm 内核调试。

    Cortex-R5 处理器是用于深度嵌入式实时系统的 CPU，它采用了 **Thumb-2 技术** 以获得最佳的代码密度和处理吞吐量，它还具有一个算术逻辑单元(ALU)，为了更加有效地利用其他资源（例如寄存器资源），算术逻辑单元会执行有限的双重指令。Cortex-R5 处理器会通过重新启动和加载多个指令来保持较低的中断延迟，并且还会使用一个专用的外围端口来实现对中断控制器的低延迟访问。处理器具有紧密耦合内存(TCM) 端口，用于低延迟和确定性地访问本地 RAM。错误检查和纠正功能(ECC)是用于 Cortex-R5 处理器端口和 Level 1 (L1) 存储器的，这样可以提高系统的可靠性和准确性。Cortex-R5 处理器的结构框图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/21571fa533509d390545702afb58271c.png"></p>
<h4 id="（3）GPU（Graphics-Processing-Unit）"><a href="#（3）GPU（Graphics-Processing-Unit）" class="headerlink" title="（3）GPU（Graphics Processing Unit）"></a>（3）GPU（Graphics Processing Unit）</h4><pre><code>    GPU 是基于 **Arm Mali - 400 MP2** 硬件加速器的 2D 和 3D 图形子系统。它由一个**几何图形处理器（GP）、 两个像素处理器（PP）、64KB L2 缓存控制器（L2）、针对 GP 和每个 PP 的独立内存管理单元(MMU)以及 128 位 AXI 总线接口构成** 。Arm Mali-400 MP2 作为 PS 专用的图形处理器它可以支持 2D 和 3D 图形加速， 最高分辨率为 1080p，对于 3D 图形它能够支持 OpenGL ES 1.1 and 2.0 规范而对于 2D 的矢量图形它只能支 持 Open VG 1.1 标准。它的几何处理器(GP)和 2 个像素处理器会并行地执行贴图渲染操作。它为 GP 和像素处理器提供了专用的内存管理单元，支持 4 KB 的页面大小。

    GPU 还有 64KB 的二级(L2)只读缓存，它支持 4X 和 16X 全场景抗锯齿(FSAA)功能。它有内置的硬件纹理解压缩，允许纹理在图形硬件中保持压缩(ETC 格式)，并在运行中解压所需的样本。它还支持在不消耗额外带宽的情况下有效地混合多个硬件层，它的像素填充率为 200 万像素/秒/MHz，三角形填充率为 0.1Mvertex/秒/MHz。GPU 支持广泛的纹理格式为 RGBA 8888、565、1556 以及 YUV 格式，对于功率敏感 的应用，GPU 支持对每个 GP、像素处理器和 L2 缓存的时钟和功率进行门控。在功率门控过程中，GPU 不 消耗任何静态或动态功率；在时钟门控过程中，它只消耗静态电源。
</code></pre>
<h4 id="（4）DDR-Memory-Controller"><a href="#（4）DDR-Memory-Controller" class="headerlink" title="（4）DDR Memory Controller"></a>（4）DDR Memory Controller</h4><pre><code>    DDR 存储控制器通过**六个 AXI 数据接口** 和一**个 AXI 控制接口** 连接到 MPSoC 的其余部分，其中一条数据路径连接到实时处理单元(RPU)，两条数据路径连接到缓存相干互连(CCI-400)，其他的在 DisplayPort 控 制器、FPD、DMA 和编程逻辑(PL) 上多路复用。在 6 个接口中，5 个是 128 位宽，而第 6 个接口(绑定到 RPU)是 64 位宽。DDR 子系统支持 DDR3、DDR3L、LPDDR3、DDR4 和 LPDDR4，它可以通过 AXI 总线 接口接收来自 6 个应用主机端口的读写请求，这些请求在内部排队访问 DRAM 设备。存储器控制器**在 DDRPHY 接口上向 PHY 模块发出命令** ，PHY 模块从 DRAM 中读取和写入数据。DDR Memory Controller 的结 构如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a8305f1515bf5ca6c2a3121525a2e38.png"></p>
<h4 id="（5）PMU（Platform-Management-Unit）"><a href="#（5）PMU（Platform-Management-Unit）" class="headerlink" title="（5）PMU（Platform Management Unit）"></a>（5）PMU（Platform Management Unit）</h4><pre><code>    Zynq UltraScale+ MPSoC包括一个专用的用户可编程处理器，用于电源、错误管理的**平台测量单元(PMU) 处理器** ，以及用于功能安全应用的可选软件测试库(STL)。由于 PMU 的结构和配置相当复杂这里我们只简 要列出他的功能，更加详细的介绍大家可以参考 Xilinx 官方文档 ug1085。 PMU 的功能如下：1、 使用系统监视器检查电源水平，以确保 CSU 和 LP 域的其余部分正常运行。 2、 初始化 pll 的默认配置和他们潜在的旁路。 3、 触发和排序必要的扫描和 MBIST。 4、 捕获并发出错误信号，错误 ID 可以通过 JTAG 读取。 5、 释放复位到 CSU。 6、 在应用程序和实时处理器处于睡眠状态时充当它们的委托，并在接收到它们的唤醒请求之后对他 们进行开机和重启。 7、 在任何时候维护系统电源状态。 8、 处理不同块的上电、下电、复位、内存内置自修复(MBISR)、MBIST 和扫描归零所需的低级事件序列。 9、 在休眠模式下管理系统，并基于各种触发机制唤醒系统。 10、 PS-level 错误捕获。
</code></pre>
<h4 id="（6）High-Speed-Connect-Zynq"><a href="#（6）High-Speed-Connect-Zynq" class="headerlink" title="（6）High-Speed Connect Zynq"></a>（6）High-Speed Connect Zynq</h4><pre><code>    UltraScale+ MPSoC 的 PS 端集成了 5 个高速外设，分别是 **DP 控制器、USB3.0 控制器、SATA3.1 控制器、PCIE 1.0/2.0 控制器以及 PS-GTR 收发器** 。

    1、DP接口（**DisplayPort 控制器** ）：Zynq UltraScale+ MPSoC 的 PS 端集成了 DisplayPort 控制器，它可以从内存(非实时输入)或(实时输入)可编程逻辑(PL)中获取数据，并将这些数据处理过后通过 DisplayPort 源控制器块输出到外部显示设备或 PL(实时输出)上。DisplayPort 控制器由 **DMA、缓冲区管理器、显示渲染块、音频混音块、DisplayPort 源控制器以及 PS-GTR 模块** 组成，它可以支持 超高清(UHD)视频，因此 **DP 接口常用来做视频图像传输的接口** 。

    2、 USB3.0：USB 3.0 控制器由两个独立的 DRD (dual-role device)控制器组成，两者都可以单独配置为 在任何给定时间作为主机或从机设备工作。USB 3.0 DRD 控制器通过高级的可扩展 AXI 从接口， 可以为系统软件提供一个可扩展的主控制器接口(xHCI)。控制器中有一个内部的 DMA 引擎，它利 用 AXI 主接口来传输数据。三个双端口 RAM 的配置可以实现 RX 数据 FIFO、TX 数据 FIFO 和描 述符/寄存器缓存功能，AXI 主端口与协议层可以通过缓冲区管理单元访问不同的 RAM。

    3、 SATA3.1：SATA 控制器是一种高性能双端口主机控制器，具有 AHCI 兼容的命令层，该命令层对 使用端口乘法器的系统来说，具有支持基于本地命令队列和帧信息结构(FIS)交换的高级功能。 SATA 使用 ATA/ATAPI 命令集，但是通过不同的导线可以实现与 SATA 第 1 代、第 2 代或第 3 代 相对应的 1.5、3.0 或 6.0 Gb/sec 的速率进行串行通信。串行数据采用 8B/10B 编码，确保数据模式 中有足够的转换以确保直流平衡（这里的转换指数据的 0/1 转换，关于直流平衡的知识大家可以自行了解或者看我们 HDMI 相关的视频，其中有涉及），并使时钟数据恢复电路能够从输入数据模式中提取时钟。

    4、 PCIe 1.0/2.0 控制器：MPSoC 集成了一个 PCIe 通信控制器，用于实现 PCIe 的通信，它包含**AXI-PCIe 桥和 DMA 组件** ，AXI-PCIe 桥主要是为 PCIe 和 AXI 提供高性能桥接。模块示意图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db511727b124ee7bc65a3c18c44c9ac5.png"></p>
<pre><code>    从上图中可以看到控制器由两个子模块组成，其中 PCIe 桥的主要功能除了**将 PCIe 协议与 AXI 协议相互转换** 外还可以转换入口/出口地址，为 DMA 和 Root Port/Endpoint (RP/EP)模式切换提供特定的服务。

    5、 PS-GTR 收发器：千兆 GTR 收发器为串行输入输出单元(SIOU)的外围设备、媒体访问控制器(mac) 以及它们的高速通信链路提供专用的 I/O。Zynq UltraScale+ MPSoC 共有四个可编程高速收发器， 可以支持数据速率高达 6gb /s 的子层协议。
</code></pre>
<h4 id="（7）普通外设控制器"><a href="#（7）普通外设控制器" class="headerlink" title="（7）普通外设控制器"></a>（7）普通外设控制器</h4><pre><code>    Zynq UltraScale+ MPSoC 的 PS 端除了集成的高速通信外设之外，还有一些普通的低速外设，其中包括 **GigE、USB2.0、CAN、UART、SPI、Quad SPI NOR、NAND 以及 SD/eMMC** 等外设控制器。
</code></pre>
<h4 id="（8）PS-PL-AXI-接口"><a href="#（8）PS-PL-AXI-接口" class="headerlink" title="（8）PS-PL AXI 接口"></a>（8）PS-PL AXI 接口</h4><pre><code>    MPSoC 将高性能 ARM Cotex-A 系列处理器与高性能 FPGA 在单芯片内紧密结合，为设计带来了如减小体积和功耗、降低设计风险，增加设计灵活性等诸多优点。在将不同工艺特征的处理器与 FPGA 融合在 一个芯片上之后，片内处理器与 FPGA 之间的互联通路就成了 MPSoC 芯片设计的重中之重。如果 Cotex-A53 与 FPGA 之间的数据交互成为瓶颈，那么处理器与 FPGA 结合的性能优势就不能发挥出来。 Xilinx 从 Spartan-6 和 Virtex-6 系列开始**使用 AXI 协议来连接 IP 核** 。在 7 系列、Zynq-7000 和 Zynq UltraScale+ MPSoC 器件中，Xilinx 在 IP 核中继续使用 AXI 协议。AXI 的英文全称是 **Advanced eXtensible Interface，即高级可扩展接口** ，它是 ARM 公司所提出的 AMBA（Advanced Microcontroller Bus Architecture）协议的一部分。

    AXI 协议是一种高性能、高带宽、低延迟的片内总线，具有如下特点：

    1、总线的**地址/控制和数据通道是分离** 的；

    2、支持**不对齐的数据传输** ；

    3、支持突发传输，突发传输过程中只需要首地址；

    4、具有分离的读/写数据通道；

    5、支持显著传输访问和乱序访问；

    6、更加容易进行时序收敛。

    在数字电路中只能传输二进制数 0 和 1，因此可能需要一组信号才能高效地传输信息，这一组信号就组成了接口。AXI4 协议支持以下三种类型的接口：

    1、 **AXI4** ：高性能存储映射接口。

    2、 **AXI4-Lite** ：简化版的 AXI4 接口，用于较少数据量的存储映射通信。

    3、 **AXI4-Stream** ：用于高速数据流传输，非存储映射接口。

    AXI4 协议支持**突发传输** ，主要用于处理器访问存储器等需要指定地址的高速数据传输场景。AXI-Lite 为外设提供单个数据传输，主要用于访问一些低速外设中的寄存器。而 AXI-Stream 接口则像 FIFO 一样， 数据传输时**不需要地址** ，在主从设备之间直接连续读写数据，主要用于如视频、高速 AD、PCIe、DMA 接 口等需要高速数据传输的场合。

    在 **PS 和 PL 之间的主要连接是通过一组 12 个 AXI 接口** ，每个接口有多个通道组成。这些形成了 PS 内部的互联以及与 PL 的连接，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fbe5480df361ea6c20b12f14e4d0579.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/24463930ff0801a294b79279e850f73d.png"></p>
<pre><code>    上图给出了每个接口的简述，标出了主机是 PL 还是 PS（按照惯例，主机是控制总线并发起会话的， 而从机是做响应的）。需要注意的是，接口命名的第一个字母表示的是 PS 的角色，也就是说，第一个字 母 “M” 表示 PS 是主机，而第一个字母“S”表示 PS 是从机。

    S_AXI_HP&#123;0:3&#125;_FPD/S_AXI_HPC&#123;0,1&#125;_FPD：六个 **PL 侧高性能（High Performance）AXI 主接口连接到 PS 侧的 FPD（Full-power domain）**，主要**用于访问 DDR 内存** ，进行大量数据的传输，如摄像头图像数据等。所有的六个高性能 AXI 主接口都经过了 PS 中的 **SMMU（System Memory Management Unit）** ， SMMU 能够使用**物理和虚拟地址转换** 。其中一致性 S_AXI_HPC 接口连接到了 **CCI（Cache-coherent interconnect）** ，可以**访问 L1 和 L2 Cache** ，也正是连接到了 CCI，所以在访问 DDR 控制器时，相比于 S_AXI_HP 接口来说，延时会较大。

    S_AXI_LPD：主机 PL 连接至从机 PS 侧**LPD（Low-power domain）** 的高性能 AXI 接口，它能够低延 时地访问 OCM（On-chip Memory）和 TCM（Tightly-coupled Memory）。         S_AXI_ACE_FPD：主机 PL 与从机 PS 中的 CCI 相连接，它能够支持 PS 和 PL 中的硬件块之间的**完全一致性（双向）** 。该接口使用的是 ACE（AXI coherency extension）协议，与 AXI 接口相比，ACE 协议 使用了五个额外的通道，三个通道用于监听，两个用于应答。         S_AXI_ACP_FPD：该接口实现了 PL 和 PS 之间的低延时访问，PL 端可以直接访问 APU 的 L1 和 L2 Cache 以及 DDR 内存。

    M_AXI_HPM&#123;0,1&#125;_FPD：该高性能接口由主机 **PS 侧 FPD 连接至从机 PL** ，可以用于 CPU、 DMA、 PCIe 等传输大量数据到 PL。

    M_AXI_HPM0_LPD：该高性能接口由主机 PS 侧 LPD 连接至从机 PL，该接口适合于为 PS 中的 LPD 主机（例如 LP-DMA）提供对 PL 中的存储器的访问，也经常用于配置 PL 端的寄存器。

    上面每条总线都是由一组信号组成的，这些总线上的会话是根据 AXI4 总线协议进行通信的。
</code></pre>
<h3 id="5-DFZU2EG-MPSoc-硬件连接资源"><a href="#5-DFZU2EG-MPSoc-硬件连接资源" class="headerlink" title="5.DFZU2EG MPSoc 硬件连接资源"></a>5.DFZU2EG MPSoc 硬件连接资源</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/285558105285fc578ebeac7655e5f78a.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/356e3108207098fd32f04578acc1619b.png"></p>
<pre><code>    具体说明见参考书目 P38~P42 ；注意点说明：1.纽扣电池座：DFZU2EG/4EV MPSoC 开发板板载一个纽扣电池座，在开发板断电时，电池可以持续为 MPSoC 芯片内 部的 RTC 实时时钟模块进行供电，以维持计时的功能。2. 1.8 V IO 电平扩展口和 3.3 V IO 电平扩展口。
</code></pre>
<p>详细说明：</p>
<h4 id="（1）IO-分配"><a href="#（1）IO-分配" class="headerlink" title="（1）IO 分配"></a>（1）IO 分配</h4><pre><code>    Zynq UltraScale+ MPSoC 系列的 xczu2cg-sfvc784-2、 xczu2eg-sfvc784-2 和 xczu4ev-sfvc784-1，总共有 14 个用户 BANK（指连接外设的 BANK，不包 BANK224）。这 14 个 BANK 中有 6 个属于 PS 端，8 个属于 PL 端，不同的 BANK 上连接有不同的外设。

    **PL 端** 的 IO 被分成 8 组也就是 8 个 BANK，同一个 BANK 中 IO 供电是相同的，不同的 BANK 之间供电电压可以不相同。在 DFZU2EG/4EV MPSoC 开发板中 PL 端 BANK24、BANK44、BANK25 以及 BANK26 都是 3.3V 电压供电，而 BANK64、BANK65 是 1.2V 供电，BANK0、BANK66 是 1.8V 供电。之所以不同 BANK 之间的供电不同主要和它们连接的外设，即承担的功能有关，遵循的原则就是**速度越快电压越低** ，例如 BANK64 连接的是 DDR4 芯片，需要处理高速的数据吞吐，因此它的供电电压较低，为 1.2V。举例 BANK 的原理图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ea8e0b7083b76eb21ac3a85c38d02a8e.png"></p>
<pre><code>    从原理图中可以看出 DFZU2EG/4EV MPSoC 开发板的 PL 端引脚是非常多的，为了方便大家查找我们将例程用到的整理成了一张表格，可在参考书目P55~P59查看。

    **PS 端** 一共包含了 6 个 IO BANK，与 PL 端 IO BANK 不同的是，**PS 端的 IO 连接是是相对固定的** ，用户不能够像 PL 引脚那样，将 PS 端的 IO 随意分配到某个外设。PS 端外设的 IO 口与 MIO（多路复用 IO）之间，具有**固定关系的映射** ，某 个外设的 IO 口可能会映射到不同的 MIO 上，某个 MIO 也有可能会具有多个外设的 IO 口映射到其上面。 可在参考书目P63~P65查看。
</code></pre>
<h4 id="（2）电源系统"><a href="#（2）电源系统" class="headerlink" title="（2）电源系统"></a>（2）电源系统</h4><p>下图是电源的拓扑结构，标出了降压模块和降压后的电压：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d78702e8eff3db86591525204aea5c5.png"></p>
<pre><code>    这里要特别提醒一下大家，板子上有的已经有一种电压了例如 1.8V，为什么后 面还要再转个 1.8V 出来，而且同一种电压还会有好几个名称，这主要是因为有很多器件是有**上电顺序** 的，**不可以同时上电** ，虽然工作电压都相等，但是上电顺序有先后要求，所以我们就通过一定的电路设计让整 个板子上的器件有一个先后的上电顺序，这就是为什么同一种电压转换了多次或者好几个名字，主要是每 个名字代表的电压产生的顺序不同。
</code></pre>
<p>电源适配器供电的电源接口原理图如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/774c4af01a11930c7c6f55af86cbf36e.png"></p>
<pre><code>    上图电路的作用是将外部输入的+12V 电压经过降压芯片转换为 5V 电源 VBTN 输出。参考书目上有各个模块供电的说明P67~P76。        
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/86bcd774d1cd313007ac19e14a85151b.png"></p>
<p><strong>启动顺序： VCC_PSAUX &gt;DDR_1V2&gt;VCC_3V3&gt;PL_VCU_0V9（1.8V&gt;1.2V&gt;3.3V&gt;0.9V）</strong></p>
<pre><code>    PS 端在全功率域（FPD）可以工作之前，低功率域（LPD）必须工作。

    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了低功率域（LPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。

    1.VCC_PSINTLP

    2.VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL 以任何顺序或同时进行。

    3.VCCO_PSIO

    为了实现最小电流消耗并确保 I/O 在通电时处于三态，列出了全功率域（FPD）的建议通电顺序。同时 建议关机顺序与开机顺序相反。 、

    1.由同一电源驱动的 VCC_PSINTFP 和 VCC_PSINTFP_DDR。         

    2.VPS_MGTRAVCC 和 VCC_PSDDR_PLL 以任何顺序或同时进行。

    3.VPS_MGTRAVTT 和 VCCO_PSDDR 以任何顺序或同时进行。

    官方推荐的 PS 端低功率域（LPD）上电顺序为：VCC_PSINTLP→VCC_PSAUX、VCC_PSADC 和 VCC_PSPLL→VCCO_PSIO。

    官方推荐的 PS 端 全 功 率 域 （ FPD ） 上 电 顺 序 为 ： VCC_PSINTFP 和 VCC_PISNTFP_DDR→ VPS_MGTRAVCC 和 VCC_PSDDR_PLL→VPS_MGTRAVTT 和 VCCO_PSDDR。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0dd10c2803ebb95a035348f35d63475.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/30ba53b3d6ab97f14bf66dc9246ad6d9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad6edabb65d61577965736979d110b08.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f70d5d4b2d9e764aae43aef8f2f91aa2.png"></p>
<h4 id="（3）启动模式"><a href="#（3）启动模式" class="headerlink" title="（3）启动模式"></a>（3）启动模式</h4><pre><code>    DFZU2EG/4EV MPSoC 开发板支持 8 种启动模式，我们常用的启动模式是 **JTAG 启动、FLASH 启动以 及 SD 卡启动，此外还支持 eMMC 启动以及 USB 启动** 。具体的启动方式选择可以通过拨动拨码开关去控制，拨码开关拨动的值和对应的启动模式，在原理图中以表格的形式给大家列举出来了。其原理图如下所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ee1a75579935f6c78af98f0332fc8eb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9fee6f910356db649db8c4e9ac714e0.png"></p>
<h4 id="（4）其他硬件资源"><a href="#（4）其他硬件资源" class="headerlink" title="（4）其他硬件资源"></a>（4）其他硬件资源</h4><pre><code>    此外，参考书目**P76~P101** 列出了 _PL 端千兆以太网、PS 端千兆以太网、USB3.0 接口、USB HUB 芯片、MINI DP 接口、PS 端串口、PL 端串口、XADC 接口、时钟振荡器、J19 扩展口、J1 扩展口、EEPROM、PCIe 接口、PS 端 4 片 DDR4、PL 端 1 片 DDR4、eMMC、风扇接口、PL和 PS 端按键、PL 和 PS 端 LED、MIPI CSI 接口、PL 配置完成指示灯、电源指示灯、HDMI 接口WIRELESS 接口、**ATK-MODULE** 、PL 和 PS 端复位、TF 卡接口、**QSPI FLASH** 、RGB888 TFT-LCD_ 等的**电路连接、引脚说明、时序结构** 等说明。
</code></pre>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h3><h4 id="（1）注意事项"><a href="#（1）注意事项" class="headerlink" title="（1）注意事项"></a>（1）注意事项</h4><pre><code>    为了让大家更好的使用 DFZU2EG/4EV MPSoC 开发板，我们在这里总结该开发板使用的时候尤其要 注意的一些问题，希望大家在使用的时候多多注意，以减少不必要的问题。

    1\. 当你想使用某个 IO 口用作其他用处的时候，请先看**看开发板的原理图** ，该 IO 口是否有连接在开发板的某个外设上，如果有，该外设的这个信号是否会对你的使用造成干扰， 先确定无干扰，再使用这个 IO。

    2\. 开发板上的**拨码开关需要拨到对应的模式** 才能启动开发板，如果模式和启动方式不对应会造成代码下载失败或者板子启动不起来。

    3\. 当液晶显示白屏的时候，请先检查液晶模块是否插好（拔下来重新插试试），如果 还不行，可以通过串口看看 LCD ID 是否正常，再做进一步的分析。
</code></pre>
<h4 id="（2）学习-MPSoC-基本方法："><a href="#（2）学习-MPSoC-基本方法：" class="headerlink" title="（2）学习 MPSoC 基本方法："></a><strong>（2）学习 MPSoC 基本方法：</strong></h4><p>**         &lt;1&gt;了解 MPSoC 的基本结构**</p>
<pre><code>    学习 MPSoC 之前需要先对 **MPSoC 基本结构和其功能** 有个大概的了解，如 PS、AXI 总线、锁相环 PLL、FIFO 等。需要知道 PLL 是用来产生不同频率的时钟，如使用 HDMI 时需要生成 75MHz 的时钟； FIFO 用于数据的缓存和异步时钟域数据的传递等。
</code></pre>
<p>**         &lt;2&gt;了解 Verilog HDL 基本语法**</p>
<pre><code>    Verilog HDL 做为一种硬件描述语言，是 对数字电路的一种描述，而数字电路是并行工作的，因而在编写 Verilog HDL 时要有**并行的思想** ，不同于 软件设计语言，软件设计语言是由 CPU 统一进行处理，一条指令一条指令的串行运行，所以软件设计语 言是基于串行的设计思想，因而在写 Verilog HDL 代码的时候要注意这种差别。另外对于 Verilog HDL 的 基本语法是务必要掌握的，如一般常用的 module/endmodule、input/output/inout、wire/reg、begin/end、 posedge/negedge、always/assign、if/else、case/default/endcase/parameter/localparam 等关键字要清楚它们的作用和区别。掌握了 Verilog HDL 的基本语法和 Verilog HDL 的并行设计思想后，会觉得 Verilog HDL 和 C 语言一样简单。
</code></pre>
<p>**         &lt;3&gt;MPSoC PS 的学习**</p>
<pre><code>    学习 MPSoC PS 首先要了解 C 语言的基本语法。然后了解 **PS 端基本的系统框架和外设** ，例如 **PS 端架构、片内互连、AXI 总线、DDR 控制器** 等等。最关键的是 **PS 端的 C 程序** 。软件系统可以被认为是建立于基于硬件的系统上的一个栈，或者说是一系列层，**从底至上依次是基础硬件系统（来自 Vivado 的自定义硬件）、板级支持包、Operating System、软件应用** 。

    初学者可以多看看官方的文档和资料，对于 PS 端的软件，**xilinx 提供了丰富的库函数** ，很多时候用户直接调用调用即可，读者要学会利用这些库函数。遇到问题时，读者可以借助 xilinx 的 SDK 开发环境中的各种调试功能来定位错误，以帮助解决问题。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133233092">https://blog.csdn.net/qq_32971095/article/details/133233092</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">790k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'H2FYHQwVGaUkawg5DkrA6d6M-gzGzoHsz',
      appKey     : 'zndS0u9Qj7qj8CqnJINs2MGT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://h2fyhqwv.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
