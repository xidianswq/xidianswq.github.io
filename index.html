<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Switch">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Switch">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SWQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Switch</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Switch</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/CSDN%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E4%B8%BAHexo%E7%9A%84MD%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/CSDN%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E4%B8%BAHexo%E7%9A%84MD%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">CSDN博客导出为Hexo的MD文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 13:13:00 / 修改时间：13:18:43" itemprop="dateCreated datePublished" datetime="2025-02-08T13:13:00+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSDN博客导出为Hexo的MD文件"><a href="#CSDN博客导出为Hexo的MD文件" class="headerlink" title="CSDN博客导出为Hexo的MD文件"></a>CSDN博客导出为Hexo的MD文件</h1><p>一.获取所有文章地址、 二.使用脚本进行采集 </p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/air/p/18429617">CSDN文章导出md并迁移至博客园 - lytcreate - 博客园</a> </p>
</blockquote>
<p>部分代码修正：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    url_list = [&#123;<span class="string">&#x27;url&#x27;</span>: item[<span class="string">&#x27;url&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: item[<span class="string">&#x27;title&#x27;</span>]&#125; <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 解析地址</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.helloworld.net/getUrlHtml?url=&#x27;</span></span><br><span class="line">    <span class="comment"># 解析错误的url</span></span><br><span class="line">    err_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(item[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">            res = requests.get(base_url + item[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">            content = res.json().get(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">            title = item[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(title+<span class="string">&#x27;已完成&#x27;</span>)</span><br><span class="line">            <span class="comment"># 调用函数，将HTML转换为Markdown并保存为文件</span></span><br><span class="line">            html_to_md(content, os.path.join(<span class="string">&#x27;md&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;title&#125;</span>.md&#x27;</span>)) </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">            <span class="built_in">print</span>(e) </span><br><span class="line">            err_list.append(item[<span class="string">&#x27;url&#x27;</span>]) </span><br><span class="line">        <span class="keyword">if</span> err_list: </span><br><span class="line">            <span class="built_in">print</span>(err_list) </span><br><span class="line">            df = pd.DataFrame([&#123;<span class="string">&#x27;name&#x27;</span>: err_list&#125;]) </span><br><span class="line">            df.to_csv(<span class="string">&#x27;err.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><em><strong>注：可能出现的问题：博客名不合规无法保存——修改文件名</strong></em></p>
<hr>
<h2 id="三-批量给md文件增加hexo识别码"><a href="#三-批量给md文件增加hexo识别码" class="headerlink" title="三.批量给md文件增加hexo识别码"></a>三.批量给md文件增加hexo识别码</h2><p>hexo识别文章需要添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;XXX&quot;</span><br><span class="line">date: 20XX-XX-XX XX:XX:XX</span><br><span class="line">tags: [&#x27;AA&#x27;, &#x27;BB&#x27;,...]</span><br><span class="line">......(依据manu设置)</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>对于CSDN批量导出文章，采用以下方法快速增加相关信息：</p>
<ul>
<li>创建 <em>CSDN_INFO.txt</em> 保存之前在浏览器console导出的文章信息</li>
<li>使用脚本 <em>AddInfo_CSDN.py</em> 将信息自动添加到对应md文件中，将需要转换的 <em>.md</em> 文件保存在同目录的 <em>md</em> 文件夹中</li>
</ul>
<p><em>AddInfo_CSDN.py</em> 内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为所有md文件开头添加对应CSDN_INFO.txt中的信息</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="comment"># title: &quot;标题&quot;</span></span><br><span class="line"><span class="comment"># date: 2020-01-01 00:00:00</span></span><br><span class="line"><span class="comment"># tags: [&quot;标签1&quot;, &quot;标签2&quot;...]</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSDN_INFO.txt，提取每篇文章对应的文章标题title、日期postTime、标签tags</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readCSDNInfo</span>():</span><br><span class="line">    CSDNInfo = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;CSDN_INFO.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 字符匹配title、postTime、tags</span></span><br><span class="line">        title = re.findall(<span class="string">r&quot;title\&quot;: \&quot;(.*?)\&quot;&quot;</span>, f.read())</span><br><span class="line">        f.seek(<span class="number">0</span>)<span class="comment">#文件指针重置</span></span><br><span class="line">        postTime = re.findall(<span class="string">r&quot;postTime\&quot;: \&quot;(.*?)\&quot;&quot;</span>, f.read())</span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        all_tags = re.findall(<span class="string">r&#x27;&quot;tags&quot;:\s*\[([^\]]+)\]&#x27;</span>, f.read())</span><br><span class="line">        tags = [<span class="literal">None</span>] * <span class="built_in">len</span>(title)</span><br><span class="line">        <span class="comment"># 进一步提取每个标签</span></span><br><span class="line">        <span class="keyword">for</span> tag_group <span class="keyword">in</span> all_tags:</span><br><span class="line">            <span class="comment"># 提取双引号中的内容</span></span><br><span class="line">            tags[all_tags.index(tag_group)] = re.findall(<span class="string">r&#x27;&quot;([^&quot;]+)&quot;&#x27;</span>, tag_group)</span><br><span class="line">        <span class="comment"># 提取title、postTime、tags</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(title)):</span><br><span class="line">            CSDNInfo[title[i]] = &#123;&#125;</span><br><span class="line">            CSDNInfo[title[i]][<span class="string">&quot;postTime&quot;</span>] = postTime[i]</span><br><span class="line">            CSDNInfo[title[i]][<span class="string">&quot;tags&quot;</span>] = tags[i]</span><br><span class="line">    <span class="keyword">return</span> CSDNInfo</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 为md文件开头添加对应CSDN_INFO.txt中的信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addInfo2MD</span>(<span class="params">mdPath, CSDNInfo</span>):</span><br><span class="line">    title = os.path.basename(mdPath).split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">in</span> CSDNInfo:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="keyword">if</span> lines[<span class="number">0</span>].startswith(<span class="string">&quot;---&quot;</span>):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mdPath, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;title: \&quot;<span class="subst">&#123;title&#125;</span>\&quot;\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;date: <span class="subst">&#123;CSDNInfo[title][<span class="string">&#x27;postTime&#x27;</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;tags: <span class="subst">&#123;CSDNInfo[title][<span class="string">&#x27;tags&#x27;</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(content)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;AddInfo: <span class="subst">&#123;title&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;title&#125;</span> not in CSDN_INFO.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有md文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverseMDFiles</span>(<span class="params">mdDir, CSDNInfo</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(mdDir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">                mdPath = os.path.join(root, file)</span><br><span class="line">                addInfo2MD(mdPath, CSDNInfo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    mdDir = <span class="string">&quot;md&quot;</span></span><br><span class="line">    CSDNInfo = readCSDNInfo()</span><br><span class="line">    traverseMDFiles(mdDir, CSDNInfo)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/08/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-08 00:33:48 / 修改时间：12:47:55" itemprop="dateCreated datePublished" datetime="2025-02-08T00:33:48+08:00">2025-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>367</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/27/RANSAC%E7%AE%97%E6%B3%95%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/27/RANSAC%E7%AE%97%E6%B3%95%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">RANSAC算法的FPGA实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-27 12:18:23" itemprop="dateCreated datePublished" datetime="2024-05-27T12:18:23+08:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">一.算法原理</a></p>
<p><a href="about:blank#1.%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">1.参数变量</a></p>
<p><a href="about:blank#2.%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">2.算法流程</a></p>
<p><a href="about:blank#%3C1%3E%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">&lt;1&gt;随机读取数据</a></p>
<p><a href="about:blank#%3C2%3E%E6%8B%9F%E5%90%88%E6%A8%A1%E5%9E%8B">&lt;2&gt;拟合模型</a></p>
<p><a href="about:blank#%3C3%3E%E6%A3%80%E9%AA%8C%E6%A8%A1%E5%9E%8B">&lt;3&gt;检验模型</a></p>
<p><a href="about:blank#%3C4%3E%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86">&lt;4&gt;循环遍历</a></p>
<p><a href="about:blank#%E4%BA%8C.%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">二.设计思路</a></p>
<p><a href="about:blank#1.%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">1.设计目标</a></p>
<p><a href="about:blank#2.%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">2.模块设计</a></p>
<p><a href="about:blank#%3C1%3E%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%BA%A7%E7%94%9F%E6%A8%A1%E5%9D%97">&lt;1&gt;随机数产生模块</a></p>
<p><a href="about:blank#%3C2%3E%E6%9A%82%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8">&lt;2&gt;暂存寄存器</a></p>
<p><a href="about:blank#%3C3%3E%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97">&lt;3&gt;计算模块</a></p>
<p><a href="about:blank#%3C4%3E%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9D%97">&lt;4&gt;模型评估模块</a></p>
<p><a href="about:blank#%3C5%3E%E4%B8%BB%E4%BD%93%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BE%93%E5%87%BA%E6%A8%A1%E5%9D%97">&lt;5&gt;主体控制与输出模块</a></p>
<p><a href="about:blank#%3C6%3E%E6%95%B4%E5%90%88">&lt;6&gt;整合</a></p>
<p><a href="about:blank#%E4%B8%89.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">三.具体实现</a></p>
<p><a href="about:blank#1.Python%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97">1.Python数据生成模块</a></p>
<p><a href="about:blank#2.Verilog%20RANSAC%E7%AE%97%E6%B3%95%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">2.Verilog<br>RANSAC算法仿真结果</a></p>
<p><a href="about:blank#%E5%9B%9B.%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">四.性能分析</a></p>
<p><a href="about:blank#1.%E8%B5%84%E6%BA%90%E5%88%86%E6%9E%90">1.资源分析</a></p>
<p><a href="about:blank#2.%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90">2.速度分析</a></p>
<p><a href="about:blank#3.%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%A7%8D%E5%AD%90%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C">3.选择不同随机数种子下的结果</a></p>
<p><a href="about:blank#4.%E4%B8%8D%E5%90%8C%E9%A2%84%E8%AE%BE%E7%9B%B4%E7%BA%BF%E5%8F%82%E6%95%B0%E4%B8%8B%E7%9A%84%E6%8B%9F%E5%90%88%E7%BB%93%E6%9E%9C">4.不同预设直线参数下的拟合结果</a></p>
<p><a href="about:blank#%E4%BA%94.%E6%80%9D%E8%80%83%E4%B8%8E%E6%94%B9%E8%BF%9B">五.思考与改进</a></p>
<p><a href="about:blank#1.%E6%8F%90%E9%80%9F%E7%93%B6%E9%A2%88">1.提速瓶颈</a></p>
<p><a href="about:blank#2.%E5%A2%9E%E5%8A%A0%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%A6">2.增加并行程度</a></p>
<p><a href="about:blank#3.%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E6%94%B9%E8%BF%9B">3.算法流程改进</a></p>
<p><a href="about:blank#%E5%85%AD.%E9%99%84%E5%BD%95">六.附录</a></p>
<p><a href="about:blank#1.vivado%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86">1.vivado工程源码部分</a></p>
<p><a href="about:blank#%3C1%3E%E4%B8%BB%E4%BD%93%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86">&lt;1&gt;主体控制部分</a></p>
<p><a href="about:blank#%E4%B8%83.%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">七.参考文献</a></p>
<p><a href="about:blank#%E5%85%AB.%E8%AE%BE%E8%AE%A1%E6%94%B9%E8%BF%9B">八.设计改进</a></p>
<p><a href="about:blank#1.%E4%B8%8D%E5%8F%AF%E7%BB%BC%E5%90%88%E8%AF%AD%E5%8F%A5">1.不可综合语句</a></p>
<p><a href="about:blank#2.%E4%BF%AE%E6%AD%A3%E7%A8%8B%E5%BA%8F%E8%AF%AD%E5%8F%A5">2.修正程序语句</a></p>
<p><a href="about:blank#3.%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97">3.时钟模块</a></p>
<p><a href="about:blank#%E4%B9%9D.%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">九.设计实现分析</a></p>
<p><a href="about:blank#1.%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90">1.静态时序分析</a></p>
<p><a href="about:blank#%E5%8D%81.%E4%B8%8B%E8%BD%BD%E9%AA%8C%E8%AF%81">十.下载验证</a></p>
<hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Graduate2015/article/details/113133919" title="伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-
CSDN博客">伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-<br>CSDN博客</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xijuezhu8128/article/details/122930455" title="RANSAC算法(附RANSAC直线拟合C++与Python版本)-CSDN博客">RANSAC算法(附RANSAC直线拟合C++与Python版本)-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoucoolqi/article/details/105497572?spm=1001.2014.3001.5506" title="RANSAC算法——看完保证你理解-CSDN博客">RANSAC算法——看完保证你理解-<br>CSDN博客</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Graduate2015/article/details/113133919" title="伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-CSDN博客">伪随机序列：LFSR Sequence、m-Sequence和Gold Code&#x2F;Sequence-<br>CSDN博客</a></p>
<h2 id="一-算法原理"><a href="#一-算法原理" class="headerlink" title="一.算法原理"></a>一.算法原理</h2><h3 id="1-参数变量"><a href="#1-参数变量" class="headerlink" title="1.参数变量"></a>1.参数变量</h3><p>输入：数据集data、拟合模型model</p>
<p>中间参数：一次拟合需要的数据量n；算法最大遍历次数k；计算匹配阈值t；最小匹配数据数d</p>
<p>输出：完成信号done、最匹配的模型model参数</p>
<p>模型：二元一次线性模型，二元多次非线性模型，任意函数…</p>
<h3 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2.算法流程"></a>2.算法流程</h3><h4 id="随机读取数据"><a href="#随机读取数据" class="headerlink" title="&lt;1&gt;随机读取数据"></a>&lt;1&gt;随机读取数据</h4><p>随机数生成模块生成n个随机地址，取出存储器对应地址数据。</p>
<h4 id="拟合模型"><a href="#拟合模型" class="headerlink" title="&lt;2&gt;拟合模型"></a>&lt;2&gt;拟合模型</h4><p>由读出的n个数据拟合出相应模型</p>
<h4 id="检验模型"><a href="#检验模型" class="headerlink" title="&lt;3&gt;检验模型"></a>&lt;3&gt;检验模型</h4><p>检验存储器中所有数据对于该模型的拟合程度</p>
<h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="&lt;4&gt;循环遍历"></a>&lt;4&gt;循环遍历</h4><p>每次循环评价随机拟合的模型，当遍历k次后结束拟合，得到最佳模型</p>
<h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二.设计思路"></a>二.设计思路</h2><h3 id="1-设计目标"><a href="#1-设计目标" class="headerlink" title="1.设计目标"></a>1.设计目标</h3><pre><code>    工程能够完成一组坐标点集的线性拟合。输入坐标数据（x,y）的值为8bit 无符号整数数据类型，输出拟合直线参数，包括斜率k和y轴截距b，为8bit 有符号整数。
</code></pre>
<h3 id="2-模块设计"><a href="#2-模块设计" class="headerlink" title="2.模块设计"></a>2.模块设计</h3><h4 id="随机数产生模块"><a href="#随机数产生模块" class="headerlink" title="&lt;1&gt;随机数产生模块"></a>&lt;1&gt;随机数产生模块</h4><pre><code>    利用线性反馈移位寄存器（Linear Feedback Shift Register，LFSR）产生随机数，对于反馈移位寄存器和异或门构成的电路，可以按下面的关系式生成序列[1]：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a2ef04e43713d49cbd2d77c4b3b13d13.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1a40e9fb00f3d512134c9efbe023418.png"></p>
<pre><code>    对于m位的线性反馈移位寄存器，最多可以产生2^m-1个不同状态。如果一个序列发生器正好生产这 2^m-1个不同状态之后才重复此序列。随机数产生器的初始队列成为种子（seed），随后队列对种子进行移位运算生成新队列。

    工程中采用32位随机数产生模块，每次取前14位分别作为两随机点的地址（128个数据对应7位地址）。
</code></pre>
<h4 id="暂存寄存器"><a href="#暂存寄存器" class="headerlink" title="&lt;2&gt;暂存寄存器"></a>&lt;2&gt;暂存寄存器</h4><pre><code>    通过rom读取文件内数据信息，存入相关数据。Rom深度为128，对应7位地址线，宽度为16位数据前8位为x，后8位为y。采用组合逻辑电路直接输出对应地址数据。
</code></pre>
<h4 id="计算模块"><a href="#计算模块" class="headerlink" title="&lt;3&gt;计算模块"></a>&lt;3&gt;计算模块</h4><pre><code>    通过所给数据拟合出模型。输入为32位数据，前16位和后16位分别是(x1,y1)和(x2,y2)。实现的组合电路结构如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c14f200db8d3e933e48fbe49a193f1fc.png"></p>
<p>K&#x3D;(y2-y1)&#x2F;(x2-x1)    b&#x3D;y2-k*x2</p>
<h4 id="模型评估模块"><a href="#模型评估模块" class="headerlink" title="&lt;4&gt;模型评估模块"></a>&lt;4&gt;模型评估模块</h4><pre><code>    给定参数T_RANGE，表示允许残差平方RSS的最大值（RSS=(y-k*x-b)^2，表示期望值与实际值只差的平方），当RSS&lt;T_RANGE时，表示该点在允许范围之内。Fit信号输出为1。实现的组合电路结构如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fab333897437b774df5bb4bc2a42adc5.png"></p>
<h4 id="主体控制与输出模块"><a href="#主体控制与输出模块" class="headerlink" title="&lt;5&gt;主体控制与输出模块"></a>&lt;5&gt;主体控制与输出模块</h4><pre><code>    用于控制迭代次数K，以及产生随机数产生模块时钟和rom地址更新。每次迭代重新生成随机数以产生新模型。遍历rom检验后比较最大线内点数fit_num，如果大于最大值则更新模型参数
</code></pre>
<h4 id="整合"><a href="#整合" class="headerlink" title="&lt;6&gt;整合"></a>&lt;6&gt;整合</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7d6b9180c527cfd5d39786f27076598b.png"></p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>ADDR_WIDTH</th>
<th>DATA_WIDTH</th>
<th>INPUTDATA_WIDTH</th>
<th>PARA_WIDTH</th>
<th>T_WIDTH</th>
</tr>
</thead>
<tbody><tr>
<td>WIDTH&#x2F;BITS</td>
<td>7</td>
<td>16</td>
<td>32</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>DETAILS</td>
<td></td>
<td>x(h_8b)</td>
<td>y(l_8b)</td>
<td>x1(h_8b)</td>
<td>y1(l_8b)</td>
</tr>
</tbody></table>
<h2 id="三-具体实现"><a href="#三-具体实现" class="headerlink" title="三.具体实现"></a>三.具体实现</h2><h3 id="1-Python数据生成模块"><a href="#1-Python数据生成模块" class="headerlink" title="1.Python数据生成模块"></a>1.Python数据生成模块</h3><pre><code>    使用python编写代码生成十六进制数据集，包含线内点和噪声点，并给出python实现ransac和最小二乘法的拟合结果。如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f8b333fec06e0a78982e2978f077efd7.png"></p>
<pre><code>    设定直线的参数：斜率k=2，截距b=25，最小二乘法和ransac拟合参数结果如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/aa641fc13e378827a3ed2d7763b60aab.png"></p>
<pre><code>    其中红色线是最小二乘法的拟合结果，绿色线是ransac在迭代1000次，允许误差为5的拟合结果。

    将产生数据以16进制形式保存，并存储于data.mem文件中在vivado中读取。
</code></pre>
<h3 id="2-Verilog-RANSAC算法仿真结果"><a href="#2-Verilog-RANSAC算法仿真结果" class="headerlink" title="2.Verilog RANSAC算法仿真结果"></a>2.Verilog RANSAC算法仿真结果</h3><pre><code>    工程拟合结果直线参数为：斜率k=2(0x02),b=24(0x18)，完全符合设定值。符合误差范围的点数最多为47个（0x2F），并在第450代（0x01C2）时随机产生的地址拟合出了最佳参数。此时的残差平方和RSS为2086（0x826）。

    由于拟合和评估部分皆为组合逻辑电路，算法完成的速度取决于迭代次数K和时钟频率CLK_FRE。仿真采用100MHZ时钟，K取1000次，每次迭代遍历128个点需要128个时钟周期，故算法每次执行需要：128*K/CLK_FRE秒。本次仿真算法在0.00128s（128*1k/1M）左右结束，done信号置高电平有效，故算法频率为781.25HZ。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/face361f9b63a0ff29ebaa18ae4d4d2f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f39ebf2287ecd3f78f9f303dcd7d844.png"></p>
<h2 id="四-性能分析"><a href="#四-性能分析" class="headerlink" title="四.性能分析"></a>四.性能分析</h2><h3 id="1-资源分析"><a href="#1-资源分析" class="headerlink" title="1.资源分析"></a>1.资源分析</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2b5db5cfbb3689bbf2b38712717330ee.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/332a59e94e620fbd13c87aa0a98f3baa.png"></p>
<pre><code>    设计使用到的查找表、IO、缓存器等资源均较少，满足设计的资源限制。
</code></pre>
<h3 id="2-速度分析"><a href="#2-速度分析" class="headerlink" title="2.速度分析"></a>2.速度分析</h3><pre><code>    下表给出不同迭代次数和时钟频率下的算法频率F=CLK_FRE/(128*K)：
</code></pre>
<h2 id="F-CLK-FRE-128-K"><a href="#F-CLK-FRE-128-K" class="headerlink" title="F&#x3D;CLK_FRE&#x2F;(128*K)  "></a>F&#x3D;CLK_FRE&#x2F;(128*K)  </h2><p>CLK_FRE(&#x2F;M) |  K |  frequency(&#x2F;Hz)<br>100 |  1000 |  781.25<br>100 |  10000 |  78.125<br>100 |  500 |  1562.5<br>80 |  1000 |  625<br>15 |  1000 |  117.1875  </p>
<h3 id="3-选择不同随机数种子下的结果"><a href="#3-选择不同随机数种子下的结果" class="headerlink" title="3.选择不同随机数种子下的结果"></a>3.选择不同随机数种子下的结果</h3><pre><code>    在迭代次数k=1000次下，不同随机数种子下最终结果出现的时机（其中k是代数，para是拟合参数）：
</code></pre>
<table>
<thead>
<tr>
<th>seed</th>
<th>0x12345678</th>
<th>0xFFFFFFFF</th>
<th>0x11111111</th>
<th>0xcd62f912</th>
<th>0x63e8c090</th>
</tr>
</thead>
<tbody><tr>
<td>K</td>
<td>450</td>
<td>403</td>
<td>13</td>
<td>524</td>
<td>360</td>
</tr>
<tr>
<td>PARA</td>
<td>0x0218</td>
<td>0x0218</td>
<td>0x0218</td>
<td>0x0218</td>
<td>0x0218</td>
</tr>
</tbody></table>
<h3 id="4-不同预设直线参数下的拟合结果"><a href="#4-不同预设直线参数下的拟合结果" class="headerlink" title="4.不同预设直线参数下的拟合结果"></a>4.不同预设直线参数下的拟合结果</h3><pre><code>    在seed=0x12345678下，不同预设直线参数下的拟合结果如下，其中k，b为设定值，ransac_k、ransac_b为拟合值，fit_num为检测为线内的点数（实际为128）：
</code></pre>
<table>
<thead>
<tr>
<th>k</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>2.5</th>
</tr>
</thead>
<tbody><tr>
<td>ransac_k</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>b</td>
<td>25</td>
<td>10</td>
<td>77</td>
<td>16</td>
</tr>
<tr>
<td>ransac_b</td>
<td>24</td>
<td>11</td>
<td>51</td>
<td>41</td>
</tr>
<tr>
<td>fit_num</td>
<td>47</td>
<td>64</td>
<td>25</td>
<td>39</td>
</tr>
</tbody></table>
<h2 id="五-思考与改进"><a href="#五-思考与改进" class="headerlink" title="五.思考与改进"></a>五.思考与改进</h2><h3 id="1-提速瓶颈"><a href="#1-提速瓶颈" class="headerlink" title="1.提速瓶颈"></a>1.提速瓶颈</h3><pre><code>    在算法的实现流程中，计算和评估模块均采用组合逻辑电路，而 控制部分电路采用循环遍历的方式，依次选取rom中数据对模型进行检验，大大降低了算法的速度。
</code></pre>
<h3 id="2-增加并行程度"><a href="#2-增加并行程度" class="headerlink" title="2.增加并行程度"></a>2.增加并行程度</h3><pre><code>    在检验阶段，设计一寄存器组，提前将rom中所有数据存储至寄存器组后并行输出，连接至同等数量的evaluate_kernel模块同时进行检验。实现由之前的循环遍历校验转化为同时并行检验：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb02859e4670ee07014b6af6ab546d75.png"></p>
<h3 id="3-算法流程改进"><a href="#3-算法流程改进" class="headerlink" title="3.算法流程改进"></a>3.算法流程改进</h3><p>&lt;1&gt;工程中模型的拟合采用直接随机选取n个数据进行拟合的方法，进而确定线内点。可以改进为最后增加一个步骤，由已经确定的线内点重新使用最小二乘法拟合参数，减小拟合参数的残差平方和RSS。</p>
<p>&lt;2&gt;线内点的确定可改进为投票式，即由k个模型共同投票符合要求的片内点，选取票数最高的点作为真正的片内点[2]。</p>
<h2 id="六-附录"><a href="#六-附录" class="headerlink" title="六.附录"></a>六.附录</h2><h3 id="1-vivado工程源码部分"><a href="#1-vivado工程源码部分" class="headerlink" title="1.vivado工程源码部分"></a>1.vivado工程源码部分</h3><h4 id="主体控制部分"><a href="#主体控制部分" class="headerlink" title="&lt;1&gt;主体控制部分"></a>&lt;1&gt;主体控制部分</h4><pre><code>`timescale 1ns / 1ps
//
// Engineer: switch_swq
// Create Date: 2024/05/20 10:48:12
//
module evaluate
#(
    parameter ADDR_WIDTH = 7,
    parameter DATA_WIDTH = 16,
    parameter INPUTDATA_WIDTH = 32,
    parameter PARA_WIDTH = 16,  
    parameter T_WIDTH = 18,  
    parameter T_RANGE = 10,
    parameter K_RANGE = 1000,
    parameter DATA_FILE = &quot;data.mem&quot;
)
(
    input wire clk_in,
    input wire rst_in,
    output reg done,
    //output reg [PARA_WIDTH-1:0]best_para
    output wire [5:0]sel, 
    output wire [7:0]seg          
);

wire clk,rst;
wire [31:0]random_num;
wire [PARA_WIDTH-1:0] para;
wire [DATA_WIDTH-1:0] data;
wire [INPUTDATA_WIDTH-1:0]input_data;
wire fit;
wire [T_WIDTH-1:0]RSS;
reg random_clk;
reg [ADDR_WIDTH-1:0] addr,fit_count,fit_max;
reg [T_WIDTH-1:0]rss_num,rss_min;
reg [15:0]k_num;
reg [PARA_WIDTH-1:0]best_para;
wire [23:0]output_data;
wire [5:0]point;

assign rst=~rst_in;

always@(posedge clk or posedge rst)
if(rst==1&#39;b1)
    addr&lt;=1&#39;b0;
else
    addr&lt;=addr+1;
    
always@(posedge clk or posedge rst)
if(rst==1&#39;b1)
    k_num&lt;=1&#39;b0;
else if(k_num&lt;=K_RANGE &amp;&amp; addr==1&#39;b0)
    k_num&lt;=k_num+1;
    
always@(posedge clk or posedge rst)
if(rst==1&#39;b1)
    random_clk&lt;=1&#39;b0;
else if(k_num&lt;=K_RANGE &amp;&amp; addr==1&#39;b0)
    random_clk&lt;=1&#39;b1;
else 
    random_clk&lt;=1&#39;b0;
   
always@(posedge clk or posedge rst)
if(rst==1&#39;b1)
    done&lt;=1&#39;b0;
else if(k_num&gt;K_RANGE)
    done&lt;=1&#39;b1;
else 
    done&lt;=1&#39;b0;

always@(posedge clk or posedge rst)
begin
    if(rst==1&#39;b1)begin
        rss_num&lt;=&#39;b0;
        fit_count&lt;=&#39;b0;
        fit_max&lt;=&#39;b0;        
        
        best_para&lt;=&#39;b0;
     end
     else if(k_num&lt;=K_RANGE)begin   
        if(fit==1&#39;b1)begin
            fit_count&lt;=fit_count+1;
            rss_num&lt;=rss_num+RSS;
        end     
        
        if(addr==1&#39;b0)begin
            if(fit_count&gt;fit_max)begin
                best_para&lt;=para;
                fit_max&lt;=fit_count;
                rss_min&lt;=rss_num;
            end
            rss_num&lt;=&#39;b0;
            fit_count&lt;=1&#39;b0;
        end
    end
end

assign output_data=&#123;8&#39;b0,best_para&#125;;
assign point=6&#39;b0;

clk_wiz_0 clk_wiz_0_inst
   (
    // Clock out ports
    .clk_out1(clk),     // output clk_out1
   // Clock in ports
    .clk_in1(clk_in)      // input clk_in1
);

blk_mem_gen_0 blk_mem_gen_0_inst1 (
  .clka(clk),    // input wire clka
  .addra(addr),  // input wire [6 : 0] addra
  .douta(data)  // output wire [15 : 0] douta
);

blk_mem_gen_0 blk_mem_gen_0_inst2 (
  .clka(clk),    // input wire clka
  .addra(random_num[6:0]),  // input wire [6 : 0] addra
  .douta(input_data[INPUTDATA_WIDTH-1:INPUTDATA_WIDTH/2])  // output wire [15 : 0] douta
);

blk_mem_gen_0 blk_mem_gen_0_inst3 (
  .clka(clk),    // input wire clka
  .addra(random_num[13:7]),  // input wire [6 : 0] addra
  .douta(input_data[INPUTDATA_WIDTH/2-1:0])  // output wire [15 : 0] douta
);

evaluate__kernel
#(
    .DATA_WIDTH(DATA_WIDTH),
    .PARA_WIDTH(PARA_WIDTH),
    .T_WIDTH   (T_WIDTH   ),
    .T_RANGE   (T_RANGE   ) 
)
evaluate__kernel_inst
(
    .data(data),
    .para(para),
    .RSS(RSS),
    .fit(fit)
);

calculate_kernel
#(
    .INPUTDATA_WIDTH(INPUTDATA_WIDTH),
    .PARA_WIDTH(PARA_WIDTH)
)
calculate_kernel_inst
(
    .input_data(input_data),
    .para(para)
);

random_num random_num_inst
(
    .clk   (random_clk)  ,
    .rst   (rst   )  ,
    .data  (random_num)
);

seg_dynamic seg_dynamic_inst
(
    .sys_clk  (clk      )   ,
    .sys_rst_n(rst      )   ,
    .data     (output_data)   , 
    .point    (point),
    .sel      (sel      )   ,
    .seg      (seg      )    
);

endmodule
</code></pre>
<h2 id="七-参考文献"><a href="#七-参考文献" class="headerlink" title="七.参考文献"></a>七.参考文献</h2><p>[1]束礼宝,宋克柱,王砚方.伪随机数发生器的FPGA实现与研究[J].电路与系统学报,2003(03):121-124.</p>
<p>[2]江洁,凌思睿.一种投票式并行RANSAC算法及其FPGA实现[J].电子与信息学报,2014,36(05):1145-1150.</p>
<h2 id="八-设计改进"><a href="#八-设计改进" class="headerlink" title="八.设计改进"></a>八.设计改进</h2><h3 id="1-不可综合语句"><a href="#1-不可综合语句" class="headerlink" title="1.不可综合语句"></a>1.不可综合语句</h3><pre><code>    原代码中夹杂着不可综合语句，如rom中的initial语句。现将数据存储器使用xilinx block memory generator ip核替换原本不可综合的rom模块。
</code></pre>
<h3 id="2-修正程序语句"><a href="#2-修正程序语句" class="headerlink" title="2.修正程序语句"></a>2.修正程序语句</h3><p>（1）原程序出现阻塞赋值和非阻塞赋值语句混用情况，现对evaluate、evaluate_kernel、calculate_kernel相关语句进行了修正。（说明：控制模块evaluate和随机数生成模块random_num采用时序逻辑，计算和评估模块_kernel仍使用组合逻辑）</p>
<p>（2）原程序的控制模块evaluate中语句较为混乱，现依据信号划分语句，使结构更为清晰。</p>
<h3 id="3-时钟模块"><a href="#3-时钟模块" class="headerlink" title="3.时钟模块"></a>3.时钟模块</h3><pre><code>    添加xilinx clocking wizard ip核代替原硬件时钟直连，方便后续进行时序分析和调试。
</code></pre>
<h2 id="九-设计实现分析"><a href="#九-设计实现分析" class="headerlink" title="九.设计实现分析"></a>九.设计实现分析</h2><h3 id="1-静态时序分析"><a href="#1-静态时序分析" class="headerlink" title="1.静态时序分析"></a>1.静态时序分析</h3><pre><code>    在vivado设计实现中，观察“Timing Summary”内的时钟域内路径“intra-clock paths”以确定时钟频率。可以看到路径上的时序要求“requirement”为30.303ns，数据信号在时钟周期内稳定下来的最长时间在path1上，如下图：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8479c74fa867c5f9ca2329e5ac82e282.png"></p>
<pre><code>    该路径是从存储器blk_mem_gen0至寄存器fit_count_reg，即对应从随机从存储器中取数至模型遍历评估一个数结束。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/462f462ef19b1e592eaa28041ca7d0d8.png"></p>
<pre><code>    按照信号稳定的最长时间为30.303ns，计算出的最大频率约为33.00MHz。在时钟约束中设置时钟的输出频率为33MHz，implement后的结果如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/91c5ac678cde8f1b0bf32fa7ae06f688.png"></p>
<pre><code>    可以看到系统的最差负时序裕量“WNS”和最差保持时序裕量“WHS”均为正；总的负时序裕量“TNS”和保持时序裕量“THS”为零，即所有的时序路径都能满足这些要求。
</code></pre>
<h2 id="十-下载验证"><a href="#十-下载验证" class="headerlink" title="十.下载验证"></a>十.下载验证</h2><pre><code>    在工程中添加数码管显示模块，并生成比特流对工程进行下载验证。使用开发板芯片型号为xc7a35tfgg484-2，资源使用情况如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32d8e202d68c50edda80d9e40a9f5d36.png"></p>
<pre><code>    实际运行情况如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd0a71b7d0b73f5101eb227302152b34.png"></p>
<h2 id="十一-后续改进"><a href="#十一-后续改进" class="headerlink" title="十一.后续改进"></a>十一.后续改进</h2><h3 id="1-时序电路设计"><a href="#1-时序电路设计" class="headerlink" title="1.时序电路设计"></a>1.时序电路设计</h3><pre><code>    将模型拟合模块和评估模块（calculate_kernel和evaluate__kernel模块）由组合逻辑改为时序逻辑，减小了信号传递的长度，从而减少线路上信号稳定所需要的时间。
</code></pre>
<h3 id="2-流水线改进"><a href="#2-流水线改进" class="headerlink" title="2.流水线改进"></a>2.流水线改进</h3><pre><code>    在拟合和评估模块将相关计算步骤分解成流水线。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/direct/7cc6346feffd47fbb37c328f1ba6f213.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/b4d02ced10924951b3a607efb1514515.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1d33919743cf4a19a82137d91e857368.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/c561475921714635b0cce41ba03c8ab0.png"></p>
<h3 id="3-数值精度提升"><a href="#3-数值精度提升" class="headerlink" title="3.数值精度提升"></a>3.数值精度提升</h3><pre><code>    提升线路宽度从原来8位提高到16位，并使用定点小数表示数值。高8位为整数部分，低8位为小数部分。
</code></pre>
<h3 id="4-算法结构改进"><a href="#4-算法结构改进" class="headerlink" title="4.算法结构改进"></a>4.算法结构改进</h3><pre><code>    将评估模块由原先循环取数评估改为并行评估（evaluate_parralle模块），将评估所需时钟周期数由128变为1，以适配流水线周期长度。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/direct/4fda9ff18bf140c6a740e791e136710a.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/d00fb992865d4c92bf86772ec2471575.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/7a1311448ae04201b9232d675c8a8c9a.png"></p>
<h3 id="5-改进后性能"><a href="#5-改进后性能" class="headerlink" title="5.改进后性能"></a>5.改进后性能</h3><pre><code>    最高时钟频率约72.4MHz（最长路径时间为12.002ns）
</code></pre>
<h3 id="6-现存问题"><a href="#6-现存问题" class="headerlink" title="6.现存问题"></a>6.现存问题</h3><p>&lt;1&gt;评估模块（evaluate_parralle模块）以空间换速度，占用资源较多</p>
<p>&lt;2&gt;使用vivado提供的除法运算“&#x2F;”所综合的器件导致该路径用时（logic delay）过长，成为时钟频率无法提升的主要问题，需进行改进。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/c3fd17c5f6ca4efabdd1acaaab26491f.png"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/5c821beb009e40e3b2ad1ac4a359fe48.png"></p>
<pre><code>    另一方面系统布线时延（net delay）也较长，表现在参数计算模块calculate_kernel的b_reg到并行评估模块kxb_reg上，仍在探索优化方法。
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/139198487">https://blog.csdn.net/qq_32971095/article/details/139198487</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/23/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/23/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/" class="post-title-link" itemprop="url">西电计科大三下SOC微体系结构设计实验合集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 11:46:02" itemprop="dateCreated datePublished" datetime="2024-05-23T11:46:02+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>174k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:38</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%BA%8C.%E7%BA%BF%E4%B8%8B%E5%AE%9E%E9%AA%8C">二.线下实验</a></p>
<p><a href="about:blank#%E7%AE%A1%E8%84%9A%E7%BB%91%E5%AE%9A%E6%A8%A1%E7%89%88">管脚绑定模版</a></p>
<p><a href="about:blank#%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97%E6%A8%A1%E7%89%88">通用模块模版</a></p>
<p><a href="about:blank#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></p>
<p><a href="about:blank#1.%E8%B7%91%E9%A9%AC%E7%81%AF%E6%8E%A7%E5%88%B6%E8%AE%BE%E8%AE%A1">1.跑马灯控制设计</a></p>
<p><a href="about:blank#2.8%20%E4%BD%8D%E5%B9%B6%E8%A1%8C%E5%85%A8%E5%8A%A0%E5%99%A8%E8%AE%BE%E8%AE%A1%2B%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">2.8<br>位并行全加器设计+数码管显示程序设计</a></p>
<p><a href="about:blank#3.%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1">3.阵列乘法器设计</a></p>
<p><a href="about:blank#4.%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%20FIFO%20%E7%9A%84%E8%AE%BE%E8%AE%A1">4.先进先出 FIFO<br>的设计</a></p>
<p><a href="about:blank#5.PC%20%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AE%BE%E8%AE%A1">5.PC<br>程序计数器设计</a></p>
<p><a href="about:blank#6.%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%20ROM%20%E8%AE%BE%E8%AE%A1">6.程序存储器 ROM<br>设计</a></p>
<p><a href="about:blank#7.%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E9%99%A4%E6%B3%95%E5%99%A8">7.加减交替除法器</a></p>
<p><a href="about:blank#8.%E6%8C%87%E4%BB%A4%E5%AD%98%E5%82%A8%E5%99%A8%20IR%20%E8%AE%BE%E8%AE%A1">8.指令存储器 IR<br>设计</a></p>
<p><a href="about:blank#9.%E5%AF%84%E5%AD%98%E5%99%A8%20RN%20%E8%AE%BE%E8%AE%A1">9.寄存器 RN<br>设计</a></p>
<p><a href="about:blank#10.ALU%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1">10.ALU算术逻辑单元设计</a></p>
<p><a href="about:blank#11.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%99%A8%20RAM%20%E8%AE%BE%E8%AE%A1">11.数据存储器 RAM<br>设计</a></p>
<p><a href="about:blank#12.%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%20SP%20%E8%AE%BE%E8%AE%A1">12.堆栈指针 SP<br>设计</a></p>
<p><a href="about:blank#13.%E9%87%87%E7%94%A8%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%20IO%20%E6%A8%A1%E5%9D%97">13.采用硬件描述语言语言设计 IO<br>模块</a></p>
<p><a href="about:blank#14.%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1">14.微控制器设计</a></p>
<p><a href="about:blank#15.8%20%E4%BD%8D%20SOC%20%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1">15.8 位 SOC<br>综合设计</a></p>
<p><a href="about:blank#1.%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">1.实验结果分析</a></p>
<p><a href="about:blank#%3C1%3E%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90">&lt;1&gt;模块工作顺序分析</a></p>
<p><a href="about:blank#%3C2%3E%E2%80%8B%E2%80%8B%E2%80%8B%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">&lt;2&gt;​​​指令执行过程分析</a></p>
<p><a href="about:blank#2.%E5%85%B6%E4%BB%96">2.其他</a></p>
<p><a href="about:blank#%3C1%3ESOC%E6%A8%A1%E5%9D%97%E9%9B%86%E6%88%90%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C">&lt;1&gt;SOC模块集成设计经验</a></p>
<p><a href="about:blank#%3C2%3E%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BSOC%E9%9B%86%E6%88%90%E5%85%B3%E9%94%AE">&lt;2&gt;SOC集成关键</a></p>
<hr>
<h2 id="二-线下实验"><a href="#二-线下实验" class="headerlink" title="二.线下实验"></a>二.线下实验</h2><h3 id="管脚绑定模版"><a href="#管脚绑定模版" class="headerlink" title="管脚绑定模版"></a>管脚绑定模版</h3><pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/18 13:02:24
#----------------------------------------------------------------------------------
#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]

#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;a_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;a_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;a_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;a_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;a_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;a_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;a_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;a_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;a_in[7]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;b_in[7]&#125;]
set_property PACKAGE_PIN B10        [get_ports &#123;b_in[0]&#125;]
set_property PACKAGE_PIN A10        [get_ports &#123;b_in[1]&#125;]
set_property PACKAGE_PIN B15        [get_ports &#123;b_in[2]&#125;]
set_property PACKAGE_PIN A15        [get_ports &#123;b_in[3]&#125;]
set_property PACKAGE_PIN A13        [get_ports &#123;b_in[4]&#125;]
set_property PACKAGE_PIN A12        [get_ports &#123;b_in[5]&#125;]
set_property PACKAGE_PIN D8         [get_ports &#123;b_in[6]&#125;]
set_property PACKAGE_PIN D9         [get_ports &#123;b_in[7]&#125;]

#SW16~23
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;c_in[7]&#125;]
set_property PACKAGE_PIN F8         [get_ports &#123;c_in[0]&#125;]
set_property PACKAGE_PIN F9         [get_ports &#123;c_in[1]&#125;]
set_property PACKAGE_PIN H11        [get_ports &#123;c_in[2]&#125;]
set_property PACKAGE_PIN H12        [get_ports &#123;c_in[3]&#125;]
set_property PACKAGE_PIN G14        [get_ports &#123;c_in[4]&#125;]
set_property PACKAGE_PIN J10        [get_ports &#123;c_in[5]&#125;]
set_property PACKAGE_PIN H14        [get_ports &#123;c_in[6]&#125;]
set_property PACKAGE_PIN J11        [get_ports &#123;c_in[7]&#125;]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports rst]
set_property IOSTANDARD LVCMOS18    [get_ports rst]
set_property PACKAGE_PIN J14        [get_ports key_in]
set_property IOSTANDARD LVCMOS18    [get_ports key_in]
set_property PACKAGE_PIN H9         [get_ports wr]
set_property IOSTANDARD LVCMOS18    [get_ports wr]
set_property PACKAGE_PIN H8         [get_ports rd]
set_property IOSTANDARD LVCMOS18    [get_ports rd]
set_property PACKAGE_PIN G10        [get_ports a]
set_property IOSTANDARD LVCMOS18    [get_ports a]
set_property PACKAGE_PIN G9         [get_ports b]
set_property IOSTANDARD LVCMOS18    [get_ports b]
set_property PACKAGE_PIN J13        [get_ports c]
set_property IOSTANDARD LVCMOS18    [get_ports c]
set_property PACKAGE_PIN H13        [get_ports d]
set_property IOSTANDARD LVCMOS18    [get_ports d]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]

#LED
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[6]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[7]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;data_out[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;data_out[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;data_out[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;data_out[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;data_out[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;data_out[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;data_out[6]&#125;]
set_property PACKAGE_PIN C19 			[get_ports &#123;data_out[7]&#125;]

#led15
set_property PACKAGE_PIN L20        [get_ports empty]
set_property IOSTANDARD LVCMOS33    [get_ports empty]
#led11
set_property PACKAGE_PIN J20        [get_ports full]
set_property IOSTANDARD LVCMOS33    [get_ports full]
</code></pre>
<h3 id="通用模块模版"><a href="#通用模块模版" class="headerlink" title="通用模块模版"></a>通用模块模版</h3><p>时钟分频：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity clk_div is
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end clk_div;

architecture Behavioral of clk_div is

begin

process(rst,clk_in)
variable count:integer:=0;
begin
    if(rst=&#39;1&#39;)then count:=0; 
    elsif(clk_in=&#39;1&#39;and clk_in&#39;event)then 
        count:=count+1;
        if(count&lt;=DIV_NUM/2)then
            clk_out&lt;=&#39;1&#39;;
        elsif(count&gt;DIV_NUM/2 and count&lt;DIV_NUM)then
            clk_out&lt;=&#39;0&#39;;
        elsif(count&gt;=DIV_NUM)then
            count:=0;
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>按键消抖：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity key_stroke is
    generic(CLK_FRE:integer:=100000000);
    Port (
        clk:in std_logic;
        reset:in std_logic;
        key_in:in std_logic;
        output:out std_logic           
    );
end key_stroke;

architecture Behavioral of key_stroke is

type states is(s0,s1,s2,s3);
signal state:states;

begin

process(reset,clk,key_in)
variable count_num:integer:=3*CLK_FRE/1000;--delay 3ms
variable count:integer:=0;
    begin
        if reset=&#39;0&#39;then
            state&lt;=s0;
            count:=0;
            output&lt;=&#39;0&#39;;
        elsif(clk=&#39;1&#39;and clk&#39;event)then
            case state is
                when s0=&gt;if(key_in=&#39;1&#39;)then count:=0;output&lt;=&#39;0&#39;;state&lt;=s1;end if;
                when s1=&gt;
                    count:=count+1;
                    if (count&gt;=count_num) then state&lt;=s2; end if;
                when s2=&gt;
                    if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s3;
                    --if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s0;--one clk cycle
                    elsif(key_in=&#39;0&#39;)then state&lt;=s0;
                    end if;
                when s3=&gt;if(key_in=&#39;0&#39;)then state&lt;=s0;end if;                                                                   
            end case;               
        end if;     
end process;

end Behavioral;
</code></pre>
<p> 数码管显示：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity seg_dis is
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );

end seg_dis;

architecture Behavioral of seg_dis is

signal data_in_line: std_logic_vector(3 downto 0);

type states is(s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15);
signal state,next_state:states;

begin   

process(rst,clk)
begin 
    if(rst=&#39;1&#39;)then state&lt;=s0;
    elsif(clk=&#39;1&#39;and clk&#39;event)then 
        state&lt;=next_state;
    end if;
end process;


process(state)
begin
    case state is
    when s0 =&gt;  seg_dig&lt;=not&quot;0000000000000001&quot;;   data_in_line&lt;=data_in_A(3 downto 0);   next_state&lt;=s1;
    when s1 =&gt;  seg_dig&lt;=not&quot;0000000000000010&quot;;   data_in_line&lt;=data_in_A(7 downto 4);   next_state&lt;=s2;
    when s2 =&gt;  seg_dig&lt;=not&quot;0000000000000100&quot;;   data_in_line&lt;=data_in_A(11 downto 8);  next_state&lt;=s3;
    when s3 =&gt;  seg_dig&lt;=not&quot;0000000000001000&quot;;   data_in_line&lt;=data_in_A(15 downto 12); next_state&lt;=s4;   
    when s4 =&gt;  seg_dig&lt;=not&quot;0000000000010000&quot;;   data_in_line&lt;=data_in_B(3 downto 0);   next_state&lt;=s5;
    when s5 =&gt;  seg_dig&lt;=not&quot;0000000000100000&quot;;   data_in_line&lt;=data_in_B(7 downto 4);   next_state&lt;=s6;
    when s6 =&gt;  seg_dig&lt;=not&quot;0000000001000000&quot;;   data_in_line&lt;=data_in_B(11 downto 8);  next_state&lt;=s7;
    when s7 =&gt;  seg_dig&lt;=not&quot;0000000010000000&quot;;   data_in_line&lt;=data_in_B(15 downto 12); next_state&lt;=s8;     
    when s8 =&gt;  seg_dig&lt;=not&quot;0000000100000000&quot;;   data_in_line&lt;=data_in_C(3 downto 0);   next_state&lt;=s9;
    when s9 =&gt;  seg_dig&lt;=not&quot;0000001000000000&quot;;   data_in_line&lt;=data_in_C(7 downto 4);   next_state&lt;=s10;
    when s10=&gt;  seg_dig&lt;=not&quot;0000010000000000&quot;;   data_in_line&lt;=data_in_C(11 downto 8);  next_state&lt;=s11;
    when s11=&gt;  seg_dig&lt;=not&quot;0000100000000000&quot;;   data_in_line&lt;=data_in_C(15 downto 12); next_state&lt;=s12;
    when s12=&gt;  seg_dig&lt;=not&quot;0001000000000000&quot;;   data_in_line&lt;=data_in_D(3 downto 0);   next_state&lt;=s13;
    when s13=&gt;  seg_dig&lt;=not&quot;0010000000000000&quot;;   data_in_line&lt;=data_in_D(7 downto 4);   next_state&lt;=s14;
    when s14=&gt;  seg_dig&lt;=not&quot;0100000000000000&quot;;   data_in_line&lt;=data_in_D(11 downto 8);  next_state&lt;=s15;
    when s15=&gt;  seg_dig&lt;=not&quot;1000000000000000&quot;;   data_in_line&lt;=data_in_D(15 downto 12); next_state&lt;=s0;
    when others=&gt;next_state&lt;=s0;
    end case;
end process;

process(data_in_line)
begin
    case data_in_line is
        when &quot;0000&quot;=&gt;seg_data&lt;=not&quot;00111111&quot;;
        when &quot;0001&quot;=&gt;seg_data&lt;=not&quot;00000110&quot;;
        when &quot;0010&quot;=&gt;seg_data&lt;=not&quot;01011011&quot;;
        when &quot;0011&quot;=&gt;seg_data&lt;=not&quot;01001111&quot;;
        when &quot;0100&quot;=&gt;seg_data&lt;=not&quot;01100110&quot;;
        when &quot;0101&quot;=&gt;seg_data&lt;=not&quot;01101101&quot;;
        when &quot;0110&quot;=&gt;seg_data&lt;=not&quot;01111101&quot;;
        when &quot;0111&quot;=&gt;seg_data&lt;=not&quot;00000111&quot;;
        when &quot;1000&quot;=&gt;seg_data&lt;=not&quot;01111111&quot;;
        when &quot;1001&quot;=&gt;seg_data&lt;=not&quot;01101111&quot;;
        when &quot;1010&quot;=&gt;seg_data&lt;=not&quot;01110111&quot;;
        when &quot;1011&quot;=&gt;seg_data&lt;=not&quot;01111100&quot;;
        when &quot;1100&quot;=&gt;seg_data&lt;=not&quot;00111001&quot;;
        when &quot;1101&quot;=&gt;seg_data&lt;=not&quot;01011110&quot;;
        when &quot;1110&quot;=&gt;seg_data&lt;=not&quot;01111001&quot;;
        when &quot;1111&quot;=&gt;seg_data&lt;=not&quot;01110001&quot;;
        when others=&gt;seg_data&lt;=not&quot;11111111&quot;;
    end case;
end process;

end Behavioral;
</code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p>1.器件型号：xc7k160tfbg676-2</p>
<p>2.输入一般cmos18 输出cmos33</p>
<p>3.输入数码管的时钟需分频</p>
<p>4.按键加消抖</p>
<p>5.程序的运行结合.xdc文件进行理解</p>
<h3 id="1-跑马灯控制设计"><a href="#1-跑马灯控制设计" class="headerlink" title="1.跑马灯控制设计"></a>1.跑马灯控制设计</h3><pre><code>    功能叙述：初始情况下 Y0=‘1’，其它为‘0’。然后，在 en 为高电平的情况下，在时钟信 号 clk 的下降沿进行移位。当 dir=‘1’时，每来一个时钟信号，循环左移一位，当 dir=‘0’时， 每来一个时钟，循环右移一位。 另外，移位控制时钟可以选择为按键，即每按键一次相当于一个时钟信号，系统可以在 按键和系统分频时钟之间进行选择。
</code></pre>
<p>资源使用：</p>
<p>1）用 LED0~LED7 作为跑马灯输出显示，LED7 为高位，LED0 为低位；</p>
<p>2）SW0 为循环方向控制；</p>
<p>3）SW1 为工作允许 EN 控制端；</p>
<p>4）计数时钟频率为 1Hz，通过对 50Mhz 系统时钟分频得到；</p>
<p>5）扩展：可以由按键来控制循环（按键为 BTN_SOUTH），即每按一次 BTN_SOUTH, 则完成一次移位。通过 SW2 选择移位控制时钟沿。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbc0bb7faf453566ef923063e4d002fb.png"></p>
<p>源文件：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity run_led is
    Port(
        en,dir,sel,clk,con:in std_logic;
        y:out std_logic_vector(7 downto 0)
    );
end run_led;

architecture Behavioral of run_led is
signal input:std_logic;
signal clk_div:std_logic;
begin

process(clk)
variable clk_cnt:integer:=0;
variable clk_cnt_2:integer:=0;
begin 
    if(clk=&#39;1&#39;and clk&#39;event)then 
        clk_cnt_2:=clk_cnt_2+1;
        if(clk_cnt_2&gt;=10000)then 
        clk_cnt:=clk_cnt+1;
        clk_cnt_2:=0;
        end if;
        if(clk_cnt&lt;5000)then clk_div&lt;=&#39;1&#39;;
        elsif(clk_cnt&gt;=5000)then clk_div&lt;=&#39;0&#39;;
        end if;
        if(clk_cnt&gt;=10000)then clk_cnt:=0;
        end if; 
    end if;
end process;

process(clk,en,clk_div,con,sel)
    begin
        if(en=&#39;1&#39;)then
            if(sel=&#39;0&#39;)then input&lt;=clk_div;
            elsif(sel=&#39;1&#39;)then input&lt;=con;
            end if;
        elsif(en=&#39;0&#39;)then input&lt;=&#39;0&#39;;
        end if;
end process;

process(input,dir)
variable count:integer:=0;
begin
if(input=&#39;1&#39;and input&#39;event)then 
    if(dir=&#39;1&#39;)then
        count:=count+1;
        if(count&gt;7)then count:=0;end if;
    elsif(dir=&#39;0&#39;)then 
        count:=count-1;
        if(count&lt;0)then count:=7;end if;
    end if;  
        
    if(count=0)then y&lt;=&quot;00000001&quot;;
    elsif(count=1)then y&lt;=&quot;00000010&quot;;
    elsif(count=2)then y&lt;=&quot;00000100&quot;;
    elsif(count=3)then y&lt;=&quot;00001000&quot;;
    elsif(count=4)then y&lt;=&quot;00010000&quot;;
    elsif(count=5)then y&lt;=&quot;00100000&quot;;
    elsif(count=6)then y&lt;=&quot;01000000&quot;;
    elsif(count=7)then y&lt;=&quot;10000000&quot;;
    else y&lt;=&quot;11111111&quot;;
    end if;
    
end if;       
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity run_led_tb is
end run_led_tb;

architecture Behavioral of run_led_tb is
component run_led
    Port(
        en,dir,sel,clk,con:in std_logic;
        y:out std_logic_vector(7 downto 0)
    );
end component;

SIGNAL en,dir,sel,clk,con: std_logic;
SIGNAL y: std_logic_vector(7 downto 0);

begin
run_led_inst:run_led port map(en=&gt;en,dir=&gt;dir,sel=&gt;sel,clk=&gt;clk,con=&gt;con,y=&gt;y); 

clock:process
begin 
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

key:process
begin 
    con&lt;=&#39;1&#39;;
    wait for 25ns;
    con&lt;=&#39;0&#39;;
    wait for 25ns;
end process;

test:process
begin
    en&lt;=&#39;0&#39;;
    sel&lt;=&#39;1&#39;;
    dir&lt;=&#39;1&#39;;
    wait for 25ns;
    en&lt;=&#39;1&#39;;
    wait;

end process;


end Behavioral;
</code></pre>
<p>xdc:</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/18 13:02:24
#----------------------------------------------------------------------------------
set_property PACKAGE_PIN C9 [get_ports dir]
set_property PACKAGE_PIN AF12 [get_ports con]
set_property PACKAGE_PIN B9 [get_ports en]
set_property PACKAGE_PIN E10 [get_ports clk]
set_property PACKAGE_PIN G11 [get_ports sel]
set_property PACKAGE_PIN G16 [get_ports &#123;y[0]&#125;]
set_property PACKAGE_PIN H16 [get_ports &#123;y[1]&#125;]
set_property PACKAGE_PIN D16 [get_ports &#123;y[2]&#125;]
set_property PACKAGE_PIN D15 [get_ports &#123;y[3]&#125;]
set_property PACKAGE_PIN C18 [get_ports &#123;y[4]&#125;]
set_property PACKAGE_PIN C17 [get_ports &#123;y[5]&#125;]
set_property PACKAGE_PIN B19 [get_ports &#123;y[6]&#125;]
set_property PACKAGE_PIN C19 [get_ports &#123;y[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[0]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;y[3]&#125;]

set_property DRIVE 12 [get_ports &#123;y[4]&#125;]
set_property DRIVE 12 [get_ports &#123;y[5]&#125;]
set_property DRIVE 12 [get_ports &#123;y[0]&#125;]
set_property DRIVE 12 [get_ports &#123;y[6]&#125;]
set_property DRIVE 12 [get_ports &#123;y[1]&#125;]
set_property DRIVE 12 [get_ports &#123;y[7]&#125;]
set_property DRIVE 12 [get_ports &#123;y[2]&#125;]
set_property DRIVE 12 [get_ports &#123;y[3]&#125;]

set_property IOSTANDARD LVCMOS18 [get_ports dir]
set_property IOSTANDARD LVCMOS18 [get_ports con]
set_property IOSTANDARD LVCMOS18 [get_ports en]
set_property IOSTANDARD LVCMOS18 [get_ports clk]
set_property IOSTANDARD LVCMOS18 [get_ports sel]
</code></pre>
<h3 id="2-8-位并行全加器设计-数码管显示程序设计"><a href="#2-8-位并行全加器设计-数码管显示程序设计" class="headerlink" title="2.8 位并行全加器设计+数码管显示程序设计"></a>2.8 位并行全加器设计+数码管显示程序设计</h3><p><strong>注：数码管部分未使用优化代码</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce6fd932b35130aa5e27c5aed20ea4d1.png"></p>
<pre><code>    其中 a_in，b_in：数据输入，使用板上开关（SW0~SW15）； sum_out：运算结果输出，使用 LED 显示运算结果。
</code></pre>
<p>（1）用硬件描述语言实现 16 个七段数码管扫描显示模块</p>
<pre><code>    七段数码管扫描显示模块电路如图所示，主要包括顶层的数码管扫描显示模块，以及输入数据向七段数码管进行译码的模块。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c7d8f4a915fe5bd8c1ead81f14b23a98.png"></p>
<pre><code>    该模块实现数码管扫描显示功能，扩展板上的 16 个数码管四个一组，分为 A，B，C，D 四组。模块管脚说明如下：clk 为系统的时钟输入，rst 信号为复位信号，data_in_A(15:0)为 A 组四个数码管的输入显示值，其中，data_in_A(3:0)对应于第一个数码管的输入显示值； data_in_A(7:4)对应第二个数码管的输入显示值；data_in_A(11:8）对应第三个数码管的输入显 示值；data_in_A(15:12)对应第四个数码管的输入显示值，其它各组与 A 组分配一致； data_in_B(15:0)为 B 组四个数码管的输入显示值；data_in_C(15:0)为 C 组四个数码管的输入显 示值；data_in_D(15:0)为 D 组四个数码管的输入显示值；seg_sel(3:0)为数码管选择编码输出 信号，seg_data(7:0)为数码管显示数据输出。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/80cc88d89b55bfa5281ac1e8bd0b69bc.png"></p>
<pre><code>    该模块实现将输入的 4 为二进制数转换为数码管显示的数据；其中，data_in(3:0)为输入 值，seg_data(7:0)为数码管编码的输出值。
</code></pre>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity adder is
    Port (
        clk,rst:in std_logic;
        a,b:in std_logic_vector(7 downto 0);
        c:in std_logic;
        
        c_out:out std_logic;
        sel_out:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
     );
end adder;

architecture Behavioral of adder is

component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        seg_sel:out std_logic_vector(3 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );
end component;
component decoder4_16
    Port (
        sel_in:in std_logic_vector(3 downto 0);
        sel_out:out std_logic_vector(15 downto 0)
     );
end component;

signal clk_out_line:std_logic;
signal sum_line:std_logic_vector(16 downto 0);
signal data_line:std_logic_vector(15 downto 0);
signal c_line:std_logic;
signal sel_out_line:std_logic_vector(3 downto 0);

begin

clk_div_inst:clk_div generic map(10000)port map(clk,clk_out_line);
seg_dis_inst:seg_dis port map(rst,clk_out_line,data_line,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,sel_out_line,seg_data);
decoder4_16_inst:decoder4_16 port map(sel_out_line,sel_out);

process(a,b,c)
begin  
    sum_line&lt;=(&quot;00000000&quot;&amp;a)+(&quot;00000000&quot;&amp;b)+(&quot;0000000000000000&quot;&amp;c);
    data_line&lt;=sum_line(15 downto 0);
    c_out&lt;=sum_line(16);
end process;
    

end Behavioral;
</code></pre>
<p>模块：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity decoder4_16 is
    Port (
        sel_in:in std_logic_vector(3 downto 0);
        sel_out:out std_logic_vector(15 downto 0)
     );
end decoder4_16;

architecture Behavioral of decoder4_16 is

begin

process(sel_in)
begin
    case sel_in is
    when &quot;0000&quot;=&gt;sel_out&lt;=not&quot;0000000000000001&quot;;
    when &quot;0001&quot;=&gt;sel_out&lt;=not&quot;0000000000000010&quot;;
    when &quot;0010&quot;=&gt;sel_out&lt;=not&quot;0000000000000100&quot;;
    when &quot;0011&quot;=&gt;sel_out&lt;=not&quot;0000000000001000&quot;;
    when &quot;0100&quot;=&gt;sel_out&lt;=not&quot;0000000000010000&quot;;
    when &quot;0101&quot;=&gt;sel_out&lt;=not&quot;0000000000100000&quot;;
    when &quot;0110&quot;=&gt;sel_out&lt;=not&quot;0000000001000000&quot;;
    when &quot;0111&quot;=&gt;sel_out&lt;=not&quot;0000000010000000&quot;;
    when &quot;1000&quot;=&gt;sel_out&lt;=not&quot;0000000100000000&quot;;
    when &quot;1001&quot;=&gt;sel_out&lt;=not&quot;0000001000000000&quot;;
    when &quot;1010&quot;=&gt;sel_out&lt;=not&quot;0000010000000000&quot;;
    when &quot;1011&quot;=&gt;sel_out&lt;=not&quot;0000100000000000&quot;;
    when &quot;1100&quot;=&gt;sel_out&lt;=not&quot;0001000000000000&quot;;
    when &quot;1101&quot;=&gt;sel_out&lt;=not&quot;0010000000000000&quot;;
    when &quot;1110&quot;=&gt;sel_out&lt;=not&quot;0100000000000000&quot;;
    when &quot;1111&quot;=&gt;sel_out&lt;=not&quot;1000000000000000&quot;;
    when others=&gt;sel_out&lt;=not&quot;1111111111111111&quot;;
    end case;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity seg_dis is
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        seg_sel:out std_logic_vector(3 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );

end seg_dis;

architecture Behavioral of seg_dis is
component data2seg
    port(
        data_in:in std_logic_vector(3 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );
end component;

signal data_in_line: std_logic_vector(3 downto 0);

type states is(s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15);
signal state,next_state:states;

begin   

data2seg_inst:data2seg port map(data_in_line,seg_data);

process(rst,clk)
begin 
    if(rst=&#39;1&#39;)then state&lt;=s0;
    elsif(clk=&#39;1&#39;and clk&#39;event)then
        state&lt;=next_state;
    end if;
end process;


process(state)
begin
    case state is
    when s0=&gt;
        seg_sel&lt;=&quot;0000&quot;;
        data_in_line&lt;=data_in_A(3 downto 0);
        next_state&lt;=s1;
    when s1=&gt;
        seg_sel&lt;=&quot;0001&quot;;
        data_in_line&lt;=data_in_A(7 downto 4);
        next_state&lt;=s2;
    when s2=&gt;
        seg_sel&lt;=&quot;0010&quot;;
        data_in_line&lt;=data_in_A(11 downto 8);
        next_state&lt;=s3;
    when s3=&gt;
        seg_sel&lt;=&quot;0011&quot;;
        data_in_line&lt;=data_in_A(15 downto 12);
        next_state&lt;=s4;
    
    when s4=&gt;seg_sel&lt;=&quot;0100&quot;;data_in_line&lt;=data_in_B(3 downto 0);next_state&lt;=s5;
    when s5=&gt;seg_sel&lt;=&quot;0101&quot;;data_in_line&lt;=data_in_B(7 downto 4);next_state&lt;=s6;
    when s6=&gt;seg_sel&lt;=&quot;0110&quot;;data_in_line&lt;=data_in_B(11 downto 8);next_state&lt;=s7;
    when s7=&gt;seg_sel&lt;=&quot;0111&quot;;data_in_line&lt;=data_in_B(15 downto 12);next_state&lt;=s8;
    
    when s8=&gt;seg_sel&lt;=&quot;1000&quot;;data_in_line&lt;=data_in_C(3 downto 0);next_state&lt;=s9;
    when s9=&gt;seg_sel&lt;=&quot;1001&quot;;data_in_line&lt;=data_in_C(7 downto 4);next_state&lt;=s10;
    when s10=&gt;seg_sel&lt;=&quot;1010&quot;;data_in_line&lt;=data_in_C(11 downto 8);next_state&lt;=s11;
    when s11=&gt;seg_sel&lt;=&quot;1011&quot;;data_in_line&lt;=data_in_C(15 downto 12);next_state&lt;=s12;
    
    when s12=&gt;seg_sel&lt;=&quot;1100&quot;;data_in_line&lt;=data_in_D(3 downto 0);next_state&lt;=s13;
    when s13=&gt;seg_sel&lt;=&quot;1101&quot;;data_in_line&lt;=data_in_D(7 downto 4);next_state&lt;=s14;
    when s14=&gt;seg_sel&lt;=&quot;1110&quot;;data_in_line&lt;=data_in_D(11 downto 8);next_state&lt;=s15;
    when s15=&gt;seg_sel&lt;=&quot;1111&quot;;data_in_line&lt;=data_in_D(15 downto 12);next_state&lt;=s0;
    
    when others=&gt;state&lt;=next_state;
    end case;
end process;

end Behavioral;


----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity data2seg is
    port(
        data_in:in std_logic_vector(3 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );

end data2seg;

architecture Behavioral of data2seg is
begin 
process(data_in)
begin
    case data_in is
        when &quot;0000&quot;=&gt;seg_data&lt;=not&quot;00111111&quot;;
        when &quot;0001&quot;=&gt;seg_data&lt;=not&quot;00000110&quot;;
        when &quot;0010&quot;=&gt;seg_data&lt;=not&quot;01011011&quot;;
        when &quot;0011&quot;=&gt;seg_data&lt;=not&quot;01001111&quot;;
        when &quot;0100&quot;=&gt;seg_data&lt;=not&quot;01100110&quot;;
        when &quot;0101&quot;=&gt;seg_data&lt;=not&quot;00110111&quot;;
        when &quot;0110&quot;=&gt;seg_data&lt;=not&quot;01111101&quot;;
        when &quot;0111&quot;=&gt;seg_data&lt;=not&quot;00000111&quot;;
        when &quot;1000&quot;=&gt;seg_data&lt;=not&quot;01111111&quot;;
        when &quot;1001&quot;=&gt;seg_data&lt;=not&quot;01101111&quot;;
        when &quot;1010&quot;=&gt;seg_data&lt;=not&quot;01110111&quot;;
        when &quot;1011&quot;=&gt;seg_data&lt;=not&quot;01111100&quot;;
        when &quot;1100&quot;=&gt;seg_data&lt;=not&quot;00111000&quot;;
        when &quot;1101&quot;=&gt;seg_data&lt;=not&quot;01011110&quot;;
        when &quot;1110&quot;=&gt;seg_data&lt;=not&quot;01111001&quot;;
        when &quot;1111&quot;=&gt;seg_data&lt;=not&quot;01110001&quot;;
        when others=&gt;seg_data&lt;=not&quot;11111111&quot;;
    end case;
        
end process;
end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity adder_tb is
--  Port ( );
end adder_tb;

architecture Behavioral of adder_tb is
component adder
    Port (
        clk,rst:in std_logic;
        a,b:in std_logic_vector(7 downto 0);
        c:in std_logic;
        c_out:out std_logic;
        sel_out:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
     );
end component;
signal clk,rst :std_logic;
signal a,b     :std_logic_vector(7 downto 0);
signal c       :std_logic;
signal c_out   : std_logic;
signal sel_out : std_logic_vector(15 downto 0);
signal seg_data: std_logic_vector(7 downto 0);

begin
adder_inst:adder port map(clk,rst,a,b,c,c_out,sel_out,seg_data);

clock:process
begin
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

restart:process
begin
    rst&lt;=&#39;1&#39;;
    wait for 25ns;
    rst&lt;=&#39;0&#39;;
    wait;
end process;

test:process
begin
    a&lt;=&quot;00100010&quot;;
    b&lt;=&quot;01000100&quot;;
    c&lt;=&#39;1&#39;;
    wait for 100ns;
    
    a&lt;=&quot;11111111&quot;;
    b&lt;=&quot;11111111&quot;;
    c&lt;=&#39;1&#39;;
    wait;
end process;

end Behavioral;
</code></pre>
<p>xdc：</p>
<pre><code>set_property PACKAGE_PIN E26 [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26 [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26 [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21 [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21 [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23 [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24 [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21 [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[0]&#125;]

set_property PACKAGE_PIN E10 [get_ports clk]
set_property PACKAGE_PIN C9 [get_ports &#123;a[0]&#125;]
set_property PACKAGE_PIN B9 [get_ports &#123;a[1]&#125;]
set_property PACKAGE_PIN G11 [get_ports &#123;a[2]&#125;]
set_property PACKAGE_PIN F10 [get_ports &#123;a[3]&#125;]
set_property PACKAGE_PIN D10 [get_ports &#123;a[4]&#125;]
set_property PACKAGE_PIN E11 [get_ports &#123;a[5]&#125;]
set_property PACKAGE_PIN D11 [get_ports &#123;a[6]&#125;]
set_property PACKAGE_PIN A14 [get_ports &#123;a[7]&#125;]

set_property PACKAGE_PIN B10 [get_ports &#123;b[0]&#125;]
set_property PACKAGE_PIN A10 [get_ports &#123;b[1]&#125;]
set_property PACKAGE_PIN B15 [get_ports &#123;b[2]&#125;]
set_property PACKAGE_PIN A15 [get_ports &#123;b[3]&#125;]
set_property PACKAGE_PIN A13 [get_ports &#123;b[4]&#125;]
set_property PACKAGE_PIN A12 [get_ports &#123;b[5]&#125;]
set_property PACKAGE_PIN D8 [get_ports &#123;b[6]&#125;]
set_property PACKAGE_PIN D9 [get_ports &#123;b[7]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b[7]&#125;]

set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a[7]&#125;]


set_property IOSTANDARD LVCMOS18 [get_ports clk]
set_property IOSTANDARD LVCMOS18 [get_ports rst]
set_property IOSTANDARD LVCMOS33 [get_ports c_out]
set_property IOSTANDARD LVCMOS18 [get_ports c]

set_property PACKAGE_PIN J14 [get_ports c]
set_property PACKAGE_PIN G16 [get_ports c_out]
set_property PACKAGE_PIN J8 [get_ports rst]

#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[0]&#125;]
#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[1]&#125;]
#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[2]&#125;]
#set_property IOSTANDARD LVCMOS18 [get_ports &#123;sel_in[3]&#125;]

#set_property PACKAGE_PIN F8 [get_ports &#123;sel_in[0]&#125;]
#set_property PACKAGE_PIN F9 [get_ports &#123;sel_in[1]&#125;]
#set_property PACKAGE_PIN H11 [get_ports &#123;sel_in[2]&#125;]
#set_property PACKAGE_PIN H12 [get_ports &#123;sel_in[3]&#125;]

set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[10]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[15]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[12]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[0]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[13]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[8]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[11]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[14]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[3]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;sel_out[9]&#125;]
set_property PACKAGE_PIN A23 [get_ports &#123;sel_out[15]&#125;]
set_property PACKAGE_PIN A24 [get_ports &#123;sel_out[14]&#125;]
set_property PACKAGE_PIN D26 [get_ports &#123;sel_out[13]&#125;]
set_property PACKAGE_PIN C26 [get_ports &#123;sel_out[12]&#125;]
set_property PACKAGE_PIN A20 [get_ports &#123;sel_out[11]&#125;]
set_property PACKAGE_PIN J25 [get_ports &#123;sel_out[10]&#125;]
set_property PACKAGE_PIN J24 [get_ports &#123;sel_out[9]&#125;]
set_property PACKAGE_PIN H22 [get_ports &#123;sel_out[8]&#125;]
set_property PACKAGE_PIN K21 [get_ports &#123;sel_out[7]&#125;]
set_property PACKAGE_PIN L23 [get_ports &#123;sel_out[6]&#125;]
set_property PACKAGE_PIN B25 [get_ports &#123;sel_out[5]&#125;]
set_property PACKAGE_PIN B26 [get_ports &#123;sel_out[4]&#125;]
set_property PACKAGE_PIN C24 [get_ports &#123;sel_out[3]&#125;]
set_property PACKAGE_PIN D21 [get_ports &#123;sel_out[2]&#125;]
set_property PACKAGE_PIN C22 [get_ports &#123;sel_out[1]&#125;]
set_property PACKAGE_PIN B20 [get_ports &#123;sel_out[0]&#125;]
</code></pre>
<h3 id="3-阵列乘法器设计"><a href="#3-阵列乘法器设计" class="headerlink" title="3.阵列乘法器设计"></a>3.阵列乘法器设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9b23c4e7c365f7e9bd09cd34b890dbe.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8ebdee3a1727312ec82f82a48997c04.png"></p>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier_seg is
    Port (
        rst,clk:in std_logic;
        a_in,b_in:in std_logic_vector(7 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );
end array_multiplier_seg;

architecture Behavioral of array_multiplier_seg is

component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component array_multiplier
    Port (
        clk:in std_logic;
        a_in,b_in:in std_logic_vector(7 downto 0);
        sum_out:out std_logic_vector(15 downto 0)
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        seg_sel:out std_logic_vector(3 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );
end component;
component decoder4_16
    Port (
        sel_in:in std_logic_vector(3 downto 0);
        sel_out:out std_logic_vector(15 downto 0)
     );
end component;

signal clk_out_line:std_logic;
signal sum_out_line:std_logic_vector(15 downto 0);
signal seg_dig_line:std_logic_vector(3 downto 0);

begin

clk_div_inst:clk_div generic map(10000)port map(clk,clk_out_line);
array_multiplier_inst:array_multiplier port map(clk_out_line,a_in,b_in,sum_out_line);
seg_dis_inst:seg_dis port map(rst,clk_out_line,sum_out_line,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,&quot;0000000000000000&quot;,seg_dig_line,seg_data);
decoder4_16_inst:decoder4_16 port map(seg_dig_line,seg_dig);

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/48f312e41997369070448630c369ef88.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier is
    Port (
        clk:in std_logic;
        a_in,b_in:in std_logic_vector(7 downto 0);
        sum_out:out std_logic_vector(15 downto 0)
    );
end array_multiplier;

architecture Behavioral of array_multiplier is
component array_multiplier_top
    Port (
        a_in:in std_logic;
        b_in:in std_logic_vector(7 downto 0);
        s:out std_logic_vector(7 downto 0)
     );
end component;
component array_multiplier_unit
    Port (
        x_in:in std_logic;
        y_in:in std_logic_vector(7 downto 0);
        c_in:in std_logic_vector(6 downto 0);
        z_in:in std_logic_vector(7 downto 0);
        c_out:out std_logic_vector(6 downto 0);
        z_out:out std_logic_vector(7 downto 0)
     );
end component;
component array_multiplier_low
    Port (
        z_in,c_in:in std_logic_vector(6 downto 0);
        s_out:out std_logic_vector(7 downto 0)
     );
end component;

signal z_in0:std_logic_vector(7 downto 0);
signal z_in1:std_logic_vector(7 downto 0);
signal z_in2:std_logic_vector(7 downto 0);
signal z_in3:std_logic_vector(7 downto 0);
signal z_in4:std_logic_vector(7 downto 0);
signal z_in5:std_logic_vector(7 downto 0);
signal z_in6:std_logic_vector(7 downto 0);
signal z_in7:std_logic_vector(7 downto 0);
signal c_in1:std_logic_vector(6 downto 0);
signal c_in2:std_logic_vector(6 downto 0);
signal c_in3:std_logic_vector(6 downto 0);
signal c_in4:std_logic_vector(6 downto 0);
signal c_in5:std_logic_vector(6 downto 0);
signal c_in6:std_logic_vector(6 downto 0);
signal c_in7:std_logic_vector(6 downto 0);

begin

array_multiplier_top_inst:array_multiplier_top port map(a_in(0),b_in,z_in0);
array_multiplier_unit_inst1:array_multiplier_unit port map(a_in(1),b_in,&quot;0000000&quot;,z_in0,c_in1,z_in1);
array_multiplier_unit_inst2:array_multiplier_unit port map(a_in(2),b_in,c_in1,z_in1,c_in2,z_in2);
array_multiplier_unit_inst3:array_multiplier_unit port map(a_in(3),b_in,c_in2,z_in2,c_in3,z_in3);
array_multiplier_unit_inst4:array_multiplier_unit port map(a_in(4),b_in,c_in3,z_in3,c_in4,z_in4);
array_multiplier_unit_inst5:array_multiplier_unit port map(a_in(5),b_in,c_in4,z_in4,c_in5,z_in5);
array_multiplier_unit_inst6:array_multiplier_unit port map(a_in(6),b_in,c_in5,z_in5,c_in6,z_in6);
array_multiplier_unit_inst7:array_multiplier_unit port map(a_in(7),b_in,c_in6,z_in6,c_in7,z_in7);
array_multiplier_low_inst:array_multiplier_low port map(z_in7(7 downto 1),c_in7,sum_out(15 downto 8));

process(clk,a_in,b_in)
begin
    sum_out(0)&lt;=z_in0(0);
    sum_out(1)&lt;=z_in1(0);
    sum_out(2)&lt;=z_in2(0);
    sum_out(3)&lt;=z_in3(0);
    sum_out(4)&lt;=z_in4(0);
    sum_out(5)&lt;=z_in5(0);
    sum_out(6)&lt;=z_in6(0);
    sum_out(7)&lt;=z_in7(0);
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b2b81a5e7b42395fba8c9fb656d835fd.png"></p>
<p>模块：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier_top is
    Port (
        a_in:in std_logic;
        b_in:in std_logic_vector(7 downto 0);
        s:out std_logic_vector(7 downto 0)
     );
end array_multiplier_top;

architecture Behavioral of array_multiplier_top is

begin

process(a_in,b_in)
begin
    for i in 0 to 7 loop
       s(i)&lt;=a_in and b_in(i); 
    end loop;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier_unit is
    Port (
        x_in:in std_logic;
        y_in:in std_logic_vector(7 downto 0);
        c_in:in std_logic_vector(6 downto 0);
        z_in:in std_logic_vector(7 downto 0);
        c_out:out std_logic_vector(6 downto 0);
        z_out:out std_logic_vector(7 downto 0)
     );
end array_multiplier_unit;

architecture Behavioral of array_multiplier_unit is
component adder_1bit
    Port (
        a,b,c_in:in std_logic;
        s,c_out:out std_logic
     );
end component;

signal a_line:std_logic_vector(7 downto 0);

begin

adder_1bit_inst1:adder_1bit port map(a_line(0),c_in(0),z_in(1),z_out(0),c_out(0));
adder_1bit_inst2:adder_1bit port map(a_line(1),c_in(1),z_in(2),z_out(1),c_out(1));
adder_1bit_inst3:adder_1bit port map(a_line(2),c_in(2),z_in(3),z_out(2),c_out(2));
adder_1bit_inst4:adder_1bit port map(a_line(3),c_in(3),z_in(4),z_out(3),c_out(3));
adder_1bit_inst5:adder_1bit port map(a_line(4),c_in(4),z_in(5),z_out(4),c_out(4));
adder_1bit_inst6:adder_1bit port map(a_line(5),c_in(5),z_in(6),z_out(5),c_out(5));
adder_1bit_inst7:adder_1bit port map(a_line(6),c_in(6),z_in(7),z_out(6),c_out(6));

process(x_in,y_in)
begin 
    z_out(7)&lt;=x_in and y_in(7);
    for i in 0 to 7 loop
       a_line(i)&lt;=x_in and y_in(i);
    end loop;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a2c62b9b632c261aa03fc7767147d496.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier_low is
    Port (
        z_in,c_in:in std_logic_vector(6 downto 0);
        s_out:out std_logic_vector(7 downto 0)
     );
end array_multiplier_low;

architecture Behavioral of array_multiplier_low is
component adder_1bit
    Port (
        a,b,c_in:in std_logic;
        s,c_out:out std_logic
     );
end component;

signal c_line:std_logic_vector(5 downto 0);

begin

adder_1bit_inst0:adder_1bit port map(z_in(0),c_in(0),&#39;0&#39;,s_out(0),c_line(0));
adder_1bit_inst1:adder_1bit port map(z_in(1),c_in(1),c_line(0),s_out(1),c_line(1));
adder_1bit_inst2:adder_1bit port map(z_in(2),c_in(2),c_line(1),s_out(2),c_line(2));
adder_1bit_inst3:adder_1bit port map(z_in(3),c_in(3),c_line(2),s_out(3),c_line(3));
adder_1bit_inst4:adder_1bit port map(z_in(4),c_in(4),c_line(3),s_out(4),c_line(4));
adder_1bit_inst5:adder_1bit port map(z_in(5),c_in(5),c_line(4),s_out(5),c_line(5));
adder_1bit_inst6:adder_1bit port map(z_in(6),c_in(6),c_line(5),s_out(6),s_out(7));

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity adder_1bit is
    Port (
        a,b,c_in:in std_logic;
        s,c_out:out std_logic
     );
end adder_1bit;

architecture Behavioral of adder_1bit is

begin

process(a,b,c_in)
begin
    s&lt;=a xor b xor c_in;
    c_out&lt;=(a and b)or((a xor b)and c_in);
end process;

end Behavioral;
</code></pre>
<p>testbench:</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity array_multiplier_tb is
--  Port ( );
end array_multiplier_tb;

architecture Behavioral of array_multiplier_tb is
component array_multiplier_seg
    Port (
        rst,clk:in std_logic;
        a_in,b_in:in std_logic_vector(7 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)
    );
end component;

signal rst,clk:std_logic;
signal a_in,b_in:std_logic_vector(7 downto 0);
signal seg_dig:std_logic_vector(15 downto 0);
signal seg_data:std_logic_vector(7 downto 0);


begin

array_multiplier_seg_inst:array_multiplier_seg port map(rst,clk,a_in,b_in,seg_dig,seg_data);

clock:process
begin 
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

restart:process
begin
    rst&lt;=&#39;1&#39;;
    wait for 25ns;
    rst&lt;=&#39;0&#39;;
    wait;
end process;

test:process
begin
    a_in&lt;=&quot;10111101&quot;;
    b_in&lt;=&quot;11001010&quot;;
    wait;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c1acafbbcf9f2fcb9878c936a3f2244.png"></p>
<p>xdc:</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/18 13:02:24
#----------------------------------------------------------------------------------
#CLK_100M
set_property PACKAGE_PIN E10 [get_ports clk]
set_property IOSTANDARD LVCMOS18 [get_ports clk]

#SW0~15
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;a_in[7]&#125;]
set_property PACKAGE_PIN C9 [get_ports &#123;a_in[0]&#125;]
set_property PACKAGE_PIN B9 [get_ports &#123;a_in[1]&#125;]
set_property PACKAGE_PIN G11 [get_ports &#123;a_in[2]&#125;]
set_property PACKAGE_PIN F10 [get_ports &#123;a_in[3]&#125;]
set_property PACKAGE_PIN D10 [get_ports &#123;a_in[4]&#125;]
set_property PACKAGE_PIN E11 [get_ports &#123;a_in[5]&#125;]
set_property PACKAGE_PIN D11 [get_ports &#123;a_in[6]&#125;]
set_property PACKAGE_PIN A14 [get_ports &#123;a_in[7]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;b_in[7]&#125;]
set_property PACKAGE_PIN B10 [get_ports &#123;b_in[0]&#125;]
set_property PACKAGE_PIN A10 [get_ports &#123;b_in[1]&#125;]
set_property PACKAGE_PIN B15 [get_ports &#123;b_in[2]&#125;]
set_property PACKAGE_PIN A15 [get_ports &#123;b_in[3]&#125;]
set_property PACKAGE_PIN A13 [get_ports &#123;b_in[4]&#125;]
set_property PACKAGE_PIN A12 [get_ports &#123;b_in[5]&#125;]
set_property PACKAGE_PIN D8 [get_ports &#123;b_in[6]&#125;]
set_property PACKAGE_PIN D9 [get_ports &#123;b_in[7]&#125;]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23 [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24 [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26 [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26 [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20 [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25 [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24 [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22 [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21 [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23 [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25 [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26 [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24 [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21 [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22 [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20 [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26 [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26 [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26 [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21 [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21 [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23 [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24 [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21 [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;seg_data[0]&#125;]


set_property PACKAGE_PIN J8 [get_ports rst]
set_property IOSTANDARD LVCMOS18 [get_ports rst]
</code></pre>
<h3 id="4-先进先出-FIFO-的设计"><a href="#4-先进先出-FIFO-的设计" class="headerlink" title="4.先进先出 FIFO 的设计"></a>4.先进先出 FIFO 的设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/311aeef9dede913202b7df632c3aa302.png"></p>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
-- Module Name: FIFO_ring_test - Behavioral
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity FIFO_ring_test is
generic(
    CLK_FRE:integer:=100000000;
    cycle_max:positive:=3;--最大读写圈数
    depth:positive:=3;
    width:positive:=8
);
    Port(
        clk:in std_logic;
        rst:in std_logic;
        key_in:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end FIFO_ring_test;

architecture Behavioral of FIFO_ring_test is

component key_stroke
    generic(CLK_FRE:integer:=100000000);
    Port (
        clk:in std_logic;
        reset:in std_logic;
        key_in:in std_logic;
        output:out std_logic           
    );
end component;
component FIFO_ring
generic(
    cycle_max:positive:=3;--最大读写圈数
    depth:positive:=3;
    width:positive:=8
);
    Port(
        clk,clk_rd,clk_wr:in std_logic;
        rst:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end component;

signal out_put:std_logic;

begin
key_stroke_inst:key_stroke generic map(CLK_FRE)port map(clk=&gt;clk,reset=&gt;rst,key_in=&gt;key_in,output=&gt;out_put);
FIFO_ring_inst:FIFO_ring generic map(cycle_max,depth,width)port map(rst=&gt;rst,clk=&gt;clk,clk_rd=&gt;out_put,clk_wr=&gt;out_put,wr=&gt;wr,rd=&gt;rd,data_in=&gt;data_in,full=&gt;full,empty=&gt;empty,data_out=&gt;data_out);

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
-- Module Name: FIFO_ring - Behavioral
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity FIFO_ring is
generic(
    cycle_max:positive:=3;--最大读写圈数
    depth:positive:=3;
    width:positive:=8
);
    Port(
        clk,clk_rd,clk_wr:in std_logic;
        rst:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end FIFO_ring;

architecture Behavioral of FIFO_ring is
component duaram
generic(
    depth:positive:=3;
    width:positive:=8
);
Port(
    clka:in std_logic;
    wr:in std_logic;
    wr_en:in std_logic;
    addra:in std_logic_vector(depth-1 downto 0);
    datain:in std_logic_vector(width-1 downto 0);
    
    clkb:in std_logic;
    rd:in std_logic;
    rd_en:in std_logic;
    addrb:in std_logic_vector(depth-1 downto 0);
    dataout:out std_logic_vector(width-1 downto 0)
); 
end component;
component FIFO_ring_duaram_controller
generic(
    cycle_max:positive;--最大读写圈数
    depth:positive
);
Port(
    rst:in std_logic;
    clk,clka,clkb:in std_logic;
    wq:in std_logic;
    rq:in std_logic;
    full:out std_logic;
    empty:out std_logic;
    
    wr_pt:out std_logic_vector(depth-1 downto 0);
    rd_pt:out std_logic_vector(depth-1 downto 0)
);
end component;

signal rp_line:std_logic_vector(depth-1 downto 0);
signal wp_line:std_logic_vector(depth-1 downto 0);
signal empty_line:std_logic;
signal full_line:std_logic;

begin
duaram_inst:duaram generic map(depth,width)port map(clka=&gt;clk_wr,clkb=&gt;clk_rd,datain=&gt;data_in,dataout=&gt;data_out,addra=&gt;wp_line,addrb=&gt;rp_line,rd=&gt;rd,wr=&gt;wr,rd_en=&gt;empty_line,wr_en=&gt;full_line);
FIFO_ring_duaram_controller_inst:FIFO_ring_duaram_controller generic map(cycle_max,depth)port map(rst=&gt;rst,clk=&gt;clk,clkb=&gt;clk_rd,clka=&gt;clk_wr,wq=&gt;wr,rq=&gt;rd,full=&gt;full_line,empty=&gt;empty_line,wr_pt=&gt;wp_line,rd_pt=&gt;rp_line);

process(empty_line,full_line)
begin
    empty&lt;=empty_line;
    full&lt;=full_line;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a99a9296939596a5890faf5f0a592e12.png"></p>
<p>模块：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
-- Module Name: FIFO_ring - Behavioral
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity duaram is
    generic(
        depth:positive;
        width:positive
    );
    Port(
        clka:in std_logic;
        wr:in std_logic;
        wr_en:in std_logic;
        addra:in std_logic_vector(depth-1 downto 0);
        datain:in std_logic_vector(width-1 downto 0);
        
        clkb:in std_logic;
        rd:in std_logic;
        rd_en:in std_logic;
        addrb:in std_logic_vector(depth-1 downto 0);
        dataout:out std_logic_vector(width-1 downto 0)
    );
end duaram;

architecture Behavioral of duaram is
type ram is array(2**depth-1 downto 0)of std_logic_vector(width-1 downto 0);
signal dualram:ram;
begin

    process(clka)
    begin
        if(clka&#39;event and clka=&#39;1&#39;)then
            if(wr=&#39;0&#39;and wr_en=&#39;0&#39;)then dualram(conv_integer(addra))&lt;=datain;end if;
        end if;
    end process;
    
    process(clkb)
    begin
        if(clkb&#39;event and clkb=&#39;1&#39;)then
            if(rd=&#39;0&#39;and rd_en=&#39;0&#39;)then dataout&lt;=dualram(conv_integer(addrb));end if;
        end if;
    end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
-- Module Name: FIFO_ring_duaram_controller - Behavioral
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity FIFO_ring_duaram_controller is
generic(
    cycle_max:positive;--最大读写圈数
    depth:positive
);
Port(
    rst:in std_logic;
    clk,clka,clkb:in std_logic;
    wq:in std_logic;
    rq:in std_logic;
    full:out std_logic;
    empty:out std_logic;
    
    wr_pt:out std_logic_vector(depth-1 downto 0);
    rd_pt:out std_logic_vector(depth-1 downto 0)
);
end FIFO_ring_duaram_controller;

architecture Behavioral of FIFO_ring_duaram_controller is
signal wr_pt_t:std_logic_vector(depth+cycle_max-1 downto 0);
signal rd_pt_t:std_logic_vector(depth+cycle_max-1 downto 0);
signal full_line:std_logic;
signal empty_line:std_logic;
begin

--write_pointer
process(rst,clka)
begin
    if(rst=&#39;0&#39;)then
        wr_pt_t&lt;=(others=&gt;&#39;0&#39;);
    elsif(clka&#39;event and clka=&#39;1&#39;)then
        if (wq=&#39;0&#39;and full_line=&#39;0&#39;)then wr_pt_t&lt;=wr_pt_t+1;end if;
    end if;     
end process;

--read_pointer
process(rst,clkb)
begin
    if(rst=&#39;0&#39;)then
        rd_pt_t&lt;=(others=&gt;&#39;0&#39;);
    elsif(clkb&#39;event and clkb=&#39;1&#39;)then
        if (rq=&#39;0&#39;and empty_line=&#39;0&#39;)then 
rd_pt_t&lt;=rd_pt_t+1;
end if;
    end if;
end process;

--judge_status
process(rst,clk)
begin
    if(rst=&#39;0&#39;)then empty_line&lt;=&#39;1&#39;;full_line&lt;=&#39;0&#39;;
    elsif(clk&#39;event and clk=&#39;1&#39;)then
        if(wr_pt_t=rd_pt_t)then empty_line&lt;=&#39;1&#39;;full_line&lt;=&#39;0&#39;;
        elsif(wr_pt_t=rd_pt_t+2**depth)then empty_line&lt;=&#39;0&#39;;full_line&lt;=&#39;1&#39;;
        else empty_line&lt;=&#39;0&#39;;full_line&lt;=&#39;0&#39;;
        end if;
    end if;  
end process;

process(wr_pt_t)
begin wr_pt&lt;=wr_pt_t(depth-1 downto 0);
end process;

process(rd_pt_t)
begin rd_pt&lt;=rd_pt_t(depth-1 downto 0);
end process;

process(empty_line)
begin empty&lt;=empty_line;
end process;

process(full_line)
begin full&lt;=full_line;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
-- Module Name: FIFO_ring_tb - Behavioral
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FIFO_ring_tb is
--  Port ( );
end FIFO_ring_tb;

architecture Behavioral of FIFO_ring_tb is

component FIFO_ring_test
generic(
    CLK_FRE:integer:=100000000;
    cycle_max:positive:=3;--最大读写圈数
    depth:positive:=3;
    width:positive:=8
);
    Port(
        clk:in std_logic;
        rst:in std_logic;
        key_in:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end component;

signal clk:std_logic;
signal rst:std_logic;
signal key_in:std_logic;
signal data_in:std_logic_vector(7 downto 0);
signal wr:std_logic;
signal rd:std_logic;
signal empty:std_logic;
signal full:std_logic;
signal data_out:std_logic_vector(7 downto 0);

begin

FIFO_ring_test_inst:FIFO_ring_test generic map(100000000,3,8)port map(clk,rst,key_in,data_in,wr,rd,empty,full,data_out);

clock:process
begin
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
end process;

reset:process
begin
    rst&lt;=&#39;0&#39;;
    wait for 25ns;
    rst&lt;=&#39;1&#39;;
    wait;
end process;

test:process
begin
    rd&lt;=&#39;1&#39;;
    wr&lt;=&#39;1&#39;;
    data_in&lt;=&quot;00000000&quot;;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    
    rd&lt;=&#39;1&#39;;
    wr&lt;=&#39;0&#39;;
    data_in&lt;=&quot;00000001&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00000010&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00000100&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00001000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00010000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00100000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;01000000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;10000000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;11111111&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;00001111&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=&quot;11110000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    
    wr&lt;=&#39;1&#39;;
    rd&lt;=&#39;0&#39;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    
    rd&lt;=&#39;1&#39;;
    wr&lt;=&#39;0&#39;;
    data_in&lt;=not&quot;00000001&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00000010&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00000100&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00001000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00010000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00100000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;01000000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;10000000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;11111111&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;00001111&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    data_in&lt;=not&quot;11110000&quot;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    
    wr&lt;=&#39;1&#39;;
    rd&lt;=&#39;0&#39;;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    wait for 4ms;
    key_in&lt;=&#39;1&#39;;
    wait for 4ms;
    key_in&lt;=&#39;0&#39;;
    wait for 4ms;
    
    wait;

end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/36a731b3be24e70c8626b6c8ffc27d7b.png"></p>
<p>xdc：</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/18 13:02:24
#----------------------------------------------------------------------------------
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;data_in[7]&#125;]
set_property PACKAGE_PIN C9 [get_ports &#123;data_in[0]&#125;]
set_property PACKAGE_PIN B9 [get_ports &#123;data_in[1]&#125;]
set_property PACKAGE_PIN G11 [get_ports &#123;data_in[2]&#125;]
set_property PACKAGE_PIN F10 [get_ports &#123;data_in[3]&#125;]
set_property PACKAGE_PIN D10 [get_ports &#123;data_in[4]&#125;]
set_property PACKAGE_PIN E11 [get_ports &#123;data_in[5]&#125;]
set_property PACKAGE_PIN D11 [get_ports &#123;data_in[6]&#125;]
set_property PACKAGE_PIN A14 [get_ports &#123;data_in[7]&#125;]

set_property PACKAGE_PIN E10 [get_ports clk]
set_property IOSTANDARD LVCMOS18 [get_ports clk]

#sw31
set_property PACKAGE_PIN J8 [get_ports rst]
set_property IOSTANDARD LVCMOS18 [get_ports rst]
#sw30
set_property PACKAGE_PIN J14 [get_ports key_in]
set_property IOSTANDARD LVCMOS18 [get_ports key_in]
#sw29
set_property PACKAGE_PIN H9 [get_ports wr]
set_property IOSTANDARD LVCMOS18 [get_ports wr]
#sw28
set_property PACKAGE_PIN H8 [get_ports rd]
set_property IOSTANDARD LVCMOS18 [get_ports rd]
#led15
set_property PACKAGE_PIN L20 [get_ports empty]
set_property IOSTANDARD LVCMOS33 [get_ports empty]
#led11
set_property PACKAGE_PIN J20 [get_ports full]
set_property IOSTANDARD LVCMOS33 [get_ports full]
#led0-7
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[6]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[7]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;data_out[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;data_out[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;data_out[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;data_out[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;data_out[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;data_out[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;data_out[6]&#125;]
set_property PACKAGE_PIN C19 			[get_ports &#123;data_out[7]&#125;]
</code></pre>
<h3 id="5-PC-程序计数器设计"><a href="#5-PC-程序计数器设计" class="headerlink" title="5.PC 程序计数器设计"></a>5.PC 程序计数器设计</h3><p> PC 功能分析 加 1 功能、更新地址功能、PC 数值送到数据总线</p>
<p> PC 功能实现</p>
<p>1）全局异步复位功能</p>
<pre><code>     ADDR&lt;=“000000000000”;

     数据总线高阻态;
</code></pre>
<p>2）加 1 功能</p>
<pre><code>     clk_PC 上升沿有效;

     M_PC 高电平有效，PC+1=&gt;ADDR;
</code></pre>
<p>3）地址更新功能</p>
<pre><code>     clk_PC 上升沿有效，nLD_PC 低电平有效，新的 PC=&gt;ADDR；

     PC 数值送到数据总线，nPCH 和 nPCL 低电平有效，注意分两次输出到总线上，先高 8 位后低 8 位。
</code></pre>
<p><strong>注：自行添加按键消抖模块</strong></p>
<p>源码：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity pc is
    Port (        
        rst,clk_PC,M_PC,nLD_PC:in std_logic;
        PC_in:in std_logic_vector(11 downto 0);
        
        DATA_BUS:inout std_logic_vector(7 downto 0);
        
        nPCH,nPCL:out std_logic
     );
end pc;

architecture Behavioral of pc is

signal pc_count:std_logic_vector(11 downto 0);
signal ADDR:std_logic_vector(11 downto 0);


begin

process(rst,clk_PC)
variable addr_count:integer:=0;
begin
    if(rst=&#39;1&#39;)then 
        pc_count&lt;=PC_in;
        ADDR&lt;=pc_count;
        DATA_BUS&lt;=&quot;XXXXXXXX&quot;;
        nPCH&lt;=&#39;1&#39;;nPCL&lt;=&#39;1&#39;;

    elsif(clk_PC=&#39;1&#39;and clk_PC&#39;event)then
        if(addr_count=0)then pc_count&lt;=pc_count+1;end if;
        if(M_PC=&#39;1&#39;)then ADDR&lt;=pc_count;end if;
        if(nLD_PC=&#39;0&#39;)then 
            if(addr_count=0)then DATA_BUS&lt;=&quot;0000&quot;&amp; ADDR(11 downto 8);addr_count:=addr_count+1;nPCH&lt;=&#39;0&#39;;nPCL&lt;=&#39;1&#39;;
            elsif(addr_count=1)then DATA_BUS&lt;=ADDR(7 downto 0);addr_count:=addr_count-1;nPCH&lt;=&#39;1&#39;;nPCL&lt;=&#39;0&#39;;
            end if;
        end if;
    end if;
end process;



end Behavioral;
</code></pre>
<p>xdc:</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/18 13:02:24
#----------------------------------------------------------------------------------
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;PC_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;PC_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;PC_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;PC_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;PC_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;PC_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;PC_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;PC_in[7]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[8]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[9]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[10]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;PC_in[11]&#125;]
set_property PACKAGE_PIN B10        [get_ports &#123;PC_in[8]&#125;]
set_property PACKAGE_PIN A10        [get_ports &#123;PC_in[9]&#125;]
set_property PACKAGE_PIN B15        [get_ports &#123;PC_in[10]&#125;]
set_property PACKAGE_PIN A15        [get_ports &#123;PC_in[11]&#125;]


set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[6]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;DATA_BUS[7]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;DATA_BUS[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;DATA_BUS[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;DATA_BUS[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;DATA_BUS[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;DATA_BUS[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;DATA_BUS[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;DATA_BUS[6]&#125;]
set_property PACKAGE_PIN C19 			[get_ports &#123;DATA_BUS[7]&#125;]

#sw31
set_property PACKAGE_PIN J8 [get_ports rst]
set_property IOSTANDARD LVCMOS18 [get_ports rst]
#sw30
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_PC]
set_property PACKAGE_PIN J14 [get_ports clk_PC]
set_property IOSTANDARD LVCMOS18 [get_ports clk_PC]
#sw29
set_property PACKAGE_PIN H9 [get_ports M_PC]
set_property IOSTANDARD LVCMOS18 [get_ports M_PC]
#sw28
set_property PACKAGE_PIN H8 [get_ports nLD_PC]
set_property IOSTANDARD LVCMOS18 [get_ports nLD_PC]

#led15
set_property PACKAGE_PIN L20 [get_ports nPCH]
set_property IOSTANDARD LVCMOS33 [get_ports nPCH]
#led11
set_property PACKAGE_PIN J20 [get_ports nPCL]
set_property IOSTANDARD LVCMOS33 [get_ports nPCL]
</code></pre>
<h3 id="6-程序存储器-ROM-设计"><a href="#6-程序存储器-ROM-设计" class="headerlink" title="6.程序存储器 ROM 设计"></a>6.程序存储器 ROM 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ca1179f853bd18943bce21382adae2c2.png"></p>
<p>源码：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_unsigned.ALL;
use IEEE.STD_LOGIC_textio.ALL;
use std.textio.all;

entity ROM is
    generic(
        depth:positive:=12;
        width:positive:=8
    );
    Port (
        clk_ROM,M_ROM,ROM_EN:in std_logic;
        addr:in std_logic_vector(11 downto 0);
        DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end ROM;

architecture Behavioral of ROM is
type matrix is array (integer range&lt;&gt;)of std_logic_vector(width-1 downto 0);
signal rom:matrix(0 to 2**depth-1);

procedure load_rom (signal data_word:out matrix)is
file romfile:text open read_mode is &quot;romfile.dat&quot;;
variable lbuf:line;
variable i:integer:=0;
variable fdata:std_logic_vector(7 downto 0);
begin
    while(not endfile(romfile)and i&lt;2**depth)loop
        readline(romfile,lbuf);
        read(lbuf,fdata);
        data_word(i)&lt;=fdata;
        i:=i+1;
    end loop;
end procedure;

begin

load_rom(rom);

process(clk_ROM)
begin
    if(clk_ROM=&#39;1&#39;and clk_ROM&#39;event)then        
        if(ROM_EN=&#39;0&#39;and M_ROM=&#39;1&#39;)then
            DATA_BUS&lt;=rom(conv_integer(addr));
        else DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);
        end if;
    end if;
end process;        
        
end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 13:02:24
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity ROM_tb is
--  Port ( );
end ROM_tb;

architecture Behavioral of ROM_tb is
component ROM
    generic(
        depth:positive:=12;
        width:positive:=8
    );
    Port (
        clk_ROM,M_ROM,ROM_EN:in std_logic;
        addr:in std_logic_vector(11 downto 0);
        DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end component;

signal rst:std_logic;
signal clk_ROM,M_ROM,ROM_EN:std_logic;
signal addr:std_logic_vector(11 downto 0);
signal DATA_BUS:std_logic_vector(7 downto 0);

begin

ROM_inst:ROM generic map(12,8)port map(clk_ROM,M_ROM,ROM_EN,addr,DATA_BUS);

clock:process
begin
    clk_ROM&lt;=&#39;1&#39;;
    wait for 5ns;
    clk_ROM&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    M_ROM&lt;=&#39;0&#39;;
    ROM_EN&lt;=&#39;1&#39;;
    addr&lt;=(others=&gt;&#39;0&#39;);
    wait for 25ns;
    M_ROM&lt;=&#39;1&#39;;
    wait for 25ns;
    ROM_EN&lt;=&#39;0&#39;;
    
    wait for 5ns;
    addr&lt;=&quot;000000000000&quot;;
    wait for 20ns;  
    wait for 5ns;
    addr&lt;=&quot;000000000001&quot;;
    wait for 20ns;
    wait for 5ns;
    addr&lt;=&quot;000000000010&quot;;
    wait for 20ns;
    wait for 5ns;
    addr&lt;=&quot;000000000011&quot;;
    wait for 20ns;
    
    wait;

end process;

end Behavioral;
</code></pre>
<p>xdc:</p>
<pre><code>set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[6]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[7]&#125;]
set_property PACKAGE_PIN C9 [get_ports &#123;addr[0]&#125;]
set_property PACKAGE_PIN B9 [get_ports &#123;addr[1]&#125;]
set_property PACKAGE_PIN G11 [get_ports &#123;addr[2]&#125;]
set_property PACKAGE_PIN F10 [get_ports &#123;addr[3]&#125;]
set_property PACKAGE_PIN D10 [get_ports &#123;addr[4]&#125;]
set_property PACKAGE_PIN E11 [get_ports &#123;addr[5]&#125;]
set_property PACKAGE_PIN D11 [get_ports &#123;addr[6]&#125;]
set_property PACKAGE_PIN A14 [get_ports &#123;addr[7]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[8]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[9]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[10]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;addr[11]&#125;]
set_property PACKAGE_PIN B10 [get_ports &#123;addr[8]&#125;]
set_property PACKAGE_PIN A10 [get_ports &#123;addr[9]&#125;]
set_property PACKAGE_PIN B15 [get_ports &#123;addr[10]&#125;]
set_property PACKAGE_PIN A15 [get_ports &#123;addr[11]&#125;]

set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[0]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[1]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[2]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[3]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[4]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[5]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[6]&#125;]
set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[7]&#125;]
set_property PACKAGE_PIN G16 [get_ports &#123;DATA_BUS[0]&#125;]
set_property PACKAGE_PIN H16 [get_ports &#123;DATA_BUS[1]&#125;]
set_property PACKAGE_PIN D16 [get_ports &#123;DATA_BUS[2]&#125;]
set_property PACKAGE_PIN D15 [get_ports &#123;DATA_BUS[3]&#125;]
set_property PACKAGE_PIN C18 [get_ports &#123;DATA_BUS[4]&#125;]
set_property PACKAGE_PIN C17 [get_ports &#123;DATA_BUS[5]&#125;]
set_property PACKAGE_PIN B19 [get_ports &#123;DATA_BUS[6]&#125;]
set_property PACKAGE_PIN C19 [get_ports &#123;DATA_BUS[7]&#125;]

#sw30
set_property PACKAGE_PIN J14 [get_ports ROM_EN]
set_property IOSTANDARD LVCMOS18 [get_ports ROM_EN]

#sw31
set_property PACKAGE_PIN J8 [get_ports M_ROM]
set_property IOSTANDARD LVCMOS18 [get_ports M_ROM]

set_property PACKAGE_PIN E10 [get_ports clk_ROM]
set_property IOSTANDARD LVCMOS18 [get_ports clk_ROM]
</code></pre>
<h3 id="7-加减交替除法器"><a href="#7-加减交替除法器" class="headerlink" title="7.加减交替除法器"></a>7.加减交替除法器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/36f7c7ddcdd765b4f80b09904c236f2c.png"></p>
<p>原码加减交替除法器的运算法则：</p>
<p>1）除法运算前，应满足条件：X*&lt;Y*,且 Y*≠0,否则，按溢出或非法除数处理；</p>
<p>2）符号位不参与运算，单独处理：qf&#x3D; xf xor yf ;</p>
<p>3）部分余数采用单符号位或双符号位；</p>
<p>4）每步部分余数运算规则：</p>
<pre><code>    ①若余数 R≥0, 则商上 1，左移一次，减除数；

    ②若余数 R＜0, 则商上 0，左移一次，加除数。
</code></pre>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity divider_origin_test is
    Port(
        rst,clk,start:in std_logic;
        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)
        bin:in std_logic_vector(7 downto 0);--被除数
        done:out std_logic;

        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end divider_origin_test;

architecture Behavioral of divider_origin_test is
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        sel_out:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;
component divider_origin
    Port(
        clk,start:in std_logic;
        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)
        bin:in std_logic_vector(7 downto 0);--被除数
        done:out std_logic;

        s,r:out std_logic_vector(7 downto 0)
    );
end component;

signal clk_line:std_logic;
signal s,r:std_logic_vector(7 downto 0);
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);

begin

clk_div_inst:clk_div generic map(10000)port map(rst,clk,clk_line);
seg_dis_inst:seg_dis port map(rst,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);
divider_origin_inst:divider_origin port map(clk,start,ain,bin,done,s,r);

process(s,r,ain,bin)
begin
    data_in_A&lt;=&quot;00000000&quot;&amp;s;
    data_in_B&lt;=&quot;00000000&quot;&amp;r;
    data_in_C&lt;=&quot;00000000&quot;&amp;bin;
    data_in_D&lt;=ain;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3579eeb2efc9ed74282411d3cc4a7c43.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity divider_origin is
    Port(
        clk,start:in std_logic;
        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)
        bin:in std_logic_vector(7 downto 0);--被除数
        done:out std_logic;

        s,r:out std_logic_vector(7 downto 0)
    );
end divider_origin;

architecture Behavioral of divider_origin is

component divider_origin_ctrl
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end component;
component divider_origin_16bitreg
    Port (
        clk,rst:in std_logic;
        ain:in std_logic_vector(15 downto 0);
        d:in std_logic_vector(8 downto 0);
        c_out:out std_logic;
        q:out std_logic_vector(15 downto 0)
     );
end component;
component divider_origin_selector
    Port (
        clk,rst:in std_logic;
        a0:in std_logic;
        din:in std_logic_vector(7 downto 0);
        cout:out std_logic;
        dout:out std_logic_vector(7 downto 0)
     );
end component;
component divider_origin_8bitadder
    Port (
        clk,rst:in std_logic;
        cina,cinb:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end component;

signal clk_line:std_logic;
signal rst_line:std_logic;
signal cina_line,cinb_line:std_logic;
signal bin_line:std_logic_vector(7 downto 0);
signal sout_line:std_logic_vector(8 downto 0);
signal q_line:std_logic_vector(15 downto 0);

begin
divider_origin_ctrl_inst:divider_origin_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);
divider_origin_16bitreg_inst:divider_origin_16bitreg port map(clk=&gt;clk_line,rst=&gt;rst_line,ain=&gt;ain,d=&gt;sout_line,c_out=&gt;cina_line,q=&gt;q_line);
divider_origin_selector_inst:divider_origin_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;q_line(0),din=&gt;bin,cout=&gt;cinb_line,dout=&gt;bin_line);
divider_origin_8bitadder_inst:divider_origin_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,cina=&gt;cina_line,cinb=&gt;cinb_line,ain=&gt;q_line(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);

process(q_line)
begin
    s&lt;=q_line(7 downto 0);--&amp;not sout_line(8);
    r&lt;=cina_line&amp;q_line(15 downto 9);
    --r&lt;=q_line(15 downto 8);
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/19d7c0eaa963aceabd7b7c37f2e266a9.png"></p>
<p>模块：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity divider_origin_ctrl is
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end divider_origin_ctrl;

architecture Behavioral of divider_origin_ctrl is

signal cnt4b:std_logic_vector(3 downto 0);

begin

process(clk,start)
begin
    rstall&lt;=start;
    if(start=&#39;1&#39;)then cnt4b&lt;=&quot;0000&quot;;
    elsif clk&#39;event and clk=&#39;1&#39;then if cnt4b&lt;=7 then cnt4b&lt;=cnt4b+1;end if;
    end if;
end process;

process(clk,cnt4b,start)
begin
    if (start=&#39;1&#39;)then
        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;; 
    elsif(start=&#39;0&#39;)then    
        if cnt4b&lt;=7 then clkout&lt;=clk;
        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;
        end if; 
    end if;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity divider_origin_16bitreg is
    Port (
        clk,rst:in std_logic;
        ain:in std_logic_vector(15 downto 0);
        d:in std_logic_vector(8 downto 0);
        c_out:out std_logic;
        q:out std_logic_vector(15 downto 0)
     );
end divider_origin_16bitreg;

architecture Behavioral of divider_origin_16bitreg is

begin

process(clk,rst)
variable sr16b:std_logic_vector(15 downto 0);
begin
    if rst=&#39;1&#39;then
        sr16b:=ain;
        c_out&lt;=sr16b(15);--发送符号位
        sr16b(15 downto 1):=sr16b(14 downto 0);--左移一位
        sr16b(0):=&#39;0&#39;;--上0
    elsif(clk=&#39;1&#39;and clk&#39;event)then  
        sr16b(15 downto 8):=d(7 downto 0);
        c_out&lt;=sr16b(15);--发送符号位
        sr16b(15 downto 1):=sr16b(14 downto 0);--左移一位
        sr16b(0):=not d(8);    --上商取反符号位
    end if;   
    q&lt;=sr16b;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity divider_origin_selector is
    Port (
        clk,rst:in std_logic;
        a0:in std_logic;
        din:in std_logic_vector(7 downto 0);
        cout:out std_logic;
        dout:out std_logic_vector(7 downto 0)
     );
end divider_origin_selector;

architecture Behavioral of divider_origin_selector is

signal complement_x_negative:std_logic_vector(7 downto 0);

begin

process(din)
begin
    complement_x_negative&lt;=(not din)+1;
end process;

process(clk,rst,a0,din)

begin
    if(rst=&#39;1&#39;)then dout&lt;=complement_x_negative;cout&lt;=&#39;1&#39;;
    elsif(clk&#39;event and clk=&#39;0&#39;)then
        if(a0=&#39;1&#39;)then dout&lt;=complement_x_negative;cout&lt;=&#39;1&#39;;--输出加数和其符号位
        else dout&lt;=din;cout&lt;=&#39;0&#39;;
        end if;
    end if;    
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity divider_origin_8bitadder is
    Port (
        clk,rst:in std_logic;
        cina,cinb:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end divider_origin_8bitadder;

architecture Behavioral of divider_origin_8bitadder is
begin

process(rst,clk,ain,bin,cina,cinb)
begin
    if(rst=&#39;1&#39;)then sout&lt;=(cina &amp; ain)+(cinb &amp; bin);
    elsif(clk=&#39;0&#39;)then
        sout&lt;=(cina &amp; ain)+(cinb &amp; bin);
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench:</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/18 19:49:35
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity divider_origin_tb is
--  Port ( );
end divider_origin_tb;

architecture Behavioral of divider_origin_tb is
component divider_origin
    Port(
        clk,start:in std_logic;
        ain:in std_logic_vector(15 downto 0);--除数
        bin:in std_logic_vector(7 downto 0);--被除数
        done:out std_logic;

        s,r:out std_logic_vector(7 downto 0)
    );
end component;
signal clk,start: std_logic;
signal ain: std_logic_vector(15 downto 0);
signal bin: std_logic_vector(7 downto 0);
signal done: std_logic;
signal s,r: std_logic_vector(7 downto 0);
begin
divider_origin_inst:divider_origin port map(clk,start,ain,bin,done,s,r);

clock_gen:process
begin  
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    --09 0d
    ain&lt;=x&quot;008B&quot;;
    bin&lt;=x&quot;0E&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 100ns;
    
    --00 ff
    ain&lt;=x&quot;0001&quot;;
    bin&lt;=x&quot;02&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 100ns;
    
    --01 33
    ain&lt;=x&quot;00AB&quot;;
    bin&lt;=x&quot;78&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 100ns;
    
    --ad 27
    ain&lt;=x&quot;ABCD&quot;;
    bin&lt;=x&quot;FE&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 100ns;
   
    --01 01
    ain&lt;=x&quot;0100&quot;;
    bin&lt;=x&quot;FF&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 100ns;
    
    wait;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb48954106bbd0bf39a333bc9517b390.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8445a0d3d348041fe6fd9b83e6bbab68.png"></p>
<p>xdc:</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/23 21:55:51
#----------------------------------------------------------------------------------
#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]
#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;ain[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;ain[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;ain[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;ain[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;ain[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;ain[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;ain[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;ain[7]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[8]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[9]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[10]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[11]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[12]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[13]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[14]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;ain[15]&#125;]
set_property PACKAGE_PIN B10        [get_ports &#123;ain[8]&#125;]
set_property PACKAGE_PIN A10        [get_ports &#123;ain[9]&#125;]
set_property PACKAGE_PIN B15        [get_ports &#123;ain[10]&#125;]
set_property PACKAGE_PIN A15        [get_ports &#123;ain[11]&#125;]
set_property PACKAGE_PIN A13        [get_ports &#123;ain[12]&#125;]
set_property PACKAGE_PIN A12        [get_ports &#123;ain[13]&#125;]
set_property PACKAGE_PIN D8         [get_ports &#123;ain[14]&#125;]
set_property PACKAGE_PIN D9         [get_ports &#123;ain[15]&#125;]
#SW16~SW23
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;bin[7]&#125;]
set_property PACKAGE_PIN F8         [get_ports &#123;bin[0]&#125;]
set_property PACKAGE_PIN F9         [get_ports &#123;bin[1]&#125;]
set_property PACKAGE_PIN H11        [get_ports &#123;bin[2]&#125;]
set_property PACKAGE_PIN H12        [get_ports &#123;bin[3]&#125;]
set_property PACKAGE_PIN G14        [get_ports &#123;bin[4]&#125;]
set_property PACKAGE_PIN J10        [get_ports &#123;bin[5]&#125;]
set_property PACKAGE_PIN H14        [get_ports &#123;bin[6]&#125;]
set_property PACKAGE_PIN J11        [get_ports &#123;bin[7]&#125;]


#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]

set_property PACKAGE_PIN J8         [get_ports rst]
set_property IOSTANDARD LVCMOS18    [get_ports rst]
set_property PACKAGE_PIN J14        [get_ports start]
set_property IOSTANDARD LVCMOS18    [get_ports start]

#LED
set_property IOSTANDARD LVCMOS33 		[get_ports done]
set_property PACKAGE_PIN G16			[get_ports done]
</code></pre>
<h3 id="8-指令存储器-IR-设计"><a href="#8-指令存储器-IR-设计" class="headerlink" title="8.指令存储器 IR 设计"></a>8.指令存储器 IR 设计</h3><p> IR 功能分析</p>
<pre><code>     传送指令编码到微控制器

     生成 PC 的新地址

     生成 RAM 的读写地址
</code></pre>
<p> IR 功能实现</p>
<pre><code>     传送指令编码到微控制器

            clk_IR 上升沿有效，LD_IR1 高电平有效， data-&gt;IR。

     寄存器地址操作 Data[0]-&gt; RS；Data[1]-&gt;RD；

     生成 PC 的新地址

            clk_IR 上升沿有效，LD_IR2 高电平有效，data[3..0]-&gt;PC[11..8];

            clk_IR 上升沿有效，LD_IR3 高电平有效，data[7..0]-&gt;PC[7..0]。

     生成 RAM 的读写地址

            clk_IR 上升沿有效，LD_IR3 高电平有效 data[7..0]-&gt;PC[7..0];

            nARen 低电平有效， PC[6..0]-&gt;AR[6..0]。
</code></pre>
<p>源码：  </p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/20 10:29:36
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IR_test is
    port (
        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;
        
        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end IR_test;

architecture Behavioral of IR_test is
component IR
    Port (
        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;
        DATA_BUS:in std_logic_vector(7 downto 0);
        
        IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器
        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）
        PC_out:out std_logic_vector(11 downto 0);--PC地址总线
        AR:out std_logic_vector(6 downto 0)
    );
end component;
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        sel_out:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;

signal clk_line: std_logic;
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);
signal DATA_BUS_line :std_logic_vector(7 downto 0);
signal IR_line_line       :std_logic_vector(7 downto 0);--传送指令到指令寄存器
signal PC_out_line   :std_logic_vector(11 downto 0);--PC地址总线
signal AR_line       :std_logic_vector(6 downto 0);

begin

clk_div_inst:clk_div generic map(10000)port map(rst,clk_IR,clk_line);
sig_dis_inst:seg_dis port map(rst,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);
IR_inst:IR port map(rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen,DATA_BUS_line,IR_line_line,RS,RD,PC_out_line,AR_line);

process(DATA_BUS_line,IR_line_line,PC_out_line,AR_line)
begin
        data_in_A&lt;=&quot;00000000&quot;&amp;DATA_BUS_line;
        data_in_B&lt;=&quot;00000000&quot;&amp;IR_line_line;
        data_in_C&lt;=&quot;0000&quot;&amp;PC_out_line;
        data_in_D&lt;=&quot;000000000&quot;&amp;AR_line;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9b9e9bdcb11e643277242864ba0880d9.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/20 10:29:36
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IR is
    Port (
        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;
        DATA_BUS:in std_logic_vector(7 downto 0);
        
        IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器
        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）
        PC_out:out std_logic_vector(11 downto 0);--PC地址总线
        AR:out std_logic_vector(6 downto 0)
    );
end IR;

architecture Behavioral of IR is

begin

process(rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen)
begin
    if(rst=&#39;1&#39;)then
        IR_out&lt;=(others=&gt;&#39;0&#39;);
        PC_out&lt;=(others=&gt;&#39;0&#39;);
        RS&lt;=&#39;0&#39;;RD&lt;=&#39;0&#39;;
    elsif(clk_IR=&#39;1&#39; and clk_IR&#39;event)then
        if(LD_IR1=&#39;1&#39;)then IR_out&lt;=DATA_BUS;end if;
        RS&lt;=DATA_BUS(0);RD&lt;=DATA_BUS(1);
        if(LD_IR2=&#39;1&#39;)then PC_out(11 downto 8)&lt;=DATA_BUS(3 downto 0);
        elsif(LD_IR3=&#39;1&#39;)then 
            PC_out(7 downto 0)&lt;=DATA_BUS(7 downto 0);
            if(nARen=&#39;0&#39;)then AR&lt;=DATA_BUS(6 downto 0);end if;
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/20 10:29:36
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IR_tb is
--  Port ( );
end IR_tb;

architecture Behavioral of IR_tb is
component IR
    Port (
        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;
        DATA_BUS:in std_logic_vector(7 downto 0);
        
        IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器
        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）
        PC_out:out std_logic_vector(11 downto 0);--PC地址总线
        AR:out std_logic_vector(6 downto 0)
    );
end component;

signal rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen,RS,RD: std_logic;
signal DATA_BUS :std_logic_vector(7 downto 0);
signal IR_line       :std_logic_vector(7 downto 0);--传送指令到指令寄存器
signal PC_out   :std_logic_vector(11 downto 0);--PC地址总线
signal AR       :std_logic_vector(6 downto 0);

begin

IR_inst:IR port map(rst=&gt;rst,clk_IR=&gt;clk_IR,LD_IR1=&gt;LD_IR1,LD_IR2=&gt;LD_IR2,LD_IR3=&gt;LD_IR3,nARen=&gt;nARen,DATA_BUS=&gt;DATA_BUS,IR_out=&gt;IR_line,RS=&gt;RS,RD=&gt;RD,PC_out=&gt;PC_out,AR=&gt;AR);

clock:process
begin
    clk_IR&lt;=&#39;1&#39;;
    wait for 5ns;
    clk_IR&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    rst&lt;=&#39;1&#39;;
    --DATA_BUS&lt;=x&quot;EE&quot;;
    DATA_BUS&lt;=&quot;11111111&quot;;
    LD_IR1&lt;=&#39;1&#39;;
    LD_IR2&lt;=&#39;0&#39;;
    LD_IR3&lt;=&#39;0&#39;;
    nARen&lt;=&#39;1&#39;;
    wait for 25ns;
    rst&lt;=&#39;0&#39;;
    wait for 20ns;
    DATA_BUS&lt;=x&quot;FA&quot;;
    LD_IR1&lt;=&#39;0&#39;;
    LD_IR2&lt;=&#39;1&#39;;
    LD_IR3&lt;=&#39;0&#39;;
    nARen&lt;=&#39;1&#39;;
    wait for 20ns;
    DATA_BUS&lt;=x&quot;BC&quot;;
    LD_IR1&lt;=&#39;0&#39;;
    LD_IR2&lt;=&#39;0&#39;;
    LD_IR3&lt;=&#39;1&#39;;
    nARen&lt;=&#39;0&#39;;   
    wait;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/366b42fa88d3bab2b3d92539815238d9.png"></p>
<p>xdc：</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/23 21:55:51
#----------------------------------------------------------------------------------
#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports rst]
set_property IOSTANDARD LVCMOS18    [get_ports rst]
set_property PACKAGE_PIN J14        [get_ports LD_IR1]
set_property IOSTANDARD LVCMOS18    [get_ports LD_IR1]
set_property PACKAGE_PIN H9         [get_ports LD_IR2]
set_property IOSTANDARD LVCMOS18    [get_ports LD_IR2]
set_property PACKAGE_PIN H8         [get_ports LD_IR3]
set_property IOSTANDARD LVCMOS18    [get_ports LD_IR3]
set_property PACKAGE_PIN G10        [get_ports nARen]
set_property IOSTANDARD LVCMOS18    [get_ports nARen]

#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk_IR]
set_property IOSTANDARD LVCMOS18    [get_ports clk_IR]

#LED0~1
set_property IOSTANDARD LVCMOS33 		[get_ports RS]
set_property IOSTANDARD LVCMOS33 		[get_ports RD]
set_property PACKAGE_PIN G16			[get_ports RS]
set_property PACKAGE_PIN H16 			[get_ports RD]

#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]
</code></pre>
<h3 id="9-寄存器-RN-设计"><a href="#9-寄存器-RN-设计" class="headerlink" title="9.寄存器 RN 设计"></a>9.寄存器 RN 设计</h3><p>RN 功能分析：</p>
<p> 数据锁存功能</p>
<p> 读写功能</p>
<pre><code>     读寄存器操作

            clk_RN 上升沿有效，Ri_EN 低电平有效，读信号 RDRi 高电平有效，选择 RS 寄存器， 输出 data[7..0]。

     写寄存器操作

            clk_RN 上升沿有效，Ri_EN 低电平有效，写信号 WRRi 高电平有效，选择 RD 寄存器， data[7..0] RD 。
</code></pre>
<p>源码：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/20 17:36:21
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity RN is
    generic(
        depth:integer:=1
    );
    Port(
        clk_RN,Ri_EN,RDRi,WRRi:in std_logic;
        RS,RD:in std_logic_vector(depth-1 downto 0);
        data_in:in std_logic_vector(7 downto 0);
        data_out:out std_logic_vector(7 downto 0)
        --DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end RN;

architecture Behavioral of RN is
type RN is array(2**depth-1 downto 0)of std_logic_vector(7 downto 0);
signal RN_in:RN;

begin

process(clk_RN)
begin
    if(Ri_EN=&#39;1&#39;)then data_out&lt;=(others=&gt;&#39;Z&#39;);
    elsif(clk_RN=&#39;1&#39;and clk_RN&#39;event)then
        if(RDRi=&#39;1&#39;)then data_out&lt;=RN_in(conv_integer(RS));
        elsif(WRRi=&#39;1&#39;)then RN_in(conv_integer(RD))&lt;=data_in;
        else data_out&lt;=(others=&gt;&#39;Z&#39;);
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench:</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/22 09:34:26
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity RN_tb is
--  Port ( );
end RN_tb;

architecture Behavioral of RN_tb is
component RN
    generic(
        depth:integer:=1
    );
    Port(
        clk_RN,Ri_EN,RDRi,WRRi:in std_logic;
        RS,RD:in std_logic_vector(depth-1 downto 0);
        data_in:in std_logic_vector(7 downto 0);
        data_out:out std_logic_vector(7 downto 0)
        --DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end component;

signal clk_RN,Ri_EN,RDRi,WRRi:std_logic;
signal RS,RD:std_logic_vector(0 downto 0);
signal DATA_BUS:std_logic_vector(7 downto 0);
signal data_in:std_logic_vector(7 downto 0);
signal data_out:std_logic_vector(7 downto 0);

begin

RN_inst:RN generic map(1)port map(clk_RN,Ri_EN,RDRi,WRRi,RS,RD,data_in,data_out);
--RN_inst:RN generic map(1)port map(clk_RN,Ri_EN,RDRi,WRRi,RS,RD,DATA_BUS);

clock:process
begin
    clk_RN&lt;=&#39;1&#39;;
    wait for 5ns;
    clk_RN&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    Ri_EN&lt;=&#39;1&#39;;
    wait for 25ns;
    Ri_EN&lt;=&#39;0&#39;;
    
    RDRi&lt;=&#39;0&#39;;
    WRRi&lt;=&#39;1&#39;;
    RS&lt;=&quot;0&quot;;
    RD&lt;=&quot;0&quot;;
    data_in&lt;=x&quot;FF&quot;;
    wait for 25ns;
    
    RDRi&lt;=&#39;0&#39;;
    WRRi&lt;=&#39;1&#39;;
    RS&lt;=&quot;0&quot;;
    RD&lt;=&quot;1&quot;;
    data_in&lt;=x&quot;EE&quot;;
    wait for 25ns;
    
    RDRi&lt;=&#39;1&#39;;
    WRRi&lt;=&#39;0&#39;;
    RS&lt;=&quot;0&quot;;
    RD&lt;=&quot;0&quot;;
    wait for 25ns;
    
    RDRi&lt;=&#39;1&#39;;
    WRRi&lt;=&#39;0&#39;;
    RS&lt;=&quot;1&quot;;
    RD&lt;=&quot;0&quot;;
       
    wait for 25ns;
    Ri_EN&lt;=&#39;1&#39;;
    wait;
end process;

end Behavioral;
</code></pre>
<p>xdc:</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/23 21:55:51
#----------------------------------------------------------------------------------
#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]

#LED
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[6]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[7]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;data_out[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;data_out[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;data_out[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;data_out[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;data_out[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;data_out[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;data_out[6]&#125;]
set_property PACKAGE_PIN C19 			[get_ports &#123;data_out[7]&#125;]

#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk_RN]
set_property IOSTANDARD LVCMOS18    [get_ports clk_RN]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports Ri_EN]
set_property IOSTANDARD LVCMOS18    [get_ports Ri_EN]
set_property PACKAGE_PIN J14        [get_ports RDRi]
set_property IOSTANDARD LVCMOS18    [get_ports RDRi]
set_property PACKAGE_PIN H9         [get_ports WRRi]
set_property IOSTANDARD LVCMOS18    [get_ports WRRi]
set_property PACKAGE_PIN H8         [get_ports &#123;RS[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;RS[0]&#125;]
set_property PACKAGE_PIN G10        [get_ports &#123;RD[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;RD[0]&#125;]
</code></pre>
<h3 id="10-ALU算术逻辑单元设计"><a href="#10-ALU算术逻辑单元设计" class="headerlink" title="10.ALU算术逻辑单元设计"></a>10.ALU算术逻辑单元设计</h3><p>算术逻辑单元（ALU）:执行各种算术和逻辑运算。</p>
<p> 算术运算操作 :加、减、乘、除</p>
<p> 逻辑运算操作:与、或、非、异或</p>
<p> ALU 输入:操作数以及来自控制单元的控制命令</p>
<p> ALU 输出:运算结果，以及状态信息</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/43bde231cdd8555e9e66b22f437d9014.png"></p>
<p>源码：</p>
<p>顶层;</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/23 12:35:51
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

entity ALU_test is
    port(
        clk : in std_logic; --全局时钟和ALU时钟
        nreset : in std_logic;      --全局复位信号
        M_A,M_B : in std_logic;     --暂存器控制信号
        M_F : in std_logic;         --程序状态字控制信号
        nALU_EN : in std_logic;     --alu运算结果输出使能
        nPSW_EN : in std_logic;     --psw输出使能
        C0 : in std_logic;          --进位输入
        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位
        F_in : in std_logic_vector(1 downto 0);     --移位功能选择
        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end ALU_test;

architecture Behavioral of ALU_test is
component clock
    Port(
        clk,rst:in std_logic;
        clk1,nclk1:out std_logic;   --clk
        clk2,nclk2:out std_logic;   --clk二分频
        w0,w1,w2,w3:out std_logic   --节拍信号
    );
end component;
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;
component ALU 
    port(
        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟
        nreset : in std_logic;      --全局复位信号
        M_A,M_B : in std_logic;     --暂存器控制信号
        M_F : in std_logic;         --程序状态字控制信号
        nALU_EN : in std_logic;     --alu运算结果输出使能
        nPSW_EN : in std_logic;     --psw输出使能
        C0 : in std_logic;          --进位输入
        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位
        F_in : in std_logic_vector(1 downto 0);     --移位功能选择
        
        regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);
        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线
        AC : out std_logic;     --半进位标志
        CY : out std_logic;     --进位标志
        ZN : out std_logic;     --零标志
        OV : out std_logic      --溢出标志
    );
end component;

signal nclk2,clk_line:std_logic;
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);
signal regA_out,regB_out,result_out:std_logic_vector(7 downto 0);

signal AC : std_logic;     --半进位标志
signal CY : std_logic;     --进位标志
signal ZN : std_logic;     --零标志
signal OV : std_logic;      --溢出标志

begin
clock_inst:clock port map(clk=&gt;clk,rst=&gt;nreset,nclk2=&gt;nclk2);
clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);
seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);
ALU_inst:ALU port map(clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,regA_out,regB_out,result_out,DATA_BUS,AC,CY,ZN,OV);

process(DATA_BUS,AC,CY,ZN,OV,regA_out,regB_out,result_out)
begin
    data_in_A&lt;=&quot;00000000&quot;&amp;DATA_BUS;
    data_in_B&lt;=&quot;000&quot;&amp; AC &amp; &quot;000&quot; &amp; CY &amp; &quot;000&quot; &amp; ZN &amp; &quot;000&quot; &amp; OV;
    data_in_C&lt;=regA_out&amp;regB_out;
    data_in_D&lt;=result_out&amp;&quot;00000000&quot;;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/22 11:58:10
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

entity ALU is
    port(
        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟
        nreset : in std_logic;      --全局复位信号
        M_A,M_B : in std_logic;     --暂存器控制信号
        M_F : in std_logic;         --程序状态字控制信号
        nALU_EN : in std_logic;     --alu运算结果输出使能
        nPSW_EN : in std_logic;     --psw输出使能
        C0 : in std_logic;          --进位输入
        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位
        F_in : in std_logic_vector(1 downto 0);     --移位功能选择
        
        regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);
        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线
        AC : out std_logic;     --半进位标志
        CY : out std_logic;     --进位标志
        ZN : out std_logic;     --零标志
        OV : out std_logic      --溢出标志
    );
end ALU;

architecture Behavioral of ALU is
component array_multiplier
    Port (
        clk:in std_logic;
        a_in,b_in:in std_logic_vector(7 downto 0);
        sum_out:out std_logic_vector(15 downto 0)
    );
end component;
component divider_origin
    Port(
        clk,start:in std_logic;
        ain:in std_logic_vector(15 downto 0);--除数(要求除数大于被除数！)
        bin:in std_logic_vector(7 downto 0);--被除数
        done:out std_logic;

        s,r:out std_logic_vector(7 downto 0)
    );
end component;

signal regA:std_logic_vector(8 downto 0);
signal regB:std_logic_vector(8 downto 0);
signal result:std_logic_vector(8 downto 0);
signal PSW_reg:std_logic_vector(7 downto 0);        --pws(0):CY psw(1):ZN

signal AC_signal :std_logic;
signal CY_signal :std_logic;
signal ZN_signal :std_logic;
signal OV_signal :std_logic;

signal multiplier_out:std_logic_vector(15 downto 0);
signal start,done:std_logic;
signal divider_ina:std_logic_vector(15 downto 0);
signal divider_r:std_logic_vector(7 downto 0);

begin
array_multiplier_inst:array_multiplier port map(clk_ALU,regA(7 downto 0),regB(7 downto 0),multiplier_out);
--divider_origin_inst:divider_origin port map(clk,start,divider_ina,DATA_BUS,done,result(7 downto 0),divider_r);

process(clk_ALU,nreset) 
variable count:integer:=0;
begin
    if(nreset = &#39;1&#39;)then
        start&lt;=&#39;1&#39;;   
        regA &lt;= &quot;000000000&quot;;
        regA &lt;= &quot;000000000&quot;;
        result &lt;= &quot;000000000&quot;;
        DATA_BUS &lt;= &quot;ZZZZZZZZ&quot;;
        AC&lt;= &#39;0&#39;;CY&lt;= &#39;0&#39;;ZN&lt;= &#39;0&#39;;OV&lt;= &#39;0&#39;;
        
    elsif(clk_ALU&#39;event and clk_ALU = &#39;1&#39;)then
        if(M_A=&#39;1&#39;and M_B=&#39;0&#39;)then     --锁存到A
            regA(7 downto 0) &lt;= DATA_BUS;
            regA(8) &lt;= &#39;0&#39;;
        elsif(M_A=&#39;0&#39;and M_B=&#39;1&#39;)then     --锁存到B 
            regB(7 downto 0) &lt;= DATA_BUS;
            regB(8) &lt;= &#39;0&#39;;
            
        elsif(nALU_EN = &#39;0&#39;)then
            case S is
                when &quot;00000&quot; =&gt;         --直传
                    result &lt;= regA;
                    CY_signal &lt;= result(8);
                when &quot;00001&quot; =&gt;         --加法
                    result &lt;= regA+regB+C0;
                    CY_signal &lt;= result(8);
                when &quot;00010&quot; =&gt;         --减法
                    result &lt;= regA - regB;
                    CY_signal &lt;= result(8);
                    if(regA&lt;regB)then OV_signal&lt;=&#39;1&#39;;end if; 
                when &quot;00100&quot; =&gt;         --乘法
                    result(7 downto 0) &lt;= multiplier_out(7 downto 0);
                    CY_signal &lt;= regA(8)xor regB(8);
                    if(regA*regB&gt;x&quot;FF&quot;)then OV_signal&lt;=&#39;1&#39;;end if; 
                when &quot;01000&quot; =&gt;         --除法
                    case count is
                        when 0=&gt;
                            divider_ina&lt;=regA(7 downto 0)&amp;regB(7 downto 0);
                            start&lt;=&#39;0&#39;;
                            count:=count+1;
                        when others=&gt;null;
                    end case;
                    CY_signal &lt;= regA(8)xor regB(8);
                    
                when &quot;10000&quot; =&gt;         --清零
                    regA &lt;= &quot;000000000&quot;;
                    result &lt;= regA;
                    CY_signal &lt;= &#39;0&#39;;
                when &quot;10001&quot; =&gt;         --与
                    result &lt;= regA and regB;
                    CY_signal &lt;= &#39;0&#39;;
                when &quot;10010&quot; =&gt;         --或
                    result &lt;= regA or regB;
                    CY_signal &lt;= &#39;0&#39;;
                when &quot;10100&quot; =&gt;         --A取非
                    result &lt;= not regA;
                    CY_signal &lt;= &#39;0&#39;;
                when &quot;11000&quot; =&gt;         --异或
                    result &lt;= regA xor regB;
                    CY_signal &lt;= &#39;0&#39;;
                when others =&gt;
                    result &lt;= &quot;000000000&quot;;
            end case;
            
            case F_in is 
                when &quot;00&quot; =&gt; DATA_BUS&lt;= result(7 downto 0);--直接传送
                when &quot;01&quot; =&gt; DATA_BUS&lt;= result(8 downto 1);--带C右移
                when &quot;10&quot; =&gt; DATA_BUS&lt;= result(6 downto 0)&amp;CY_signal;--循环左移
                when &quot;11&quot; =&gt; DATA_BUS&lt;= result(6 downto 0)&amp;&#39;0&#39;;--逻辑左移
                when others =&gt; DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);
            end case;
            
            CY &lt;= CY_signal;
            if(result=&quot;000000000&quot;)then ZN_signal&lt;=&#39;1&#39;;else ZN_signal&lt;=&#39;0&#39;;end if;
            ZN&lt;=ZN_signal;
            
        elsif(nPSW_EN = &#39;0&#39;)then
            PSW_reg(0) &lt;= CY_signal;
            PSW_reg(1) &lt;= ZN_signal;
            DATA_BUS&lt;= PSW_reg;
        else
            DATA_BUS &lt;= &quot;ZZZZZZZZ&quot;;
        end if;
        
    end if;
end process;

process(regA,regB,result)
begin
    regA_out&lt;=regA(7 downto 0);
    regB_out&lt;=regB(7 downto 0);
    result_out&lt;=result(7 downto 0);
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/23 13:34:13
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ALU_tb is
--  Port ( );
end ALU_tb;

architecture Behavioral of ALU_tb is
component ALU
    port(
        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟
        nreset : in std_logic;      --全局复位信号
        M_A,M_B : in std_logic;     --暂存器控制信号
        M_F : in std_logic;         --程序状态字控制信号
        nALU_EN : in std_logic;     --alu运算结果输出使能
        nPSW_EN : in std_logic;     --psw输出使能
        C0 : in std_logic;          --进位输入
        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位
        F_in : in std_logic_vector(1 downto 0);     --移位功能选择
        
        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线
        AC : out std_logic;     --半进位标志
        CY : out std_logic;     --进位标志
        ZN : out std_logic;     --零标志
        OV : out std_logic      --溢出标志
    );
end component;

signal clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0:std_logic;

signal S :std_logic_vector(4 downto 0);
signal F_in :std_logic_vector(1 downto 0);     
signal DATA_BUS:std_logic_vector(7 downto 0);   
signal AC : std_logic;     --半进位标志
signal CY : std_logic;     --进位标志
signal ZN : std_logic;     --零标志
signal OV : std_logic;      --溢出标志

begin
ALU_inst:ALU port map(clk,nclk2,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,DATA_BUS,AC,CY,ZN,OV);

clock:process
begin
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

clock_nclk2:process
begin
    nclk2&lt;=&#39;0&#39;;
    wait for 10ns;
    nclk2&lt;=&#39;1&#39;;
    wait for 10ns;
end process;

test:process
begin
    nreset&lt;=&#39;1&#39;;
    M_A&lt;=&#39;0&#39;;
    M_B&lt;=&#39;0&#39;;
    M_F&lt;=&#39;0&#39;;
    nALU_EN&lt;=&#39;1&#39;;
    nPSW_EN&lt;=&#39;1&#39;;
    C0&lt;=&#39;0&#39;;
    S&lt;=&quot;10010&quot;;
    F_in&lt;=&quot;00&quot;;
    wait for 25ns;
    
    nreset&lt;=&#39;0&#39;;
    DATA_BUS&lt;=X&quot;04&quot;;
    M_A&lt;=&#39;1&#39;;
    M_B&lt;=&#39;0&#39;;
    wait for 25ns;
    DATA_BUS&lt;=X&quot;02&quot;;
    M_A&lt;=&#39;0&#39;;
    M_B&lt;=&#39;1&#39;;
    wait for 25ns;
--    DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;
    M_A&lt;=&#39;0&#39;;
    M_B&lt;=&#39;0&#39;;
    nALU_EN&lt;=&#39;0&#39;;
    wait for 50ns;
    
    nALU_EN&lt;=&#39;1&#39;;
    nPSW_EN&lt;=&#39;0&#39;;
    wait;
    
end process;

end Behavioral;
</code></pre>
<p>xdc：</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/23 21:55:51
#----------------------------------------------------------------------------------
#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]

#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;DATA_BUS[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;DATA_BUS[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;DATA_BUS[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;DATA_BUS[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;DATA_BUS[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;DATA_BUS[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;DATA_BUS[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;DATA_BUS[7]&#125;]

#sw31~23
set_property PACKAGE_PIN J8         [get_ports nreset]
set_property IOSTANDARD LVCMOS18    [get_ports nreset]
set_property PACKAGE_PIN J14        [get_ports nALU_EN]
set_property IOSTANDARD LVCMOS18    [get_ports nALU_EN]
set_property PACKAGE_PIN H9         [get_ports nPSW_EN]
set_property IOSTANDARD LVCMOS18    [get_ports nPSW_EN]
set_property PACKAGE_PIN H8         [get_ports M_A]
set_property IOSTANDARD LVCMOS18    [get_ports M_A]
set_property PACKAGE_PIN G10        [get_ports M_B]
set_property IOSTANDARD LVCMOS18    [get_ports M_B]
set_property PACKAGE_PIN G9         [get_ports M_F]
set_property IOSTANDARD LVCMOS18    [get_ports M_F]
set_property PACKAGE_PIN J13        [get_ports C0]
set_property IOSTANDARD LVCMOS18    [get_ports C0]

#SW16~20
set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;S[4]&#125;]
set_property PACKAGE_PIN F8         [get_ports &#123;S[0]&#125;]
set_property PACKAGE_PIN F9         [get_ports &#123;S[1]&#125;]
set_property PACKAGE_PIN H11        [get_ports &#123;S[2]&#125;]
set_property PACKAGE_PIN H12        [get_ports &#123;S[3]&#125;]
set_property PACKAGE_PIN G14        [get_ports &#123;S[4]&#125;]

#SW22~23
set_property IOSTANDARD LVCMOS18    [get_ports &#123;F_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;F_in[1]&#125;]
set_property PACKAGE_PIN H14        [get_ports &#123;F_in[0]&#125;]
set_property PACKAGE_PIN J11        [get_ports &#123;F_in[1]&#125;]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]
</code></pre>
<h3 id="11-数据存储器-RAM-设计"><a href="#11-数据存储器-RAM-设计" class="headerlink" title="11.数据存储器 RAM 设计"></a>11.数据存储器 RAM 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0f5ae5f7d65bf36add50df2465e24d2.png"></p>
<p>高电平写操作有效，低电平读有效。其中 clk_RAM&#x3D;nclk1 &amp; W1，在组建 CPU 模块时使用。</p>
<p>1）读数据操作：clk_RAM 上升沿有效，RAM_CS 高电平，wr_nRD 低电平，nRAM_EN 低 电平，[AR] -&gt; data 。</p>
<p>2）写数据操作：clk_RAM 上升沿有效，RAM_CS 高电平，wr_nRD 高电平有效，data-&gt;[AR]。</p>
<p>源码：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/23 21:55:51
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity RAM is
    generic(
        depth:integer:=7;
        width:integer:=8
        );
    port( 
        clk_RAM:in STD_LOGIC;       --RAM时钟信号
        n_reset:in STD_LOGIC;       --RAM选择信号
        RAM_CS:in STD_LOGIC;        --RAM片选信号
        nRAM_EN:in STD_LOGIC;       --RAM输出使能
        Wr_nRD :in STD_LOGIC;       --RAM读写信号
        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号
        
        --DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线
        data_in:in STD_LOGIC_VECTOR (width-1 downto 0);
        data_out:out STD_LOGIC_VECTOR (width-1 downto 0)
        );
end RAM;

architecture Behavioral of RAM is

type ram_array is array(0 to 2**depth) of STD_LOGIC_VECTOR (width-1 downto 0);
signal index : integer range 0 to 2**depth;
signal SRAM:ram_array;

begin

process (n_reset,clk_RAM) 
begin
    index&lt;=conv_integer(AR);
    if(n_reset=&#39;1&#39;)  then 
        --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);
        data_out&lt;=(others=&gt;&#39;Z&#39;);
    elsif(clk_RAM&#39;event and clk_RAM=&#39;1&#39;) then
        if(RAM_CS=&#39;1&#39;)then
            if(Wr_nRD=&#39;1&#39;)then
                --SRAM(index)&lt;=DATA_BUS;
                SRAM(index)&lt;=data_in;
            elsif(nRAM_EN=&#39;0&#39;)then
                --DATA_BUS&lt;=SRAM(index);
                data_out&lt;=SRAM(index);
            else
                --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);
                data_out&lt;=(others=&gt;&#39;Z&#39;);
            end if;
        else 
            --DATA_BUS&lt;=(others=&gt;&#39;Z&#39;);
            data_out&lt;=(others=&gt;&#39;Z&#39;);
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/23 21:55:51
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity RAM_tb is
--  Port ( );
end RAM_tb;

architecture Behavioral of RAM_tb is
component RAM
    generic(
        depth:positive:=7;
        width:positive:=8
    );
    Port (
        clk_RAM:in STD_LOGIC;       --RAM时钟信号
        n_reset:in STD_LOGIC;       --RAM选择信号
        RAM_CS:in STD_LOGIC;        --RAM片选信号
        nRAM_EN:in STD_LOGIC;       --RAM输出使能
        Wr_nRD :in STD_LOGIC;       --RAM读写信号
        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号
        
        DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线
        --data_in:in STD_LOGIC_VECTOR (width-1 downto 0);
        --data_out:out STD_LOGIC_VECTOR (width-1 downto 0))
    );
end component;

signal clk_RAM,n_reset,RAM_CS,nRAM_EN,Wr_nRD:std_logic;
signal AR:std_logic_vector(6 downto 0);
signal DATA_BUS:std_logic_vector(7 downto 0);
signal data_in,data_out:std_logic_vector(7 downto 0);

begin

RAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;n_reset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,DATA_BUS=&gt;DATA_BUS);
--RAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;n_reset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,data_in=&gt;data_in,data_out=&gt;data_out);

clock:process
begin
    clk_RAM&lt;=&#39;1&#39;;
    wait for 5ns;
    clk_RAM&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    n_reset&lt;=&#39;1&#39;;
    wait for 25ns;
    n_reset&lt;=&#39;0&#39;;
    
    RAM_CS&lt;=&#39;1&#39;;
    nRAM_EN&lt;=&#39;1&#39;;
    Wr_nRD&lt;=&#39;1&#39;;
    AR&lt;=&quot;0000000&quot;;
    wait for 25ns;
    DATA_BUS&lt;=x&quot;FF&quot;;
    wait for 25ns;
    AR&lt;=&quot;0000001&quot;;
    wait for 25ns;
    DATA_BUS&lt;=x&quot;EE&quot;;
    wait for 25ns;
    
    nRAM_EN&lt;=&#39;0&#39;;
    Wr_nRD&lt;=&#39;0&#39;;
    AR&lt;=&quot;0000000&quot;;
    wait for 25ns;
    AR&lt;=&quot;0000001&quot;;
    
    wait;

end process;

end Behavioral;
</code></pre>
<p>xdc：</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/23 21:55:51
#----------------------------------------------------------------------------------
#sw0~6
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[0]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[1]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[2]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[3]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[4]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[5]&#125;]
set_property IOSTANDARD LVCMOS18 [get_ports &#123;AR[6]&#125;]
set_property PACKAGE_PIN C9 [get_ports &#123;AR[0]&#125;]
set_property PACKAGE_PIN B9 [get_ports &#123;AR[1]&#125;]
set_property PACKAGE_PIN G11 [get_ports &#123;AR[2]&#125;]
set_property PACKAGE_PIN F10 [get_ports &#123;AR[3]&#125;]
set_property PACKAGE_PIN D10 [get_ports &#123;AR[4]&#125;]
set_property PACKAGE_PIN E11 [get_ports &#123;AR[5]&#125;]
set_property PACKAGE_PIN D11 [get_ports &#123;AR[6]&#125;]

#LED
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[0]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[1]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[2]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[3]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[4]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[5]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[6]&#125;]
#set_property IOSTANDARD LVCMOS33 [get_ports &#123;DATA_BUS[7]&#125;]
#set_property PACKAGE_PIN G16 [get_ports &#123;DATA_BUS[0]&#125;]
#set_property PACKAGE_PIN H16 [get_ports &#123;DATA_BUS[1]&#125;]
#set_property PACKAGE_PIN D16 [get_ports &#123;DATA_BUS[2]&#125;]
#set_property PACKAGE_PIN D15 [get_ports &#123;DATA_BUS[3]&#125;]
#set_property PACKAGE_PIN C18 [get_ports &#123;DATA_BUS[4]&#125;]
#set_property PACKAGE_PIN C17 [get_ports &#123;DATA_BUS[5]&#125;]
#set_property PACKAGE_PIN B19 [get_ports &#123;DATA_BUS[6]&#125;]
#set_property PACKAGE_PIN C19 [get_ports &#123;DATA_BUS[7]&#125;]

#sw31
set_property PACKAGE_PIN J8 [get_ports n_reset]
set_property IOSTANDARD LVCMOS18 [get_ports n_reset]

#sw30~28
set_property PACKAGE_PIN J14 [get_ports RAM_CS]
set_property IOSTANDARD LVCMOS18 [get_ports RAM_CS]
set_property PACKAGE_PIN H9         [get_ports nRAM_EN]
set_property IOSTANDARD LVCMOS18    [get_ports nRAM_EN]
set_property PACKAGE_PIN H8         [get_ports Wr_nRD]
set_property IOSTANDARD LVCMOS18    [get_ports Wr_nRD]

#clk
set_property PACKAGE_PIN E10 [get_ports clk_RAM]
set_property IOSTANDARD LVCMOS18 [get_ports clk_RAM]

#LED
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[6]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;data_out[7]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;data_out[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;data_out[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;data_out[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;data_out[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;data_out[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;data_out[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;data_out[6]&#125;]
set_property PACKAGE_PIN C19 			[get_ports &#123;data_out[7]&#125;]

set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]
set_property PACKAGE_PIN B10        [get_ports &#123;data_in[0]&#125;]
set_property PACKAGE_PIN A10        [get_ports &#123;data_in[1]&#125;]
set_property PACKAGE_PIN B15        [get_ports &#123;data_in[2]&#125;]
set_property PACKAGE_PIN A15        [get_ports &#123;data_in[3]&#125;]
set_property PACKAGE_PIN A13        [get_ports &#123;data_in[4]&#125;]
set_property PACKAGE_PIN A12        [get_ports &#123;data_in[5]&#125;]
set_property PACKAGE_PIN D8         [get_ports &#123;data_in[6]&#125;]
set_property PACKAGE_PIN D9         [get_ports &#123;data_in[7]&#125;]
</code></pre>
<h3 id="12-堆栈指针-SP-设计"><a href="#12-堆栈指针-SP-设计" class="headerlink" title="12.堆栈指针 SP 设计"></a>12.堆栈指针 SP 设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/450ff7787e4fbc15befc93420b279e3f.png"></p>
<p>其中 clk_SP&#x3D;nclk2，在组建 CPU 模块时使用。</p>
<p>1）数据存储功能：clk_SP 上升沿有效，SP_CS 高电平，nSP_EN 高电平，data-&gt;SP。</p>
<p>2）加 1 功能：clk_SP 上升沿有效，SP_CS 高电平，SP_UP 高电平，nSP_EN 低电平有效，SP+1-&gt;SP,SP-&gt;AR。</p>
<p>3）减 1 功能：clk_SP 上升沿有效，SP_CS 高电平，SP_DN 高电平，nSP_EN 低电平有效， SP-1-&gt;SP,SP-&gt;AR。</p>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 13:45:37
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SP_test is
    Port(
        clk:in std_logic;       --时钟信号
        nreset:in std_logic;    --复位信号                
        SP_CS:in std_logic;     --SP选择信号
        SP_UP:in std_logic;     --SP+1控制
        SP_DN:in std_logic;     --SP-1控制
        nSP_EN:in std_logic;    --SP输出使能
        key_in:in std_logic;    --按键时钟
        
        AR:out std_logic_vector(6 downto 0);--SP指向RAM地址
        --data_in:in std_logic_vector(7 downto 0);
        --data_out:out std_logic_vector(7 downto 0)
        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线
    );
end SP_test;

architecture Behavioral of SP_test is
component SP
    Port(
        clk_SP:in std_logic;    --SP时钟信号
        nreset:in std_logic;    --复位信号                
        SP_CS:in std_logic;     --SP选择信号
        SP_UP:in std_logic;     --SP+1控制
        SP_DN:in std_logic;     --SP-1控制
        nSP_EN:in std_logic;    --SP输出使能
        
        AR:out std_logic_vector(6 downto 0);--SP指向RAM地址
        --data_in:in std_logic_vector(7 downto 0);
        --data_out:out std_logic_vector(7 downto 0)
        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线
    );
end component;
component key_stroke
    generic(CLK_FRE:integer:=100000000);
    Port (
        clk:in std_logic;
        reset:in std_logic;
        key_in:in std_logic;
        output:out std_logic           
    );
end component;

signal clk_line:STD_LOGIC;

begin

key_stroke_inst:key_stroke generic map(100000000)port map(clk,nreset,key_in,clk_line);
SP_inst:SP PORT MAP(clk_line,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);


end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ca7b953040d5420bd324dcceae3363c.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 10:52:17
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity SP is
    Port(
        clk_SP:in std_logic;    --SP时钟信号
        nreset:in std_logic;    --复位信号                
        SP_CS:in std_logic;     --SP选择信号
        SP_UP:in std_logic;     --SP+1控制
        SP_DN:in std_logic;     --SP-1控制
        nSP_EN:in std_logic;    --SP输出使能
        
        AR:out std_logic_vector(6 downto 0);--SP指向RAM地址
        --data_in:in std_logic_vector(7 downto 0);
        --data_out:out std_logic_vector(7 downto 0)
        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线
    );
end SP;

architecture Behavioral of SP is

signal SP_p:std_logic_vector(6 downto 0);--指向RAM地址

begin

process(clk_SP,nreset)
begin   
    if(nreset=&#39;0&#39;)then AR&lt;=(others=&gt;&#39;Z&#39;);
    elsif(clk_SP=&#39;1&#39;and clk_SP&#39;event)then
        if(SP_CS=&#39;1&#39;)then
            if(nSP_EN=&#39;1&#39;)then 
                --SP_p&lt;=data_in;
                SP_p&lt;=DATA_BUS(6 downto 0);
            else
                if(SP_UP=&#39;1&#39;and SP_DN=&#39;0&#39;)then SP_p&lt;=SP_p+1;
                elsif(SP_UP=&#39;0&#39;and SP_DN=&#39;1&#39;)then SP_p&lt;=SP_p-1;
                end if;
                --data_out&lt;=SP_p;
                AR&lt;=SP_p;
            end if;
        else AR&lt;=(others=&gt;&#39;Z&#39;);
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 13:29:19
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SP_tb is
--  Port ( );
end SP_tb;

architecture Behavioral of SP_tb is
component SP
    Port(
        clk_SP:in std_logic;    --SP时钟信号
        nreset:in std_logic;    --复位信号                
        SP_CS:in std_logic;     --SP选择信号
        SP_UP:in std_logic;     --SP+1控制
        SP_DN:in std_logic;     --SP-1控制
        nSP_EN:in std_logic;    --SP输出使能
        
        AR:out std_logic_vector(6 downto 0);--SP指向RAM地址
        --data_in:in std_logic_vector(7 downto 0);
        --data_out:out std_logic_vector(7 downto 0)
        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线
    );
end component;

signal clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN:STD_LOGIC;
signal AR:std_logic_vector(6 downto 0);
signal DATA_BUS:std_logic_vector(7 downto 0);

begin

SP_inst:SP PORT MAP(clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);

clock:process
begin
    clk_SP&lt;=&#39;1&#39;;
    wait for 5ns;
    clk_SP&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

test:process
begin
    nreset&lt;=&#39;0&#39;;
    SP_CS&lt;=&#39;1&#39;;
    SP_UP&lt;=&#39;0&#39;;
    SP_DN&lt;=&#39;0&#39;;
    nSP_EN&lt;=&#39;1&#39;;
    DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;
    wait for 25ns;
    
    DATA_BUS&lt;=x&quot;0F&quot;;
    nreset&lt;=&#39;1&#39;;
    wait for 25ns;
    
    SP_UP&lt;=&#39;1&#39;;
    SP_DN&lt;=&#39;0&#39;;
    nSP_EN&lt;=&#39;0&#39;;
    wait for 25ns;
    
    SP_UP&lt;=&#39;1&#39;;
    SP_DN&lt;=&#39;0&#39;;
    nSP_EN&lt;=&#39;0&#39;;
    wait for 25ns;
    
    SP_UP&lt;=&#39;0&#39;;
    SP_DN&lt;=&#39;1&#39;;
    nSP_EN&lt;=&#39;0&#39;;
    wait for 25ns;
    
    wait;
    
end process;

end Behavioral;
</code></pre>
<p>xdc：</p>
<pre><code>#clk
set_property PACKAGE_PIN E10 [get_ports clk]
set_property IOSTANDARD LVCMOS18 [get_ports clk]

#sw31~28
set_property PACKAGE_PIN J8 [get_ports nreset]
set_property IOSTANDARD LVCMOS18 [get_ports nreset]
set_property PACKAGE_PIN J14        [get_ports SP_CS]
set_property IOSTANDARD LVCMOS18    [get_ports SP_CS]
set_property PACKAGE_PIN H9         [get_ports key_in]
set_property IOSTANDARD LVCMOS18    [get_ports key_in]
set_property PACKAGE_PIN H8         [get_ports nSP_EN]
set_property IOSTANDARD LVCMOS18    [get_ports nSP_EN]
set_property PACKAGE_PIN G10        [get_ports SP_UP ]
set_property IOSTANDARD LVCMOS18    [get_ports SP_UP ]
set_property PACKAGE_PIN G9         [get_ports SP_DN ]
set_property IOSTANDARD LVCMOS18    [get_ports SP_DN ]

#LED0~6
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[0]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[1]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[2]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[3]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[4]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[5]&#125;]
set_property IOSTANDARD LVCMOS33 		[get_ports &#123;AR[6]&#125;]
set_property PACKAGE_PIN G16			[get_ports &#123;AR[0]&#125;]
set_property PACKAGE_PIN H16 			[get_ports &#123;AR[1]&#125;]
set_property PACKAGE_PIN D16 			[get_ports &#123;AR[2]&#125;]
set_property PACKAGE_PIN D15 			[get_ports &#123;AR[3]&#125;]
set_property PACKAGE_PIN C18 			[get_ports &#123;AR[4]&#125;]
set_property PACKAGE_PIN C17 			[get_ports &#123;AR[5]&#125;]
set_property PACKAGE_PIN B19 			[get_ports &#123;AR[6]&#125;]

#SW0~7
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;DATA_BUS[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;DATA_BUS[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;DATA_BUS[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;DATA_BUS[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;DATA_BUS[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;DATA_BUS[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;DATA_BUS[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;DATA_BUS[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;DATA_BUS[7]&#125;]
</code></pre>
<h3 id="13-采用硬件描述语言语言设计-IO-模块"><a href="#13-采用硬件描述语言语言设计-IO-模块" class="headerlink" title="13.采用硬件描述语言语言设计 IO 模块"></a>13.采用硬件描述语言语言设计 IO 模块</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/de38a24f3d908b663a479d455c4f613d.png"></p>
<p>其中 clk_P0&#x3D;nclk2，在组建 CPU 模块时使用。</p>
<p>1）输入锁存：</p>
<pre><code>    clk_PO 上升沿有效，P0_CS 高电平，P0_IEN 低电平，

    P0_IN-&gt; 暂存器，RIEN 低电平， 暂存器 -&gt;数据总线（data）。
</code></pre>
<p>2）输出锁存：</p>
<pre><code>    clk_PO 上升沿有效，P0_CS 高电平，P0_OEN 低电平，

    数据总线（data）-&gt;暂存器，ROEN 低电平，暂存器 -&gt;P0_OUT。
</code></pre>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 14:37:22
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IO_test is
    Port(
        clk:in std_logic;    --IO时钟信号
        nreset:in std_logic;    --IO复位信号
        IO_CS:in std_logic;     --IO选择信号
        IO_IEN:in std_logic;    --IO输入使能
        IO_OEN:in std_logic;    --IO输出使能
        RI_EN:in std_logic;     --IO缓存器输入使能
        RO_EN:in std_logic;     --IO缓存器输出使能
        IO_in:in std_logic_vector(7 downto 0);          --IO输入
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end IO_test;

architecture Behavioral of IO_test is

component IO
    Port(
        clk_IO:in std_logic;    --IO时钟信号
        nreset:in std_logic;    --IO复位信号
        IO_CS:in std_logic;     --IO选择信号
        IO_IEN:in std_logic;    --IO输入使能
        IO_OEN:in std_logic;    --IO输出使能
        RI_EN:in std_logic;     --IO缓存器输入使能
        RO_EN:in std_logic;     --IO缓存器输出使能
        IO_in:in std_logic_vector(7 downto 0);          --IO输入
        
        IO_out:out std_logic_vector(7 downto 0);        --IO输出
        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线
    );
end component;
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;

signal clk_line,rst_seg:std_logic;
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0); 
signal IO_out,DATA_BUS:std_logic_vector(7 downto 0);

begin

IO_inst:IO port map(clk,nreset,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN,IO_in,IO_out,DATA_BUS);
clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);
seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);

process(IO_in,IO_out,DATA_BUS)
begin
    data_in_A&lt;=&quot;00000000&quot;&amp;IO_in;
    data_in_B&lt;=&quot;00000000&quot;&amp;DATA_BUS;
    data_in_C&lt;=&quot;00000000&quot;&amp;IO_out;
    data_in_D&lt;=&quot;0000000000000000&quot;;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7c0424c57486f62ce1df707bbc1d0f14.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: 
-- Create Date: 2024/04/24 14:06:31
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IO is
    Port(
        clk_IO:in std_logic;    --IO时钟信号
        nreset:in std_logic;    --IO复位信号
        IO_CS:in std_logic;     --IO选择信号
        IO_IEN:in std_logic;    --IO输入使能
        IO_OEN:in std_logic;    --IO输出使能
        RI_EN:in std_logic;     --IO缓存器输入使能
        RO_EN:in std_logic;     --IO缓存器输出使能
        IO_in:in std_logic_vector(7 downto 0);          --IO输入
        
        IO_out:out std_logic_vector(7 downto 0);        --IO输出
        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线
    );
end IO;

architecture Behavioral of IO is
signal reg:std_logic_vector(7 downto 0);
begin

process(nreset,clk_IO)
begin
    if(nreset=&#39;0&#39;)then IO_out&lt;=&quot;ZZZZZZZZ&quot;;DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;
    elsif(clk_IO=&#39;1&#39;and clk_IO&#39;event)then
        if(IO_CS=&#39;1&#39;)then
            if(IO_IEN=&#39;0&#39;)then 
                reg&lt;=IO_in;
                if(RI_EN=&#39;0&#39;)then DATA_BUS&lt;=reg;end if;
            elsif(IO_OEN=&#39;0&#39;)then 
                reg&lt;=DATA_BUS;
                if(RO_EN=&#39;0&#39;)then IO_out&lt;=reg;END IF;
            end if; 
        else IO_out&lt;=&quot;ZZZZZZZZ&quot;;DATA_BUS&lt;=&quot;ZZZZZZZZ&quot;;
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>xdc：</p>
<pre><code>#----------------------------------------------------------------------------------
#-- Engineer: switch_swq
#-- Create Date: 2024/04/24 15:50:00
#----------------------------------------------------------------------------------
#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#SW0~7
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IO_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;IO_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;IO_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;IO_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;IO_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;IO_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;IO_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;IO_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;IO_in[7]&#125;]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports nreset]
set_property IOSTANDARD LVCMOS18    [get_ports nreset]
set_property PACKAGE_PIN J14        [get_ports IO_CS]
set_property IOSTANDARD LVCMOS18    [get_ports IO_CS]
set_property PACKAGE_PIN H9         [get_ports IO_IEN]
set_property IOSTANDARD LVCMOS18    [get_ports IO_IEN]
set_property PACKAGE_PIN H8         [get_ports IO_OEN]
set_property IOSTANDARD LVCMOS18    [get_ports IO_OEN]
set_property PACKAGE_PIN G10        [get_ports RI_EN]
set_property IOSTANDARD LVCMOS18    [get_ports RI_EN]
set_property PACKAGE_PIN G9         [get_ports RO_EN]
set_property IOSTANDARD LVCMOS18    [get_ports RO_EN]
</code></pre>
<h3 id="14-微控制器设计"><a href="#14-微控制器设计" class="headerlink" title="14.微控制器设计"></a>14.微控制器设计</h3><p>微程序控制器基本原理：</p>
<pre><code>    1)将指令分解为基本的微命令序列，把操作控制信号编制成微指令，存放到控制存储器 (CM)。

    2)运行时，从控存中取出微指令，产生指令运行所需的操作控制信号。
</code></pre>
<p>微程序控制器基本结构：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3df769d2ac5eb7d9b1a2a850829c1e56.png"></p>
<p> 控制存储器 CM –存放微程序</p>
<p> 微指令寄存器 µIR –存放现行微指令</p>
<p> 微地址形成电路–提供下一条微地址</p>
<p> 微地址寄存器 µAR–存放现在微地址</p>
<p>控制信号设计：</p>
<pre><code>    • 39 条控制信号（39 位编码）

    • 27 条指令（5 位编码）-&gt;8 位微地址
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29292e122740addc20eb4a530ec67bd0.png"></p>
<p>其中 clk_MC&#x3D;clk2 &amp; W0，在组建 CPU 模块时使用。</p>
<p>源码：</p>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/25 16:09:02
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uC_test is
    Port(
        clk:in std_logic;    --微程序控制器时钟信号
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;      --微地址控制信号
        IR:in std_logic_vector(7 downto 2); --IR操作码信息
        CMROM_CS:in std_logic;  --控制存储器选通信号
        
        seg_dig : out std_logic_vector(15 downto 0);
        seg_data : out std_logic_vector(7 downto 0)
    );
end uC_test;

architecture Behavioral of uC_test is
component uC
    Port(
        clk_uC:in std_logic;    --微程序控制器时钟信号
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;      --微地址控制信号
        IR:in std_logic_vector(7 downto 2); --IR操作码信息
        CMROM_CS:in std_logic;  --控制存储器选通信号
        
        CM:out std_logic_vector(47 downto 8)    --控制信号输出
    );
end component;
component clock
    Port(
        clk,rst:in std_logic;
        clk1,nclk1:out std_logic;   --clk
        clk2,nclk2:out std_logic;   --clk二分频
        w0,w1,w2,w3:out std_logic   --节拍信号
    );
end component;
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;

signal clk_line,clk_line2,clk_uC,clk2,w0:std_logic;
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0); 
signal CM_line:std_logic_vector(47 downto 8);

begin

uC_inst:uC port map(clk_uC,nreset,M_uA,IR,CMROM_CS,CM_line);
clock_inst:clock port map(clk=&gt;clk_line2,rst=&gt;nreset,clk2=&gt;clk2,w0=&gt;w0);
clk_div_inst:clk_div generic map(10000)port map(nreset,clk,clk_line);
clk_div_inst2:clk_div generic map(10000000)port map(nreset,clk,clk_line2);
seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);

process(clk2,w0)
begin
    clk_uC&lt;=clk2 and w0;
end process;

process(IR,CM_line)
begin
    data_in_A&lt;=&quot;0000000000&quot;&amp;IR;
    data_in_B&lt;=CM_line(15 downto 8)&amp;&quot;00000000&quot;;
    data_in_C&lt;=CM_line(31 downto 16);
    data_in_D&lt;=CM_line(47 downto 32);
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef02d5402b0594182dafe67debe07644.png"></p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 16:22:50
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uC is
    Port(
        clk_uC:in std_logic;    --微程序控制器时钟信号
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;      --微地址控制信号
        IR:in std_logic_vector(7 downto 2); --IR操作码信息
        CMROM_CS:in std_logic;  --控制存储器选通信号
        
        CM:out std_logic_vector(47 downto 8)    --控制信号输出
    );
end uC;

architecture Behavioral of uC is
component uC_uA
    Port(
        clk:in std_logic;
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;
        IR:in std_logic_vector(7 downto 2);     --IR操作码信息
        uA_in:in std_logic_vector(7 downto 0);  --uIR传送的微地址
        
        uA_out:out std_logic_vector(7 downto 0) --下一条微指令的地址
    );
end component;
component uC_uAR
    Port(
        clk:in std_logic;
        nreset: in std_logic;
        uAR_in:in std_logic_vector(7 downto 0);  --uA传送的微地址
        
        uAR_out:out std_logic_vector(7 downto 0) --送至uCM的地址
    );
end component;
component uC_CM
    generic(
        width:integer := 48;    --位宽
        depth:integer := 8      --深度
    );
    port(
        clk:in std_logic;
        addr:in std_logic_vector(depth-1 downto 0);     ----uC_ROM地址
        CMROM_CS:in std_logic;  --uC_ROM输出使能
        
        data_out:out std_logic_vector(width-1 downto 0) --uC_ROM输出
    );
end component;
component uC_uIR
  Port (
    clk:in std_logic;
    CM:in std_logic_vector(47 downto 0);
    
    uA:out std_logic_vector(7 downto 0);
    uI:out std_logic_vector(47 downto 8)
  );
end component;

signal uA_in,uA_out,uAR_out:std_logic_vector(7 downto 0); 
signal CM_line:std_logic_vector(47 downto 0);

begin

uC_uA_inst:uC_uA port map(clk_uC,nreset,M_uA,IR,uA_in,uA_out);
uC_uAR_inst:uC_uAR port map(clk_uC,nreset,uA_out,uAR_out);
uC_uCM_inst:uC_CM generic map(48,8)port map(clk_uC,uAR_out,CMROM_CS,CM_line);
uC_uIR_inst:uC_uIR port map(clk_uC,CM_line,uA_in,CM);

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/63008edd2b3325b6e6ef2c8e700998d8.png"></p>
<p><img src="https://img-blog.csdnimg.cn/direct/e135b733d411449797e2018f91c18b99.png"></p>
<p>  模块：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 16:22:50
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.std_logic_unsigned.all;
use IEEE.std_logic_textio.all;
use STD.textio.all;

entity uC_CM is
    generic(
        width:integer := 48;    --位宽
        depth:integer := 8      --深度
    );
    port(
        clk:in std_logic;
        addr:in std_logic_vector(depth-1 downto 0);     ----uC_ROM地址
        CMROM_CS:in std_logic;  --uC_ROM输出使能
        
        data_out:out std_logic_vector(width-1 downto 0) --uC_ROM输出
    );
end uC_CM;

architecture Behavioral of uC_CM is

type matrix is array(integer range&lt;&gt;) of std_logic_vector(width-1 downto 0);
signal uC_ROM : matrix(0 to 2**depth-1);

procedure load_rom(signal data_word:out matrix) is 
    file romfile:text open read_mode is &quot;uC_ROM.txt&quot;;
    variable lbuf:line;
    variable i:integer := 0; --循环变量
    variable fdata:std_logic_vector(width-1 downto 0);
begin
    while(not endfile(romfile) and i&lt;2**depth) loop
        readline(romfile,lbuf); -- 逐行读数据
        read(lbuf,fdata); -- 将行数据保存到变量fdata
        data_word(i)&lt;=fdata; -- 将fdata保存到内存信号量中
        i := i+1;
    end loop;
end procedure;

begin

load_rom(uC_ROM);
data_out &lt;= uC_ROM(conv_integer(addr)) when CMROM_CS=&#39;1&#39;else(others=&gt;&#39;0&#39;);

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 16:22:50
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uC_uA is
    Port(
        clk:in std_logic;
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;
        IR:in std_logic_vector(7 downto 2);     --IR操作码信息
        uA_in:in std_logic_vector(7 downto 0);  --uIR传送的微地址
        
        uA_out:out std_logic_vector(7 downto 0) --下一条微指令的地址
    );
end uC_uA;

architecture Behavioral of uC_uA is

begin

process(clk,nreset)
begin
    if(nreset=&#39;0&#39;)then uA_out&lt;=(others=&gt;&#39;0&#39;);
    elsif(clk=&#39;1&#39;and clk&#39;event)then
        if(M_uA=&#39;1&#39;)then uA_out&lt;=IR&amp;&quot;00&quot;;
        else uA_out&lt;=uA_in;
        end if;
    end if;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 16:22:50
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uC_uAR is
    Port(
        clk:in std_logic;
        nreset: in std_logic;
        uAR_in:in std_logic_vector(7 downto 0);  --uA传送的微地址
        
        uAR_out:out std_logic_vector(7 downto 0) --送至uCM的地址
    );
end uC_uAR;

architecture Behavioral of uC_uAR is

begin

process(clk,nreset)
begin
    if(nreset=&#39;0&#39;)then uAR_out&lt;=(others=&gt;&#39;0&#39;);
    elsif(clk=&#39;1&#39;and clk&#39;event)then uAR_out&lt;=uAR_in;
    end if;
end process;

end Behavioral;



----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/24 16:22:50
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uC_uIR is
  Port (
    clk:in std_logic;
    CM:in std_logic_vector(47 downto 0);
    
    uA:out std_logic_vector(7 downto 0);
    uI:out std_logic_vector(47 downto 8)
  );
end uC_uIR;

architecture Behavioral of uC_uIR is

begin

uA&lt;=CM(7 downto 0);
uI&lt;=CM(47 downto 8);

end Behavioral;
</code></pre>
<p> uC_ROM.txt：</p>
<pre><code>100000000000000000000000000000000000000000000001
010000000000000000000000000000000000000000000010
001000000000000000000000000000000000000000000011
000100000000000000000000000000000000000000000100
000010000000000000000000000000000000000000000101
000001000000000000000000000000000000000000000110
000000100000000000000000000000000000000000000111
000000010000000000000000000000000000000000000000
</code></pre>
<p>xdc：</p>
<pre><code>#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]

#SW0~15
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;IR[7]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;IR[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;IR[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;IR[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;IR[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;IR[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;IR[7]&#125;]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports nreset]
set_property IOSTANDARD LVCMOS18    [get_ports nreset]
set_property PACKAGE_PIN J14         [get_ports CMROM_CS]
set_property IOSTANDARD LVCMOS18    [get_ports CMROM_CS]
set_property PACKAGE_PIN H9        [get_ports M_uA]
set_property IOSTANDARD LVCMOS18    [get_ports M_uA]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]
</code></pre>
<h3 id="15-8-位-SOC-综合设计"><a href="#15-8-位-SOC-综合设计" class="headerlink" title="15.8 位 SOC 综合设计"></a>15.8 位 SOC 综合设计</h3><p>根据以上所设计的功能模块连接成完整的 8 位 SOC 结构。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cfdc1dbc85d346b9c3541e7e13e4fd2f.png"></p>
<p>模块修改记录：</p>
<pre><code>SOC:
修改PC/ROM
*修改各模块时钟
修改各模块总线输出时机提高片选及使能优先级，并加入到敏感检测列表
修改uC使能：M_uA和CMROM_CS低电平有效（根据指令知）
uC输入输出冲突，同时输入输出控制信号
修改微指令34H：IO_CS位
修改微指令38H：IO_CS位
修改微指令24H：Ri_EN错误
修改微指令8AH：M_PC位
修改微指令65H： RDRi位
PC不再产生nPCL和nPCH信号并修改PC模块
ADD微程序增加一条微指令
</code></pre>
<p>源码：</p>
<p>顶层测试：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/27 20:08:24
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity CPU_test is
    generic(
        CLK_FRE:integer:=100000000
    );
    Port(
        clk:in std_logic;
        nreset:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end CPU_test;

architecture Behavioral of CPU_test is
component CPU
    generic(
        CLK_FRE:integer:=100000000
    );
    Port(
        clk:in std_logic;
        nreset:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        
        regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);
        data_out:out std_logic_vector(7 downto 0)
    );
end component;
component clk_div
    generic(
        DIV_NUM:integer:=10000
    );
    Port (
        rst:in std_logic;
        clk_in:in std_logic;
        clk_out:out std_logic
    );
end component;
component seg_dis
    port(
        rst,clk:in std_logic;
        data_in_A,data_in_B,data_in_C,data_in_D:in std_logic_vector(15 downto 0);
        
        seg_dig:out std_logic_vector(15 downto 0);
        seg_data:out std_logic_vector(7 downto 0)--管脚连接顺序：dp,g,f,e,d,c,b,a
    );
end component;
signal clk_line:std_logic;
signal data_in_A,data_in_B,data_in_C,data_in_D:std_logic_vector(15 downto 0);
signal regA_out,regB_out,result_out,data_out:std_logic_vector(7 downto 0);
begin
clk_div_inst:clk_div generic map(1000000)port map(nreset,clk,clk_line);
seg_dis_inst:seg_dis port map(nreset,clk_line,data_in_A,data_in_B,data_in_C,data_in_D,seg_dig,seg_data);
CPU_inst:CPU generic map(100000000)port map(clk_line,nreset,data_in,regA_out,regB_out,result_out,data_out);

process(regA_out,regB_out,result_out,data_out)
begin
    data_in_A&lt;=&quot;00000000&quot;&amp;result_out;
    data_in_B&lt;=&quot;00000000&quot;&amp;regB_out;
    data_in_C&lt;=&quot;00000000&quot;&amp;regA_out;
    data_in_D&lt;=&quot;00000000&quot;&amp;data_out;
end process;

end Behavioral;
</code></pre>
<p>顶层：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/25 17:50:57
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity CPU is
    generic(
        CLK_FRE:integer:=100000000
    );
    Port(
        clk:in std_logic;
        nreset:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        
        regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);
        data_out:out std_logic_vector(7 downto 0)
    );
end CPU;

architecture Behavioral of CPU is
signal clk1,nclk1:std_logic;   --clk
signal clk2,nclk2:std_logic;   --clk二分频
signal w0,w1,w2,w3:std_logic;   --节拍信号
component clock
    Port(
        clk,rst:in std_logic;
        clk1,nclk1:out std_logic;   --clk
        clk2,nclk2:out std_logic;   --clk二分频
        w0,w1,w2,w3:out std_logic   --节拍信号
    );
end component;

signal clk_uC,M_uA,CMROM_CS:std_logic;
signal IR_line:std_logic_vector(7 downto 0);
signal CTR_BUS:std_logic_vector(47 downto 8);
component uC
    Port(
        clk_uC:in std_logic;    --微程序控制器时钟信号
        nreset:in std_logic;    --复位信号
        M_uA:in std_logic;      --微地址控制信号
        IR:in std_logic_vector(7 downto 2); --IR操作码信息
        CMROM_CS:in std_logic;  --控制存储器选通信号
        
        CM:out std_logic_vector(47 downto 8)    --控制信号输出
    );
end component;

signal clk_SP,SP_CS,SP_UP,SP_DN,nSP_EN:STD_LOGIC;
signal AR:std_logic_vector(6 downto 0);
signal DATA_BUS:std_logic_vector(7 downto 0);
component SP
    Port(
        clk_SP:in std_logic;    --SP时钟信号
        nreset:in std_logic;    --复位信号                
        SP_CS:in std_logic;     --SP选择信号
        SP_UP:in std_logic;     --SP+1控制
        SP_DN:in std_logic;     --SP-1控制
        nSP_EN:in std_logic;    --SP输出使能
        
        AR:out std_logic_vector(6 downto 0);--SP指向RAM地址
        DATA_BUS:inout std_logic_vector(7 downto 0)   --数据总线
    );
end component;

signal clk_IO,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN:std_logic;
signal IO_in,IO_out:std_logic_vector(7 downto 0);
component IO
    Port(
        clk_IO:in std_logic;    --IO时钟信号
        nreset:in std_logic;    --IO复位信号
        IO_CS:in std_logic;     --IO选择信号
        IO_IEN:in std_logic;    --IO输入使能
        IO_OEN:in std_logic;    --IO输出使能
        RI_EN:in std_logic;     --IO缓存器输入使能
        RO_EN:in std_logic;     --IO缓存器输出使能
        IO_in:in std_logic_vector(7 downto 0);          --IO输入
        
        IO_out:out std_logic_vector(7 downto 0);        --IO输出
        DATA_BUS:inout std_logic_vector(7 downto 0)    --数据总线
    );
end component;

signal clk_RAM,RAM_CS,nRAM_EN,Wr_nRD:std_logic;
component RAM
    generic(
        depth:positive:=7;
        width:positive:=8
    );
    Port (
        clk_RAM:in STD_LOGIC;       --RAM时钟信号
        n_reset:in STD_LOGIC;       --RAM选择信号
        RAM_CS:in STD_LOGIC;        --RAM片选信号
        nRAM_EN:in STD_LOGIC;       --RAM输出使能
        Wr_nRD :in STD_LOGIC;       --RAM读写信号
        AR:in STD_LOGIC_VECTOR (depth-1 downto 0);  --RAM地址信号
        
        DATA_BUS: inout STD_LOGIC_VECTOR (width-1 downto 0) --数据总线
    );
end component;

signal clk_ALU,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0:std_logic;
signal S :std_logic_vector(4 downto 0);
signal F_in :std_logic_vector(1 downto 0);    
--signal regA_out,regB_out,result_out:std_logic_vector(7 downto 0);
signal AC : std_logic;     --半进位标志
signal CY : std_logic;     --进位标志
signal ZN : std_logic;     --零标志
signal OV : std_logic;      --溢出标志
component ALU 
    port(
        clk,clk_ALU : in std_logic; --全局时钟和ALU时钟
        nreset : in std_logic;      --全局复位信号
        M_A,M_B : in std_logic;     --暂存器控制信号
        M_F : in std_logic;         --程序状态字控制信号
        nALU_EN : in std_logic;     --alu运算结果输出使能
        nPSW_EN : in std_logic;     --psw输出使能
        C0 : in std_logic;          --进位输入
        S : in std_logic_vector(4 downto 0);        --运算类型和操作选择，M为最高位S(4),其余在低四位
        F_in : in std_logic_vector(1 downto 0);     --移位功能选择
        
        regA_out,regB_out,result_out:out std_logic_vector(7 downto 0);
        DATA_BUS : inout std_logic_vector(7 downto 0);  --数据总线
        AC : out std_logic;     --半进位标志
        CY : out std_logic;     --进位标志
        ZN : out std_logic;     --零标志
        OV : out std_logic      --溢出标志
    );
end component;

signal clk_RN,Rn_CS,nRi_EN,RDRi,WRRi:std_logic;
signal RS,RD:std_logic;
component RN
    Port(
        clk_RN,Rn_CS,nRi_EN,RDRi,WRRi:in std_logic;
        RS,RD:in std_logic;

        DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end component;

signal clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen: std_logic;
signal IR_AR       :std_logic_vector(6 downto 0);
component IR
    Port (
        rst,clk_IR,LD_IR1,LD_IR2,LD_IR3,nARen:in std_logic;
        DATA_BUS:in std_logic_vector(7 downto 0);
        
        IR_out:out std_logic_vector(7 downto 0);--传送指令到指令寄存器
        RS,RD:out std_logic;--传送操作寄存器（寄存器地址）
        PC_out:out std_logic_vector(11 downto 0);--PC地址总线
        AR:out std_logic_vector(6 downto 0)
    );
end component;

signal clk_ROM,M_ROM,ROM_EN:std_logic;
signal ROM_PC:std_logic_vector(11 downto 0);
component ROM
    generic(
        depth:positive:=12;
        width:positive:=8
    );
    Port (
        clk_ROM,M_ROM,ROM_EN:in std_logic;
        addr:in std_logic_vector(11 downto 0);
        DATA_BUS:inout std_logic_vector(7 downto 0)
    );
end component;

signal clk_PC,M_PC,nLD_PC,nPCH,nPCL:std_logic;
signal PC_in:std_logic_vector(11 downto 0):=(others=&gt;&#39;0&#39;);
component pc
    Port (        
        rst,clk_PC,M_PC,nLD_PC:in std_logic;
        nPCH,nPCL:in std_logic;
        PC_in:in std_logic_vector(11 downto 0);
        
        PC_out:out std_logic_vector(11 downto 0);
        DATA_BUS:inout std_logic_vector(7 downto 0)
     );
end component;

signal test_line:std_logic_vector(7 downto 0);

begin

clock_inst:clock port map(clk,nreset,clk1,nclk1,clk2,nclk2,w0,w1,w2,w3);
PC_inst:PC port map(nreset,clk_PC,M_PC,nLD_PC,nPCH,nPCL,PC_in,ROM_PC,DATA_BUS);
ROM_inst:ROM generic map(12,8)port map(clk_ROM,M_ROM,ROM_EN,ROM_PC,DATA_BUS);
uC_inst:uC port map(clk_uC,nreset,M_uA,IR_line(7 downto 2),CMROM_CS,CTR_BUS);
IR_inst:IR port map(rst=&gt;nreset,clk_IR=&gt;clk_IR,LD_IR1=&gt;LD_IR1,LD_IR2=&gt;LD_IR2,LD_IR3=&gt;LD_IR3,nARen=&gt;nARen,DATA_BUS=&gt;DATA_BUS,IR_out=&gt;IR_line,RS=&gt;RS,RD=&gt;RD,PC_out=&gt;PC_in,AR=&gt;AR(6 downto 0));
RAM_inst:RAM generic map(7,8)port map(clk_RAM=&gt;clk_RAM,n_reset=&gt;nreset,RAM_CS=&gt;RAM_CS,nRAM_EN=&gt;nRAM_EN,Wr_nRD=&gt;Wr_nRD,AR=&gt;AR,DATA_BUS=&gt;DATA_BUS);
IO_inst:IO port map(clk_IO,nreset,IO_CS,IO_IEN,IO_OEN,RI_EN,RO_EN,data_in,data_out,DATA_BUS);
--SP_inst:SP PORT MAP(clk_SP,nreset,SP_CS,SP_UP,SP_DN,nSP_EN,AR,DATA_BUS);
ALU_inst:ALU port map(clk,clk_ALU,nreset,m_A,m_B,m_F,nALU_EN,nPSW_EN,C0,S,F_in,regA_out,regB_out,result_out,DATA_BUS,AC,CY,ZN,OV);
RN_inst:RN port map(clk_RN,Rn_CS,nRi_EN,RDRi,WRRi,RS,RD,DATA_BUS);

clk_PC&lt;=clk1 and clk2;
clk_ROM&lt;=nclk1 and clk2;
clk_IR&lt;=clk1 and nclk2;
clk_uC&lt;=nclk1 and nclk2;
clk_RN&lt;=clk1 and nclk2;
clk_ALU&lt;=nclk1 and nclk2;
--clk_IO&lt;=clk2;--（LED程序使用）
clk_IO&lt;=nclk1 and clk2;--（ADD程序使用）
clk_RAM&lt;=nclk1 and w1;
clk_SP&lt;=clk1 and clk2 and w1;

M_A &lt;= CTR_BUS(47);
M_B &lt;= CTR_BUS(46);
M_F &lt;= CTR_BUS(45);
S(4) &lt;= CTR_BUS(44);
S(3) &lt;= CTR_BUS(43);
S(2) &lt;= CTR_BUS(42);
S(1) &lt;= CTR_BUS(41);
S(0) &lt;= CTR_BUS(40);
F_in(1) &lt;= CTR_BUS(39);
F_in(0) &lt;= CTR_BUS(38);
nALU_EN &lt;= CTR_BUS(37);
nPSW_EN &lt;= CTR_BUS(36);
C0 &lt;= CTR_BUS(35);
RAM_CS &lt;= CTR_BUS(34);
Wr_nRD &lt;= CTR_BUS(33); 
nRAM_EN &lt;= CTR_BUS(32);
Rn_CS &lt;= CTR_BUS(31);
RDRi &lt;= CTR_BUS(30);
WRRi &lt;= CTR_BUS(29);
nRi_EN &lt;= CTR_BUS(28);
LD_IR1 &lt;= CTR_BUS(27);
LD_IR2 &lt;= CTR_BUS(26);
LD_IR3 &lt;= CTR_BUS(25);
nAREN &lt;= CTR_BUS(24);
M_PC &lt;= CTR_BUS(23);
nLD_PC &lt;= CTR_BUS(22); 
nPCH &lt;= CTR_BUS(21); 
nPCL &lt;= CTR_BUS(20); 
SP_UP &lt;= CTR_BUS(19);
SP_DN &lt;= CTR_BUS(18);
SP_CS &lt;= CTR_BUS(17); 
nSP_EN &lt;= CTR_BUS(16); 
IO_CS &lt;= CTR_BUS(15);
IO_IEN &lt;= CTR_BUS(14);
IO_OEN &lt;= CTR_BUS(13);
RI_EN&lt;=&#39;0&#39;;
RO_EN&lt;=&#39;0&#39;;
-- &lt;= CTR_BUS(12);
M_ROM &lt;= CTR_BUS(11);
ROM_EN &lt;= CTR_BUS(10);
M_uA &lt;= CTR_BUS(9);
CMROM_CS &lt;= CTR_BUS(8);

process(nPCH,nPCL)
begin
    if(nPCH=&#39;0&#39;)then PC_in(11 downto 8)&lt;=DATA_BUS(3 downto 0);
    elsif(nPCL=&#39;0&#39;)then PC_in(7 downto 0)&lt;=DATA_BUS;
    end if;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b870e7e63c2438527c9603091d047576.png"></p>
<p>时钟：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bd3c1b7d51ed7ee02fd3b42b4c4ba89.png"></p>
<p>ADD微程序：</p>
<pre><code>00111000 --IR:38H MOV Ri,IO
00111011 --IR:38H MOV Ri,IO
00001000 --ADD R0,R1
00000100 --JMP addr12
00000000 --addr1:00H
00000000 --addr2:00H
</code></pre>
<p>LED微程序：</p>
<pre><code>00100100 --IR:24H MOV Ri,#data
00000001 --data:01H
00110100 --IR:34H MOV IO,Ri
00100100 --IR:24H
00000010 --data:02H
00110100 --IR:34H
00100100 --IR:24H
00000100 --data:04H
00110100 --IR:34H
00100100 --IR:24H
00001000 --data:08H
00110100 --IR:34H
00100100 --IR:24H
00010000 --data:10H
00110100 --IR:34H
00100100 --IR:24H
00100000 --data:20H
00110100 --IR:34H
00100100 --IR:24H
01000000 --data:40H
00110100 --IR:34H
00100100 --IR:24H
10000000 --data:80H
00110100 --IR:34H
00000100 --JMP addr12
00000000 --addr:00H
00000000 --addr:00H
00000000
</code></pre>
<p> 程序：</p>
<pre><code>000000000011000100011001111100110111100100000000		--00H
000000000000000000000000000000000000000000000000		--01H
000000000000000000000000000000000000000000000000		--02H
000000000000000000000000000000000000000000000000		--03H
000000000011000100010101111100110111101100000101		--04H JMP addr12
000000000011000100010011111100110111101100000110		--05H
000000000011000100010001101100110111011100000000		--06H
000000000000000000000000000000000000000000000000		--07H
010000000011000101000001011100110111011100001001		--08H ADD Ri,Rj
100000000011000101000001011100110111011100001010		--09H
001000010001000100110001011100110111011100000000		--0AH
000000000001000100100001111100110111011100000000		--0BH
000000000000000000000000000000000000000000000000		--0CH
000000000000000000000000000000000000000000000000		--0DH
000000000000000000000000000000000000000000000000		--0EH
000000000000000000000000000000000000000000000000		--0FH
000000000000000000000000000000000000000000000000		--10H
000000000000000000000000000000000000000000000000		--11H
000000000000000000000000000000000000000000000000		--12H
000000000000000000000000000000000000000000000000		--13H
000000000000000000000000000000000000000000000000		--14H
000000000000000000000000000000000000000000000000		--15H
000000000000000000000000000000000000000000000000		--16H
000000000000000000000000000000000000000000000000		--17H
000000000000000000000000000000000000000000000000		--18H
000000000000000000000000000000000000000000000000		--19H
000000000000000000000000000000000000000000000000		--1AH
000000000000000000000000000000000000000000000000		--1BH
000000000000000000000000000000000000000000000000		--1CH
000000000000000000000000000000000000000000000000		--1DH
000000000000000000000000000000000000000000000000		--1EH
000000000000000000000000000000000000000000000000		--1FH
000000000000000000000000000000000000000000000000		--20H
000000000000000000000000000000000000000000000000		--21H
000000000000000000000000000000000000000000000000		--22H
000000000000000000000000000000000000000000000000		--23H
000000000011000100100001111100110111101100100101		--24H MOV Ri,#data ***修改***
000000000011000100010001011100110111011100100110		--25H
000000000011000100010001011100110111011100000000		--26H
000000000000000000000000000000000000000000000000		--27H
000000000011000101100001011100110111011100101001		--28H
000000000011000101100001011100110111011100101010		--29H
000000000011000100010001011100110111011100000000		--2AH
000000000000000000000000000000000000000000000000		--2BH
000000000011000100010010111100110111101100101101		--2CH
000000000011010000100000011100110111011100101110		--2DH
000000000011000100010001011100110111011100000000		--2EH
000000000000000000000000000000000000000000000000		--2FH
000000000011000100010010111100110111101100110001		--30H
000000000011011101000000011100110111011100110010		--31H
000000000011000100010001011100110111011100000000		--32H
000000000000000000000000000000000000000000000000		--33H
000000000011000101000001011100111101011100110101		--34H MOV IO,Ri
000000000011000100010001011100110101011100110110		--35H 
000000000011000100010001011100110111011100000000		--36H
000000000000000000000000000000000000000000000000		--37H
000000000011000100010001011100111011011100111001		--38H MOV Ri,IO
000000000011000100100001011100111001011100111010		--39H
000000000011000100010001011100110111011100000000		--3AH
000000000000000000000000000000000000000000000000		--3BH
000000000011000100010001111100010111101100111101		--3CH
000000000011000100010001011100110111011100111110		--3DH
000000000011000100010001011100110111011100000000		--3EH
000000000000000000000000000000000000000000000000		--3FH
010000010011000101000001011100110111011101000001		--40H
000000000011000101100001011100110111011101000010		--41H
100000000011000111000001011100110111011101000011		--42H
001000010001000100110001111100110111011101000100		--43H
000000000011000100010001011100110111011100000000		--44H
000000000000000000000000000000000000000000000000		--45H
</code></pre>
<p>testbench：</p>
<pre><code>----------------------------------------------------------------------------------
-- Engineer: switch_swq
-- Create Date: 2024/04/26 08:47:54
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity CPU_tb is

end CPU_tb;

architecture Behavioral of CPU_tb is
component CPU
    generic(
        CLK_FRE:integer:=100000000
    );
    Port(
        clk:in std_logic;
        nreset:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        
        data_out:out std_logic_vector(7 downto 0)
    );
end component;

signal clk,nreset:std_logic;
signal data_in,data_out:std_logic_vector(7 downto 0);

begin

CPU_inst:CPU generic map(100000000)port map(clk,nreset,data_in,data_out);

clock:process
begin
    clk&lt;=&#39;1&#39;;
    wait for 5ns;
    clk&lt;=&#39;0&#39;;
    wait for 5ns;
end process;

reset:process
begin
    nreset&lt;=&#39;0&#39;;
    wait for 15ns;
    nreset&lt;=&#39;1&#39;;
    wait;
end process;

test:process
begin
    data_in&lt;=x&quot;FF&quot;;
    wait;
end process;

end Behavioral;
</code></pre>
<p>LED结果：</p>
<p>整体：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f9cfb770135c8cd06409fe765cdb265.png"></p>
<p>取数（00100100 –IR:24H MOV Ri,#data 00000001 –data:01H）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/595f539ee9983cb3ad064110256b9d3d.png"></p>
<p>IO输出（00110100 –IR:34H MOV IO,Ri）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/deb8630114a8896456e6eea801735970.png"></p>
<p>ADD结果：</p>
<p>整体：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/08792675191fd507e190b166618ace0c.png"></p>
<p>IO输入（00111000 –IR:38H MOV Ri,IO）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b48d14803e3b211bfb14f2d81f5dc40a.png"></p>
<p>加法（00001000 –ADD R0,R1）：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5399cba63467fb5d837fe1e49c0adb02.png"></p>
<p>xdc：</p>
<pre><code>#CLK_100M
set_property PACKAGE_PIN E10        [get_ports clk]
set_property IOSTANDARD LVCMOS18    [get_ports clk]

#sw31~24
set_property PACKAGE_PIN J8         [get_ports nreset]
set_property IOSTANDARD LVCMOS18    [get_ports nreset]

#SW0~7
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[0]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[1]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[2]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[3]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[4]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[5]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[6]&#125;]
set_property IOSTANDARD LVCMOS18    [get_ports &#123;data_in[7]&#125;]
set_property PACKAGE_PIN C9         [get_ports &#123;data_in[0]&#125;]
set_property PACKAGE_PIN B9         [get_ports &#123;data_in[1]&#125;]
set_property PACKAGE_PIN G11        [get_ports &#123;data_in[2]&#125;]
set_property PACKAGE_PIN F10        [get_ports &#123;data_in[3]&#125;]
set_property PACKAGE_PIN D10        [get_ports &#123;data_in[4]&#125;]
set_property PACKAGE_PIN E11        [get_ports &#123;data_in[5]&#125;]
set_property PACKAGE_PIN D11        [get_ports &#123;data_in[6]&#125;]
set_property PACKAGE_PIN A14        [get_ports &#123;data_in[7]&#125;]

#SEG_DIG1~16
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[15]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[14]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[13]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[12]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[11]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[10]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[9]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[8]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_dig[0]&#125;]
set_property PACKAGE_PIN A23        [get_ports &#123;seg_dig[15]&#125;]
set_property PACKAGE_PIN A24        [get_ports &#123;seg_dig[14]&#125;]
set_property PACKAGE_PIN D26        [get_ports &#123;seg_dig[13]&#125;]
set_property PACKAGE_PIN C26        [get_ports &#123;seg_dig[12]&#125;]
set_property PACKAGE_PIN A20        [get_ports &#123;seg_dig[11]&#125;]
set_property PACKAGE_PIN J25        [get_ports &#123;seg_dig[10]&#125;]
set_property PACKAGE_PIN J24        [get_ports &#123;seg_dig[9]&#125;]
set_property PACKAGE_PIN H22        [get_ports &#123;seg_dig[8]&#125;]
set_property PACKAGE_PIN K21        [get_ports &#123;seg_dig[7]&#125;]
set_property PACKAGE_PIN L23        [get_ports &#123;seg_dig[6]&#125;]
set_property PACKAGE_PIN B25        [get_ports &#123;seg_dig[5]&#125;]
set_property PACKAGE_PIN B26        [get_ports &#123;seg_dig[4]&#125;]
set_property PACKAGE_PIN C24        [get_ports &#123;seg_dig[3]&#125;]
set_property PACKAGE_PIN D21        [get_ports &#123;seg_dig[2]&#125;]
set_property PACKAGE_PIN C22        [get_ports &#123;seg_dig[1]&#125;]
set_property PACKAGE_PIN B20        [get_ports &#123;seg_dig[0]&#125;]

#seg_data
set_property PACKAGE_PIN E26        [get_ports &#123;seg_data[7]&#125;]
set_property PACKAGE_PIN J26        [get_ports &#123;seg_data[6]&#125;]
set_property PACKAGE_PIN H26        [get_ports &#123;seg_data[5]&#125;]
set_property PACKAGE_PIN H21        [get_ports &#123;seg_data[4]&#125;]
set_property PACKAGE_PIN G21        [get_ports &#123;seg_data[3]&#125;]
set_property PACKAGE_PIN H23        [get_ports &#123;seg_data[2]&#125;]
set_property PACKAGE_PIN H24        [get_ports &#123;seg_data[1]&#125;]
set_property PACKAGE_PIN J21        [get_ports &#123;seg_data[0]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[7]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[6]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[5]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[4]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[3]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[2]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[1]&#125;]
set_property IOSTANDARD LVCMOS33    [get_ports &#123;seg_data[0]&#125;]
</code></pre>
<h4 id="1-实验结果分析"><a href="#1-实验结果分析" class="headerlink" title="1.实验结果分析"></a>1.实验结果分析</h4><h5 id="模块工作顺序分析"><a href="#模块工作顺序分析" class="headerlink" title="&lt;1&gt;模块工作顺序分析"></a>&lt;1&gt;<strong>模块工作顺序分析</strong></h5><pre><code>    各个模块工作的逻辑顺序如上时钟时序图所示，每条指令执行则可分为m0~3四个阶段。在m0阶段首先由PC发送地址至ROM，然后ROM输出该地址的指令或数据，传送至IR，IR经过简单处理后继续传送至UC，UC产生各个模块的控制信号。在m1~3阶段，依据微程序产生3次控制信号，实现相应指令功能（注意ALU、RN、IO时钟不同，后面有相关解释）。
</code></pre>
<h5 id="​​​指令执行过程分析"><a href="#​​​指令执行过程分析" class="headerlink" title="&lt;2&gt;​​​指令执行过程分析"></a>&lt;2&gt;​​​<strong>指令执行过程分析</strong></h5><ul>
<li><strong><strong>以ADD加法为例：</strong></strong></li>
</ul>
<p><strong><strong>MOV Ri,IO：</strong></strong></p>
<pre><code>    m1~3——执行38H MOV Ri,IO：在m1使能IO相关信号使IO_IN-&gt;REG，在m2时，REG-&gt;DATA_BUS-&gt;Ri（IO的时钟先于RN，使数据在DATA_BUS刚好能传送至RN）
</code></pre>
<p><strong><strong>ADD R0,R1：</strong></strong></p>
<pre><code>    m1~3——执行08H ADD R0,R1：由于无法在计算出结果的同时将结果通过数据总线DATA_BUS传送至RN，所以在一条指令中，我的ADD指令只能实现计算功能，计算结果由ALU另行输出至result总线。在m1和m2分别实现RN-&gt;DATA_BUS-&gt;regA/B（其中regA/B为ALU内部缓冲器），在m3实现计算和UC地址回到00H操作。
</code></pre>
<p><strong><strong>以LED流水灯为例：</strong></strong></p>
<pre><code>    m0——取指令：PC-&gt;ROM-&gt;DATA_BUS-&gt;IR-&gt;UC，微指令为0x003119f37900H

    注意到ROM将地址信息输出到总线，IR接收并传递地址到UC，从而执行24H地址的微程序。
</code></pre>
<p><strong><strong>MOV Ri,#data：</strong></strong></p>
<pre><code>    m1~3——执行24H MOV Ri,#data：在m1将ROM中的立即数输出至
</code></pre>
<p>DATA_BUS，在m2传输至Ri之中，在m3阶段UC地址回到00H准备进入下一条指令，即取值公操作。</p>
<p><strong><strong>MOV IO,Ri：</strong></strong></p>
<pre><code>    m1~3——执行34H MOV IO,Ri：在m1将Ri-&gt;DATA_BUS，在m2，DATA_BUS-&gt;REG-&gt;IO_OUT（REG是IO内暂存器，由于UC控制信号不包含RI_EN和RO_EN，一直使能，即DATA_BUS&lt;-&gt;IO直接完成），在m3阶段UC地址回到00H准备进入下一条指令，即取值公操作。
</code></pre>
<p><strong><strong>JMP addr12</strong></strong><strong><strong>：</strong></strong></p>
<pre><code>    m1~3——执行04H JMP addr12：在m1、m2依次将立即数加载至IR中，对应LD_IR2和LD_IR3分别有效，IR将新地址传送至PC。
</code></pre>
<ul>
<li><strong><strong>以ADD加法为例：</strong></strong></li>
</ul>
<p><strong><strong>MOV Ri,IO：</strong></strong></p>
<pre><code>    m1~3——执行38H MOV Ri,IO：在m1使能IO相关信号使IO_IN-&gt;REG，在m2时，REG-&gt;DATA_BUS-&gt;Ri（IO的时钟先于RN，使数据在DATA_BUS刚好能传送至RN）
</code></pre>
<p><strong><strong>ADD R0,R1：</strong></strong></p>
<pre><code>    m1~3——执行08H ADD R0,R1：由于无法在计算出结果的同时将结果通过数据总线DATA_BUS传送至RN，所以在一条指令中，我的ADD指令只能实现计算功能，计算结果由ALU另行输出至result总线。在m1和m2分别实现RN-&gt;DATA_BUS-&gt;regA/B（其中regA/B为ALU内部缓冲器），在m3实现计算和UC地址回到00H操作。
</code></pre>
<h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h4><h5 id="SOC-模块集成设计经验"><a href="#SOC-模块集成设计经验" class="headerlink" title="&lt;1&gt;SOC****模块集成设计经验"></a>&lt;1&gt;<strong>SOC****模块集成设计经验</strong></h5><pre><code>    在集成各个组成模块时，为避免总线冲突以及方便调试，采用各个模块依次添加测试的方法。

    首先测试PC、ROM、IR、UC组成的系统，要求取指令时4个模块的运行顺序为：PC发送ROM地址-&gt;ROM输出指令/数据-&gt;IR传送指令-&gt;UC解析执行微程序。随后依次加入IO、RN、ALU、RAM模块进行调试（按照指令执行逻辑顺序）。
</code></pre>
<h5 id="SOC集成关键"><a href="#SOC集成关键" class="headerlink" title="&lt;2&gt;SOC集成关键"></a>&lt;2&gt;<strong>SOC集成关键</strong></h5><p>在集成各个模块时，关键在于：</p>
<ul>
<li><p>清楚模块工作逻辑顺序</p>
<pre><code>需清楚知晓各个模块工作先后关系，理清数据/控制/地址信号流的传递顺序，以避免读写顺序出错，出现写未读到的情况。
</code></pre>
</li>
<li><p>避免总线冲突</p>
<pre><code>主要是DATA_BUS数据总线使用的原子性，各模块严格按照时钟时序进行输出，在允许输出时输入/出数据到数据总线，其他时刻不要忘记将数据总线置高阻态。
</code></pre>
</li>
<li><p>考虑信号的建立、保持</p>
<pre><code>在课程参考资料中，ALU、IO、RN的时钟都是nclk2，但是对于任意一条微指令，如果涉及到上述3个模块的协作,如将RN中数据传送至ALU中缓存器regA，由于时钟相同，且都在上升沿工作，则在同一时刻，RN中数据传输到数据总线，上一时刻数据总线的数值传送至regA，并不能实现RN-&gt;DATA_BUS-&gt;regA这一连贯操作。

解决方法在于错开操作时间，即RN-&gt;DATA_BUS先于DATA_BUS-&gt;regA，需要修改模块时钟，故出现了上面仿真图中的时钟。
</code></pre>
</li>
</ul>
<p>&lt;3&gt;反思与改进</p>
<ul>
<li><p>对数据不能在总线上连续传递的思考</p>
<pre><code>考虑上面“考虑信号的建立、保持”部分产生的问题，问题产生的原因在于组合逻辑电路和时序逻辑电路的区别，如果将信号的触发条件由时钟的上升沿改为高电平（类似于使能信号），则将时序逻辑转变为组合逻辑，可能解决上述问题，使得ALU、IO、RN等模块的时钟可以都是nclk2。
</code></pre>
</li>
<li><p>ADD指令的改进</p>
<pre><code>上述实现的ADD指令在有限的m1~3阶段内计算完结果无法实现结果存储至RN（在上面ADD指令时序图可观测到计算结果曾短时间内输出到数据总线DATA_BUS上），仅一个指令周期无法实现，可以扩展成两个，即在第二个指令周期的m0~3阶段实现指令存储至RN。
</code></pre>
</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/999503810dc63f0f906be47e3bbaca66.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/139143519">https://blog.csdn.net/qq_32971095/article/details/139143519</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E5%A4%A7%E4%B8%89%E4%B8%8BSOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86/" class="post-title-link" itemprop="url">西电计科大三下SOC微体系结构设计作业合集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 19:33:51" itemprop="dateCreated datePublished" datetime="2024-04-03T19:33:51+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.VHDL%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A">一.VHDL设计作业</a></p>
<p><a href="about:blank#1.%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E7%9A%843-8%E8%AF%91%E7%A0%81%E5%99%A8%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1">1.基于硬件描述语言的3-8译码器逻辑电路设计</a></p>
<p><a href="about:blank#2.8%E4%BD%8D%E5%8F%8C%E5%90%91%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E8%AE%A1">2.8位双向移位寄存器设计</a></p>
<p><a href="about:blank#3.%E5%9F%BA%E4%BA%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%87%AA%E5%8A%A9%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">3.基于有限状态机的自助售票系统设计</a></p>
<p><a href="about:blank#4.%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1">4.按键消抖电路设计</a></p>
<p><a href="about:blank#5.%E5%90%8C%E6%AD%A5%E7%8E%AF%E5%BD%A2FIFO%E8%AE%BE%E8%AE%A1">5.同步环形FIFO设计</a></p>
<p><a href="about:blank#6.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">6.线上实验——时钟模块设计</a></p>
<p><a href="about:blank#7.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%8E%9F%E7%A0%81%E4%BA%8C%E4%BD%8D%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1%C2%A0">7.线上实验——原码二位乘法器设计
</a></p>
<p><a href="about:blank#8.%E7%BA%BF%E4%B8%8A%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%B8%83%E6%96%AF%E4%B9%98%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1">8.线上实验——布斯乘法器设计</a></p>
<hr>
<h2 id="一-VHDL设计作业"><a href="#一-VHDL设计作业" class="headerlink" title="一.VHDL设计作业"></a>一.VHDL设计作业</h2><p>源文件、测试文件及仿真结果</p>
<h3 id="1-基于硬件描述语言的3-8译码器逻辑电路设计"><a href="#1-基于硬件描述语言的3-8译码器逻辑电路设计" class="headerlink" title="1.基于硬件描述语言的3-8译码器逻辑电路设计"></a>1.基于硬件描述语言的3-8译码器逻辑电路设计</h3><p>根据3-8译码器基本原理，采用硬件描述语言设计一个3-8译码器逻辑电路，并给出仿真结果。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity decoder3_8 is
    Port (  
        OE: in std_logic;
        X: in std_logic_vector(2 downto 0);
        Y: out std_logic_vector(7 downto 0)
    );
end decoder3_8;

architecture Behavioral of decoder3_8 is
begin
process(OE,X)
begin
    if OE=&#39;0&#39; then Y&lt;=&quot;00000000&quot;;
    elsif OE=&#39;1&#39;then
        Case X is
            When &quot;000&quot; =&gt;Y&lt;=&quot;11111110&quot;;
            When &quot;001&quot; =&gt;Y&lt;=&quot;11111101&quot;;
            When &quot;010&quot; =&gt;Y&lt;=&quot;11111011&quot;;
            When &quot;011&quot; =&gt;Y&lt;=&quot;11110111&quot;;
            When &quot;100&quot; =&gt;Y&lt;=&quot;11101111&quot;;
            When &quot;101&quot; =&gt;Y&lt;=&quot;11011111&quot;;
            When &quot;110&quot; =&gt;Y&lt;=&quot;10111111&quot;;
            When &quot;111&quot; =&gt;Y&lt;=&quot;01111111&quot;;
            When others =&gt;Y&lt;=&quot;11111111&quot;;
        END CASE;    
   end if;
end process;
end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity decoder3_8_tb is
--  Port ( );
end decoder3_8_tb;

architecture structural of decoder3_8_tb is
component decoder3_8
    port(
        OE: in std_logic;
        X: in std_logic_vector(2 downto 0);
        Y: out std_logic_vector(7 downto 0)
    );
end component;
signal oe:std_logic;
signal input:std_logic_vector(2 downto 0);
signal output:std_logic_vector(7 downto 0);
begin
d1:decoder3_8 port map(oe,input,output);

ensure:process
    begin
        oe&lt;=&#39;0&#39;;
        wait for 50ns;
        oe&lt;=&#39;1&#39;;
        wait;
end process;

sel:process
    begin
        input&lt;=&quot;000&quot;;
        wait for 20ns;
        input&lt;=&quot;001&quot;;
        wait for 20ns;
        input&lt;=&quot;010&quot;;
        wait for 20ns;
        input&lt;=&quot;011&quot;;
        wait for 20ns;
        input&lt;=&quot;100&quot;;
        wait for 20ns;
        input&lt;=&quot;101&quot;;
        wait for 20ns;
        input&lt;=&quot;110&quot;;
        wait for 20ns;
        input&lt;=&quot;111&quot;;
        wait for 20ns;
end process;
end structural;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cdaef1463aa82317fd6029b8c7bb08e.png"></p>
<h3 id="2-8位双向移位寄存器设计"><a href="#2-8位双向移位寄存器设计" class="headerlink" title="2.8位双向移位寄存器设计"></a>2.8位双向移位寄存器设计</h3><p>采用硬件描述语言实现8位双向移位寄存器，其功能包括异步置零，同步置数，左移，右移和保持状态不变等5种功能。其中输入端口包括8位并行数据、两位的选择信号和两个1位串行数据，输出是8位并行数据。当RESET信号为低电平时，寄存器的输出被异步置零；否则当RESET&#x3D;1时，与时钟有关的四种功能由输入信号MODE决定。请给出仿真结果。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity shift_register is
    Port (
        clk,reset,left,right:in std_logic;
        mode:in std_logic_vector(1 downto 0);
        input_data:in std_logic_vector(7 downto 0);
        output_data:inout std_logic_vector(7 downto 0)
    );
end shift_register;

architecture Behavioral of shift_register is
begin
process(reset,clk,mode)

begin
    if (reset=&#39;0&#39;)then
        output_data&lt;=&quot;00000000&quot;;
    elsif(reset=&#39;1&#39;and clk=&#39;1&#39;)then
        case mode is
            when &quot;00&quot;=&gt;output_data&lt;=output_data;
            when &quot;01&quot;=&gt;output_data&lt;=input_data;
            when &quot;10&quot;=&gt;
                    output_data(0)&lt;=left;
                    output_data(7)&lt;=output_data(6);
                    output_data(6)&lt;=output_data(5);
                    output_data(5)&lt;=output_data(4);
                    output_data(4)&lt;=output_data(3);
                    output_data(3)&lt;=output_data(2);
                    output_data(2)&lt;=output_data(1);
                    output_data(1)&lt;=output_data(0);              
            when &quot;11&quot;=&gt;
                    output_data(0)&lt;=output_data(1);
                    output_data(1)&lt;=output_data(2);
                    output_data(2)&lt;=output_data(3);
                    output_data(3)&lt;=output_data(4);
                    output_data(4)&lt;=output_data(5);
                    output_data(5)&lt;=output_data(6);
                    output_data(6)&lt;=output_data(7);
                    output_data(7)&lt;=right;
            when others=&gt;output_data&lt;=output_data;
        end case;         
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity shift_register_tb is
--  Port ( );
end shift_register_tb;

architecture Behavioral of shift_register_tb is
component shift_register
port(
        clk,reset,left,right:in std_logic;
        mode:in std_logic_vector(1 downto 0);
        input_data:in std_logic_vector(7 downto 0);
        output_data:inout std_logic_vector(7 downto 0)   
);
end component;
signal clk,reset,left,right:std_logic;
signal mode:std_logic_vector(1 downto 0);
signal input_data:std_logic_vector(7 downto 0);
signal output_data:std_logic_vector(7 downto 0);   
begin
sr1:shift_register port map(clk,reset,left,right,mode,input_data,output_data);

clock_gen:process
    begin
        left&lt;=output_data(7);
        right&lt;=output_data(0);
        clk&lt;=&#39;0&#39;;
        wait for 10ns;
        clk&lt;=&#39;1&#39;;
        wait for 10ns;
end process;

reset_gen:process
    begin
        reset&lt;=&#39;0&#39;;
        wait for 25ns;
        reset&lt;=&#39;1&#39;;
        wait;
end process;

mode_test:process
    begin
        mode&lt;=&quot;00&quot;;
        wait for 30ns;
        mode&lt;=&quot;01&quot;;
        input_data&lt;=&quot;00001111&quot;;
        wait for 30ns;
        mode&lt;=&quot;10&quot;;
        wait for 200ns;
        mode&lt;=&quot;01&quot;;
        input_data&lt;=&quot;00001111&quot;;
        wait for 30ns;
        mode&lt;=&quot;11&quot;;
        wait for 200ns;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5dcfe13e83a9275011aae48f12d1be1c.png"></p>
<h3 id="3-基于有限状态机的自助售票系统设计"><a href="#3-基于有限状态机的自助售票系统设计" class="headerlink" title="3.基于有限状态机的自助售票系统设计"></a>3.基于有限状态机的自助售票系统设计</h3><p>某自助售票系统只能接收 5元和10元纸币，若一张票的价格设定为 25元。<br>请利用有限状态机设计该售票系统，<br>1. 首先给出状态说明，然后画出具体的状态图及说明状态转移关系。<br>2. 并完成硬件描述语言程序设计。</p>
<p>3.将第1和2题的答案做成word文档上传。</p>
<p>4.扩展要求（加分10分）：增加20元纸币输入。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ticket_state_machine is
    Port (
        clk,reset:in std_logic;
        input_money:in std_logic_vector(2 downto 0);
        return_money:out std_logic_vector(2 downto 0);
        output_ticket:out std_logic
    );
end ticket_state_machine;

architecture Behavioral of ticket_state_machine is
type states is (m0,m5,m10,m15,m20,m25,m30,m35,m40);
signal current_state,next_state:states;
begin

start:process(reset,clk)
    begin
        if(reset=&#39;1&#39;)then
            current_state&lt;=m0;
        elsif(reset=&#39;0&#39;and clk=&#39;1&#39;and clk&#39;event)then
            current_state&lt;=next_state;
        end if;         
end process;

state_machine:process(current_state,input_money)
    begin
        case current_state is
            when m0=&gt;
                output_ticket&lt;=&#39;0&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m0;
                    when&quot;001&quot;=&gt;next_state&lt;=m5;
                    when&quot;010&quot;=&gt;next_state&lt;=m10;
                    when&quot;100&quot;=&gt;next_state&lt;=m20;
                    when others=&gt;next_state&lt;=current_state;
                end case;
            when m5=&gt;
                output_ticket&lt;=&#39;0&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m5;
                    when&quot;001&quot;=&gt;next_state&lt;=m10;
                    when&quot;010&quot;=&gt;next_state&lt;=m15;
                    when&quot;100&quot;=&gt;next_state&lt;=m25;
                    when others=&gt;next_state&lt;=current_state;
                end case;
            when m10=&gt;
                output_ticket&lt;=&#39;0&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m10;
                    when&quot;001&quot;=&gt;next_state&lt;=m15;
                    when&quot;010&quot;=&gt;next_state&lt;=m20;
                    when&quot;100&quot;=&gt;next_state&lt;=m30;
                    when others=&gt;next_state&lt;=current_state;
                end case; 
            when m15=&gt;
                output_ticket&lt;=&#39;0&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m15;
                    when&quot;001&quot;=&gt;next_state&lt;=m20;
                    when&quot;010&quot;=&gt;next_state&lt;=m25;
                    when&quot;100&quot;=&gt;next_state&lt;=m35;
                    when others=&gt;next_state&lt;=current_state;
                end case; 
            when m20=&gt;
                output_ticket&lt;=&#39;0&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m20;
                    when&quot;001&quot;=&gt;next_state&lt;=m25;
                    when&quot;010&quot;=&gt;next_state&lt;=m30;
                    when&quot;100&quot;=&gt;next_state&lt;=m40;
                    when others=&gt;next_state&lt;=current_state;
                end case; 
            when m25=&gt;
                output_ticket&lt;=&#39;1&#39;;
                return_money&lt;=&quot;000&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m0;
                    when&quot;001&quot;=&gt;next_state&lt;=m5;
                    when&quot;010&quot;=&gt;next_state&lt;=m10;
                    when&quot;100&quot;=&gt;next_state&lt;=m20;
                    when others=&gt;next_state&lt;=current_state;
                end case; 
            when m30=&gt;
                output_ticket&lt;=&#39;1&#39;;
                return_money&lt;=&quot;001&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m0;
                    when&quot;001&quot;=&gt;next_state&lt;=m5;
                    when&quot;010&quot;=&gt;next_state&lt;=m10;
                    when&quot;100&quot;=&gt;next_state&lt;=m20;
                    when others=&gt;next_state&lt;=current_state;
                end case;
             when m35=&gt;
                output_ticket&lt;=&#39;1&#39;;
                return_money&lt;=&quot;010&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m0;
                    when&quot;001&quot;=&gt;next_state&lt;=m5;
                    when&quot;010&quot;=&gt;next_state&lt;=m10;
                    when&quot;100&quot;=&gt;next_state&lt;=m20;
                    when others=&gt;next_state&lt;=current_state;
                end case;    
            when m40=&gt;
                output_ticket&lt;=&#39;1&#39;;
                return_money&lt;=&quot;011&quot;;
                case input_money is
                    when&quot;000&quot;=&gt;next_state&lt;=m0;
                    when&quot;001&quot;=&gt;next_state&lt;=m5;
                    when&quot;010&quot;=&gt;next_state&lt;=m10;
                    when&quot;100&quot;=&gt;next_state&lt;=m20;
                    when others=&gt;next_state&lt;=current_state;
                end case;    
        end case;             
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ticket_state_machine_tb is
--  Port ( );
end ticket_state_machine_tb;

architecture Behavioral of ticket_state_machine_tb is
component ticket_state_machine
    Port (
        clk,reset:in std_logic;
        input_money:in std_logic_vector(2 downto 0);
        return_money:out std_logic_vector(2 downto 0);
        output_ticket:out std_logic
    );
end component;
signal clk,reset: std_logic;
signal input_money: std_logic_vector(2 downto 0);
signal return_money: std_logic_vector(2 downto 0);
signal output_ticket: std_logic;
begin
tsm:ticket_state_machine port map(clk,reset,input_money,return_money,output_ticket);

clock:process
    begin
        clk&lt;=&#39;0&#39;;
        wait for 10ns;
        clk&lt;=&#39;1&#39;;
        wait for 10ns;
end process;

start:process
    begin
        reset&lt;=&#39;1&#39;;
        wait for 20ns;
        reset&lt;=&#39;0&#39;;
        wait;
end process;

test:process
    begin
        wait for 50ns;
        input_money&lt;=&quot;001&quot;;
        wait for 20ns;
        input_money&lt;=&quot;000&quot;;
        wait for 50ns;
        input_money&lt;=&quot;010&quot;;
        wait for 20ns;
        input_money&lt;=&quot;000&quot;;
        wait for 50ns;
        input_money&lt;=&quot;100&quot;;
        wait for 20ns;
        input_money&lt;=&quot;000&quot;;
        wait for 50ns;
        input_money&lt;=&quot;010&quot;;
        wait for 20ns;
        input_money&lt;=&quot;000&quot;;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/711bd6d2672a650569b2474d89e3f38e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dfad20f27e654f243f373cfb9b80256c.png"></p>
<h3 id="4-按键消抖电路设计"><a href="#4-按键消抖电路设计" class="headerlink" title="4.按键消抖电路设计"></a>4.按键消抖电路设计</h3><p>请使用硬件描述语言设计一个按键消抖电路，假设输入时钟频率为50MHZ。请给出设计方案及仿真验证结果。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity key_stroke is
    generic(CLK_FRE:integer:=50000000);
    Port (
        clk:in std_logic;
        reset:in std_logic;
        key_in:in std_logic;
        output:out std_logic           
    );
end key_stroke;

architecture Behavioral of key_stroke is

type states is(s0,s1,s2,s3,s4);
signal state:states;

begin
process(reset,clk,key_in)
variable count_num:integer:=3*CLK_FRE/1000;
variable count:integer:=0;
    begin
        if reset=&#39;1&#39;then
            state&lt;=s0;
            count:=0;
            output&lt;=&#39;0&#39;;
        elsif reset=&#39;0&#39;then
            case state is
                when s0=&gt;if key_in=&#39;1&#39; then state&lt;=s1;end if;
                when s1=&gt;
                    if clk=&#39;1&#39; then count:=count+1;end if;
                    if count=count_num then state&lt;=s2; end if;
                when s2=&gt;
                    if(key_in=&#39;1&#39;)then output&lt;=&#39;1&#39;;state&lt;=s3;
                    elsif(key_in=&#39;0&#39;)then output&lt;=&#39;0&#39;;state&lt;=s4;
                    end if;
                when s3=&gt;
                    output&lt;=&#39;0&#39;;
                    if(key_in=&#39;0&#39;)then state&lt;=s4;end if;
                when s4=&gt;
                    state&lt;=s0;
                    count:=0;
                    output&lt;=&#39;0&#39;;             
            end case;               
        end if;     
end process;



end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity key_stroke_tb is
--  Port ( );
end key_stroke_tb;

architecture Behavioral of key_stroke_tb is
component key_stroke
    generic(CLK_FRE:integer:=50000000);
    port(
        clk:in std_logic;
        reset:in std_logic;
        key_in:in std_logic;
        output:out std_logic 
    ); 
end component;
signal clk:std_logic;
signal reset:std_logic;
signal key_in:std_logic;
signal output:std_logic;
begin
ks:key_stroke generic map(50000000)port map(clk,reset,key_in,output);

clock:process
begin
    clk&lt;=&#39;0&#39;;
    wait for 10ns;
    clk&lt;=&#39;1&#39;;
    wait for 10ns;
end process;

rst:process
begin
    reset&lt;=&#39;1&#39;;
    wait for 25ns;
    reset&lt;=&#39;0&#39;;
    wait;
end process;

test:process
begin
    key_in&lt;=&#39;1&#39;;
    wait for 50ns;
    key_in&lt;=&#39;0&#39;;
    wait for 70ns;
    key_in&lt;=&#39;1&#39;;
    wait for 100ns;
    key_in&lt;=&#39;0&#39;;
    wait for 40ns;
    key_in&lt;=&#39;1&#39;;
    wait for 120ns;
    key_in&lt;=&#39;0&#39;;
    wait for 30ns;
    key_in&lt;=&#39;1&#39;;
    wait for 40ns;
    key_in&lt;=&#39;0&#39;;
    wait for 70ns;
    key_in&lt;=&#39;1&#39;;
    wait for 30ns;
    key_in&lt;=&#39;0&#39;;
    wait for 100ns;
    key_in&lt;=&#39;1&#39;;
    wait for 50ns;
    key_in&lt;=&#39;0&#39;;
    wait for 20ns;
    key_in&lt;=&#39;1&#39;;
    wait for 1000ns;
    key_in&lt;=&#39;0&#39;;
    wait for 2000ns;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2b1e4d12b3c904bbdb1f64914294b450.png"></p>
<h3 id="5-同步环形FIFO设计"><a href="#5-同步环形FIFO设计" class="headerlink" title="5.同步环形FIFO设计"></a>5.同步环形FIFO设计</h3><p>请采用硬件描述语言设计实现一个存储深度M和数据宽度N可以用户配置的同步FIFO存储器，请给出仿真结果。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity FIFO_ring is
generic(
    depth:positive :=8;
    width:positive:=8
);
    Port(
        clk:in std_logic;
        rst:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
--        wr_clr:in std_logic;
--        wr_en:in std_logic;
--        rd_clr:in std_logic;
--        rd_en:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end FIFO_ring;

architecture Behavioral of FIFO_ring is
component duaram
generic(
    depth:positive :=8;
    width:positive:=8
);
Port(
    clka:in std_logic;
    wr:in std_logic;
    addra:in std_logic_vector(depth-1 downto 0);
    datain:in std_logic_vector(width-1 downto 0);
    
    clkb:in std_logic;
    rd:in std_logic;
    addrb:in std_logic_vector(depth-1 downto 0);
    dataout:out std_logic_vector(width-1 downto 0)
); 
end component;
component write_pointer
    generic(
        depth:positive
    );
    Port(
        clk:in std_logic;
        rst:in std_logic;
        wq:in std_logic;
        wr_pt:out std_logic_vector(depth-1 downto 0)
    );
end component;
component read_pointer
    generic(
        depth:positive
    );
    Port(
        clk:in std_logic;
        rst:in std_logic;
        rq:in std_logic;
        rd_pt:out std_logic_vector(depth-1 downto 0)
    );
end component;
component judge_status
    generic(
        depth:positive
    );
    port(
        clk:in std_logic;
        rst:in std_logic;
        wr_pt:in std_logic_vector(depth-1 downto 0);
        rd_pt:in std_logic_vector(depth-1 downto 0);
        empty:out std_logic;
        full:out std_logic
    );
end component;

signal rp_line:std_logic_vector(depth-1 downto 0);
signal wp_line:std_logic_vector(depth-1 downto 0);

begin
duaram_inst:duaram generic map(depth,width)port map(clka=&gt;clk,clkb=&gt;clk,datain=&gt;data_in,dataout=&gt;data_out,addra=&gt;wp_line,addrb=&gt;rp_line,rd=&gt;rd,wr=&gt;wr);
write_pointer_inst:write_pointer generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,wq=&gt;wr,wr_pt=&gt;wp_line);
read_pointer_inst:read_pointer generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,rq=&gt;rd,rd_pt=&gt;rp_line);
judge_status_inst:judge_status generic map(depth)port map(clk=&gt;clk,rst=&gt;rst,wr_pt=&gt;wp_line,rd_pt=&gt;rp_line,full=&gt;full,empty=&gt;empty);


end Behavioral;



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity duaram is
generic(
    depth:positive :=8;
    width:positive:=8
);
Port(
    clka:in std_logic;
    wr:in std_logic;
    addra:in std_logic_vector(depth-1 downto 0);
    datain:in std_logic_vector(width-1 downto 0);
    
    clkb:in std_logic;
    rd:in std_logic;
    addrb:in std_logic_vector(depth-1 downto 0);
    dataout:out std_logic_vector(width-1 downto 0)
);
end duaram;

architecture Behavioral of duaram is

type ram is array(2**depth-1 downto 0)of std_logic_vector(width-1 downto 0);
signal dualram:ram;

begin

process(clka,clkb)
begin
    if(clka&#39;event and clka=&#39;1&#39;)then
        if(wr=&#39;0&#39;)then dualram(conv_integer(addra))&lt;=datain;end if;
    end if;
end process;

process(clkb)
begin
    if(clkb&#39;event and clkb=&#39;1&#39;)then
        if(rd=&#39;0&#39;)then dataout&lt;=dualram(conv_integer(addrb));end if;
    end if;
end process;

end Behavioral;



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity write_pointer is
    generic(
        depth:positive
    );
    Port(
        clk:in std_logic;
        rst:in std_logic;
        wq:in std_logic;
        wr_pt:out std_logic_vector(depth-1 downto 0)
    );
end write_pointer;

architecture Behavioral of write_pointer is

signal wr_pt_t:std_logic_vector(depth-1 downto 0);

begin
process(rst,clk)
begin
    if(rst=&#39;0&#39;)then
        wr_pt_t&lt;=(others=&gt;&#39;0&#39;);
    elsif(clk&#39;event and clk=&#39;1&#39;)then
        if wq=&#39;0&#39;then wr_pt_t&lt;=wr_pt_t+1;end if;
    end if;     
end process;
wr_pt&lt;=wr_pt_t;
end Behavioral;



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity read_pointer is
    generic(
        depth:positive
    );
    Port(
        clk:in std_logic;
        rst:in std_logic;
        rq:in std_logic;
        rd_pt:out std_logic_vector(depth-1 downto 0)
    );
end read_pointer;

architecture Behavioral of read_pointer is

signal rd_pt_t:std_logic_vector(depth-1 downto 0);

begin
process(rst,clk)
begin
    if(rst=&#39;0&#39;)then
        rd_pt_t&lt;=(others=&gt;&#39;0&#39;);
    elsif(clk&#39;event and clk=&#39;1&#39;)then
        if rq=&#39;0&#39;then rd_pt_t&lt;=rd_pt_t+1;end if;
    end if;     
end process;
rd_pt&lt;=rd_pt_t;
end Behavioral;



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity judge_status is
    generic(
        depth:positive
    );
    port(
        clk:in std_logic;
        rst:in std_logic;
        wr_pt:in std_logic_vector(depth-1 downto 0);
        rd_pt:in std_logic_vector(depth-1 downto 0);
        empty:out std_logic;
        full:out std_logic
    );
end entity judge_status;

architecture Behavioral of judge_status is

begin

process(rst,clk)
begin
    if(rst=&#39;0&#39;)then empty&lt;=&#39;1&#39;;
    elsif clk&#39;event and clk=&#39;1&#39;then
        if wr_pt=rd_pt then empty&lt;=&#39;1&#39;;
        else empty&lt;=&#39;0&#39;;
        end if;
    end if;  
end process;

process(rst,clk)
begin
    if(rst=&#39;0&#39;)then full&lt;=&#39;0&#39;;
    elsif clk&#39;event and clk=&#39;1&#39;then
        if wr_pt&gt;rd_pt then
            if(depth+rd_pt)=wr_pt then full&lt;=&#39;1&#39;;else full&lt;=&#39;0&#39;;end if;
        end if;
    end if;  
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FIFO_ring_tb is
--  Port ( );
end FIFO_ring_tb;

architecture Behavioral of FIFO_ring_tb is

component FIFO_ring
generic(
    depth:positive :=8;
    width:positive:=8
);
    Port(
        clk:in std_logic;
        rst:in std_logic;
        data_in:in std_logic_vector(7 downto 0);
        wr:in std_logic;
        rd:in std_logic;
--        wr_clr:in std_logic;
--        wr_en:in std_logic;
--        rd_clr:in std_logic;
--        rd_en:in std_logic;
        
        empty:out std_logic;
        full:out std_logic;
        data_out:out std_logic_vector(7 downto 0)
    );
end component;

signal clk:std_logic;
signal rst:std_logic;
signal data_in:std_logic_vector(7 downto 0);
signal wr:std_logic;
signal rd:std_logic;
signal empty:std_logic;
signal full:std_logic;
signal data_out:std_logic_vector(7 downto 0);

begin

FIFO_ring_inst:FIFO_ring generic map(8,8)port map(clk,rst,data_in,wr,rd,empty,full,data_out);

clock:process
begin
    clk&lt;=&#39;0&#39;;
    wait for 10ns;
    clk&lt;=&#39;1&#39;;
    wait for 10ns;
end process;

reset:process
begin
    rst&lt;=&#39;0&#39;;
    wait for 25ns;
    rst&lt;=&#39;1&#39;;
    wait;
end process;

test:process
begin
    rd&lt;=&#39;1&#39;;
    wr&lt;=&#39;1&#39;;
    data_in&lt;=&quot;00000000&quot;;
    wait for 50ns;
    data_in&lt;=&quot;00000001&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;00000010&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;00000100&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;00001000&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;00010000&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;00100000&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;01000000&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 30ns;
    data_in&lt;=&quot;10000000&quot;;
    wr&lt;=&#39;0&#39;;
    wait for 20ns;
    wr&lt;=&#39;1&#39;;
    wait for 50ns;
    
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    rd&lt;=&#39;0&#39;;
    wait for 20ns;
    rd&lt;=&#39;1&#39;;
    wait for 30ns;
    
    wait;
    
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9085cd14c31cada75062d36a643fb2b5.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4dbe7b6e7886a88433a6fb76f77ee7f8.png"></p>
<h3 id="6-线上实验——时钟模块设计"><a href="#6-线上实验——时钟模块设计" class="headerlink" title="6.线上实验——时钟模块设计"></a>6.线上实验——时钟模块设计</h3><p>采用硬件描述语言设计实现CPU时钟模块，输出信号包括四个节拍信号（每两个时钟周期一个节拍），时钟反相信号，时钟2分频信号及其反相信号，完成逻辑功能设计及仿真验证，并给出仿真结果。</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity clock is
    Port(
        clk,rst:in std_logic;
        clk1,nclk1:out std_logic;   --clk
        clk2,nclk2:out std_logic;   --clk二分频
        w0,w1,w2,w3:out std_logic   --节拍信号
    );
end clock;

architecture Behavioral of clock is
begin

process(clk)
variable count_clk2:integer:=0;
variable count_w:integer:=0;
begin
    if(rst=&#39;0&#39;)then
        w0&lt;=&#39;0&#39;;
        w1&lt;=&#39;0&#39;;
        w2&lt;=&#39;0&#39;;
        w3&lt;=&#39;0&#39;;
        clk1&lt;=&#39;0&#39;;
        nclk1&lt;=&#39;1&#39;;
        clk2&lt;=&#39;0&#39;;
        nclk2&lt;=&#39;1&#39;;
        count_clk2:=0;
        count_w:=0;
    elsif(rst=&#39;1&#39;)then
        clk1&lt;=clk;
        nclk1&lt;=not clk;
        if(clk&#39;event and clk=&#39;1&#39;)then
            if(count_clk2=0)then count_clk2:=1;clk2&lt;=&#39;1&#39;;nclk2&lt;=&#39;0&#39;;
            elsif(count_clk2=1)then count_clk2:=0;clk2&lt;=&#39;0&#39;;nclk2&lt;=&#39;1&#39;;
            end if;
            if(count_w&gt;=0 and count_w&lt;=3)then w0&lt;=&#39;1&#39;;else w0&lt;=&#39;0&#39;;end if;
            if(count_w&gt;=4 and count_w&lt;=7)then w1&lt;=&#39;1&#39;;else w1&lt;=&#39;0&#39;;end if;
            if(count_w&gt;=8 and count_w&lt;=11)then w2&lt;=&#39;1&#39;;else w2&lt;=&#39;0&#39;;end if;
            if(count_w&gt;=12 and count_w&lt;=15)then w3&lt;=&#39;1&#39;;else w3&lt;=&#39;0&#39;;end if;
            if(count_w&lt;15)then count_w:=count_w+1;else count_w:=0;end if;
        end if;
    end if;
end process;

end Behavioral;
</code></pre>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity clock_tb is
--  Port ( );
end clock_tb;

architecture Behavioral of clock_tb is
component clock
    Port(
        clk,rst:in std_logic;
        clk1,nclk1:out std_logic;   --clk
        clk2,nclk2:out std_logic;   --clk二分频
        w0,w1,w2,w3:out std_logic   --节拍信号
    );
end component;

signal clk,rst:std_logic;
signal clk1,nclk1:std_logic;   --clk
signal clk2,nclk2:std_logic;   --clk二分频
signal w0,w1,w2,w3:std_logic;  --节拍信号

begin
clock_inst:clock port map(clk,rst,clk1,nclk1,clk2,nclk2,w0,w1,w2,w3);

clock_gen:process
begin
    clk&lt;=&#39;0&#39;;
    wait for 10ns;
    clk&lt;=&#39;1&#39;;
    wait for 10ns;
end process;

reset_gen:process
begin
    rst&lt;=&#39;0&#39;;
    wait for 25ns;
    rst&lt;=&#39;1&#39;;
    wait;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/adec0f2295677479c7321988b4b0f166.png"></p>
<h3 id="7-线上实验——原码二位乘法器设计"><a href="#7-线上实验——原码二位乘法器设计" class="headerlink" title="7.线上实验——原码二位乘法器设计"></a>7.线上实验——原码二位乘法器设计</h3><p>请用硬件描述语言设计一个原码二位乘法器，其中两个操作数位宽为8，请给出仿真结果。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7bb5fc46ac6d878964e59ddeb1fe803c.png"></p>
<p>顶层——multiplier_2bit：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity multiplier_2bit is
    Port(
        clk,start:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        done:out std_logic;
        sout:inout std_logic_vector(15 downto 0)
    );
end multiplier_2bit;

architecture Behavioral of multiplier_2bit is

component multiplier_ctrl
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end component;
component multiplier_8bitshiftreg
    Port (
        clk,load:in std_logic;
        din:in std_logic_vector(7 downto 0);
        qb0,qb1:out std_logic
     );
end component;
component multiplier_16bitreg
    Port (
        clk,clr:in std_logic;
        d:in std_logic_vector(8 downto 0);
        q:out std_logic_vector(15 downto 0)
     );
end component;
component multiplier_selector
    Port (
        clk,rst:in std_logic;
        a0,a1,cin:in std_logic;
        din:in std_logic_vector(7 downto 0);
        cout:out std_logic;
        dout:out std_logic_vector(7 downto 0)
     );
end component;
component multiplier_8bitadder
    Port (
        clk,rst:in std_logic;
        cin:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end component;

signal clk_line:std_logic;
signal rst_line:std_logic;
signal cin_line:std_logic;
signal qb1_line,qb0_line:std_logic;
signal bin_line:std_logic_vector(7 downto 0);
signal sout_line:std_logic_vector(8 downto 0);
signal test_line:std_logic_vector(8 downto 0);

begin
multiplier_ctrl_inst:multiplier_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);
multiplier_8bitshiftreg_inst:multiplier_8bitshiftreg port map(clk=&gt;clk_line,load=&gt;rst_line,din=&gt;ain,qb0=&gt;qb0_line,qb1=&gt;qb1_line);
multiplier_16bitreg_inst:multiplier_16bitreg port map(clk=&gt;clk_line,clr=&gt;rst_line,d=&gt;sout_line,q=&gt;sout);
multiplier_selector_inst:multiplier_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;qb0_line,a1=&gt;qb1_line,cin=&gt;sout_line(8),din=&gt;bin,cout=&gt;cin_line,dout=&gt;bin_line);
multiplier_8bitadder_inst:multiplier_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,cin=&gt;cin_line,ain=&gt;sout(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f30332a988566f33bab93454ab0c0ca.png"></p>
<p>testbench:</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity multiplier_2bit_tb is
--  Port ( );
end multiplier_2bit_tb;

architecture Behavioral of multiplier_2bit_tb is
component multiplier_2bit
    Port(
        clk,start:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        done:out std_logic;
        sout:inout std_logic_vector(15 downto 0)
    );
end component;
signal clk,start: std_logic;
signal ain,bin: std_logic_vector(7 downto 0);
signal done: std_logic;
signal sout: std_logic_vector(15 downto 0);
begin
multiplier_2bit_inst:multiplier_2bit port map(clk,start,ain,bin,done,sout);

clock_gen:process
begin  
    clk&lt;=&#39;1&#39;;
    wait for 10ns;
    clk&lt;=&#39;0&#39;;
    wait for 10ns;
end process;

test:process
begin
    ain&lt;=&quot;10011010&quot;;
    bin&lt;=&quot;01100101&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 150ns;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/559a1c00923a7cda00c06f63c6dec1cc.png"></p>
<p>模块：</p>
<p>multiplier_2bit_ctrl ：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_ctrl is
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end multiplier_ctrl;

architecture Behavioral of multiplier_ctrl is

signal cnt3b:std_logic_vector(2 downto 0);

begin

process(clk,start)
begin
    rstall&lt;=start;
    if(start=&#39;1&#39;)then cnt3b&lt;=&quot;000&quot;;
    elsif clk&#39;event and clk=&#39;1&#39;then if cnt3b&lt;=4 then cnt3b&lt;=cnt3b+1;end if;
    end if;
end process;

process(clk,cnt3b,start)
begin
    if (start=&#39;1&#39;)then
        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;; 
    elsif(start=&#39;0&#39;)then    
        if cnt3b&lt;=4 then clkout&lt;=clk;
        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;
        end if; 
    end if;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/920cb7c013bd5af2e09bc59aafba028c.png"></p>
<p>multiplier_2bit_8bitshiftreg：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_8bitshiftreg is
    Port (
        clk,load:in std_logic;
        din:in std_logic_vector(7 downto 0);
        qb0,qb1:out std_logic
     );
end multiplier_8bitshiftreg;

architecture Behavioral of multiplier_8bitshiftreg is

signal reg8b:std_logic_vector(7 downto 0);

begin

process(clk,load)
begin
    if load=&#39;1&#39;then reg8b&lt;=din;qb0&lt;=&#39;0&#39;;qb1&lt;=&#39;0&#39;;end if;
    if(load=&#39;0&#39;and clk=&#39;1&#39;)then 
        qb0&lt;=reg8b(0);
        qb1&lt;=reg8b(1);
        reg8b(5 downto 0)&lt;=reg8b(7 downto 2);
        reg8b(7 downto 6)&lt;=&quot;00&quot;;   
    end if;     
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d171f9dc0e6d54b72cf1ffe1f8c759ec.png"></p>
<p>multiplier_2bit_16bitreg：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_16bitreg is
    Port (
        clk,clr:in std_logic;
        d:in std_logic_vector(8 downto 0);
        q:out std_logic_vector(15 downto 0)
     );
end multiplier_16bitreg;

architecture Behavioral of multiplier_16bitreg is

begin

process(clk,clr)
variable sr16b:std_logic_vector(15 downto 0);
begin
    if clr=&#39;1&#39;then
        sr16b:=&quot;0000000000000000&quot;;
    elsif(clr=&#39;0&#39;and clk&#39;event and clk=&#39;1&#39;)then  
        sr16b(15 downto 8):=d(7 downto 0);
        sr16b(13 downto 0):=sr16b(15 downto 2);
        sr16b(15):=d(8);
        sr16b(14):=d(8);
    end if;   
    q&lt;=sr16b;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/08847d6e576be1f9f61c68f8d15899b6.png"></p>
<p>multiplier_2bit_selector：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_selector is
    Port (
        clk,rst:in std_logic;
        a0,a1,cin:in std_logic;
        din:in std_logic_vector(7 downto 0);
        cout:out std_logic;
        dout:out std_logic_vector(7 downto 0)
     );
end multiplier_selector;

architecture Behavioral of multiplier_selector is

begin

process(clk,a0,a1,cin,din)
begin
    if(rst=&#39;1&#39;)then cout&lt;=&#39;0&#39;;dout&lt;=&quot;00000000&quot;;
    elsif(rst=&#39;0&#39;and clk&#39;event and clk=&#39;0&#39;)then
        if(a0=a1 and a0=cin)then dout&lt;=&quot;00000000&quot;;cout&lt;=cin;
        elsif(a1=&#39;0&#39;and (a0 xor cin)=&#39;1&#39;)then dout&lt;=din;cout&lt;=&#39;0&#39;;
        elsif((a1 xor a0)=&#39;1&#39;and a0=cin)then
            dout(7 downto 1)&lt;=din(6 downto 0);  
            dout(0)&lt;=&#39;0&#39;;
            cout&lt;=&#39;0&#39;;
        elsif(a1=&#39;1&#39;and(a0 xor cin)=&#39;1&#39;)then
            dout&lt;=(not din)+1;
            cout&lt;=&#39;1&#39;;  
        end if;
    end if;    
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e286d15abce298cf0b629350ba7e076e.png"></p>
<p>multiplier_2bit_8bitadder：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_8bitadder is
    Port (
        clk,rst:in std_logic;
        cin:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end multiplier_8bitadder;

architecture Behavioral of multiplier_8bitadder is
begin

process(clk,rst,ain,bin,cin)
begin
    if(rst=&#39;1&#39;)then sout&lt;=&quot;000000000&quot;;
    elsif(rst=&#39;0&#39;and clk=&#39;0&#39;)then
        sout&lt;=(&#39;0&#39;&amp; ain)+(cin &amp; bin);
    end if;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cdd818c3fea80ef3bef0a36c7c6ab446.png"></p>
<p><strong>设计注意点：</strong></p>
<p>0.设计顺序：控制器-8b移位寄存器-16位缓存器-选择器-加法器</p>
<p>1.输入位8位无符号数，若输入有符号数需修改位宽并另外计算符号位。</p>
<p>2.共用总线需注意时序，防止总线冲突以及数据读取错误</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b25fa007565503bdd4b69b5d6c31496d.png"></p>
<p>共用总线sout时序设计：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/daac7ca07dca672e89a3e831d4b8bd9a.png"></p>
<p>3.process内语句顺序执行的次序。</p>
<p>4.变量的使用：mulitiplier_16bitreg中</p>
<pre><code>variable sr16b:std_logic_vector(15 downto 0);
</code></pre>
<p>若使用 signal sr16b，则 q&lt;&#x3D;sr16b; 无效</p>
<p>5.位拓展：</p>
<pre><code>sout&lt;=(&#39;0&#39;&amp; ain)+(cin &amp; bin); 
</code></pre>
<p>使用 &amp; 符拓展位宽</p>
<h3 id="8-线上实验——布斯乘法器设计"><a href="#8-线上实验——布斯乘法器设计" class="headerlink" title="8.线上实验——布斯乘法器设计"></a>8.线上实验——布斯乘法器设计</h3><p>采用硬件描述语言设计实现布斯乘法器，完成逻辑功能设计及仿真验证，并给出仿真结果。</p>
<p>按照7中的设计顺序对7中设计文件进行修改：</p>
<pre><code>    ctrl模块发出时钟周期数改为8；8bitshiftreg和16bitreg模块每个时钟周期移动1位，且8；8bitshiftreg输出的是a0和a-1；16bitreg和selector模块载入数值后求补；selector模块删去cin和cout信号并修改规则；adder无cin...
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8c09ab4e531a18f069ba4afb9e18d438.png"></p>
<p>顶层模块——multiplier_booth：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity multiplier_booth is
    Port(
        clk,start:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        done:out std_logic;
        sout:inout std_logic_vector(15 downto 0)
    );
end multiplier_booth;

architecture Behavioral of multiplier_booth is

component multiplier_booth_ctrl
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end component;
component multiplier_booth_8bitshiftreg
    Port (
        clk,load:in std_logic;
        din:in std_logic_vector(7 downto 0);
        qb0,qb1:out std_logic
     );
end component;
component multiplier_booth_16bitreg
    Port (
        clk,clr:in std_logic;
        d:in std_logic_vector(8 downto 0);
        q:out std_logic_vector(15 downto 0)
     );
end component;
component multiplier_booth_selector
    Port (
        clk,rst:in std_logic;
        a0,a1:in std_logic;
        din:in std_logic_vector(7 downto 0);
        dout:out std_logic_vector(7 downto 0)
     );
end component;
component multiplier_booth_8bitadder
    Port (
        clk,rst:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end component;

signal clk_line:std_logic;
signal rst_line:std_logic;
signal qb1_line,qb0_line:std_logic;
signal bin_line:std_logic_vector(7 downto 0);
signal sout_line:std_logic_vector(8 downto 0);
signal test_line:std_logic_vector(8 downto 0);

begin
multiplier_booth_ctrl_inst:multiplier_booth_ctrl port map(clk=&gt;clk,start=&gt;start,clkout=&gt;clk_line,rstall=&gt;rst_line,done=&gt;done);
multiplier_booth_8bitshiftreg_inst:multiplier_booth_8bitshiftreg port map(clk=&gt;clk_line,load=&gt;rst_line,din=&gt;ain,qb0=&gt;qb0_line,qb1=&gt;qb1_line);
multiplier_booth_16bitreg_inst:multiplier_booth_16bitreg port map(clk=&gt;clk_line,clr=&gt;rst_line,d=&gt;sout_line,q=&gt;sout);
multiplier_booth_selector_inst:multiplier_booth_selector port map(clk=&gt;clk_line,rst=&gt;rst_line,a0=&gt;qb0_line,a1=&gt;qb1_line,din=&gt;bin,dout=&gt;bin_line);
multiplier_booth_8bitadder_inst:multiplier_booth_8bitadder port map(clk=&gt;clk_line,rst=&gt;rst_line,ain=&gt;sout(15 downto 8),bin=&gt;bin_line,sout=&gt;sout_line);

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3e67513e1e27963a8e15f23f6a8cc7c.png"></p>
<p>testbench：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity multiplier_booth_tb is
--  Port ( );
end multiplier_booth_tb;

architecture Behavioral of multiplier_booth_tb is
component multiplier_booth
    Port(
        clk,start:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        done:out std_logic;
        sout:inout std_logic_vector(15 downto 0)
    );
end component;
signal clk,start: std_logic;
signal ain,bin: std_logic_vector(7 downto 0);
signal done: std_logic;
signal sout: std_logic_vector(15 downto 0);
begin
multiplier_booth_inst:multiplier_booth port map(clk,start,ain,bin,done,sout);

clock_gen:process
begin  
    clk&lt;=&#39;1&#39;;
    wait for 10ns;
    clk&lt;=&#39;0&#39;;
    wait for 10ns;
end process;

test:process
begin
    ain&lt;=&quot;00000010&quot;;
    bin&lt;=&quot;10000010&quot;;
    wait for 25ns;
    start&lt;=&#39;1&#39;;
    wait for 25ns;
    start&lt;=&#39;0&#39;;    
    wait for 200ns;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4cd31e8dc5958ee6e4b4eedfd590f2fa.png"></p>
<p>模块：</p>
<p>multiplier_booth_ctrl：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_booth_ctrl is
    Port (
        clk,start:in std_logic;
        clkout,rstall,done:out std_logic
     );
end multiplier_booth_ctrl;

architecture Behavioral of multiplier_booth_ctrl is

signal cnt4b:std_logic_vector(3 downto 0);

begin

process(clk,start)
begin
    rstall&lt;=start;
    if(start=&#39;1&#39;)then cnt4b&lt;=&quot;0000&quot;;
    elsif clk&#39;event and clk=&#39;1&#39;then if cnt4b&lt;=8 then cnt4b&lt;=cnt4b+1;end if;
    end if;
end process;

process(clk,cnt4b,start)
begin
    if (start=&#39;1&#39;)then
        clkout&lt;=&#39;0&#39;;done&lt;=&#39;0&#39;; 
    elsif(start=&#39;0&#39;)then    
        if cnt4b&lt;=8 then clkout&lt;=clk;
        else clkout&lt;=&#39;0&#39;;done&lt;=&#39;1&#39;;
        end if; 
    end if;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/83c13baff1be05be6cda0e582d59099f.png"></p>
<p>multiplier_booth_8bitshiftreg：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_booth_8bitshiftreg is
    Port (
        clk,load:in std_logic;
        din:in std_logic_vector(7 downto 0);
        qb0,qb1:out std_logic
     );
end multiplier_booth_8bitshiftreg;

architecture Behavioral of multiplier_booth_8bitshiftreg is

signal reg8b:std_logic_vector(8 downto 0);

begin

process(clk,load)
begin
    if load=&#39;1&#39;then 
        if(din(7)=&#39;1&#39;)then reg8b(8 downto 1)&lt;=(din(7)&amp;(not din(6 downto 0)))+1;else reg8b(8 downto 1)&lt;=din;end if;  --取补码
        reg8b(0)&lt;=&#39;0&#39;;
        qb0&lt;=&#39;0&#39;;qb1&lt;=&#39;0&#39;;
    end if;
    if(load=&#39;0&#39;and clk=&#39;1&#39;)then 
        qb0&lt;=reg8b(0);
        qb1&lt;=reg8b(1);
        reg8b(7 downto 0)&lt;=reg8b(8 downto 1);
        reg8b(8)&lt;=&#39;0&#39;;   
    end if;     
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/61bbc405e10beaea2c2635a94871b4cb.png"></p>
<p>multiplier_booth_16bitreg：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_booth_16bitreg is
    Port (
        clk,clr:in std_logic;
        d:in std_logic_vector(8 downto 0);
        q:out std_logic_vector(15 downto 0)
     );
end multiplier_booth_16bitreg;

architecture Behavioral of multiplier_booth_16bitreg is

begin

process(clk,clr)
variable sr16b:std_logic_vector(15 downto 0);
begin
    if clr=&#39;1&#39;then
        sr16b:=&quot;0000000000000000&quot;;
    elsif(clr=&#39;0&#39;and clk&#39;event and clk=&#39;1&#39;)then  
        sr16b(15 downto 8):=d(7 downto 0);
        sr16b(14 downto 0):=sr16b(15 downto 1);
        sr16b(15):=d(8);    --移位复制符号位
    end if;   
    q&lt;=sr16b;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/78e8dae445e0aa8620fd29c657228abd.png"></p>
<p>multiplier_booth_selector：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_booth_selector is
    Port (
        clk,rst:in std_logic;
        a0,a1:in std_logic;
        din:in std_logic_vector(7 downto 0);
        dout:out std_logic_vector(7 downto 0)
     );
end multiplier_booth_selector;

architecture Behavioral of multiplier_booth_selector is

begin

process(clk,a0,a1,din)
variable complement_x:std_logic_vector(7 downto 0);
variable complement_x_negative:std_logic_vector(7 downto 0);
begin
    if(rst=&#39;1&#39;)then dout&lt;=&quot;00000000&quot;;
    elsif(rst=&#39;0&#39;and clk&#39;event and clk=&#39;0&#39;)then
        if(din(7)=&#39;1&#39;)then complement_x:=(din(7)&amp;(not din(6 downto 0)))+1;else complement_x:=din;end if;    --取X补码
        if((not din(7))=&#39;1&#39;)then complement_x_negative:=((not din(7))&amp;(not din(6 downto 0)))+1;else complement_x_negative:=(not din(7))&amp;din(6 downto 0);end if; --取-X补码
        if(a1=a0)then dout&lt;=&quot;00000000&quot;;
        elsif(a0=&#39;1&#39;and a1=&#39;0&#39;)then dout&lt;=complement_x;
        elsif(a0=&#39;0&#39;and a1=&#39;1&#39;)then dout&lt;=complement_x_negative;
        end if;
    end if;    
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9597c2a19cccbc17358d377d0ee32df8.png"></p>
<p>multiplier_booth_8bitadder：</p>
<pre><code>library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity multiplier_booth_8bitadder is
    Port (
        clk,rst:in std_logic;
        ain,bin:in std_logic_vector(7 downto 0);
        sout:out std_logic_vector(8 downto 0)
     );
end multiplier_booth_8bitadder;

architecture Behavioral of multiplier_booth_8bitadder is
begin

process(clk,rst,ain,bin)
begin
    if(rst=&#39;1&#39;)then sout&lt;=&quot;000000000&quot;;
    elsif(rst=&#39;0&#39;and clk=&#39;0&#39;)then
        sout&lt;=(ain(7) &amp; ain)+(bin(7)  &amp; bin);   --符号位扩展加法
    end if;
end process;

end Behavioral;
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d7c983ed1ce45af2d329d820c088e9dd.png"></p>
<p><strong>设计注意点：</strong></p>
<p>1.求补码的方法：</p>
<pre><code>if(din(7)=&#39;1&#39;)then 
    reg8b(8 downto 1)&lt;=(din(7)&amp;(not din(6 downto 0)))+1;
else reg8b(8 downto 1)&lt;=din;
end if;  
--取补码
</code></pre>
<p>2.求和时符号位拓展：</p>
<pre><code>sout&lt;=(ain(7) &amp; ain)+(bin(7)  &amp; bin);   --符号位扩展加法
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/137247923">https://blog.csdn.net/qq_32971095/article/details/137247923</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/29/Vitis%20AI%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/29/Vitis%20AI%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Vitis AI——FPGA学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-29 17:29:19" itemprop="dateCreated datePublished" datetime="2024-03-29T17:29:19+08:00">2024-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:54:05" itemprop="dateModified" datetime="2025-02-08T11:54:05+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考资料：</p>
<p>[Xilinx&#x2F;Vitis-AI-Tutorials (github.com)](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI-">https://github.com/Xilinx/Vitis-AI-</a><br>Tutorials “Xilinx&#x2F;Vitis-AI-Tutorials (github.com)“)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI" title="Xilinx&#x2F;Vitis-
AI: Vitis AI is Xilinx’s development stack for AI inference on Xilinx hardware
platforms">Xilinx&#x2F;Vitis-AI: Vitis AI is Xilinx’s development stack for AI inference on<br>Xilinx hardware platforms</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iR4y1k7wn/?spm_id_from=333.788&vd_source=01cde8042a76495bf513aa4407a56cd6" title="【03】ALINX Zynq UltraScale+ MPSoC XILINX FPGA视频教程Vitis AI开发">【03】ALINX Zynq UltraScale+ MPSoC XILINX FPGA视频教程Vitis<br>AI开发</a></p>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>边缘计算edge-ai；cloud-computing-edge-computing</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/089f9efe7c54689a339a571239a84873.png"></p>
<p>edge端inference全栈部署方案</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/966474c137754c658fddaa07152e7ef2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/319a2ebc600fdfb819856d52d5825acc.png"></p>
<h4 id="安装vitis-ai的准备"><a href="#安装vitis-ai的准备" class="headerlink" title="安装vitis-ai的准备"></a>安装vitis-ai的准备</h4><p>In addition, Vitis AI supports three host types（对于三种类型的机器，安装vitis-ai需做一定准备：</p>
<blockquote>
<blockquote>
<ul>
<li>CPU-only with no GPU acceleration：CPU hosts require no special<br>preparation.<blockquote>
<ul>
<li>CUDA-capable GPUs</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>AMD ROCm™ GPUs：见[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt#id3 “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt”)</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>&lt;1&gt;安装docker、Clone github Repository：</p>
<pre><code>git clone https://github.com/Xilinx/Vitis-AI
cd Vitis-AI
</code></pre>
<p>注：You are now ready to start working with the Vitis AI Docker container. At<br>this stage you will choose whether you wish to <strong>use the pre-built container,<br>or build the container from scripts</strong>. docker环境的搭建可以选择Vitis-<br>ai中的脚本搭建或者docker官方直接下载<strong>预构建的</strong> 特定架构docker（见后），即：</p>
<pre><code>docker pull xilinx/vitis-ai-&lt;Framework&gt;-&lt;Arch&gt;:latest
</code></pre>
<table>
<thead>
<tr>
<th>Desired Docker</th>
<th><Framework></Framework></th>
<th><Arch></Arch></th>
</tr>
</thead>
<tbody><tr>
<td>PyTorch cpu-only</td>
<td>pytorch</td>
<td>cpu</td>
</tr>
<tr>
<td>TensorFlow 2 cpu-only</td>
<td>tensorflow2</td>
<td>cpu</td>
</tr>
<tr>
<td>TensorFlow 1.15 cpu-only</td>
<td>tensorflow</td>
<td>cpu</td>
</tr>
<tr>
<td>PyTorch ROCm</td>
<td>pytorch</td>
<td>rocm</td>
</tr>
<tr>
<td>TensorFlow 2 ROCm</td>
<td>tensorflow2</td>
<td>rocm</td>
</tr>
</tbody></table>
<p>或：</p>
<pre><code>cd &lt;Vitis-AI install path&gt;/Vitis-AI
./docker_run.sh xilinx/vitis-ai-&lt;pytorch|tensorflow2|tensorflow&gt;-&lt;cpu|rocm&gt;:latest
</code></pre>
<p>适用机器类型：</p>
<ol>
<li>CPU-only</li>
<li>CUDA-capable GPUs</li>
<li>ROCm-capable GPUs</li>
</ol>
<p>注：The <code>cpu</code> option <em>does not provide GPU acceleration support</em>  which is<br><strong>strongly recommended</strong>  for acceleration of the Vitis AI [:ref:<code>Quantization process &lt;quantization-process&gt;</code>](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;install.rst.txt#id11<br>“:ref:<code>Quantization process &lt;quantization-process&gt;</code> “). The pre-built <code>cpu</code><br>container should only be used when a GPU is not available on the host machine.</p>
<p>（原文详细介绍了在NVIDIA器件上支持CUDA GPU的vitis-ai搭建）</p>
<p>注：vitis-ai补丁安装：[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;patch_instructions.rst.txt”)</p>
<p>&lt;2&gt;安装交叉编译环境</p>
<p>By default, the<strong>cross compiler</strong> will be installed in<br><strong><code>~/petalinux_sdk_2023.1</code></strong>. The ~&#x2F;petalinux_sdk_2023.1 path is recommended<br>for the installation. Regardless of the path you choose for the installation,<br>make sure the path has read-write permissions. In this quickstart, it is<br>installed in ~&#x2F;petalinux_sdk_2023.1</p>
<p>在bash中执行：</p>
<pre><code>[Host] $ cd Vitis-AI/board_setup/vek280
[Host] $ sudo chmod u+r+x host_cross_compiler_setup.sh
[Host] $ ./host_cross_compiler_setup.sh
</code></pre>
<p>注：为下载相关资源，执行前的软件安装源为清华源，也可参考：[Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;install&#x2F;China_Ubuntu_servers.”)</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/93def47e1072cf25c9fb7e564d9ac777.png"></p>
<p> When the installation is complete, follow the prompts and execute the<br>following command:</p>
<pre><code>source ~/petalinux_sdk_2023.1/environment-setup-cortexa72-cortexa53-xilinx-linux
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc05d626369cb12f1b1b386fad291dfc.png"></p>
<pre><code>     The **DPU** implements **an efficient tensor-level instruction set **designed to support and **accelerate** various popular **convolutional neural networks** , such as VGG, ResNet, GoogLeNet, YOLO, SSD, and MobileNet, among others. 

    The DPU supports on AMD **Zynq™ UltraScale+™ MPSoCs, the Kria™ KV260, Versal™ and Alveo cards**. It scales to meet the requirements of many diverse applications in terms of throughput, latency, scalability, and power. 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/acb9834ffdad75aafa209db3944d7929.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b926c0530c9f863597c101da17b84dd2.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7632c574e72b01f31355845825ac6439.png"></p>
<h5 id="Zynq-™-UltraScale-™-MPSoC-DPUCZDX8G-workflow-system"><a href="#Zynq-™-UltraScale-™-MPSoC-DPUCZDX8G-workflow-system" class="headerlink" title="Zynq ™ UltraScale+ ™ MPSoC: DPUCZDX8G([workflow-system-"></a>Zynq ™ UltraScale+ ™ MPSoC: DPUCZDX8G([workflow-system-</h5><p>integration.rst.txt at master](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;master&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;workflow-system-integration.rst.txt<br>“workflow-system-integration.rst.txt at master”)</p>
<p>The DPUCZDX8G IP has been optimized for Zynq UltraScale+ MPSoC. You can<br>integrate this IP as a block in the programmable logic (PL) of the selected<br>Zynq UltraScale+ MPSoCs with direct connections to the processing system (PS).<br>The DPU is user-configurable and exposes several parameters which can be<br>specified to optimize PL resources or customize enabled features.</p>
<p> 下载地址：</p>
<table>
<thead>
<tr>
<th>Product Guide</th>
<th>Platforms</th>
<th>Vitis AI Release</th>
<th>Reference Design</th>
<th>IP-only Download</th>
</tr>
</thead>
<tbody><tr>
<td>DPUCV2DX8G <a target="_blank" rel="noopener" href="https://docs.xilinx.com/r/en-US/pg425-dpu" title="PG425">PG425</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VEK280&#x2F;V70&#x2F;Vx2802</td>
<td>3.5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[Download](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_VAI_v3.5.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_VAI_v3.5.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Download”)</td>
<td>[Get</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IP](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_ip_repo_VAI_v3.5.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCV2DX8G_ip_repo_VAI_v3.5.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Get IP”)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DPUCV2DX8G <a target="_blank" rel="noopener" href="https://docs.xilinx.com/r/en-US/pg425-dpu" title="PG425">PG425</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VE2302(see note)</td>
<td>3.5</td>
<td>[Early Access](<a target="_blank" rel="noopener" href="https://account.amd.com/en/member/vitis-">https://account.amd.com/en/member/vitis-</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ai-ve2302.html “Early Access”)</td>
<td>[Early</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Access](<a target="_blank" rel="noopener" href="https://account.amd.com/en/member/vitis-ai-ve2302.html">https://account.amd.com/en/member/vitis-ai-ve2302.html</a> “Early Access”)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DPUCZDX8G <a target="_blank" rel="noopener" href="https://docs.xilinx.com/r/en-US/pg338-dpu" title="PG338">PG338</a></td>
<td>MPSoC &amp;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Kria K26</td>
<td>3.0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[Download](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_VAI_v3.0.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Download”)</td>
<td>[Get</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IP](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_ip_repo_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCZDX8G_ip_repo_VAI_v3.0.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Get IP”)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DPUCVDX8G <a target="_blank" rel="noopener" href="https://docs.xilinx.com/r/en-US/pg389-dpu" title="PG389">PG389</a></td>
<td>VCK190</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3.0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[Download](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_VAI_v3.0.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Download”)</td>
<td>[Get</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IP](<a target="_blank" rel="noopener" href="https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_ip_repo_VAI_v3.0.tar.gz">https://www.xilinx.com/bin/public/openDownload?filename=DPUCVDX8G_ip_repo_VAI_v3.0.tar.gz</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“Get IP”)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>For MPSoC and Versal AI Core (non AIE-ML devices) please refer to the**&#x2F;dpu**<br>subdirectory in the Vitis AI 3.0 Github repository.</p>
<p><strong>部署过程：</strong>[Vitis-AI-Tutorials&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD at 2.0 ·<br>Xilinx&#x2F;Vitis-AI-Tutorials (github.com)](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-AI-">https://github.com/Xilinx/Vitis-AI-</a><br>Tutorials&#x2F;tree&#x2F;2.0&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD “Vitis-AI-<br>Tutorials&#x2F;Tutorials&#x2F;Vitis-AI-Vivado-TRD at 2.0 · Xilinx&#x2F;Vitis-AI-Tutorials<br>(github.com)“)</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/959557dd80a7f6cf4d928cceb75051d3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0508c091f64853b67804b2e760e60cbb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3caf388ba1b35f2a14b2243c95dc133c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/999d2443c9fa5ace609d9ea94ced32fa.png"></p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7830ed03ef207f14e4a19700168625d9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd38dd26c8c57234f377f0f7a4a2ef48.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5558aa103e0c00df512de7552ebe3804.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8bd66f3a8c93d2eb320e9af0f1109b3c.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18e33f756df780499701f1488563de29.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8913598ae8b0c899f6a709062fe876f9.png"></p>
<h3 id="3-vitis-ai的解决方案"><a href="#3-vitis-ai的解决方案" class="headerlink" title="3.vitis-ai的解决方案"></a>3.vitis-ai的解决方案</h3><p>The Vitis AI solution is packaged and delivered as follows:</p>
<ul>
<li>AMD open download: pre-built target <strong>images</strong> integrating the <strong>DPU</strong></li>
<li>Vitis AI <strong>docker containers</strong> : model development tools</li>
<li>Vitis AI <strong>github repository</strong> : model deployment libraries, setup scripts, examples and reference designs</li>
</ul>
<h3 id="4-vitis-ai工具链"><a href="#4-vitis-ai工具链" class="headerlink" title="4.vitis-ai工具链"></a>4.vitis-ai工具链</h3><p><strong>Model Development</strong><br><strong>Vitis AI Model Zoo</strong><br>The :ref:<code>Vitis AI Model Zoo &lt;workflow-model-zoo&gt;</code> includes <strong>optimized deep<br>learning models</strong> to speed up the deployment of deep learning inference on<br>adaptable AMD platforms. These models cover different applications, including<br>ADAS&#x2F;AD, video surveillance, robotics, and data center. You can get started<br>with these pre-trained models to enjoy the benefits of deep learning<br>acceleration.</p>
<p><strong>Vitis AI Model Inspector</strong><br>The :ref:<code>Vitis AI Model Inspector &lt;model-inspector&gt;</code> is used to <strong>perform<br>initial sanity checks</strong> to confirm that t<strong>he operators and sequence of<br>operators</strong> in the graph is compatible with Vitis AI. Novel neural network<br>architectures, operators, and activation types are constantly being developed<br>and optimized for prediction accuracy and performance. Vitis AI provides<br>mechanisms to leverage operators that are not natively supported by your<br>specific DPU target.</p>
<p><strong>Vitis AI Optimizer</strong><br>The :ref:<code>Vitis AI Optimizer &lt;model-optimization&gt;</code> exploits <strong>the notion of<br>sparsity</strong> to r<strong>educe the overall computational complexity</strong> for inference by<br>5x to 50x with minimal accuracy degradation. Many deep neural network<br>topologies employ significant levels of redundancy. This is particularly true<br>when the network backbone is optimized for prediction accuracy with training<br>datasets supporting many classes. In many cases, this redundancy can be<br>reduced by “pruning” some of the operations out of the graph.</p>
<p><strong>Vitis AI Quantizer</strong><br>The :ref:<code>Vitis AI Quantizer &lt;model-quantization&gt;</code>, integrated as a component<br>of either TensorFlow or PyTorch, <strong>converts 32-bit floating-point weights</strong><br>and activations to<strong>fixed-point integers like INT8</strong> to reduce the computing<br>complexity without losing prediction accuracy. The fixed-point network model<br>requires less memory bandwidth and provides faster speed and higher power<br>efficiency than the floating-point model.</p>
<p><strong>Vitis AI Compiler</strong><br>The :ref:<code>Vitis AI Compiler &lt;model-compilation&gt;</code> maps the AI quantized<br>model<strong>to a highly-efficient instruction set and dataflow model</strong>. The<br>compiler performs multiple optimizations; for example, batch normalization<br>operations are fused with convolution when the convolution operator precedes<br>the normalization operator. As the DPU supports <strong>multiple dimensions of<br>parallelism</strong> , efficient instruction scheduling is <strong>key to exploiting the<br>inherent parallelism</strong> and potential for <strong>data reuse</strong> in the graph. The<br>Vitis AI Compiler addresses such optimizations.</p>
<p><strong>Model Deployment<br>Vitis AI Runtime</strong><br>The :ref:<code>Vitis AI Runtime &lt;vitis-ai-runtime&gt;</code> (VART) is<strong>a set of low-level<br>API functions</strong> that support the integration of the DPU into software<br>applications. VART is built on top of the Xilinx Runtime (XRT) amd provides a<br>unified high-level runtime for both Data Center and Embedded targets. Key<br>features of the <strong>Vitis AI Runtime API</strong> include:</p>
<p>Asynchronous <strong>submission</strong> of <strong>jobs</strong> to the <strong>DPU</strong>.<br>Asynchronous <strong>collection</strong> of <strong>jobs</strong> from the <strong>DPU</strong>.<br><strong>C++ and Python API</strong> implementations.<br>Support for <strong>multi-threading and multi-process</strong> execution.<br><strong>Vitis AI Library</strong><br>The :ref:<code>Vitis AI Library &lt;vitis-ai-library&gt;</code> is a set of <strong>high-level<br>libraries and APIs built on top of the Vitis AI Runtime (VART)</strong>. The higher-<br>level APIs included in the Vitis AI Library give developers a head-start on<br>model deployment. While it is possible for developers to directly leverage the<br>Vitis AI Runtime APIs to deploy a model on AMD platforms, it is often more<br>beneficial to start with a ready-made example that incorporates the various<br>elements of a typical application, including:</p>
<p><strong>Simplified CPU-based pre and post-processing implementations.</strong><br>Vitis AI Runtime integration at an application level.<br><strong>Vitis AI Profiler</strong><br>The :ref:<code>Vitis AI Profiler &lt;vitis-ai-profiler&gt;</code> profiles and visualizes AI<br>applications to find <strong>bottlenecks</strong> and allocates computing resources among<br>different devices. It is easy to use and requires no code changes. It can<br><strong>trace function calls</strong> and <strong>run time</strong> , and also <strong>collect hardware<br>information</strong> , including CPU, DPU, and memory utilization.</p>
<p>模型开发：示例模型、检查器（语法、适用性）、优化器（稀疏连接）、量化器（位宽）、编译器（DPU指令）</p>
<p>模型部署：VART（DPU API）、Library（优化预处理、后处理）、分析器（各环节运行时间）</p>
<h2 id="二-Docker环境搭建"><a href="#二-Docker环境搭建" class="headerlink" title="二.Docker环境搭建"></a>二.Docker环境搭建</h2><p>在第一部分“安装的准备”已经介绍了搭建的两种方法。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32b5b070bc91e1a49bc4d0cf742becc9.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0f0f5995489ccc5498b68acb9a6ac56.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3fde56db0b1e14a450d2f3f07ce98f82.png"></p>
<pre><code>sudo apt-get remove docker-engine docker-ce docker.io

sudo apt-get install curl

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

sudo apt-get update &amp;&amp; sudo apt install docker-ce docker-ce-cll containerd.io

systemctl status docker

sudo docker run hello-world

sudo usermod -aG docker $USER

newgrp docker

docker run hello-world

docker info

docker images

docker ps -a
</code></pre>
<p>若安装docker-ce失败：</p>
<p><a target="_blank" rel="noopener" href="https://mirror.tuna.tsinghua.edu.cn/help/docker-ce/" title="docker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror">docker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p>下载vitis-ai的docker：</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/r/xilinx/vitis-ai-cpu" title="xilinx&#x2F;vitis-ai-cpu - Docker Image | Docker Hub">xilinx&#x2F;vitis-ai-cpu - Docker Image | Docker Hub</a></p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/r/xilinx/vitis-ai" title="xilinx&#x2F;vitis-ai - Docker Image | Docker Hub">xilinx&#x2F;vitis-ai - Docker Image | Docker Hub</a></p>
<pre><code>docker pull xilinx/vitis-ai
</code></pre>
<p>使用git命令下载vitis-ai</p>
<pre><code>git clone https://github.com/Xilinx/Vitis-AI
</code></pre>
<p>启动docker环境：vitis-ai目录下运行脚本</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/17de1dceb4e74e034696eb3b16af2272.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/53bfce013f7c4c2e53486eb49cae2149.png"></p>
<p>可以看到其工作目录为workspace，上机目录直接为系统根目录：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/00f5736efd94ea115591a8121f7171b4.png"></p>
<p> 而且这个docker预装了conda，进入 tensorflow 的conda并打印其组件：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1a916ce4ff8de0d37df1060bec900bd9.png"></p>
<p>其他docker命令：[Docker最新超详细版教程通俗易懂(基础版) - 知乎<br>(zhihu.com)](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/442442997">https://zhuanlan.zhihu.com/p/442442997</a> “Docker最新超详细版教程通俗易懂(基础版)</p>
<ul>
<li>知乎 (zhihu.com)“)</li>
</ul>
<h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三.实例"></a>三.实例</h2><h3 id="1-下载示例模型"><a href="#1-下载示例模型" class="headerlink" title="1.下载示例模型"></a>1.下载示例模型</h3><p>在model_zoo文件夹内可以浏览各种支持的模型，这里我们选择tf_yolov3_3.5，打开model_info.md文件：</p>
<pre><code># YOLOv3

### Contents
1. [Use Case and Application](#Use-Case-and-Application)
2. [Specification](#Specification)
3. [Paper and Architecture](#Paper-and-Architecture)
4. [Dataset Preparation](#Dataset-Preparation)
5. [Use Guide](#Use-Guide)
6. [License](#License)
7. [Note](#Note)


### Use Case and Application

   - Classic Object Detection
   - Trained on VOC dataset
   
   
### Specification

| Metric             | Value                                   |
| :----------------- | :-------------------------------------- |
| Framework          | TensorFlow2                             |
| Prune Ratio        | 0%                                      |
| FLOPs              | 65.63G                                  |
| Input Dims (H W C) | 416,416,3                               |
| FP32 Accuracy      | 0.7846 mAP                              |
| INT8 Accuracy      | 0.7729 mAP                              |
| Train Dataset      | voc07+12_trainval	                   |
| Test Dataset       | voc07_test                              |
| Supported Platform | GPU, VEK280, V70                        |
  

### Paper and Architecture 

1. Network Architecture: YOLOv3

2. Paper Link: https://arxiv.org/abs/1804.02767

   
### Dataset Preparation

1. Dataset description

The model is trained on VOC2007_trainval + VOC2012_trainval and tested on VOC2007_test.

2. Download and prepare the dataset

Our script `prepare_data.sh` downloads and prepares the dataset automatically. But if you have downloaded the VOC2007 test set before, you could place them in the `data` directory manually and choose to skip downloading the dataset when the script asking for a choice. Run the script: 
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash code/test/dataset_tools/prepare_data.sh</span><br></pre></td></tr></table></figure>
Dataset diretory structure
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOCdevkit is unpacked from the downloaded data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">voc2007_test is generated by our code <span class="keyword">for</span> data preparation</span></span><br><span class="line">+ data</span><br><span class="line">  + VOCdevkit</span><br><span class="line">    + VOC2007</span><br><span class="line">      + ImageSets</span><br><span class="line">      + JPEGImages</span><br><span class="line">      + Annotations</span><br><span class="line">  + voc2007_test</span><br><span class="line">    + images</span><br><span class="line">      + 000001.jpg</span><br><span class="line">      + 000002.jpg</span><br><span class="line">      + ...</span><br><span class="line">    + test.txt</span><br><span class="line">    + gt_detection.txt</span><br></pre></td></tr></table></figure>


### Use Guide

1. Evaluation
    Configure the model path and data path in [code/test/run_eval.sh](code/test/run_eval.sh)
    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash code/test/run_eval.sh</span><br></pre></td></tr></table></figure>
  
   
### License

Apache License 2.0

For details, please refer to **[Vitis-AI License](https://github.com/Xilinx/Vitis-AI/blob/master/LICENSE)**


### Note

1. Data preprocess
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data channel order: RGB(0~255)</span><br><span class="line">input = input / 255</span><br><span class="line">resize: keep aspect ratio of the raw image and resize it to make the length of the longer side equal to 416</span><br><span class="line">padding: pad along the short side with 0.5 to generate the input image with size = 416 x 416</span><br></pre></td></tr></table></figure>
2. Node information

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input node: &#x27;input_1:0&#x27;</span><br><span class="line">output nodes: &#x27;conv2d_59/BiasAdd:0&#x27;, &#x27;conv2d_67/BiasAdd:0&#x27;, &#x27;conv2d_75/BiasAdd:0&#x27;</span><br></pre></td></tr></table></figure>
  

### Quantize

1. Quantize tool installation

   Please refer to [vai_q_tensorflow](../../../src/vai_quantizer/vai_q_tensorflow1.x)
  
2. Quantize workspace

   You could use code/quantize/ folder.
</code></pre>
<p><strong>详细阅读该文件介绍，接下来下载所需文件：</strong></p>
<p>在model_zoo文件夹，运行downloader.py，下载tf_yolov3_3.5</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9a7d62a708af32a1de4b5d1c059a76e.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/13689caf7d2c1dcba28ba1b59e594a71.png"></p>
<p> 下载后对文件进行解压：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/154c0219b2383c095a676e4a40d64715.png"></p>
<p>通常model-zoo提供的模型文件结构如下：</p>
<p>tensorflow：</p>
<pre><code>├── code                            # Contains test code that can execute the model on the target and showcase model performance.
│
│
├── readme.md                       # Documents the environment requirements, data pre-processing requirements, and model information.
│                                     Developers should refer to this to understand how to test the model with scripts.
│
├── data                            # The dataset target directory that can be used for model verification and training.
│                                     When test or training scripts run successfully, the dataset will be placed in this directory.
│
├── quantized
│   └── quantize_eval_model.pb      # Quantized model for evaluation.
│
└── float
    └── frozen.pb                   # The floating-point frozen model is used as the input to the quantizer.
                                      The naming of the protobuf file may differ from the model naming used in the model list.
</code></pre>
<p>pytorch：</p>
<pre><code>├── code                            # Contains test and training code.
│
│
├── readme.md                       # Contains the environment requirements, data pre-processing requirements and model information.
│                                     Developers should refer to this to understand how to test and train the model with scripts.
│
├── data                            # The dataset target directory that is used for model verification and training.
│                                     When test or training scripts run successfully, the dataset will be placed in this directory.
│
├── qat                             # Contains the QAT (Quantization Aware Training) results.
│                                     For some models, the accuracy of QAT is higher than with Post Training Quantization (PTQ) methods.
│                                     Some models, but not all, provide QAT reference results, and only these models have a QAT folder.
│
├── quantized
│   ├── _int.pth                    # Quantized model.
│   ├── quant_info.json             # Quantization steps of tensors got. Please keep it for evaluation of quantized model.
│   ├── _int.py                     # Converted vai_q_pytorch format model.
│   └── _int.xmodel                 # Deployed model. The name of different models may be different.
│                                     For some models that support QAT you could find better quantization results in &#39;qat&#39; folder.
│
│
└── float
    └── _int.pth                    # Trained float-point model. The pth name of different models may be different.
                                      Path and model name in test scripts could be modified according to actual situation.
</code></pre>
<p>打开下载好的tf_yolov3_3.5文件夹，其中按照之前的model_info文件所叙述的内容，进行“Download and prepare the<br>dataset”（不是必须运行）：</p>
<pre><code>bash code/test/dataset_tools/prepare_data.sh
</code></pre>
<p>下载好的文件结构也在md文件中，在docker中执行评估（不是必须运行）（docker外需配置环境cv2、numpy）：</p>
<pre><code>bash code/test/run_eval.sh
</code></pre>
<p>评估结果：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/38b92c92fb4b1a06262e88117770e500.png"></p>
<p>安装snap和snapcraft后安装模型查看工具netron：</p>
<pre><code>sudo apt-get install snap
sudo apt-get install snapcraft
sudo snap install netron
</code></pre>
<p>然后就可以查看float文件夹下的pb文件网络的结构：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a57b4d4b3f8c4bcd95910f16c04e505.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5c9e1dc7906295e163c8989b3a3b743.png"></p>
<pre><code>1. Data preprocess
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data channel order: RGB(0~255)</span><br><span class="line">input = input / 255</span><br><span class="line">resize: keep aspect ratio of the raw image and resize it to make the length of the longer side equal to 416</span><br><span class="line">padding: pad along the short side with 0.5 to generate the input image with size = 416 x 416</span><br></pre></td></tr></table></figure>
2. Node information

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input node: &#x27;input_1:0&#x27;</span><br><span class="line">output nodes: &#x27;conv2d_59/BiasAdd:0&#x27;, &#x27;conv2d_67/BiasAdd:0&#x27;, &#x27;conv2d_75/BiasAdd:0&#x27;</span><br></pre></td></tr></table></figure>
 
</code></pre>
<p>可以看到在第59、67、75个conv2d节点后进行了输出：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/030fa826ada83d08a466bb23919680bc.png"></p>
<h3 id="2-模型量化"><a href="#2-模型量化" class="headerlink" title="2.模型量化"></a>2.模型量化</h3><p>在上述md文件最后给出了量化指引：</p>
<pre><code>### Quantize

1. Quantize tool installation

   Please refer to [vai_q_tensorflow](../../../src/vai_quantizer/vai_q_tensorflow1.x)
  
2. Quantize workspace

   You could use code/quantize/ folder.
</code></pre>
<p>量化参考vitis-ai文件夹下src…和code&#x2F;quantize&#x2F;里的内容</p>
<p>在code&#x2F;quantize&#x2F;中的config.ini是配置文件，包括量化后模型名、存放位置为&#x2F;quantized及各种参数；</p>
<p>打开quantize.sh脚本，关注以下内容：</p>
<pre><code>source ./config.ini

vai_q_tensorflow quantize \
  --input_frozen_graph $FLOAT_MODEL \
  --input_nodes $Q_INPUT_NODE \
  --input_shapes ?,$INPUT_HEIGHT,$INPUT_WIDTH,3 \
  --output_nodes $Q_OUTPUT_NODE \
  --input_fn $CALIB_INPUT_FN \
  --method $METHOD \
  --gpu $GPUS \
  --calib_iter $CALIB_ITER \
  --output_dir $QUANTIZE_DIR \
</code></pre>
<p>可以看到在量化过程中其调用config.ini中的各种参数，然后通过src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x工具进行量化，转到对应位置，在readme文件中可以看到详细信息：</p>
<p>[Vitis-AI&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x at master · Xilinx&#x2F;Vitis-AI<br>(github.com)](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;tree&#x2F;master&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x “Vitis-<br>AI&#x2F;src&#x2F;vai_quantizer&#x2F;vai_q_tensorflow1.x at master · Xilinx&#x2F;Vitis-AI<br>(github.com)“)</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9d34d43f9036308c8f83f589b763afd2.jpeg"></p>
<pre><code>#目的：
The process of inference is computation intensive and requires a high memory bandwidth to satisfy the low-latency and high-throughput requirement of edge applications.

#介绍（vitis-ai工具只包含量化工具，修建工具在optimizer中）：
Quantization and channel pruning techniques are employed to address these issues while achieving high performance and high energy efficiency with little degradation in accuracy. Quantization makes it possible to use integer computing units and to represent weights and activations by lower bits, while pruning reduces the overall required operations. In the Vitis AI quantizer, only the quantization tool is included. The pruning tool is packaged in the Vitis AI optimizer. Contact the support team for the Vitis AI development kit if you require the pruning tool.
</code></pre>
<p>将32位浮点数转化为8位整数：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b4e03ee0be4436f378980db2d44681b1.jpeg"></p>
<p>量化的步骤：</p>
<pre><code>## Running vai_q_tensorflow
### Preparing the Float Model and Related Input Files
|1|frozen_graph.pb|Floating-point frozen inference graph. Ensure that the graph is the inference graph rather than the training graph.|
|2|calibration dataset|A subset of the training dataset containing 100 to 1000 images.|
|3|input_fn|An input function to convert the calibration dataset to the input data of the frozen_graph during quantize calibration. Usually performs data pre-processing and augmentation.|
#### **Generating the Frozen Inference Graph**
Training a model with TensorFlow 1.x creates a folder containing a GraphDef file (usually ending with *a.pb* or *.pbtxt* extension) and a set of checkpoint files. What you need for mobile or embedded deployment is a single GraphDef file that has been “frozen,” or had its variables converted into inline constants, so everything is in one file. To handle the conversion, TensorFlow provides *freeze_graph.py*, which is automatically installed with the vai_q_tensorflow quantizer.
#### **Preparing the Calibration Dataset and Input Function**
The calibration set is usually a subset of the training/validation dataset or actual application images (at least 100 images for performance). The input function is a Python importable function to load the calibration dataset and perform data preprocessing. The vai_q_tensorflow quantizer can accept an input_fn to do the preprocessing, which is not saved in the graph. If the preprocessing subgraph is saved into the frozen graph, the input_fn only needs to read the images from dataset and return a feed_dict.
### Quantizing the Model Using vai_q_tensorflow
### Generating the Quantized Model
- *quantize_eval_model.pb* is used to evaluate the CPU/GPUs, and can be used to simulate the results on hardware.
|1|deploy_model.pb|Quantized model for the Vitis AI compiler (extended TensorFlow format) for targeting DPUCZDX8G implementations.|
|2|quantize_eval_model.pb|Quantized model for evaluation (also, the Vitis AI compiler input for most DPU architectures, like DPUCAHX8H, and DPUCADF8H).|
### (Optional) Fast Finetune
Fast finetune adjusts the weights layer by layer with calibration dataset and may get better accuracy for some models. It will take much longer time than normal PTQ (still shorter than QAT as calibration dataset is much smaller than train dataset) and is disabled by default to save time, and can be turned on to try to improve the performance if you see accuracy issues.
### (Optional) Exporting the Quantized Model to ONNX
The quantized model is tensorflow protobuf format by default. If you want to get a ONNX format model, just add *output_format* to the *vai_q_tensorflow* command.
### (Optional) Evaluating the Quantized Model
If you have scripts to evaluate floating point models, like the models in [Vitis AI Model Zoo](https://github.com/Xilinx/Vitis-AI/tree/master/model_zoo), apply the following two changes to evaluate the quantized model:...
### (Optional) Dumping the Simulation Results

## vai_q_tensorflow Quantization Aware Training
Quantization aware training (QAT, also called *quantize finetuning* in [Quantization Overview](#quantization-overview)) is similar to float model training/finetuning, but in QAT, the vai_q_tensorflow APIs are used to rewrite the float graph to convert it to a quantized graph before the training starts. The typical workflow is as follows:...
### Generated Files
### QAT APIs for TensorFlow 1.x

## Converting to Float16 or BFloat16
The vai_q_tensorflow supports data type conversions for float models, including Float16, BFloat16, Float, and Double. To achieve this, you can add *convert_datatype* to the vai_q_tensorflow command. 

## vai_q_tensorflow Supported Operations and APIs
</code></pre>
<p> 在准备阶段包括：推理图的固化（freeze_graph.py已安装在vai_q_tensorflow内）、准备验证数据集和输入函数…</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2035fe160556f3713512b51266287de1.png"></p>
<p>关于vai_q_tensorflow命令的详细使用见readme中的vai_q_tensorflow Usage，例：</p>
<pre><code>#show help: 
$vai_q_tensorflow --help

#quantize:
$vai_q_tensorflow quantize --input_frozen_graph frozen_graph.pb \
--input_nodes inputs \
--output_nodes predictions \
--input_shapes ?,224,224,3 \
--input_fn my_input_fn.calib_input

#dump quantized model:
$vai_q_tensorflow dump --input_frozen_graph quantize_results/quantize_eval_model.pb \
--input_fn my_input_fn.dump_input
</code></pre>
<p>将 &#x2F;float&#x2F;文件夹下的fb文件重命名为float.fb，在docker环境中转到&#x2F;quantize文件夹下运行量化脚本（下载包含运行后文件，非必要）：</p>
<pre><code>bash quantize.sh
</code></pre>
<p>运行结果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d38f0ab41704bb97f91f371d5b4c3cfd.png"></p>
<p>量化后的模型文件位于&#x2F;quantize的pb文件，继续运行&#x2F;quantize下的evaluate_quantize_model.sh文件（非必要）对量化后的模型进行评估，结果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c32c7a9a74429a18ef81f04ae3638c1.png"></p>
<h3 id="3-模型编译"><a href="#3-模型编译" class="headerlink" title="3.模型编译"></a>3.模型编译</h3><h2 id="四-mpsoc快速开始"><a href="#四-mpsoc快速开始" class="headerlink" title="四.mpsoc快速开始"></a>四.mpsoc快速开始</h2><p>见：[Vitis-AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt at v3.5 ·<br>Xilinx&#x2F;Vitis-AI (github.com)](<a target="_blank" rel="noopener" href="https://github.com/Xilinx/Vitis-">https://github.com/Xilinx/Vitis-</a><br>AI&#x2F;blob&#x2F;v3.5&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt “Vitis-<br>AI&#x2F;docs&#x2F;_sources&#x2F;docs&#x2F;quickstart&#x2F;mpsoc.rst.txt at v3.5 · Xilinx&#x2F;Vitis-AI<br>(github.com)“)</p>
<p>（适合xilinx官方开发板zcu102、zcu104、kv260）</p>
<h2 id="五-官方资料"><a href="#五-官方资料" class="headerlink" title="五.官方资料"></a>五.官方资料</h2><p>vivado_integration：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c5bf2b5b0093972699eb12988ab59d9.png"></p>
<p>vitis_integration：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/478de52c0e6c34207461eb523f74eb5a.png"></p>
<p>vek280_setup:</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/781bf68946aadd0ca2d81fe1be31e3f9.png"></p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136803363">https://blog.csdn.net/qq_32971095/article/details/136803363</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/29/AI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/29/AI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">AI学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-29 17:28:37" itemprop="dateCreated datePublished" datetime="2024-03-29T17:28:37+08:00">2024-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>36 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>目录</strong></p>
<p><a href="about:blank#%E4%B8%80.%E7%BB%ADopencv%E2%80%94%E2%80%94%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8">一.续opencv——级联分类器</a></p>
<p><a href="about:blank#%E4%BA%8C.c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95">二.c语言实现进化算法</a></p>
<p><a href="about:blank#%E4%B8%89.LeNet%20%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%20MNIST%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB">三.LeNet 网络实现 MNIST<br>手写数字识别</a></p>
<p><a href="about:blank#%E5%9B%9B.the%20simplest%20neural%20network%20model">四.the simplest neural network<br>model</a></p>
<p><a href="about:blank#%E4%BA%94.Multi-Layered%20Perceptron">五.Multi-Layered Perceptron</a></p>
<p><a href="about:blank#1.Gradient%20Descent%20Optimization%EF%BC%88%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%EF%BC%89">1.Gradient Descent<br>Optimization（梯度下降算法）</a></p>
<p>[2.Multi-Layered Perceptrons and<br>Backpropagation（多层感知器和反向传播）](about:blank#2.Multi-<br>Layered%20Perceptrons%20and%20Backpropagation%EF%BC%88%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%89)</p>
<p><a href="about:blank#3.%E5%8D%95%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E6%A8%A1%E5%9E%8B">3.单层感知器模型</a></p>
<p><a href="about:blank#%3C1%3E%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8CX%E4%B8%BA%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%EF%BC%8CY%E4%B8%BA%E6%A0%87%E7%AD%BE%EF%BC%9A">&lt;1&gt;创建数据集，X为特征向量，Y为标签：</a></p>
<p><a href="about:blank#%3C2%3E%C2%A0%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%EF%BC%9A%C2%A0">&lt;2&gt; 前向传播计算过程：
</a></p>
<p><a href="about:blank#%3C3%3E%E4%BD%BF%E7%94%A8softmax%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A6%82%E7%8E%87%EF%BC%9A">&lt;3&gt;使用softmax函数转换为概率：</a></p>
<p><a href="about:blank#%3C4%3E%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">&lt;4&gt;交叉熵损失函数</a></p>
<p><a href="about:blank#%3C5%3ELoss%20Minimization%20Problem%20and%20Network%20Training%EF%BC%9A">&lt;5&gt;Loss Minimization Problem and Network<br>Training：</a></p>
<p><a href="about:blank#%3C6%3E%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93">&lt;6&gt;函数小结</a></p>
<p><a href="about:blank#%3C7%3ETraining%20the%20Model%C2%A0">&lt;7&gt;Training the Model </a></p>
<p><a href="about:blank#4.%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">4.网络模型</a></p>
<p><a href="about:blank#%3C1%3E%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%B1%BB%EF%BC%9A">&lt;1&gt;定义网络类：</a></p>
<p><a href="about:blank#%3C2%3EMulti-Layered%20Models">&lt;2&gt;Multi-Layered Models</a></p>
<p><a href="about:blank#5.%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88">5.代码整合</a></p>
<p><a href="about:blank#6.3-layer%20network%20%E5%AE%9E%E7%8E%B0%20mnist%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB">6.3-layer network 实现 mnist<br>手写数字识别</a></p>
<p><a href="about:blank#%E5%85%AD.Neural%20Network%20Frameworks">六.Neural Network<br>Frameworks</a></p>
<p><a href="about:blank#1.Keras">1.Keras</a></p>
<p>[&lt;1&gt;Training One-Layer Network<br>(Perceptron)](about:blank#%3C1%3ETraining%20One-<br>Layer%20Network%20%28Perceptron%29)</p>
<p><a href="about:blank#%E2%91%A0%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89">①模型定义</a></p>
<p><a href="about:blank#%E2%91%A1%E6%A8%A1%E5%9E%8B%E7%BC%96%E8%AF%91%EF%BC%88%E6%8C%87%E5%AE%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E3%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E3%80%90%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AD%89%E3%80%91%E3%80%81%E7%B2%BE%E5%BA%A6%EF%BC%89">②模型编译（指定损失函数、优化方法【梯度下降等】、精度）</a></p>
<p><a href="about:blank#%E2%91%A2%E8%AE%AD%E7%BB%83">③训练</a></p>
<p>[&lt;2&gt;Multi-Class Classificatio（多分类问题）](about:blank#%3C2%3EMulti-<br>Class%20Classificatio%EF%BC%88%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89)</p>
<p>[&lt;3&gt;Multi-Label Classification（多标签分类）](about:blank#%3C3%3EMulti-<br>Label%20Classification%EF%BC%88%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%EF%BC%89)</p>
<p><a href="about:blank#%3C4%3E%E6%80%BB%E7%BB%93%C2%A0Summary%20of%20Classification%20Loss%20Functions">&lt;4&gt;总结 Summary of Classification Loss<br>Functions</a></p>
<hr>
<p>参考资料：<a target="_blank" rel="noopener" href="https://github.com/microsoft/AI-For-Beginners" title="microsoft&#x2F;AI-For-
Beginners: 12 Weeks, 24 Lessons, AI for All! (github.com)">microsoft&#x2F;AI-For-Beginners: 12 Weeks, 24 Lessons, AI for All!<br>(github.com)</a></p>
<h2 id="一-续opencv——级联分类器"><a href="#一-续opencv——级联分类器" class="headerlink" title="一.续opencv——级联分类器"></a>一.续opencv——级联分类器</h2><p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/131609797" title="OpenCV学习笔记——《基于OpenCV的数字图像处理》_opencv 数字图像处理-CSDN博客">OpenCV学习笔记——《基于OpenCV的数字图像处理》_opencv 数字图像处理-<br>CSDN博客</a></p>
<pre><code>#include &quot;opencv.hpp&quot;
#include &quot;highgui.hpp&quot;
#include &quot;imgproc.hpp&quot;
#include &lt;iostream&gt;
using namespace cv;
using namespace std;
#pragma comment(lib,&quot;opencv_world480d.lib&quot;)

VideoCapture capture(0);
Mat image;
CascadeClassifier face_cascade;
// 人脸检测
vector&lt;Rect&gt; faces;

int main()
&#123;
    Mat frame_gray;
    face_cascade.load(&quot;OPENCV安装路径/opencv/sources/data/haarcascades/haarcascade_frontalface_alt.xml&quot;);
    while (capture.isOpened())
    &#123;
        capture &gt;&gt; image;
        if (image.empty())break;

        if (waitKey(1) == 27)break;

        // BGR2GRAY
        cvtColor(image, frame_gray, COLOR_BGR2GRAY);

        face_cascade.detectMultiScale(frame_gray, faces);

        for (size_t i = 0; i &lt; faces.size(); i++)
        &#123;
            // 人脸画框
            rectangle(image, faces[i], Scalar(255, 0, 0), 1, 8);
        &#125;

        imshow(&quot;Face detection&quot;,image);

    &#125;
&#125;
</code></pre>
<h2 id="二-c语言实现进化算法"><a href="#二-c语言实现进化算法" class="headerlink" title="二.c语言实现进化算法"></a>二.c语言实现进化算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136715239" title="c语言实现进化算法——人工智能导论＜1＞-CSDN博客">c语言实现进化算法——人工智能导论＜1＞-CSDN博客</a></p>
<h2 id="三-LeNet-网络实现-MNIST-手写数字识别"><a href="#三-LeNet-网络实现-MNIST-手写数字识别" class="headerlink" title="三.LeNet 网络实现 MNIST 手写数字识别"></a>三.LeNet 网络实现 MNIST 手写数字识别</h2><p><a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_32971095/88681364?spm=1001.2014.3001.5501" title="西电计科大三上计算机视觉作业">西电计科大三上计算机视觉作业</a></p>
<h2 id="四-the-simplest-neural-network-model"><a href="#四-the-simplest-neural-network-model" class="headerlink" title="四.the simplest neural network model"></a>四.the simplest neural network model</h2><p>one-layered perceptron, a linear two-class classification model.（单层线性感知机）</p>
<p>Perceptron Model：</p>
<pre><code>    假设我们的模型中有N个特征，在这种情况下，输入向量将是一个大小为N的向量。感知器是一个二元分类模型，即它可以区分两类输入数据。我们将假设对于每个输入向量x，感知器的输出将是+1或-1，这取决于类别。输出将使用以下公式计算:
</code></pre>
<p>y(x) &#x3D; f(wTx)</p>
<p>Training the Perceptron：</p>
<pre><code>    为了训练感知器，我们需要找到一个权重向量w，它能正确地分类大多数值，即产生最小的误差。该误差由感知器准则定义如下:
</code></pre>
<p>E(w) &#x3D; -∑wTxiti</p>
<p>对那些导致错误分类的训练数据点I求和，xi是输入数据，对于负例和正例，ti分别为-1或+1。</p>
<pre><code>    这个标准被认为是权重w的函数，我们需要最小化它。通常，我们使用一种称为梯度下降的方法，在这种方法中，我们从一些初始权重w(0)开始，然后在每一步中根据公式更新权重:
</code></pre>
<p>w(t+1) &#x3D; w(t) - η∇E(w)</p>
<p>这里η是所谓的学习率，∇E(w)表示E的梯度，计算出梯度后，我们得到</p>
<p>w(t+1) &#x3D; w(t) + ∑ηxiti</p>
<pre><code>//perceptron.h
#ifndef _PERCEPTRON_H
#define _PERCEPTRON_H
//the simplest neural network model - one-layered perceptron, a linear two-class classification model.
#include&lt;stdio.h&gt;
#include&lt;time.h&gt;

#define FREATURE_NUM 2	//特征数（输入向量维数）
#define LEARNING_RATE 1 //学习率 

typedef struct input_data&#123;
	double freature[FREATURE_NUM];
	int label;
&#125;input_data;
typedef struct input_dataset&#123;
	input_data* input;
	int set_num;
&#125;input_dataset;

double weight[FREATURE_NUM]=&#123;0&#125;;

void train(input_dataset dataset,int iteration);
void perceptron(input_data *input);

#endif


//perceptron.c
#include&quot;perceptron.h&quot;

void train(input_dataset dataset,int iteration)
&#123;
	//生成随机数种子 
	srand((unsigned)time(NULL));
	
	int set_num=dataset.set_num;
	int i,j,k;
	for(i=0;i&lt;iteration;i++)&#123;
		k=rand()%set_num;
		//梯度下降方法搜寻
		for(j=0;j&lt;FREATURE_NUM;j++)
		&#123;
			weight[j]+=1.0*LEARNING_RATE*dataset.input[k].freature[j]*dataset.input[k].label;
//			printf(&quot;%lf %lf\n&quot;,weight[j],dataset.input[k].freature[j]);
		&#125;
	&#125;
	return; 
&#125;

void perceptron(input_data *input)&#123;
	int i,temp;
	for(i=0,temp=0;i&lt;FREATURE_NUM;i++)temp+=weight[i]*input-&gt;freature[i];
	if(temp&gt;=0)input-&gt;label=1;
	else input-&gt;label=-1;
	
	printf(&quot;label:%d\n&quot;,input-&gt;label);
	return;
&#125;


#include&lt;stdio.h&gt;
#include&quot;perceptron.c&quot;

int main()&#123;
	
	input_data input[2];
	input[0].freature[0]=-3.0;
	input[0].freature[1]=1.0;
	input[0].label=1;
	input[1].freature[0]=-1.0;
	input[1].freature[1]=3.0;
	input[1].label=1;
	input[2].freature[0]=2.0;
	input[2].freature[1]=4;
	input[2].label=-1;
	input[3].freature[0]=4.0;
	input[3].freature[1]=-2.0;
	input[3].label=-1;
	
	input_dataset dataset;
	dataset.input=input;
	dataset.set_num=4;
	
	train(dataset,10);
	
	int i;
	for(i=0;i&lt;FREATURE_NUM;i++)printf(&quot;%lf\n&quot;,weight[i]);
	
	input_data test;
	scanf(&quot;%lf%lf&quot;,&amp;test.freature[0],&amp;test.freature[1]);
	perceptron(&amp;test);
	
	return 0;
&#125;
</code></pre>
<p> python实现及mnist手写数字识别（两类）：[NeuralNetworks&#x2F;03-Perceptron at<br>main](<a target="_blank" rel="noopener" href="https://github.com/microsoft/AI-For-">https://github.com/microsoft/AI-For-</a><br>Beginners&#x2F;tree&#x2F;main&#x2F;lessons&#x2F;3-NeuralNetworks&#x2F;03-Perceptron<br>“NeuralNetworks&#x2F;03-Perceptron at main”)</p>
<p> （特征：28pix*28pix）</p>
<p>实现N类感知器：训练N个感知器：</p>
<ol>
<li>Create 10 <strong><em>one-vs-all</em> datasets</strong> for all digits</li>
<li>Train <strong>10 perceptrons</strong></li>
<li>Define <code>classify</code> function to perform digit classification</li>
<li>Measure the accuracy of classification and print <em>confusion matrix</em></li>
<li>[Optional] Create improved <code>classify</code> function that performs the classification using one matrix multiplication.</li>
</ol>
<h2 id="五-Multi-Layered-Perceptron"><a href="#五-Multi-Layered-Perceptron" class="headerlink" title="五.Multi-Layered Perceptron"></a>五.Multi-Layered Perceptron</h2><p><strong>简介：</strong></p>
<p>we will extend themodel above into a more flexible framework, allowing us to:</p>
<ul>
<li>perform <strong>multi-class classification</strong>  in addition to two-class</li>
<li>solve <strong>regression problems</strong>  in addition to classification</li>
<li>separate classes that are not linearly separable</li>
</ul>
<p>We will also develop our own modular framework in Python that will allow us to<br>construct different neural network architectures.</p>
<p>Suppose we have a training dataset <strong>X</strong>  with labels <strong>Y</strong> , and we need to<br>build a **model  <em>f</em>  **that will make most accurate predictions. The quality<br>of predictions is measured by <strong>Loss function</strong>  <strong>ℒ</strong>. The following loss<br>functions are often used:</p>
<ul>
<li>For <strong>regression problem(回归问题)</strong> , when we need to predict a number, we can use <strong>absolute error</strong>    **∑i|f(x(i))-y(i)|   **, or <strong>squared error</strong>    **∑i(f(x(i))-y(i))^2   **</li>
<li>For <strong>classification(分类问题)</strong> , we use <strong>0-1 loss</strong>  (which is essentially the same as <strong>accuracy</strong>  of the model), or <strong>logistic loss</strong>.</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/621e77f5fb5595bedf41e588670f4c80.png"></p>
<p>从p对损失函数L的影响来看逻辑损失函数更好</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/11de84ee5edc6ce0c8007f9604f71c73.png"></p>
<p>For <strong>one-level perceptron</strong> , function <em>f</em>  was defined as a **linear<br>function  <em>f(x)&#x3D;wx+b</em>  **(here <em>w</em>  is the weight matrix, <em>x</em>  is the vector<br>of input features, and <strong><em>b</em>  is bias vector</strong>). For different neural network<br>architectures, this function can take more <strong>complex form.</strong></p>
<blockquote>
<p>In the case of <strong>classification</strong> , it is often desirable to get<br><strong>probabilities</strong> of corresponding classes as <strong>network output.</strong>  To<br>convert arbitrary numbers to probabilities (eg. to normalize the output), we<br>often use <strong>softmax</strong>  function <strong>σ</strong> , and the function <em>f</em>  becomes<br><em>f(x)&#x3D;σ(wx+b)</em></p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1760fe528375040727919cbb4587890d.png"></p>
<p>In the definition of <em>f</em>  above, <em>w</em>  and <em>b</em>  are called <strong>parameters</strong>  θ&#x3D;〈<br><em>w,b</em> 〉. Given the dataset 〈<strong>X</strong> ,<strong>Y</strong> 〉, we can compute an overall error on<br>the whole dataset as a function of parameters θ.</p>
<blockquote>
<p>✅ <strong>The goal of neural network training is to minimize the error （Loss<br>function</strong> <strong>ℒ</strong><strong>） by varying parameters θ</strong></p>
</blockquote>
<h3 id="1-Gradient-Descent-Optimization（梯度下降算法）"><a href="#1-Gradient-Descent-Optimization（梯度下降算法）" class="headerlink" title="1.Gradient Descent Optimization（梯度下降算法）"></a>1.Gradient Descent Optimization（梯度下降算法）</h3><p>This can be formalized as follows:</p>
<ul>
<li>Initialize parameters by some random values w(0), b(0)</li>
<li>Repeat the following step many times: <ul>
<li>w(i+1) &#x3D; w(i)-η∂ℒ&#x2F;∂w</li>
<li>b(i+1) &#x3D; b(i)-η∂ℒ&#x2F;∂b</li>
</ul>
</li>
</ul>
<p>During training, the optimization steps are supposed to be calculated<br>considering the whole dataset (remember that loss is calculated as a sum<br>through all training samples). However, in real life we take small portions of<br>the dataset called <strong>minibatches</strong> , and calculate gradients based on a subset<br>of data. Because subset is taken randomly each time, such method is called<br><strong>stochastic gradient descent</strong>  (SGD).</p>
<h3 id="2-Multi-Layered-Perceptrons-and-Backpropagation（多层感知器和反向传播）"><a href="#2-Multi-Layered-Perceptrons-and-Backpropagation（多层感知器和反向传播）" class="headerlink" title="2.Multi-Layered Perceptrons and Backpropagation（多层感知器和反向传播）"></a><strong>2.Multi-Layered Perceptrons and Backpropagation（多层感知器和反向传播）</strong></h3><p><strong>一个示例——两层感知器</strong> ：</p>
<p>One-layer network, as we have seen above, is capable of classifying linearly<br>separable classes. To build a richer model, we can <strong>combine several layers of<br>the network</strong>. Mathematically it would mean that the function <em>f</em>  would have<br>a more complex form, and will be computed in several steps:</p>
<ul>
<li>z1&#x3D;w1x+b1</li>
<li>z2&#x3D;w2α(z1)+b2</li>
<li>f &#x3D; σ(z2)</li>
</ul>
<p>Here, <strong>α</strong>  is a <strong>non-linear activation function</strong> , <strong>σ  is a softmax<br>function</strong>, and parameters θ&#x3D;&lt;_w1,b1,w2,b2_ &gt;.</p>
<p>The gradient descent algorithm would remain the same, but it would be more<br>difficult to calculate gradients. Given the chain differentiation rule, we can<br>calculate derivatives as:</p>
<ul>
<li>∂ℒ&#x2F;∂w2 &#x3D; (∂ℒ&#x2F;∂σ)(∂σ&#x2F;∂z2)(∂z2&#x2F;∂w2)</li>
<li>∂ℒ&#x2F;∂w1 &#x3D; (∂ℒ&#x2F;∂σ)(∂σ&#x2F;∂z2)(∂z2&#x2F;∂α)(∂α&#x2F;∂z1)(∂z1&#x2F;∂w1)</li>
</ul>
<blockquote>
<p>✅ The <strong>chain differentiation rule</strong> is used to calculate derivatives of the<br>loss function with respect to parameters.</p>
</blockquote>
<p><strong>链式规则、后向传播更新参数θ</strong> ：</p>
<p>Note that the left-most part of all those expressions is the same, and thus we<br>can** effectively calculate derivatives** **starting from the loss function<br>and going  “backwards” **through the computational graph. Thus the method of<br>training a multi-layered perceptron is called <strong>backpropagation</strong> , or<br>‘backprop’.</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/98446f8f75153030ff57d774b4684b02.png"></p>
<p>即：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/82d7932c55daa1260a98b128ecb829ba.png"></p>
<h3 id="3-单层感知器模型"><a href="#3-单层感知器模型" class="headerlink" title="3.单层感知器模型"></a>3.单层感知器模型</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/28b6864aabe5cda4e0786e846d3f43df.png"></p>
<pre><code>    Two outputs of the network correspond to two classes, and the class with highest value among two outputs corresponds to the right solution.
</code></pre>
<p>The model is defined as：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/093e6e1eb8cb98c2846ce0e7fac93586.png"></p>
<p><strong>相关依赖：</strong></p>
<pre><code>import matplotlib.pyplot as plt 
from matplotlib import gridspec
from sklearn.datasets import make_classification
import numpy as np
# pick the seed for reproducibility - change it to explore the effects of random variations
np.random.seed(0)
import random
</code></pre>
<h4 id="1-创建数据集，X为特征向量，Y为标签："><a href="#1-创建数据集，X为特征向量，Y为标签：" class="headerlink" title="&lt; 1&gt;创建数据集，X为特征向量，Y为标签："></a><strong>&lt; 1&gt;创建数据集，X为特征向量，Y为标签：</strong></h4><pre><code>n = 100
X, Y = make_classification(n_samples = n, n_features=2,
                           n_redundant=0, n_informative=2, flip_y=0.2)
X = X.astype(np.float32)
Y = Y.astype(np.int32)

# Split into train and test dataset
train_x, test_x = np.split(X, [n*8//10])
train_labels, test_labels = np.split(Y, [n*8//10])


#显示数据集
print(train_x[:5])
print(train_labels[:5])


[[-0.836906  -1.382417 ]
 [ 3.0352616 -1.1195285]
 [ 1.6688806  2.4989042]
 [-0.5790065  2.1814067]
 [-0.8730455 -1.4692409]]
[0 1 1 1 0]
</code></pre>
<h4 id="2-前向传播计算过程："><a href="#2-前向传播计算过程：" class="headerlink" title="**&lt; 2&gt; 前向传播计算过程： **"></a>**&lt; 2&gt; 前向传播计算过程： **</h4><pre><code>class Linear:
    #初始化权重
    def __init__(self,nin,nout):
        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))
        self.b = np.zeros((1,nout))
    #前向传播计算    
    def forward(self, x):
        return np.dot(x, self.W.T) + self.b
    
net = Linear(2,2)
net.forward(train_x[0:5])


#5个输入的输出
0,1.772021,-0.253845
1,0.283708,-0.396106
2,-0.300974,0.305132
3,-0.812048,0.560794
4,-1.235197,0.339497
</code></pre>
<h4 id="使用softmax函数转换为概率："><a href="#使用softmax函数转换为概率：" class="headerlink" title="&lt;3&gt;使用softmax函数转换为概率："></a>&lt;3&gt;使用softmax函数转换为概率：</h4><pre><code>class Softmax:
    def forward(self,z):
        zmax = z.max(axis=1,keepdims=True)
        expz = np.exp(z-zmax)
        Z = expz.sum(axis=1,keepdims=True)
        return expz / Z

softmax = Softmax()
softmax.forward(net.forward(train_x[0:10]))


        In case we have more than 2 classes, softmax will normalize probabilities across all of them.
</code></pre>
<h4 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="&lt;4&gt;交叉熵损失函数"></a>&lt;4&gt;交叉熵损失函数</h4><pre><code>        A loss function in classification is typically a **logistic function** , which can **be generalized as cross-entropy loss**. Cross-entropy loss is a function that can calculate similarity between two arbitrary probability distributions. 


def cross_ent(prediction, ground_truth):
    t = 1 if ground_truth &gt; 0.5 else 0
    return -t * np.log(prediction) - (1 - t) * np.log(1 - prediction)
plot_cross_ent()
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f4b2ad0f83c2804efe05f9563c4c85f.png"></p>
<pre><code>        Cross-entropy loss will be defined again as **a separate layer** , but `forward` function will have _**two input values: output of the previous layers of the network `p`, and the expected class `y`:**_
</code></pre>
<p><strong>应用：</strong></p>
<pre><code>class CrossEntropyLoss:
    def forward(self,p,y):
        self.p = p
        self.y = y
        p_of_y = p[np.arange(len(y)), y]
        log_prob = np.log(p_of_y)
        return -log_prob.mean() # average over all input samples

cross_ent_loss = CrossEntropyLoss()
p = softmax.forward(net.forward(train_x[0:10]))
cross_ent_loss.forward(p,train_labels[0:10])
</code></pre>
<blockquote>
<p><strong>IMPORTANT</strong> : Loss function returns a number that shows how good (or bad)<br>our network performs. It should return us one number for the whole dataset,<br>or for the part of the dataset (minibatch). Thus after calculating cross-<br>entropy loss for each individual component of the input vector, we need to<br>average (or add) all components together - which is done by the call to<br><code>.mean()</code>.</p>
<p>（注意计算的是<strong>交叉熵均值</strong> ：return -log_prob.mean() # average over all input samples ）</p>
</blockquote>
<pre><code>z = net.forward(train_x[0:10])    #输出
p = softmax.forward(z)            #softmax归一化
loss = cross_ent_loss.forward(p,train_labels[0:10])#cross_ent_loss = CrossEntropyLoss()
print(loss)
</code></pre>
<h4 id="Loss-Minimization-Problem-and-Network-Training："><a href="#Loss-Minimization-Problem-and-Network-Training：" class="headerlink" title="&lt;5&gt;Loss Minimization Problem and Network Training："></a>&lt;5&gt;Loss Minimization Problem and Network Training：</h4><p>数学描述：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/44ff93f6ec92975a705328447d9fcb28.png"></p>
<p>采用梯度下降法进行计算（见2.）</p>
<p><strong>网络训练</strong> 包括前向和后向传播两个过程（<strong>原理</strong> 见2和3&lt;2&gt;）</p>
<p>One pass of the <strong>network training</strong> consists of two parts:</p>
<ul>
<li><strong>Forward pass</strong> , when we calculate the value of loss function for a given input minibatch</li>
<li><strong>Backward pass</strong> , when we try to minimize this error by distributing it back to the model parameters through the computational graph.</li>
</ul>
<p><strong>后向传播的具体实现：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bcc3707448e65ae4040d2b305dc71a12.png"></p>
<p><em>注意参数的更新在一个minibatch完全计算完后，而不是单个样本</em></p>
<pre><code>def update(self,lr):
    self.W -= lr*self.dW    
    self.b -= lr*self.db
#LR是学习率
</code></pre>
<h4 id="函数小结"><a href="#函数小结" class="headerlink" title="&lt;6&gt;函数小结"></a>&lt;6&gt;函数小结</h4><pre><code>class Linear:
    def __init__(self,nin,nout):
        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))
        self.b = np.zeros((1,nout))
        self.dW = np.zeros_like(self.W)
        self.db = np.zeros_like(self.b)
        
    def forward(self, x):
        self.x=x
        return np.dot(x, self.W.T) + self.b
    
    def backward(self, dz):
        dx = np.dot(dz, self.W)
        dW = np.dot(dz.T, self.x)
        db = dz.sum(axis=0)
        self.dW = dW
        self.db = db
        return dx
    
    def update(self,lr):
        self.W -= lr*self.dW
        self.b -= lr*self.db


class Softmax:
    def forward(self,z):
        self.z = z
        zmax = z.max(axis=1,keepdims=True)
        expz = np.exp(z-zmax)
        Z = expz.sum(axis=1,keepdims=True)
        return expz / Z
    def backward(self,dp):
        p = self.forward(self.z)
        pdp = p * dp
        return pdp - p * pdp.sum(axis=1, keepdims=True)
    
class CrossEntropyLoss:
    def forward(self,p,y):
        self.p = p
        self.y = y
        p_of_y = p[np.arange(len(y)), y]
        log_prob = np.log(p_of_y)
        return -log_prob.mean()
    def backward(self,loss):
        dlog_softmax = np.zeros_like(self.p)
        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)
        return dlog_softmax / self.p
</code></pre>
<h4 id="Training-the-Model"><a href="#Training-the-Model" class="headerlink" title="&lt;7&gt;Training the Model"></a>&lt;7&gt;Training the Model</h4><pre><code>    Now we are ready to write the **training loop** , which will go through our dataset, and perform the optimization minibatch by minibatch._One complete pass through the dataset is often called**an epoch** :_


lin = Linear(2,2)
softmax = Softmax()
cross_ent_loss = CrossEntropyLoss()

learning_rate = 0.1

pred = np.argmax(lin.forward(train_x),axis=1)
acc = (pred==train_labels).mean()
print(&quot;Initial accuracy: &quot;,acc)

batch_size=4
for i in range(0,len(train_x),batch_size):
    xb = train_x[i:i+batch_size]
    yb = train_labels[i:i+batch_size]
    
    # forward pass
    z = lin.forward(xb)
    p = softmax.forward(z)
    loss = cross_ent_loss.forward(p,yb)
    
    # backward pass
    dp = cross_ent_loss.backward(loss)
    dz = softmax.backward(dp)
    dx = lin.backward(dz)
    lin.update(learning_rate)
    
pred = np.argmax(lin.forward(train_x),axis=1)
acc = (pred==train_labels).mean()
print(&quot;Final accuracy: &quot;,acc)
    


Initial accuracy:  0.2625
Final accuracy:  0.7875
</code></pre>
<h3 id="4-网络模型"><a href="#4-网络模型" class="headerlink" title="4.网络模型"></a>4.网络模型</h3><h4 id="定义网络类-："><a href="#定义网络类-：" class="headerlink" title="&lt;1&gt;定义网络类 ："></a>&lt;1&gt;定义<strong>网络类</strong> ：</h4><pre><code>    Since in many cases neural network is just **a composition of layers** , we can build a class that will allow us to **stack layers together** and**make forward and backward passes** through them without explicitly programming that logic. We will **store the list of layers inside the`Net` class**, and **use`add()` function to add new layers**:


class Net:
    def __init__(self):
        self.layers = []
    
    def add(self,l):
        self.layers.append(l)
        
    def forward(self,x):
        for l in self.layers:
            x = l.forward(x)
        return x
    
    def backward(self,z):
        for l in self.layers[::-1]:
            z = l.backward(z)
        return z
    
    def update(self,lr):
        for l in self.layers:
            if &#39;update&#39; in l.__dir__():
                l.update(lr)
</code></pre>
<p>定义网络和训练：</p>
<pre><code>net = Net()
net.add(Linear(2,2))
net.add(Softmax())
loss = CrossEntropyLoss()

def get_loss_acc(x,y,loss=CrossEntropyLoss()):
    p = net.forward(x)
    l = loss.forward(p,y)
    pred = np.argmax(p,axis=1)
    acc = (pred==y).mean()
    return l,acc

print(&quot;Initial loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))

def train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):
    for i in range(0,len(train_x),batch_size):
        xb = train_x[i:i+batch_size]
        yb = train_labels[i:i+batch_size]

        p = net.forward(xb)
        l = loss.forward(p,yb)
        dp = loss.backward(l)
        dx = net.backward(dp)
        net.update(lr)
 
train_epoch(net,train_x,train_labels)
        
print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))
print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))


Initial loss=0.8977914474068779, accuracy=0.4625: 
Final loss=0.47908832233966514, accuracy=0.825: 
Test loss=0.5317198099647931, accuracy=0.8:
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f0836ab887616dbe48bcedfff0a5ea8.png"></p>
<h4 id="Multi-Layered-Models"><a href="#Multi-Layered-Models" class="headerlink" title="&lt;2&gt;Multi-Layered Models"></a>&lt;2&gt;Multi-Layered Models</h4><pre><code>        Very important thing to note, however, is that _**in between linear layers we need to have a non-linear** **activation function**_ , such as _**tanh**_. Without such non-linearity, several linear layers would have the same expressive power as just one layers - because _**composition of linear functions is also linear!**_
</code></pre>
<p>在线性层之间添加激活函数，线性函数的叠加仍是线性。</p>
<pre><code>class Tanh:
    def forward(self,x):
        y = np.tanh(x)
        self.y = y
        return y
    def backward(self,dy):
        return (1.0-self.y**2)*dy

    Adding several layers make sense, because unlike one-layer network, multi-layered model will **be able to accuratley classify sets that are not linearly separable**. I.e., a model with several layers will be **reacher**.
</code></pre>
<blockquote>
<p>It can be demonstrated that with sufficient number of neurons a <strong>two-<br>layered model</strong> is capable to classifying any <strong>convex set of data points</strong><br>, and <strong>three-layered network</strong> can classify <strong>virtually any set.</strong></p>
</blockquote>
<p>多层网络的形式见前（2.）</p>
<p>两层网络示例：</p>
<pre><code>net = Net()
net.add(Linear(2,10))
net.add(Tanh())
net.add(Linear(10,2))
net.add(Softmax())
loss = CrossEntropyLoss()
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/aa5a7f818f593a302d689193dc8bf872.png"></p>
<p>关于线性模型和多层复杂模型的区别和**过拟合（**<strong>overfitting）</strong> 问题：</p>
<p><strong>A linear model:</strong></p>
<ul>
<li>We are likely to get high training loss - so-called <strong>underfitting</strong> , when the model does not have enough power to correctly separate all data.</li>
<li>Valiadation loss and training loss are more or less the same. The model is likely to generalize well to test data.</li>
</ul>
<p><strong>Complex multi-layered model</strong></p>
<ul>
<li>Low training loss - the model can approximate training data well, because it has enough expressive power.</li>
<li>Validation loss can be much higher than training loss and can start to increase during training - this is because the model “memorizes” training points, and loses the “overall picture”</li>
</ul>
<p><strong>小结：</strong></p>
<p><strong>Takeaways</strong></p>
<ul>
<li>Simple models (fewer layers, fewer neurons) with low number of parameters (“low capacity”) are less likely to overfit</li>
<li>More complex models (more layers, more neurons on each layer, high capacity) are likely to overfit. We need to monitor validation error to make sure it does not start to rise with further training</li>
<li>More complex models need more data to train on.</li>
<li>You can solve overfitting problem by either: <ul>
<li>simplifying your model</li>
<li>increasing the amount of training data</li>
</ul>
</li>
<li><strong>Bias-variance trade-off</strong> is a term that shows that you need to get the compromise <ul>
<li>between power of the model and amount of data,</li>
<li>between overfittig and underfitting</li>
</ul>
</li>
<li>There is not single recipe on how many layers of parameters you need - the best way is to experiment</li>
</ul>
<h3 id="5-代码整合"><a href="#5-代码整合" class="headerlink" title="5.代码整合"></a>5.代码整合</h3><pre><code>###################################################################
# package
# matplotlib nbagg
import matplotlib.pyplot as plt 
from matplotlib import gridspec
from sklearn.datasets import make_classification
import numpy as np
# pick the seed for reproducibility - change it to explore the effects of random variations
np.random.seed(0)
import random


###################################################################
# dataset
n = 100
X, Y = make_classification(n_samples = n, n_features=2,
                           n_redundant=0, n_informative=2, flip_y=0.2)
X = X.astype(np.float32)
Y = Y.astype(np.int32)

# Split into train and test dataset
train_x, test_x = np.split(X, [n*8//10])
train_labels, test_labels = np.split(Y, [n*8//10])


###################################################################
# layers
class Linear:
    def __init__(self,nin,nout):
        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))
        self.b = np.zeros((1,nout))
        self.dW = np.zeros_like(self.W)
        self.db = np.zeros_like(self.b)
        
    def forward(self, x):
        self.x=x
        return np.dot(x, self.W.T) + self.b
    
    def backward(self, dz):
        dx = np.dot(dz, self.W)
        dW = np.dot(dz.T, self.x)
        db = dz.sum(axis=0)
        self.dW = dW
        self.db = db
        return dx
    
    def update(self,lr):
        self.W -= lr*self.dW
        self.b -= lr*self.db

class Tanh:
    def forward(self,x):
        y = np.tanh(x)
        self.y = y
        return y
    def backward(self,dy):
        return (1.0-self.y**2)*dy


class Softmax:
    def forward(self,z):
        self.z = z
        zmax = z.max(axis=1,keepdims=True)
        expz = np.exp(z-zmax)
        Z = expz.sum(axis=1,keepdims=True)
        return expz / Z
    def backward(self,dp):
        p = self.forward(self.z)
        pdp = p * dp
        return pdp - p * pdp.sum(axis=1, keepdims=True)
    

class CrossEntropyLoss:
    def forward(self,p,y):
        self.p = p
        self.y = y
        p_of_y = p[np.arange(len(y)), y]
        log_prob = np.log(p_of_y)
        return -log_prob.mean()
    def backward(self,loss):
        dlog_softmax = np.zeros_like(self.p)
        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)
        return dlog_softmax / self.p


###################################################################
# network
class Net:
    def __init__(self):
        self.layers = []
    
    def add(self,l):
        self.layers.append(l)
        
    def forward(self,x):
        for l in self.layers:
            x = l.forward(x)
        return x
    
    def backward(self,z):
        for l in self.layers[::-1]:
            z = l.backward(z)
        return z
    
    def update(self,lr):
        for l in self.layers:
            if &#39;update&#39; in l.__dir__():
                l.update(lr)

def get_loss_acc(x,y,loss=CrossEntropyLoss()):
    p = net.forward(x)
    l = loss.forward(p,y)
    pred = np.argmax(p,axis=1)
    acc = (pred==y).mean()
    return l,acc

def train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):
    for i in range(0,len(train_x),batch_size):
        xb = train_x[i:i+batch_size]
        yb = train_labels[i:i+batch_size]

        p = net.forward(xb)
        l = loss.forward(p,yb)
        dp = loss.backward(l)
        dx = net.backward(dp)
        net.update(lr)
        print(&quot;epoch=&#123;&#125;: &quot;.format(i),end=&quot;&quot;)
        print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))
        print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))

###################################################################
# main
net = Net()
net.add(Linear(2,10))
net.add(Tanh())
net.add(Linear(10,2))
net.add(Softmax())
train_epoch(net,train_x,train_labels)
</code></pre>
<h3 id="6-3-layer-network-实现-mnist-手写数字识别"><a href="#6-3-layer-network-实现-mnist-手写数字识别" class="headerlink" title="6.3-layer network 实现 mnist 手写数字识别"></a>6.3-layer network 实现 mnist 手写数字识别</h3><p>训练模型，保存结果：</p>
<pre><code>###################################################################
# packages
import matplotlib.pyplot as plt 
from matplotlib import gridspec
from sklearn.datasets import make_classification
import numpy as np
# pick the seed for reproducibility - change it to explore the effects of random variations
np.random.seed(0)
import random


###################################################################
# dataset
n=70000
# generate data
# X, Y = make_classification(n_samples = n, n_features=28*28,n_redundant=0, n_informative=8*8, flip_y=0.2)
# get data from mnist
from torchvision import datasets, transforms
mnist_train = datasets.MNIST(root=&#39;./data&#39;, train=True, transform=transforms.ToTensor())
X = mnist_train.data.numpy()
Y = mnist_train.targets.numpy()
X = X.reshape(X.shape[0],-1)
X = X.astype(np.float32)                            
Y = Y.astype(np.int32)

# Split into train and test dataset
train_x, test_x = np.split(X, [n*8//10])            # 80% training and 20% test
train_labels, test_labels = np.split(Y, [n*8//10])  


###################################################################
# layers
class Linear:
    def __init__(self,nin,nout):
        self.W = np.random.normal(0, 1.0/np.sqrt(nin), (nout, nin))
        self.b = np.zeros((1,nout))
        self.dW = np.zeros_like(self.W)
        self.db = np.zeros_like(self.b)
        
    def forward(self, x):
        self.x=x
        return np.dot(x, self.W.T) + self.b
    
    def backward(self, dz):
        dx = np.dot(dz, self.W)
        dW = np.dot(dz.T, self.x)
        db = dz.sum(axis=0)
        self.dW = dW
        self.db = db
        return dx
    
    def update(self,lr):
        self.W -= lr*self.dW
        self.b -= lr*self.db

class Tanh:
    def forward(self,x):
        y = np.tanh(x)
        self.y = y
        return y
    def backward(self,dy):
        return (1.0-self.y**2)*dy


class Softmax:
    def forward(self,z):
        self.z = z
        zmax = z.max(axis=1,keepdims=True)
        expz = np.exp(z-zmax)
        Z = expz.sum(axis=1,keepdims=True)
        return expz / Z
    def backward(self,dp):
        p = self.forward(self.z)
        pdp = p * dp
        return pdp - p * pdp.sum(axis=1, keepdims=True)
    

class CrossEntropyLoss:
    def forward(self,p,y):
        self.p = p
        self.y = y
        p_of_y = p[np.arange(len(y)), y]
        log_prob = np.log(p_of_y)
        return -log_prob.mean()
    def backward(self,loss):
        dlog_softmax = np.zeros_like(self.p)
        dlog_softmax[np.arange(len(self.y)), self.y] -= 1.0/len(self.y)
        return dlog_softmax / self.p


###################################################################
# network
class Net:
    def __init__(self):
        self.layers = []
    
    def add(self,l):
        self.layers.append(l)
        
    def forward(self,x):
        for l in self.layers:
            x = l.forward(x)
        return x
    
    def backward(self,z):
        for l in self.layers[::-1]:
            z = l.backward(z)
        return z
    
    def update(self,lr):
        for l in self.layers:
            if &#39;update&#39; in l.__dir__():
                l.update(lr)

def get_loss_acc(x,y,loss=CrossEntropyLoss()):
    p = net.forward(x)
    l = loss.forward(p,y)
    pred = np.argmax(p,axis=1)
    acc = (pred==y).mean()
    return l,acc

def train_epoch(net, train_x, train_labels, loss=CrossEntropyLoss(), batch_size=4, lr=0.1):
    for i in range(0,len(train_x),batch_size):
        xb = train_x[i:i+batch_size]
        yb = train_labels[i:i+batch_size]

        p = net.forward(xb)
        l = loss.forward(p,yb)
        dp = loss.backward(l)
        dx = net.backward(dp)
        net.update(lr)
        print(&quot;epoch=&#123;&#125;: &quot;.format(i//batch_size))
        print(&quot;Final loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(train_x,train_labels)))
        print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*get_loss_acc(test_x,test_labels)))

###################################################################
# main
if __name__ == &#39;__main__&#39;:
    # model
    net = Net()
    net.add(Linear(28*28,300))
    net.add(Tanh())
    net.add(Linear(300,10))
    net.add(Softmax())
    train_epoch(net,train_x,train_labels,batch_size=1000) 

    #save the model
    import pickle
    with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:
        pickle.dump(net, f)    
</code></pre>
<p>加载模型，进行测试：</p>
<pre><code>import OwnFramework
import torchvision
import numpy as np
import pickle
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import random

# import the model   
with open(&#39;model.pkl&#39;, &#39;rb&#39;) as f:
    OwnFramework.net = pickle.load(f)

# test the data from minst
test_data = torchvision.datasets.MNIST(&#39;./data&#39;, train=False, download=False)
test_x = test_data.data.numpy().reshape(-1,28*28)
test_labels = test_data.targets.numpy()

# test the model
print(&quot;Test loss=&#123;&#125;, accuracy=&#123;&#125;: &quot;.format(*OwnFramework.get_loss_acc(test_x,test_labels)))

# show the images and the predictions
fig=plt.figure(figsize=(8, 8))
gs = gridspec.GridSpec(4, 4)
for i in range(16):
    j=random.randint(0,len(test_x))
    ax = plt.subplot(gs[i])
    ax.imshow(test_x[j].reshape(28,28))
    ax.set_title(&quot;Predicted: &#123;&#125;&quot;.format(np.argmax(OwnFramework.net.forward(test_x[j:j+1]))))
    ax.axis(&#39;off&#39;)
plt.show()

# show the images that are not predicted not correctly
fig=plt.figure(figsize=(12, 8))
gs = gridspec.GridSpec(4, 4)
i=0
for j in range(len(test_x)):
    if np.argmax(OwnFramework.net.forward(test_x[j:j+1])) != test_labels[j]:
        ax = plt.subplot(gs[i])
        ax.imshow(test_x[j].reshape(28,28))
        ax.set_title(&quot;Predicted: &#123;&#125;, True: &#123;&#125;&quot;.format(np.argmax(OwnFramework.net.forward(test_x[j:j+1])),test_labels[j]))
        ax.axis(&#39;off&#39;)
        i+=1
    if i==16:
        break
plt.show()
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f2a5124db743b6101b0841143d3f591.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/94e98f86a86028bb9b2d14b0ed7f50d3.png"></p>
<h2 id="六-Neural-Network-Frameworks"><a href="#六-Neural-Network-Frameworks" class="headerlink" title="六.Neural Network Frameworks"></a>六.Neural Network Frameworks</h2><p><strong>架构API：</strong></p>
<p>to be able to train neural networks efficiently we need to do two things:</p>
<ul>
<li><p>To <strong>operate</strong> on <strong>tensors</strong> , eg. to multiply, add, and compute some functions such as sigmoid or softmax</p>
</li>
<li><p>To compute <strong>gradients</strong> of all expressions, in order to perform gradient descent optimization</p>
<pre><code>While the **`numpy`  library** can **do the first part** , we need some mechanism to compute gradients. In our framework that we have developed in the previous section we had to manually program all derivative functions inside the `backward` method, which does backpropagation. Ideally, _**a framework should give us the opportunity to compute gradients of _any expression_  that we can define**_.

Another important thing is to be able to **perform computations on GPU** , or any other specialized compute units, such as [TPU](https://en.wikipedia.org/wiki/Tensor_Processing_Unit &quot;TPU&quot;). Deep neural network training requires _a lot_  of computations, and to be able to parallelize those computations on GPUs is very important.
</code></pre>
</li>
</ul>
<p><strong>底层和高层API：</strong>  </p>
<pre><code>    Currently, the two **most popular neural frameworks** are:** [TensorFlow](http://tensorflow.org/ &quot;TensorFlow&quot;) and [PyTorch](https://pytorch.org/ &quot;PyTorch&quot;).** Both provide a **low-level API** to operate with **tensors on both CPU and GPU**. On top of the low-level API, there is also **higher-level API** , called** [Keras](https://keras.io/ &quot;Keras&quot;) and [PyTorch Lightning](https://pytorchlightning.ai/ &quot;PyTorch Lightning&quot;) **correspondingly.
</code></pre>
<p>Low-Level API| <a target="_blank" rel="noopener" href="http://tensorflow.org/" title="TensorFlow">TensorFlow</a>|</p>
<p><a target="_blank" rel="noopener" href="https://pytorch.org/" title="PyTorch">PyTorch</a><br>—|—|—<br>High-level API| <a target="_blank" rel="noopener" href="https://keras.io/" title="Keras">Keras</a>| <a target="_blank" rel="noopener" href="https://pytorchlightning.ai/" title="PyTorch Lightning">PyTorch<br>Lightning</a>  </p>
<p><strong>Low-level APIs</strong>  in both frameworks allow you to build so-called<br><strong>computational graphs</strong>. This graph defines how to compute the output<br>(usually <strong>the loss function</strong>) <strong>with given input parameters</strong> , and can be<br>pushed for computation <strong>on GPU</strong> , if it is available. There are functions to<br>differentiate this computational graph and compute gradients, which can then<br>be used for optimizing model parameters.</p>
<p><strong>High-level APIs</strong>  pretty much consider neural networks as a <strong>sequence of<br>layers</strong> , and make constructing most of the neural networks much easier.<br>Training the model usually requires <strong>preparing the data</strong> and then calling a<br><strong><code>fit</code> function</strong> to do the job.</p>
<pre><code>    The high-level API allows you to construct typical neural networks **very quickly without worrying about lots of details**. At the same time, low-level API offer much more control over the training process, and thus they are **used a lot in research** , when you are dealing with **new neural network architectures.**

    It is also important to understand that you can**use both APIs together** , eg. you can develop your own network layer architecture using low-level API, and then use it inside the larger network constructed and trained with the high-level API. Or you can define a network using the high-level API as a sequence of layers, and then use your own low-level training loop to perform optimization. Both APIs use the same basic underlying concepts, and they are designed to work well together.
</code></pre>
<p><strong>过拟合检测：</strong></p>
<p><strong>How to detect overfitting</strong></p>
<pre><code>    As you can see from the graph above, overfitting can be detected by a very low training error, and a high validation error. Normally during training we will see both training and validation errors starting to decrease, and then **at some point validation error might stop decreasing and start rising**. This will be a sign of overfitting, and the indicator that we should probably **stop training at this point**  (or at least **make a snapshot of the model**).（及时备份）
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9c3db5d1878b3ecef22e81631f39e2b0.png"></p>
<h3 id="1-Keras"><a href="#1-Keras" class="headerlink" title="1.Keras"></a>1.Keras</h3><pre><code>    Keras is **a part of Tensorflow 2.x framework**. Let’s make sure we have version 2.x.x of Tensorflow installed:


# packages
import tensorflow as tf
from tensorflow import keras
import numpy as np
from sklearn.datasets import make_classification
import matplotlib.pyplot as plt
print(f&#39;Tensorflow version = &#123;tf.__version__&#125;&#39;)


# data prepare
np.random.seed(0) # pick the seed for reproducibility - change it to explore the effects of random variations

n = 100
X, Y = make_classification(n_samples = n, n_features=2,
                           n_redundant=0, n_informative=2, flip_y=0.05,class_sep=1.5)
X = X.astype(np.float32)
Y = Y.astype(np.int32)

split = [ 70*n//100 ]
train_x, test_x = np.split(X, split)
train_labels, test_labels = np.split(Y, split)
</code></pre>
<p>**关于张量的概念：（多维向量）  **</p>
<p><strong>Tensor</strong> is a <strong>multi-dimensional array</strong>. It is very convenient to use<br>tensors to represent different types of data:</p>
<ul>
<li>400x400 - black-and-white picture</li>
<li>400x400x3 - color picture</li>
<li>16x400x400x3 - minibatch of 16 color pictures</li>
<li>25x400x400x3 - one second of 25-fps video</li>
<li>8x25x400x400x3 - minibatch of 8 1-second videos</li>
</ul>
<p>Tensors give us a convenient way to represent input&#x2F;output data, as well we<br>weights inside the neural network.</p>
<p><strong>归一化数据：（约束网络参数范围）Normalizing Data</strong></p>
<p>Before training, it is common to bring our input features<strong>to the standard<br>range of [0,1] (or [-1,1]).</strong> The exact reasons for that we will discuss later<br>in the course, but in short the reason is the following. We want to avoid<br>values that flow through our network <strong>getting too big or too small</strong> , and we<br>normally agree to keep all values in the small range close to 0. Thus we<br><strong>initialize the weights with small random numbers</strong> , and we keep signals in<br>the same range.</p>
<pre><code>train_x_norm = (train_x-np.min(train_x,axis=0)) / (np.max(train_x,axis=0)-np.min(train_x,axis=0))
test_x_norm = (test_x-np.min(train_x,axis=0)) / (np.max(train_x,axis=0)-np.min(train_x,axis=0))
</code></pre>
<h4 id="Training-One-Layer-Network-Perceptron"><a href="#Training-One-Layer-Network-Perceptron" class="headerlink" title="&lt;1&gt;Training One-Layer Network (Perceptron)"></a>&lt;1&gt;Training One-Layer Network (Perceptron)</h4><h5 id="①模型定义"><a href="#①模型定义" class="headerlink" title="①模型定义"></a>①模型定义</h5><p>In many cases, a neural network would be <strong>a sequence of layers.</strong> It can be<br>defined in Keras using **<code>Sequential</code> **model in the following manner:</p>
<pre><code>model = keras.models.Sequential()
model.add(keras.Input(shape=(2,)))
model.add(keras.layers.Dense(1))
model.add(keras.layers.Activation(keras.activations.sigmoid))
model.summary()

# or
# Input size, as well as activation function, can also be specified directly in the Dense layer for brevity:
model = keras.models.Sequential()
model.add(keras.layers.Dense(1,input_shape=(2,),activation=&#39;sigmoid&#39;))
model.summary()
</code></pre>
<p>说明：</p>
<p>Here, we first create the model, and then add layers to it:</p>
<ul>
<li><p>First <code>Input</code> layer (<strong>which is not strictly speaking a layer</strong>) contains the specification of network’s <strong>input size</strong></p>
</li>
<li><p><code>Dense</code> layer is the actual perceptron that <strong>contains trainable weights</strong></p>
</li>
<li><p>Finally, there is a layer with **<em>sigmoid</em> <code>Activation</code> function **to bring the result of the network into 0-1 range (to make it a probability).</p>
<h1 id="Model-“sequential”-Layer-type-Output-Shape-Param"><a href="#Model-“sequential”-Layer-type-Output-Shape-Param" class="headerlink" title="Model: “sequential”_________________________________________________________________ Layer (type)                Output Shape              Param #"></a>Model: “sequential”<br>_________________________________________________________________<br> Layer (type)                Output Shape              Param #</h1><p> dense (Dense)               (None, 1)                 3</p>
<p> activation (Activation)     (None, 1)                 0</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>Total params: 3 (12.00 Byte)<br>Trainable params: 3 (12.00 Byte)<br>Non-trainable params: 0 (0.00 Byte)</p>
<hr>
</li>
</ul>
<h5 id="②模型编译（指定损失函数、优化方法【梯度下降等】、精度）"><a href="#②模型编译（指定损失函数、优化方法【梯度下降等】、精度）" class="headerlink" title="②模型编译（指定损失函数、优化方法【梯度下降等】、精度）"></a>②模型编译（指定损失函数、优化方法【梯度下降等】、精度）</h5><p>Before training the model, we need to <strong>compile it</strong> , which essentially mean<br>specifying:</p>
<ul>
<li><strong>Loss function</strong> , which defines how loss is calculated. Because we have two-class classification problem, we will use <em>binary cross-entropy loss</em>.</li>
<li><strong>Optimizer</strong> to use. The simplest option would be to use <code>sgd</code> for <em>stochastic gradient descent</em> , or you can use more sophisticated optimizers such as <code>adam</code>.</li>
<li><strong>Metrics</strong> that we want to use to measure success of our training. Since it is classification task, a good metrics would be <code>Accuracy</code> (or <code>acc</code> for short)</li>
</ul>
<p>We can specify loss, metrics and optimizer either as <strong>strings</strong> , or by<br>providing some <strong>objects from Keras framework</strong>. In our example, we need to<br>**specify<code>learning_rate</code> parameter **to fine-tune learning speed of our model,<br>and thus we provide <strong>full name of Keras SGD optimizer.</strong></p>
<p><strong>（可使用字符串或对象来定义）</strong></p>
<pre><code>model.compile(optimizer=keras.optimizers.SGD(learning_rate=0.2),loss=&#39;binary_crossentropy&#39;,metrics=[&#39;acc&#39;])
</code></pre>
<h5 id="③训练"><a href="#③训练" class="headerlink" title="③训练"></a>③训练</h5><p>After compiling the model, we can do the actual training by calling <strong><code>fit</code><br>method.</strong> The most important parameters are:</p>
<ul>
<li><p><code>x</code> and <code>y</code> specify <strong>training data, features and labels respectively</strong></p>
</li>
<li><p>If we want validation to be performed on each epoch, we can specify **<code>validation_data</code> **parameter, which would be a tuple of features and labels</p>
</li>
<li><p>**<code>epochs</code> **specified the number of epochs</p>
</li>
<li><p>If we want training to happen in <strong>minibatches</strong> , we can specify **<code>batch_size</code> **parameter. You can also pre-batch the data manually before passing it to <code>x</code>&#x2F;<code>y</code>&#x2F;<code>validation_data</code>, in which case you do not need <strong><code>batch_size</code></strong></p>
<p>model.fit(x&#x3D;train_x_norm,y&#x3D;train_labels,validation_data&#x3D;(test_x_norm,test_labels),epochs&#x3D;10,batch_size&#x3D;1)</p>
</li>
</ul>
<blockquote>
<p>Note that you can c<strong>all<code>fit</code> function several times</strong> in a row to <strong>further<br>train the network</strong>. If you want to <strong>start training from scratch</strong> - you<br>need to <strong>re-run the cell with the model definition.</strong></p>
</blockquote>
<p>注：训练是叠加的，想从头训练需<strong>重定义网络</strong></p>
<h4 id="Multi-Class-Classificatio（多分类问题）"><a href="#Multi-Class-Classificatio（多分类问题）" class="headerlink" title="&lt;2&gt;Multi-Class Classificatio（多分类问题）"></a>&lt;2&gt;Multi-Class Classificatio（多分类问题）</h4><pre><code>    If you need to solve a problem of multi-class classification, your network would have more that one output - corresponding to the number of classes .**Each output will contain the probability of a given class.（多类多输出）**
</code></pre>
<p>**         <strong>When you expect a network to output a set of probabilities , we<br>need all of them to add up to 1. To ensure this, we use <code>softmax</code> as a final<br>activation function on the last layer. <strong>Softmax</strong> takes a vector input, and<br>makes sure that all components of that vector are transformed into<br>probabilities.</strong>（softmax 使所有概率和为1）**</p>
<pre><code>    Also, since the output of the network is a C-dimensional vector, we need labels to have the same form. This can be achieved by using **one-hot encoding** , when the number of a class is i converted to **a vector of zeroes, with 1 at the i-th position.（独热码，一位1其他位0）**

    To compare the probability output of the neural network with expected one-hot-encoded label, we use **cross-entropy loss** function. It takes two probability distributions, and outputs a value of how different they are.**（概率输出和独热码标签计算交叉熵损失函数）**
</code></pre>
<p>So, to <strong>summarize</strong> what we need to do for multi-class classification with<br>classes:</p>
<ul>
<li><p>The network should have neurons in the last layer</p>
</li>
<li><p><strong>Last activation function</strong> should be <strong>softmax</strong></p>
</li>
<li><p>Loss should be <strong>cross-entropy loss</strong></p>
</li>
<li><p>Labels should be converted to <strong>one-hot encoding</strong> (this can be done using <code>numpy</code>, or using Keras utils <code>to_categorical</code>)</p>
<p>model &#x3D; keras.models.Sequential([<br>keras.layers.Dense(5,input_shape&#x3D;(2,),activation&#x3D;’relu’),<br>keras.layers.Dense(2,activation&#x3D;’softmax’)<br>])<br>model.compile(keras.optimizers.Adam(0.01),’categorical_crossentropy’,[‘acc’])</p>
<h1 id="Two-ways-to-convert-to-one-hot-encoding"><a href="#Two-ways-to-convert-to-one-hot-encoding" class="headerlink" title="Two ways to convert to one-hot encoding"></a>Two ways to convert to one-hot encoding</h1><p>train_labels_onehot &#x3D; keras.utils.to_categorical(train_labels)<br>test_labels_onehot &#x3D; np.eye(2)[test_labels]</p>
<p>hist &#x3D; model.fit(x&#x3D;train_x_norm,y&#x3D;train_labels_onehot,validation_data&#x3D;[test_x_norm,test_labels_onehot],batch_size&#x3D;1,epochs&#x3D;10)</p>
</li>
</ul>
<p><strong>Sparse Categorical Cross-Entropy（稀疏分类交叉熵）（使用整数标签代替独热码标签）</strong></p>
<p>Often labels in multi-class classification are represented by class numbers.<br>Keras also supports another kind of loss function called <strong>sparse categorical<br>crossentropy</strong> , which expects class number to be <strong>integers</strong> , and not one-<br>hot vectors. Using this kind of loss function, we can simplify our training<br>code:</p>
<pre><code>model.compile(keras.optimizers.Adam(0.01),&#39;sparse_categorical_crossentropy&#39;,[&#39;acc&#39;])
model.fit(x=train_x_norm,y=train_labels,validation_data=[test_x_norm,test_labels],batch_size=1,epochs=10)
</code></pre>
<h4 id="Multi-Label-Classification（多标签分类）"><a href="#Multi-Label-Classification（多标签分类）" class="headerlink" title="&lt;3&gt;Multi-Label Classification（多标签分类）"></a>&lt;3&gt;Multi-Label Classification（多标签分类）</h4><pre><code>    With multi-label classification, instead of one-hot encoded vector, we will **have a vector that has 1 in position corresponding to all classes** relevant to the input sample. Thus, output of the network should not have normalized probabilities for all classes, but rather for each class individually - which corresponds to using **sigmoid** activation function. Cross-entropy loss can still be used as a loss function.**（不再使用独热码，而是标签中所有包含的位为1）**
</code></pre>
<h4 id="总结-Summary-of-Classification-Loss-Functions"><a href="#总结-Summary-of-Classification-Loss-Functions" class="headerlink" title="&lt;4&gt;总结 Summary of Classification Loss Functions"></a>&lt;4&gt;总结 <strong>Summary of Classification Loss Functions</strong></h4><pre><code>    We have seen that binary, multi-class and multi-label classification **differ by the type of loss function and activation function on the last layer** of the network. It may all be a little bit confusing if you are just starting to learn, but here are a few rules to keep in mind:
</code></pre>
<ul>
<li>If the network has one output (<strong>binary classification</strong>), we use <strong>sigmoid</strong> <strong>activation function</strong> , for <strong>multiclass classification</strong> - <strong>softmax</strong></li>
<li>If the output class is represented as one-hot-encoding, the <strong>loss function</strong> will be <strong>cross entropy loss</strong> (categorical cross-entropy), if the output contains class number - <strong>sparse categorical cross-entropy</strong>. For <strong>binary classification</strong> - use <strong>binary cross-entropy</strong> (same as <strong>log loss</strong>)</li>
<li><strong>Multi-label classification</strong> is when we can have an object belonging to several classes at the same time. In this case, we need to encode labels using one-hot encoding, and use <strong>sigmoid</strong> as activation function, so that each class probability is between 0 and 1.</li>
</ul>
<table>
<thead>
<tr>
<th>Classification</th>
<th>Label Format</th>
<th>Activation Function</th>
<th>Loss</th>
</tr>
</thead>
<tbody><tr>
<td>Binary</td>
<td>Probability of 1st class</td>
<td>sigmoid</td>
<td>binary crossentropy</td>
</tr>
<tr>
<td>Binary</td>
<td>One-hot encoding (2 outputs)</td>
<td>softmax</td>
<td>categorical crossentropy</td>
</tr>
<tr>
<td>Multiclass</td>
<td>One-hot encoding</td>
<td>softmax</td>
<td>categorical crossentropy</td>
</tr>
<tr>
<td>Multiclass</td>
<td>Class Number</td>
<td>softmax</td>
<td>sparse categorical crossentropy</td>
</tr>
<tr>
<td>Multilabel</td>
<td>One-hot encoding</td>
<td>sigmoid</td>
<td>categorical crossentropy</td>
</tr>
</tbody></table>
<h3 id="2-Tensorflow2-x-Keras"><a href="#2-Tensorflow2-x-Keras" class="headerlink" title="2.Tensorflow2.x+Keras"></a>2.Tensorflow2.x+Keras</h3><pre><code>        Tensorflow 2.x + Keras - new version of Tensorflow with integrated Keras functionality, which supports **dynamic computation graph** , allowing to perform tensor operations very similar to numpy (and PyTorch)


import tensorflow as tf
import numpy as np
print(tf.__version__)
</code></pre>
<h4 id="简单张量操作"><a href="#简单张量操作" class="headerlink" title="&lt;1&gt;简单张量操作"></a>&lt;1&gt;简单张量操作</h4><h5 id="①创建"><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h5><p>You can easily create simple tensors from lists of np-arrays, or generate<br>random ones</p>
<pre><code># 创建常量张量
a = tf.constant([[1,2],[3,4]])
print(a)
# 创建正态分布随机10*3张量
a = tf.random.normal(shape=(10,3))
print(a)
</code></pre>
<h5 id="②运算"><a href="#②运算" class="headerlink" title="②运算"></a>②运算</h5><p>You can use arithmetic operations on tensors, which are performed element-<br>wise, as in numpy. Tensors are automatically expanded to required dimension,<br>if needed. <strong>To extract numpy-array from tensor, use<br><code>.numpy()</code>:（将张量转化为np数组）（以下是运算示例：）</strong></p>
<pre><code>print(a-a[0])
print(tf.exp(a)[0].numpy())
</code></pre>
<h4 id="计算梯度"><a href="#计算梯度" class="headerlink" title="&lt;2&gt;计算梯度"></a>&lt;2&gt;计算梯度</h4><p>For back propagation, you need to compute gradients. This is done using<br><strong><code>tf.GradientTape()</code></strong> idiom:</p>
<ul>
<li><p>Add <code>with tf.GradientTape() as tape:</code> block around our computations</p>
</li>
<li><p>Mark those tensors with respect to which we need to compute gradients by calling <code>tape.watch</code> (all variables are <strong>watched automatically</strong>)</p>
</li>
<li><p>Compute whatever we need (build computational graph)</p>
</li>
<li><p>Obtain gradients using <code>tape.gradient</code></p>
<p>a &#x3D; tf.random.normal(shape&#x3D;(2, 2))<br>b &#x3D; tf.random.normal(shape&#x3D;(2, 2))</p>
<p>with tf.GradientTape() as tape:<br>  tape.watch(a)  # Start recording the history of operations applied to <code>a</code><br>  c &#x3D; tf.sqrt(tf.square(a) + tf.square(b))  # Do some math using <code>a</code></p>
<h1 id="What’s-the-gradient-of-c-with-respect-to-a"><a href="#What’s-the-gradient-of-c-with-respect-to-a" class="headerlink" title="What’s the gradient of c with respect to a?"></a>What’s the gradient of <code>c</code> with respect to <code>a</code>?</h1><p>  dc_da &#x3D; tape.gradient(c, a)<br>  print(dc_da)</p>
</li>
</ul>
<p>监视变量、构建运算关系、计算梯度</p>
<h4 id="3-例1：线性回归问题"><a href="#3-例1：线性回归问题" class="headerlink" title="&lt; 3&gt;例1：线性回归问题"></a><strong>&lt; 3&gt;例1：线性回归问题</strong></h4><p>生成数据集</p>
<pre><code>import matplotlib.pyplot as plt
from sklearn.datasets import make_classification, make_regression
from sklearn.model_selection import train_test_split
import random

np.random.seed(13) # pick the seed for reproducability - change it to explore the effects of random variations

train_x = np.linspace(0, 3, 120)
train_labels = 2 * train_x + 0.9 + np.random.randn(*train_x.shape) * 0.5

plt.scatter(train_x,train_labels)
</code></pre>
<p>定义损失函数：</p>
<pre><code>input_dim = 1
output_dim = 1
learning_rate = 0.1

# This is our weight matrix
w = tf.Variable([[100.0]])
# This is our bias vector
b = tf.Variable(tf.zeros(shape=(output_dim,)))

def f(x):
  return tf.matmul(x,w) + b

def compute_loss(labels, predictions):
  return tf.reduce_mean(tf.square(labels - predictions))
</code></pre>
<p>训练函数：</p>
<pre><code>def train_on_batch(x, y):
  with tf.GradientTape() as tape:
    predictions = f(x)
    loss = compute_loss(y, predictions)
    # Note that `tape.gradient` works with a list as well (w, b).
    dloss_dw, dloss_db = tape.gradient(loss, [w, b])
  w.assign_sub(learning_rate * dloss_dw)
  b.assign_sub(learning_rate * dloss_db)
  return loss
</code></pre>
<p>训练集生成：</p>
<pre><code># Shuffle the data. 打乱数据
indices = np.random.permutation(len(train_x))
features = tf.constant(train_x[indices],dtype=tf.float32)
labels = tf.constant(train_labels[indices],dtype=tf.float32)
</code></pre>
<p>训练过程：（第 i 到 i+batch_size 为一组）</p>
<pre><code>batch_size = 4
for epoch in range(10):
  for i in range(0,len(features),batch_size):
    loss = train_on_batch(tf.reshape(features[i:i+batch_size],(-1,1)),tf.reshape(labels[i:i+batch_size],(-1,1)))
  print(&#39;Epoch %d: last batch loss = %.4f&#39; % (epoch, float(loss)))
</code></pre>
<p>绘制：</p>
<pre><code>plt.scatter(train_x,train_labels)
x = np.array([min(train_x),max(train_x)])
y = w.numpy()[0,0]*x+b.numpy()[0]
plt.plot(x,y,color=&#39;red&#39;)


We now have obtained optimized parameters $W$ and $b$. Note that their values are **similar to the original values used when generating the dataset** (W=2, b=1)
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/137124492">https://blog.csdn.net/qq_32971095/article/details/137124492</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/14/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/14/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%EF%BC%9C1%EF%BC%9E/" class="post-title-link" itemprop="url">c语言实现进化算法——人工智能导论＜1＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-14 17:23:20" itemprop="dateCreated datePublished" datetime="2024-03-14T17:23:20+08:00">2024-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一.问题描述"></a>一.问题描述</h2><p>求该函数的最优解：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b72b9e9aec3b2c8f64d8b9f4e22efa21.png"></p>
<p>解题思路：</p>
<p>变量编码-&gt;生成种群-&gt;交叉-&gt;变异-&gt;选择-&gt;迭代</p>
<pre><code>    对x1和x2在变量范围内的值按照给定精度计算编码成二进制码的位数；随机生成一定规模的种群，其二进制编码随机； 随机对种群内个体的编码进行交叉；随机对种群内个体的编码进行按位变异；对二进制码进行解码、求解适应度函数值、保留一定数量的精英、采用轮盘赌随机选取其余个体最终组成新的种群；迭代，重复 交叉-&gt;变异-&gt;选择 至最优适应度基本不变或迭代一定次数。
</code></pre>
<h2 id="二-代码解析"><a href="#二-代码解析" class="headerlink" title="二.代码解析"></a>二.代码解析</h2><h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h3><pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define POPULATION_SIZE 100	//种群规模
#define RESERVE_NUM 3		//每代精英保留数 
#define VARI_NUM 2			//变量个数 
#define ITERATION 1000		//迭代次数
#define END_TIMES 100		//稳定终止次数 
#define PC 0.6				//交叉概率 
#define CROSS_LEN 8			//交叉长度 
#define PM 0.1				//变异概率 

//种群结构体 
typedef struct v&#123;
	bool encode[50];		//二进制编码 
	double value[VARI_NUM];	//解码数值 
	bool change;			//标记是否发生交叉或变异  
	double fitness;			//适应度
	double fit_rate;		//适应度占比 
&#125;v;

double lower[VARI_NUM],upper[VARI_NUM],accur;	//x1,x2上下界和精度 
int encode_num,encode_number[VARI_NUM];			//二进制编码位数 
double real_accur[VARI_NUM];					//实际精度 
v optimization_popu;							//最优个体 

//函数声明 
v Get_Optimization(void);
void Init_Population(v* group);
void Cross(v* group);
void Mutation(v* group);
v* Select(v**group);
double Fitness(double x1,double x2); 
void Output_Result(v* optimization);
void Free_space(v** group);

//************************************************************************************************************
int main()&#123;

	int i;
	v temp;
	
	//输入样例：-3.0 12.1 4.1 5.8 0.0001 
	printf(&quot;输入变量x1和x2的上下界和精度(x1_lower,x1_upper,x2_lower,x2_upper,accur):&quot;);
	scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;lower[0],&amp;upper[0],&amp;lower[1],&amp;upper[1],&amp;accur);
	
	//可以多次进行实验
	for(i=0;i&lt;1;i++)&#123;
		temp=Get_Optimization();
		if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;
	&#125;
	Output_Result(&amp;optimization_popu);
	
	return 0;	
&#125;

//************************************************************************************************************
v Get_Optimization(void)&#123;
	
	srand((unsigned)time(NULL));
	int i,j;
	double temp;
	v** group=(v**)malloc(3*sizeof(v*));	//原始、交叉、变异种群
	for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	v* optimization=group[0],opt_tmep;				//最优种群 
	
	//初始化种群 
	Init_Population(group[0]);
	memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); 
	memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);
	
	//迭代 
	for(i=j=0;i&lt;ITERATION;i++)&#123;
		
		//交叉
		Cross(group[1]); 
		//变异
		Mutation(group[2]);
		//选择 
		temp=optimization-&gt;fitness;
		optimization=Select(group); 
		if((optimization-&gt;fitness-temp)&lt;accur)&#123;
			j++;
			if(j&gt;=END_TIMES)break;		//结果保持稳定则退出 
		&#125;
	 	
	&#125;
	
	//输出结果
	Output_Result(optimization); 
	
	opt_tmep=*optimization;
	Free_space(group);
	return opt_tmep;
	
&#125;

//计算变量二进制编码位数 
int Encode_Num(double lower,double upper,double accur)&#123;
	
	int num,i,j;
	num=(upper-lower)/accur+1;
	for(i=0,j=1;j&lt;num;j*=2,i++);
	return i;
	
&#125;

void Init_Population(v* group)&#123;
	
	int i,j;	
	
	for(i=encode_num=0;i&lt;VARI_NUM;i++)encode_num+=(encode_number[i]=Encode_Num(lower[i],upper[i],accur));		//计算编码位数
	for(i=0;i&lt;VARI_NUM;i++)real_accur[i]=(upper[i]-lower[i])/(pow(2,encode_number[i])-1);						//计算实际精度
	
	//初始化种群 
	for(i=0;i&lt;POPULATION_SIZE;i++)&#123;
		//随机生成二进制编码 
		for(j=0;j&lt;encode_num;j++)&#123;
			group[i].encode[j]=rand()%2;
//			printf(&quot;%d %d:%d\n&quot;,i,j,group[i].encode[j]);
		&#125;
		group[i].change=true;
	&#125;

&#125;

//交叉lower和upper之间的编码 
void Cross(v* group)&#123;
	
	double p;
	int i,j,lower,upper;
	bool temp;
	
	//随机选取交叉片段
	lower=rand()%(encode_num-CROSS_LEN-1);
	upper=lower+CROSS_LEN; 

	for(i=0;i&lt;POPULATION_SIZE/2-1;i++)&#123;
		p=1.0*rand()/RAND_MAX;	//***随机数*** 
		if(p&lt;PC)&#123; 
			//交叉 
			for(j=lower;j&lt;upper;j++)&#123;
				temp=group[i].encode[j];
				group[i].encode[j]=group[POPULATION_SIZE-1-i].encode[j];
				group[POPULATION_SIZE-1-i].encode[j]=temp;
			&#125;
		&#125;
		//标记未交叉 
		else group[i].change=group[POPULATION_SIZE-1-i].change=false;
	&#125;
	
&#125; 

//按位变异  
void Mutation(v* group)&#123;

	double p;
	int i,j;
	for(i=0;i&lt;POPULATION_SIZE/2;i++)&#123;
		for(j=0;j&lt;encode_num;j++)&#123;
			p=1.0*rand()/RAND_MAX;	//***随机数*** 
			if(p&lt;PM)group[i].encode[j]=!group[i].encode[j];
			else group[i].change=false;
		&#125;
	&#125;
	
&#125;

//选择
v* Select(v**group)&#123;
	
	v* fitist[RESERVE_NUM],*group_temp=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	int i,j,k,l,m,n;
	int vaild_num;	//有效个数 
	double fit_sum;	//适应度总大小
	for(i=0;i&lt;RESERVE_NUM;i++)fitist[i]=&amp;group[0][0]; 
		
	//解码并计算适应度函数 
	for(vaild_num=fit_sum=i=0;i&lt;3;i++)&#123;
		for(j=0;j&lt;POPULATION_SIZE;j++)&#123;
			if(!group[i][j].change)continue; 
			for(m=n=0;m&lt;VARI_NUM;n+=encode_number[m],m++)&#123;
				for(k=l=0;k&lt;encode_number[m];k++)l+=group[i][j].encode[k+n]*pow(2,k);
				//解码 
				group[i][j].value[m]=lower[m]+l*real_accur[m];
//				printf(&quot;%d %d--value[%d]:%lf\n&quot;,i,j,m,group[i][j].value[m]);
			&#125;
			
			//计算适应度 
			group[i][j].fitness=Fitness(group[i][j].value[0],group[i][j].value[1]);
			//保存适应度大的个体
			for(k=0;k&lt;RESERVE_NUM;k++)&#123;
				if(group[i][j].fitness&gt;fitist[k]-&gt;fitness)&#123;
					for(l=k;l&lt;RESERVE_NUM-1;l++)fitist[l+1]=fitist[l];
					fitist[k]=&amp;group[i][j];
				&#125;	
			&#125;
			vaild_num++;fit_sum+=group[i][j].fitness;						//适应度总和计算 
//			printf(&quot;%d %d--fitness:%lf\n&quot;,i,j,group[i][j].fitness);			
		&#125;
	&#125; 
	
	//***保留优秀个体***
	for(i=0;i&lt;RESERVE_NUM;i++)group_temp[i]=*fitist[i];
	
	//计算比率 
	for(i=0;i&lt;3;i++)&#123;
		for(j=0;j&lt;POPULATION_SIZE;j++)&#123;
			if(!group[i][j].change)continue;
			group[i][j].fit_rate=group[i][j].fitness/fit_sum;
//			printf(&quot;%d %d--fit_rate:%lf\n&quot;,i,j,group[i][j].fit_rate);	
		&#125;
	&#125;
	
	//轮盘赌选择
	for(i=RESERVE_NUM;i&lt;POPULATION_SIZE;i++)&#123;
		double p=1.0*rand()/RAND_MAX;
		//寻找所处区间
		double temp;
		for(temp=0,j=0;j&lt;3;j++)&#123;
			for(k=0;k&lt;POPULATION_SIZE;k++)&#123;
				if(!group[j][k].change)continue;
				temp+=group[j][k].fit_rate;
				if(p&lt;temp)break;
			&#125;
			if(p&lt;temp)break;
		&#125;
		//复制 
		if(j!=3&amp;&amp;k!=POPULATION_SIZE)group_temp[i]=group[j][k];
		else group_temp[i]=group[j-1][k-1];
//		printf(&quot;select %3d from %3d %3d--fitness:%lf	--p:%lf\n&quot;,i,j,k,group_temp[i].fitness,p);
	&#125; 
	 
	memcpy(group[0],group_temp,sizeof(v)*POPULATION_SIZE);
	free(group_temp);
	
	return fitist[0]; 
	
&#125;

//适应度函数 
double Fitness(double x1,double x2)&#123;
	return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);
&#125;

void Output_Result(v* optimization)&#123;
	int i;
	printf(&quot;最优解为:x1=%9lf x2=%9lf f(x1,x2)=%9lf 二进制编码为:&quot;,optimization-&gt;value[0],optimization-&gt;value[1],optimization-&gt;fitness); 
	for(i=0;i&lt;encode_num;i++)printf(&quot;%d&quot;,optimization-&gt;encode[i]);
	printf(&quot;\n&quot;);
&#125;

//释放空间 
void Free_space(v** group)&#123;
	int i;
	for(i=0;i&lt;3;i++)free(group[i]);
	free(group);
&#125;
</code></pre>
<h3 id="2-算法关键参数"><a href="#2-算法关键参数" class="headerlink" title="2.算法关键参数"></a>2.算法关键参数</h3><pre><code>#define POPULATION_SIZE 100	//种群规模
#define RESERVE_NUM 3		//每代精英保留数 
#define VARI_NUM 2			//变量个数 
#define ITERATION 1000		//迭代次数
#define END_TIMES 100		//稳定终止次数 
#define PC 0.6				//交叉概率 
#define CROSS_LEN 8			//交叉长度 
#define PM 0.1				//变异概率 
</code></pre>
<h3 id="3-定义种群结构体、相关变量及函数"><a href="#3-定义种群结构体、相关变量及函数" class="headerlink" title="3.定义种群结构体、相关变量及函数"></a>3.定义种群结构体、相关变量及函数</h3><pre><code>//种群结构体 
typedef struct v&#123;
	bool encode[50];		//二进制编码 
	double value[VARI_NUM];	//解码数值 
	bool change;			//标记是否发生交叉或变异  
	double fitness;			//适应度
	double fit_rate;		//适应度占比 
&#125;v;

double lower[VARI_NUM],upper[VARI_NUM],accur;	//x1,x2上下界和精度 
int encode_num,encode_number[VARI_NUM];			//二进制编码位数 
double real_accur[VARI_NUM];					//实际精度 
v optimization_popu;							//最优个体 

//函数声明 
v Get_Optimization(void);
void Init_Population(v* group);
void Cross(v* group);
void Mutation(v* group);
v* Select(v**group);
double Fitness(double x1,double x2); 
void Output_Result(v* optimization);
void Free_space(v** group);
</code></pre>
<h3 id="4-求解流程"><a href="#4-求解流程" class="headerlink" title="4.求解流程"></a>4.求解流程</h3><pre><code>v Get_Optimization(void)&#123;
	
	srand((unsigned)time(NULL));
	int i,j;
	double temp;
	v** group=(v**)malloc(3*sizeof(v*));	//原始、交叉、变异种群
	for(i=0;i&lt;3;i++)group[i]=(v*)malloc(sizeof(v)*POPULATION_SIZE);
	v* optimization=group[0],opt_tmep;				//最优种群 
	
	//初始化种群 
	Init_Population(group[0]);
	memcpy(group[1],group[0],sizeof(v)*POPULATION_SIZE); 
	memcpy(group[2],group[0],sizeof(v)*POPULATION_SIZE);
	
	//迭代 
	for(i=j=0;i&lt;ITERATION;i++)&#123;
		
		//交叉
		Cross(group[1]); 
		//变异
		Mutation(group[2]);
		//选择 
		temp=optimization-&gt;fitness;
		optimization=Select(group); 
		if((optimization-&gt;fitness-temp)&lt;accur)&#123;
			j++;
			if(j&gt;=END_TIMES)break;		//结果保持稳定则退出 
		&#125;
	 	
	&#125;
	
	//输出结果
	Output_Result(optimization); 
	
	opt_tmep=*optimization;
	Free_space(group);
	return opt_tmep;
	
&#125;
</code></pre>
<h2 id="三-求解结果"><a href="#三-求解结果" class="headerlink" title="三.求解结果"></a>三.求解结果</h2><pre><code>    改变算法关键参数会导致求解结果不同，不同的时间下的结果也不同。可以改变主函数中for循环的结束条件多次进行实验：


    //可以多次进行实验
	for(i=0;i&lt;1;i++)&#123;
		temp=Get_Optimization();
		if(optimization_popu.fitness&lt;temp.fitness)optimization_popu=temp;
	&#125;

    笔者在一定的参数下得到了最优解：


最优解为:
x1=11.625358
x2=5.725031
f(x1,x2)=38.850261
二进制编码为:
111100111111101111010110100101111

    对于问题二，修改适应度函数：


//适应度函数 
double Fitness(double x1,double x2)&#123;
//	return 21.5+x1*sin(4*M_PI*x1)+x2*sin(20*M_PI*x2);
	return 100*pow((x2-x1*x1),2)+pow((1-x1),2);
&#125;

    再输入变量范围及精度 ：


输入样例2：-2.048 2.048 -2.048 2.048 0.0001
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ede4e3460860a1737bc72b9a592cb66.png"></p>
<pre><code>最优解为:x1=-2.047875 x2=-2.037187 f(x1,x2)=3891.799899 
二进制编码为:01000000000000001011010100000000
</code></pre>
<h2 id="四-相关思考"><a href="#四-相关思考" class="headerlink" title="四.相关思考"></a>四.相关思考</h2><p>1.增加精度可以增加编码长度，减少交叉变异的影响，增加搜索精度，结果可能更加靠近最优解</p>
<p>2.增加变异概率以产生更多新的性状（<strong>变异的概率可采用自适应概率，如果最优种个体适应度值长时间未变化，可增加变异概率</strong><br>），以及采用更复杂的交叉、变异算法</p>
<p>3.交叉、变异过于随机会使求解趋于“遍历”，并且算法的“朝最优解的驱动力”不足</p>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136715239">https://blog.csdn.net/qq_32971095/article/details/136715239</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/01/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/01/Vitis%E5%BC%80%E5%8F%91%E4%BA%8C%E2%80%94%E2%80%94FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9C%EF%BC%9F%EF%BC%9E/" class="post-title-link" itemprop="url">Vitis开发二——FPGA学习笔记＜？＞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-01 15:51:21" itemprop="dateCreated datePublished" datetime="2024-03-01T15:51:21+08:00">2024-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：《DFZU2EG_4EV MPSoC 之嵌入式 VITIS 开发指南》——正点原子</p>
<h2 id="一-自定义-IP-核-呼吸灯实验"><a href="#一-自定义-IP-核-呼吸灯实验" class="headerlink" title="一.自定义 IP 核-呼吸灯实验"></a>一.自定义 IP 核-呼吸灯实验</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>   通过**创建和封装 IP 向导** 的方式来自定义 IP 核，将模块集成到 Vivado 中的 IP 库中。本 次实验选择常用的方式，即创建一个带有 AXI 接口的 IP 核，该 IP 核通过 AXI 协议实现 PS 和 PL 的数据通信。
</code></pre>
<h4 id="硬件框图"><a href="#硬件框图" class="headerlink" title="&lt;1&gt;硬件框图"></a>&lt;1&gt;硬件框图</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f7f69746d9c8b2612a562e216cbcb06d.png"></p>
<pre><code>    自定义一个 LED IP 核，来控制 PL LED 呈现呼吸灯的效果，并且 **PS 可以通过 AXI 接口来控制呼吸灯的开关和呼吸的频率** 。
</code></pre>
<h3 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><h4 id="step1：自定义IP核"><a href="#step1：自定义IP核" class="headerlink" title="step1：自定义IP核"></a>step1：自定义IP核</h4><h5 id="创建IP核"><a href="#创建IP核" class="headerlink" title="&lt;1&gt;创建IP核"></a>&lt;1&gt;创建IP核</h5><pre><code>    在vivado进入界面点击“Tasks”栏中的“Manage IP”。在弹出的选项中选择“New IP Location...”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/75f9ff5dc9db70244cab46a870f0688d.png"></p>
<p>设置工程路径**“IP Location”**   和 器件**“Part”（后续可重新指定）：**</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3b1e3885d4a1f135051044efbbe1a2b.png"></p>
<pre><code>    工程创建完成后，运行**创建和封装 IP 向导** 。点击**菜单栏的“Tools”** ，选择**“Create and Package New IP”** ，在弹出的界面中，点击“NEXT”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb4052ba288d62dba075506fe808c59d.png"></p>
<p>可选择封装 IP 或者创建一个带 AXI4 接口的 IP 核 ：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d966c8cd8965f275b224c4f87af580a0.png"></p>
<pre><code>    接下来分别设置 IP 核名称（Name）、版本号（Version）、显示名（Display name）、描述（Description） 和路径（IP location）。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/eb004f9d3e754f9cc51b150f9afb459d.png"></p>
<p>接下来对 AXI 接口进行设置：</p>
<p><strong>Name（名称）</strong> ：这里修改成 S0_AXI。</p>
<p><strong>Interface Tpye（接口类型）</strong> ：共三种接口类型可选，分别是 <strong>Lite、Full 和 Stream</strong> 。AXI4-Lite<br>接口是<strong>简化版</strong> 的 AXI4 接口，用于较少数据量的存储映射通信；AXI4-Full 接口是<strong>高性能存储映射接口</strong><br>，用于较多数据量的存储映射通信；AXI4-Stream 用于<strong>高速数据流传输</strong> ，非存储映射接口。本次实验只需少量数据的通信， 因此接口类型选择默认的<br>Lite 接口。</p>
<p><strong>Interface Mode（接口模式）</strong> ：接口模式有 <strong>Slave（从机）和 Master（主机）</strong> 两种模式可选，AXI<br>协议是<strong>主机和从机通过“握手”的方式建立连接</strong> ，这里选择默认的 <strong>Slave 接口模式</strong> 。</p>
<p><strong>Data Width（数据宽度）</strong> ：数据位宽保持默认，即 32 位位宽。</p>
<p><strong>Memory Size（存储器大小）</strong> ： 在 AXI4-Lite 接口模式下，该选项不可设置。</p>
<p><strong>Number of Registers（寄存器数量）</strong> ：用于配置 PL LED 呼吸灯寄存器的数量，这里保持默认。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/91283af0eb0913bef4fd7d225f3b9a7b.png"></p>
<pre><code>    最后弹出封装接口的总结描述和下一步操作选项的界面。这里保持默认，即**将 IP 添加至 IP 库中** ， 点击“Finish”按钮完成 IP 核的创建和封装。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/413f0da1496d94c764828b274017a30e.png"></p>
<pre><code>     在 **IP Catalog 界面** 中可以看到刚刚添加的 IP 核，位于 **User Repository** 一栏中的 AXI Peripheral 下，名称 为“breath_led_ip_v1.0”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a18c63c55f085bf15281c34ab989331.png"></p>
<h5 id="编辑IP核"><a href="#编辑IP核" class="headerlink" title="&lt;2&gt;编辑IP核"></a>&lt;2&gt;编辑IP核</h5><pre><code>    右击 breath_led_ip_v1.0 IP 核， 选择“**Edit in IP Packager** ”，在弹出的界面中点击“OK”。此时会打开一个新的工程：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/63e543b57d5d554d9b74780351c6fb78.png"></p>
<pre><code>    双击 breath_led_ip_v1_0.v文件即可开始编辑代码，来添加控制 PL LED 呼吸灯所需要的参数和端口信号：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e30dec6de76b6e61b1aa50c039589999.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3f8c3ad3ebbdf5bdc9e7ad185618452.png"></p>
<pre><code>    在创建和封装 IP 核向导中，我们总共定义了 4 个寄存器，代码中的 slv_reg0 至 slv_reg3 是寄存器地址 0 至寄存器地址 3 对应的数据，通过例化呼吸灯模块，**将寄存器地址对应的数据和呼 吸灯模块（breath_led****） 的控制端口相连接**，即可实现对呼吸灯的控制。 
</code></pre>
<p>breath_led_ip_v1_0.v文件：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/252b8cca44230059c49602a5452d9998.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f62dc01cb25ae99d4f697d5b7638e66.png"></p>
<pre><code>    breath_led_ip_v1_0_S0_AXI.v文件。 breath_led_ip_v1_0_S0_AXI 模块实现了 AXI4 协议下的读写寄存器的功能：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/425827ac7a64452aea8a0413ea593bcf.png"></p>
<p>时我们还需要在代码的第 401 行例化 breath_led.v 文件：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ffed17009e2230f835db7440ba21eee.png"></p>
<pre><code>	// Add user logic here
    breath_led #(
        .START_FREQ_STEP(START_FREQ_STEP)
    )
    u_breath_led(
        .sys_clk (S_AXI_ACLK),
        .sys_rst_n (S_AXI_ARESETN),
        .sw_ctrl (slv_reg0[0]),
        .set_en (slv_reg1[31]),
        .set_freq_step (slv_reg1[9:0]),
        .led (led)
    );
	// User logic ends

    代码中的 **slv_reg0 和 slv_reg1 是寄存器地址 0 和寄存器地址 1 对应的数据** ，我们通过寄存器地址 0 对应 的数据来控制呼吸灯的使能（sw_ctrl），寄存器地址 1 对应数据的最高位控制呼吸灯频率的设置有效信号 （set_en），寄存器地址 1 对应数据的低 10 位控制呼吸灯频率的步长（set_freq_step）。

    此时工程中缺失 breath_led.v 文件，breath_led.v 文件用于实现呼吸灯的功能。右击**“Design Sources”** ，选择**“Add Sources…”** ，在弹出的界面中选择“**Add or Create design source”** ， 点击“NEXT”；点击“**Create File ”** 创建一个新的文件，在弹出的界面输入名称 breath_led ，路径 为../**_custom_ip/ip_repo/breath_led_ip_1.0/_ hdl**，点击“OK”按钮
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e3c33e0d2c764bd425828a96898b80d.png"></p>
<pre><code>    在弹出的**模块定义界面中点击“OK”按钮** ，接下来在弹出的确认按钮中点击“YES”。双击 u_breath_led(breath_led.v)文件并编辑代码如下：


module breath_led(
    input          sys_clk        , //时钟信号
    input          sys_rst_n      , //复位信号
    input          sw_ctrl        , //呼吸灯开关控制信号 1：亮 0:灭
    input          set_en         , //设置呼吸灯频率设置使能信号
    input   [9:0]  set_freq_step  , //设置呼吸灯频率变化步长
    
    output         led              //LED
);

//*****************************************************
//**                  main code
//*****************************************************

//parameter define
parameter  START_FREQ_STEP = 10&#39;d100; //设置频率步长初始值

//reg define
reg  [15:0]  period_cnt  ;      //周期计数器
reg  [9:0]   freq_step   ;      //呼吸灯频率间隔步长
reg  [15:0]  duty_cycle  ;      //设置高电平占空比的计数点
reg          inc_dec_flag;      //用于表示高电平占空比的计数值,是递增还是递减
                                //为1时表示占空比递减,为0时表示占空比递增
//wire define
wire         led_t       ;

//将周期信号计数值与占空比计数值进行比较，以输出驱动led的PWM信号
assign led_t = ( period_cnt &lt;= duty_cycle ) ? 1&#39;b1 : 1&#39;b0 ;
assign led = led_t &amp; sw_ctrl;

//周期信号计数器在0-50_000之间计数
always @ (posedge sys_clk) begin
    if (!sys_rst_n)
        period_cnt &lt;= 16&#39;d0;
    else if(!sw_ctrl)
        period_cnt &lt;= 16&#39;d0;
    else if( period_cnt == 16&#39;d50_000 )
        period_cnt &lt;= 16&#39;d0;
    else
        period_cnt &lt;= period_cnt + 16&#39;d1;
end

//设置频率间隔
always @(posedge sys_clk) begin
    if(!sys_rst_n)
        freq_step &lt;= START_FREQ_STEP;
    else if(set_en) begin
        if(set_freq_step == 0)
            freq_step &lt;= 10&#39;d1;
        else if(set_freq_step &gt;= 10&#39;d1_000)
            freq_step &lt;= 10&#39;d1_000;
        else    
            freq_step &lt;= set_freq_step;
    end        
end

//设定高电平占空比的计数值
always @(posedge sys_clk) begin
    if (sys_rst_n == 1&#39;b0) begin
        duty_cycle &lt;= 16&#39;d0;
        inc_dec_flag &lt;= 1&#39;b0;
    end     
    else if(!sw_ctrl) begin          //呼吸灯开关关闭时，信号清零
        duty_cycle &lt;= 16&#39;d0;
        inc_dec_flag &lt;= 1&#39;b0;
    end    
    //每次计数完了一个周期，就调节占空比计数值
    else if( period_cnt == 16&#39;d50_000 ) begin
        if( inc_dec_flag ) begin  //占空比递减
            if( duty_cycle == 16&#39;d0 )     
                inc_dec_flag &lt;= 1&#39;b0;
            else if(duty_cycle &lt; freq_step)
                duty_cycle &lt;= 16&#39;d0;
            else    
                duty_cycle &lt;= duty_cycle - freq_step;
        end
        else begin  //占空比递增
            if( duty_cycle &gt;= 16&#39;d50_000 )  
                inc_dec_flag &lt;= 1&#39;b1;
            else
                duty_cycle &lt;= duty_cycle + freq_step;
        end 
    end 
    else  //未计数完一个周期时，占空比保持不变
        duty_cycle &lt;= duty_cycle ;
end
  
endmodule

    模块实现了呼吸灯的功能。呼吸灯的使能由输入的端口信号 sw_ctrl 控制，呼吸灯的呼吸频率由输入的端口信号 set_en 和 set_freq_step 控制。输入的 set_freq_step 范围是 1~1000。

    在左侧 Flow Navigator 导航栏中找到 SYNTHESIS，点击 该选项中的 **“Run Synthesis”** ，等待代码编译完成。
</code></pre>
<h5 id="IP-封装"><a href="#IP-封装" class="headerlink" title="&lt;3&gt;IP 封装"></a>&lt;3&gt;IP 封装</h5><pre><code>    将界面切换至 Package IP，也可以通过 **IP-XACT** 界面下的 **component.xml** 重新打开：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a1c22b4d8b6ddec5fb30e7748ee701a2.png"></p>
<pre><code>    Identification 这一栏的选项直接保持默认，需要注意的是，我们可以点击图 6.3.31 中 **Categories** 选项下 的“+”按钮来**修改 IP 的分类** ，这里不做修改。 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e936bc92628f578319803047bbae7cc5.png"></p>
<pre><code>    这里勾选“zynq”和“zynquplus”两项，表示该 IP 核支持 ZYNQ 和 ZYNQ MPSOC 器件。而 Life-cycle 表明该 IP 核当前的产品生命周期，这里选择“**Pre-Production** ”
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f16af805e5acec286ff245098ff0bdf9.png"></p>
<pre><code>    点击 File Groups，然后点击界面上的“Merge Changes from File Groups Wizard”，此时可以在 Verilog Synthesis 一栏中查看工程中的三个模块。

    点击 **Customization Parameters** ，点击界面上的“**Merge Changes from Customization Parameters Wizard”** ，此时多了 Hidden Parameters 一栏，展开这个界面，可以看到程序中自定义的参数 START_FREQ_STEP， 右击这个参数，选择“Edit Parameter…”，弹出编辑参数的界面：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0dc10a436eeb939c31cf5a88916780d3.png"></p>
<pre><code>    在弹出的页面中勾选“Visible in Customization GUI”，将此参数显示在 GUI 参数界面中； Format 格式改为“long”； 勾选“Specify Range”来设定此参数的范围。将 Type 改为“Range of integers”，Minimum 的值改为 1， Maximum 的值改为 1000，将 Default Value 的值改为 100，点击“OK”按钮：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e7bab0fc3776af968cd45566c20131a0.png"></p>
<pre><code>    点击“Customization GUI”，可以在“Layout”界面拖动 Page 0 下的参数来调整参数在 GUI 显示 的位置，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c5ef7a9cd6f3c7a15449f3584ad9974.png"></p>
<pre><code>    点击**“Review and Package”** ，然后点击“**IP has been modified”** 更新总结界面，最后点击**“Re-Package IP”** ，如下图所示： 
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d280db132f7fdb24445364a47d6a502d.png"></p>
<pre><code>    IP 核封装完成后，在 IP 核所在路径（...\custom_ip\ip_repo\breath_led_ip_1.0\drivers\breath_led_ip_v1_0\src） 目录下，Vivado 软件会自动生成.c 和.h 文件，方便在 VITIS 软件中对 IP 核进行操作。最后关闭工程IP核创建结束。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/161d049dd7e3bf4ca866b0d0354554ae.png"></p>
<h4 id="step2：创建vivado工程"><a href="#step2：创建vivado工程" class="headerlink" title="step2：创建vivado工程"></a>step2：创建vivado工程</h4><pre><code>    创建 Vivado 工程名为 user_led，具体过程见前。点击菜单栏的“Tools”， 选择“Setting”，把自定义的IP核添加至本工程的IP库中：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/62472d612e15937378ba85ce4929f62b.png"></p>
<pre><code>    点击“IP”一栏下的“Repository”，然后点击“+”来添加自定义的 IP 核。选择../custom_ip/**ip_repo/breath_led_ip_1.0** ，点击“Select”，点击“OK”按钮添加 IP 核：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/91eae14f825c3128bdcadc291c08c7ed.png"></p>
<h4 id="step3：使用-IP-Integrator-创建-Processing-System"><a href="#step3：使用-IP-Integrator-创建-Processing-System" class="headerlink" title="step3：使用 IP Integrator 创建 Processing System"></a>step3：使用 IP Integrator 创建 Processing System</h4><pre><code>    在左侧导航栏（Flow Navigator）中，单击 IP Integrator 下的 Create Block Design。然后在弹出的对话框中指定所创建的 Block Design 的名称，这里使用默认的“design_1”。在 Diagram 窗口中给设计添加 IP。点击图中加号“+”，会打开 IP 目录（IP Catalog）。在搜索栏中 键入“zynq”，找到并双击“ZYNQ Ultrascale+ MPSoC”，将 MPSOC 处理系统 IP 添加到设计中。和前面搭建嵌入式最小系统不同的是，我们保留了 pl_clk0、pl_resetn0、maxihpm0_lpd_aclk 和 M_AXI_HPM0_LPD 接口，只是添加了 UART 控制器（MIO42 和 MIO43），修改 Bank 电压和修改 DDR4 控制器**（见前）** 其它保持默认。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/16e20796ae329a0e1e72eb83e2676f4a.png"></p>
<pre><code>     接下来添加 Breath LED IP 核，点击“+”图标，在搜索框中输入“led”，即可找到之前添加的“breath_led_ip_v1.0”IP，添加此IP核，可以双击 led IP 核来设置参数，可以看到我们自定义的参数（Start Freq Step）和其它四个参数：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/89e3ce79246c6299be15abc7c427678b.png"></p>
<pre><code>    接下来点击**“Run Connection Automation”** 来自动连线，在弹出的窗口中勾选 **All Automation** ，然后点击 OK。此时原理图中还没有 LED 的引脚，右击 breath_led_ip_0 的 led 引脚，选择“Make External”，将引出的 led_0 改为 led：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/42ab2d5ad83cb9c00869f8e240a49e7b.png"></p>
<h4 id="step4：生成顶层-HDL-模块"><a href="#step4：生成顶层-HDL-模块" class="headerlink" title="step4：生成顶层 HDL 模块"></a>step4：生成顶层 HDL 模块</h4><pre><code>    在 Sources 窗口中，选中 **Design Sources** 下的 design_1.bd，这就是我们刚刚完成的 Block Design 设 计。右键点击 design_1.bd，在弹出的菜单栏中选择**“Generate Output Products”** ，等待 Generate 完成。在 Sources 窗口中，右键点击 design_1.bd，在弹出的菜单栏中选择**“Create HDL Wrapper”** 。
</code></pre>
<h4 id="step5：生成-Bitstream-文件并导出-Hardware。"><a href="#step5：生成-Bitstream-文件并导出-Hardware。" class="headerlink" title="step5：生成 Bitstream 文件并导出 Hardware。"></a>step5：生成 Bitstream 文件并导出 Hardware。</h4><pre><code>    在左侧 Flow Navigator 导航栏中找到 RTL ANALYSIS，点击该选项中的**“Open Elaborated Design”** 。在 ELABORATED DESIGN 界面下方找到 I/O Ports 一栏。如果没有找到则通过在菜单栏中点击 Layout， 然后在下拉列表中选择 I/O Planning。我们将在 I/O Ports 一栏对 PL 部分的接口进行管脚分配，led 分配至**BANK44**  的 **AE10** 引脚，该 BANK 的供电电压为**3.3V** ，因此 I/O Std 一列对应的电平也需要修改。

    设置完成后按快捷 Ctrl+S 保存管脚约束，在弹出的对话框输入文件名“user_led”。在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的**“Generate Bitstream”** 。在连续弹出的对话框中依次点击“YES”、“OK”。然后 Vivado 工具开始依次对设计进行综合、实现、并生成 Bitstream 文件。在菜单栏中选择 File &gt; Export &gt; **Export hardware** 。在弹出的对话框中，勾选“**Include bitstream** ”，然后点 击“OK”按钮。

    新建 vitis 文件夹，将 xsa 文件拷贝到里面。选择菜单 Tools-&gt;Launch Vitis。在弹出的界面中，指定路径到..\custom_ip\user_led\vitis 下，点击 “Launch”，打开 Vitis 软件。
</code></pre>
<h3 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><p>新建vitis工程user_led，流程同前，main.c文件内容如下：</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;breath_led_ip.h&quot;
#include &quot;xil_io.h&quot;
#include &quot;sleep.h&quot;

#define  LED_IP_BASEADDR    XPAR_BREATH_LED_IP_0_S0_AXI_BASEADDR  //LED IP基地址
#define  LED_IP_REG0        BREATH_LED_IP_S0_AXI_SLV_REG0_OFFSET  //LED IP寄存器地址0
#define  LED_IP_REG1        BREATH_LED_IP_S0_AXI_SLV_REG1_OFFSET  //LED IP寄存器地址1

//main函数
int main()
&#123;
 int freq_flag;      //定义频率状态，用于循环改变呼吸灯的呼吸频率
 int led_state;      //定义LED灯的状态

 xil_printf(&quot;LED User IP Test!\n\r&quot;);
 while(1)&#123;
     //根据freq_flag的标志位,切换呼吸灯的频率
     if(freq_flag == 0)&#123;
    	 BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x800000ef);
         freq_flag = 1;
     &#125;
     else&#123;
    	 BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,0x8000002f);
         freq_flag = 0;
     &#125;
     //获取LED当前开关状态   1:打开  0:关闭
     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);
     //如果开关关闭,打开呼吸灯
     if(led_state == 0)&#123;
    	 BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 1);
         xil_printf(&quot;Breath LED ON\n\r&quot;);
     &#125;
     sleep(5);
     //获取LED当前开关状态   1:打开  0:关闭
     led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);
     //如果开关打开,关闭呼吸灯
     if(led_state == 1)&#123;
    	 BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, 0);
         xil_printf(&quot;Breath LED OFF\n\r&quot;);
     &#125;
     sleep(1);
 &#125;
&#125;

    在代码的第 8 行至第 10 行，我们对 Breath LED IP 基地址、寄存器地址 0 和寄存器地址 1 进行了宏定义。按住 Ctrl 键不放，将鼠标移动到这些参数上，单击鼠标左键，会自动跳转到定义这些参数的地方。其中 BREATH LED IP 寄存器地址 0 和寄存器地址 1 位于**breath_led_ip.h** 文件内，这个文件是系统自动为我们生成的。

    程序中的 main 函数实现了每 6 秒钟（点亮 5 秒+关闭 1 秒）打开和关闭 LED 呼吸灯的开关，并切换 LED 灯呼吸频率的功能。我们通过 **BREATH_LED_IP_mReadReg()** 函数来**读取寄存器地址的数据** ，通过 **BREATH_LED_IP_mWriteReg()** 函数来**写入寄存器地址的数据** ，这两个函数同样位于 breath_led_ip.h 文件中。

    在硬件设计的自定义 IP 核部分中，我们例化 breath_led 代码的时候，将寄存器 0 的数据（slv_reg0）连接至呼吸灯的开关控制信号（sw_ctrl），寄存器 1 的数据高位（slv_reg1[31]）连接至呼吸灯频率设置使能信号（set_en），寄存器 1 的数据低位（slv_reg1[9:0]）连接至呼吸灯频率间隔设置（set_freq_step）。因此，在 Vitis 应用程序中，可以很方便的**通过 Breath LED IP 寄存器地址 0 和寄存器地址 1 来控制 LED 呼吸灯的开关和频率** 。

    值得一提的是，在 Vitis 中添加导出的硬件平台文件后，自**定义 IP 核的库函数也会导入进来** ，而这个 库函数是在自定义 IP 核时，由 Vivado 软件自动生成的：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b90ad057bdb4f0e9b727ccacfb8609e6.png"></p>
<p>接着“build project”，如果编译出现error，可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62179548/article/details/132042828" title="Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-CSDN博客">Vitis2021.1报错：fatal error: xparameters.h: No such file or directory-<br>CSDN博客</a></p>
<p>若run时出现错误：</p>
<p>Error while launching program: Hardaware specification file used in the launch<br>configuration ‘Debugger_user_led_ip-Default’ doesn’t exist at the location<br>…..</p>
<h3 id="4-下载验证"><a href="#4-下载验证" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><pre><code>    打开 Vitis Terminal 终端，设置并连接串口。在应用工程 user_led 上右击，选择**“Run As”** ，然后选择第一项**“1 Launch on Hardware (System Debugger)”** 。
</code></pre>
<h2 id="二-程序固化实验"><a href="#二-程序固化实验" class="headerlink" title="二.程序固化实验"></a>二.程序固化实验</h2><pre><code>   之前都是通过 JTAG 接口将 FPGA 配置文件和应用程序下载到 MPSOC 器件中。接下来尝试把程序存储在非易失性存储器中，在上电或者复位时让程序自动运行，这个过程需要启动引导程序**（Boot Loader）** 的参与。**Boot Loader 会加载 FPGA 配置文件，以及运行在 ARM 中的软件应用。**
</code></pre>
<p>**        <strong>本章的实验任务是在“AXI GPIO 按键控制 LED 实验”的基础上</strong>创建 FSBL** ，实现程序上电自启动，<strong>包括从 SD<br>卡启动，QSPI Flash 和 eMMC 启动三种方式</strong> 。</p>
<h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.*简介"></a>1.*简介</h3><pre><code>    MPSOC 的系统启动过程由**平台管理单元**(**PMU**)和**配置安全单元**(**CSU**)管理和执行。启动过程包括三个功能阶段：**预配置阶段、配置阶段和后配置阶段** 。

   _ **预配置阶段** 由**平台管理单元** 控制。平台管理单元运行 **PMU ROM** 代码以设置系统。PMU 处理所有复位和唤醒过程。_

    _**在配置阶段** ，**BootROM(CSU ROM 代码的一部分)** 解释引导头以配置系统，并在安全或非安全引导模式下将处理系统(PS)的**第一阶段引导加载程序(FSBL)代码** 加载到**片上 RAM(OCM)** 中。引导头定义了许多引导参数，包括安全模式和**执行 FSBL 的处理器 MPCore** 。在引导期间，CSU 还将 **PMU 用户固件(PMU FW)** 加载到**PMU RAM** 中，以与 PMU ROM 一起提供**平台管理服务** 。对于**基于 Xilinx 的 FSBL 和系统软件，PMU FW 必须存在于大多数系统中** 。_

   _  FSBL 执行开始后，CSU ROM 代码进入**后配置阶段** ，该阶段负责系统干预响应。CSU 硬件提供持续的硬件支持，以验证文件，**通过 PCAP 配置 PL，存储和管理安全密钥，解密文件** 。_
</code></pre>
<h4 id="启动流程-Boot-Flow"><a href="#启动流程-Boot-Flow" class="headerlink" title="启动流程(Boot Flow)"></a><strong>启动流程(Boot Flow)</strong></h4><p>**         **PMU对内部寄存器、存储器等进行复位，检查电压，则验证 CSU ROM 完整性并释放对 CSU 的复位。PMU<br>负责处理主要的预引导任务和 PS 的管理，以确保系统资源的可靠通电断电。启动 PMU<br>的上电复位(POR)操作，直接或间接的释放了预期上电模块的复位。在这种情况下，PMU 需要 ROM 代码来保持初始化上电顺序。即使在启动过程之后，PMU<br>仍在运行，并且负责处理各种系统复位。在更改系统电源状态时也会使用它(例如上电、睡眠和唤醒)。在初始化启动期间，POR 将 PMU 从复位中释放，然后执行<br>PMU ROM。</p>
<pre><code>下面描述了 PMU 处理器在 POR 复位后，通过运行 PMU ROM 预启动代码完成的操作序列：

1、 初始化 PS SYSMON 和引导单元所需的 PLL。

2、 清除 PMU RAM 和 CSU RAM(仅外部 POR)。

3、 验证 PLL 锁。

4、 通过 PS SYSMON 单元验证 LPD、AUX 和 IO 电源范围。

5、 清除低功耗和全功耗域。

6、 如果前面的步骤没有错，PMU 将释放 CSU 复位并进入 PMU 服务模式。如果有错，将产生一个启动错误标志。

当 CSU 复位被释放，CSU 将按照下面序列运行：

1、 初始化 OCM

2、 通过读取引导模式寄存器来确定启动模式。

3、 CSU 继续在 OCM 中加载 FSBL，以供 RPU 或 APU 执行。然后，CSU 将 PMU 用户固件加载到 PMU RAM 中，以供 PMU 固件执行。
</code></pre>
<h4 id="启动模式-Boot-Modes"><a href="#启动模式-Boot-Modes" class="headerlink" title="启动模式(Boot Modes)"></a><strong>启动模式(Boot Modes)</strong></h4><pre><code>    BootROM 可以通过 Quad-SPI，SD，eMMC，USB2.0 控制器 0 或 NAND 等外部设备启动系统。

    MPSOC 使用多个模式引脚来决定配置器件的类型，软件的存储位置以及其他的系统设置，这些引脚共享 PS 端的 MIO 引脚。总共有 7 个模式引脚，分别为 MIO[8:2]。其中，前四个引脚定义启动模式，第五个引脚定义是否使用 PLL，第六个和第七个引脚定义上电过程中 MIO bank0 和
</code></pre>
<p>bank1 的 bank 电压。如下图所示：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7fd4d98a93ce3511d9f836a14f2f9eb9.png"></p>
<h4 id="整个系统的启动过程"><a href="#整个系统的启动过程" class="headerlink" title="整个系统的启动过程"></a><strong>整个系统的启动过程</strong></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6da7cbc34256053b4b7e3b7c4ee48dc5.png"></p>
<p>更详细的内容可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/133468006?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22133468006%22,%22source%22:%22qq_32971095%22%7D" title="嵌入式Linux_Petalinux一——三.1软件栈">嵌入式Linux_Petalinux一——三.1软件栈</a></p>
<h3 id="2-硬件设计-1"><a href="#2-硬件设计-1" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><pre><code>    本次实验在“AXI GPIO 按键控制 LED 实验”的基础上进行，另存为本次实验工程，工程名为 axi_gpio_fsbl。

    接下来对系统的硬件设计进行修改。在 Vivado 界面左侧选择 Open Block Design，然后在右侧的 Diagram 界面中双击 Zynq UltraScale+ MPSOC 模块修改其配置。

    首先**使能 QSPI 外设** 。在左侧的导航栏中选择 I/O Configuration，在打开的右侧页面中，依次展开 Low Speed &gt; Memory Interfaces，然后勾选 QSPI 并在后面的下拉菜单中选择 Single，QSPI Data Mode 选择 x4， QSPI IO 默认为 MIO0..5，勾选 Feedback Clk 并选择 MIO6，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29757f782abd8955ade80399b026870b.png"></p>
<pre><code>    然后**打开 SD 卡外设** 。在上一步的页面中，展开 SD 外设，勾选 SD1，在后面的菜单栏中选择 MIO46..51， Slot Type 选择 SD2.0，Data Transfer Mode 选择 4Bit，勾选**CD 用于检测 SD 卡插入** 并选择 MIO45，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/446f0a292906d77dee9052eabc0e669b.png"></p>
<pre><code>    最后**打开 eMMC 外设** 。在同样的页面中，勾选 SD0 并选择 MIO13..22，Slot Type 设置成 eMMC，Data Transfer Mode 选择 8bit，勾选 Reset 并选择 MIO23，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c686ddf6f2ebcb2be138150d60ba3ff9.png"></p>
<pre><code>    上面两幅图中具体每个外设所连接的 MIO 引脚可以通过查看开发板原理图得知，设置完成后点击“OK”。然后在 Diagram 窗口空白处右击，然后选择“Validate Design”验证设计。验证完成后弹出对话框提示 “Validation Successful”表明设计无误，点击“OK”确认。最后按快捷键“Ctrl + S”保存设计。

    接下来在 Source 窗口中右键点击 Block Design 设计文件“design_1.bd”，执行“Generate Output Products”。 最后在左侧 Flow Navigator 导航栏中找到 PROGRAM AND DEBUG，点击该选项中的“Generate Bitstream”， 对设计进行综合、实现、并生成 Bitstream 文件。

    在菜单栏中选择 File &gt; Export &gt; Export hardware 导出硬件，并在弹出的对话框中，勾选“Include bitstream”。

    新建 vitis 文件夹，将生成的 xsa 文件放入其中。 然后在菜单栏选择 Tools &gt; Launch Vitis，启动 Vitis 开发环境。在弹出的对话框中，将路径指定到新建 的 vitis 文件夹下，点击 Launch 启动 Vitis。
</code></pre>
<h3 id="3-软件设计-1"><a href="#3-软件设计-1" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    新建vitis工程如上，main.c代码：


#include &quot;stdio.h&quot;
#include &quot;xparameters.h&quot;
#include &quot;xgpiops.h&quot;
#include &quot;xgpio.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;xil_exception.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;sleep.h&quot;

//宏定义
#define SCUGIC_ID    XPAR_SCUGIC_0_DEVICE_ID      //中断控制器  ID
#define GPIOPS_ID    XPAR_XGPIOPS_0_DEVICE_ID     //PS端  GPIO器件  ID
#define AXI_GPIO_ID  XPAR_AXI_GPIO_0_DEVICE_ID    //PL端  AXI GPIO器件  ID
#define GPIO_INT_ID  XPAR_FABRIC_GPIO_0_VEC_ID    //PL端  AXI GPIO中断  ID

#define MIO_LED      38                           //PS_LED1 连接到  MIO38
#define KEY_CHANNEL  1                            //PL按键使用 AXI GPIO通道1
#define KEY_MASK     XGPIO_IR_CH1_MASK            //通道1的位定义

//函数声明
void instance_init();                             //初始化器件驱动
void axi_gpio_handler(void *CallbackRef);         //中断服务函数

//全局变量
XScuGic            scugic_inst;                   //中断控制器    驱动实例
XScuGic_Config  *  scugic_cfg_ptr;                //中断控制器    配置信息
XGpioPs            gpiops_inst;                   //PS端  GPIO 驱动实例
XGpioPs_Config  *  gpiops_cfg_ptr;                //PS端  GPIO 配置信息
XGpio              axi_gpio_inst;                 //PL端  AXI GPIO 驱动实例

int led_value = 1;                                //LED显示状态

int main()
&#123;
	printf(&quot;AXI GPIO INTERRUPT TEST!\n&quot;);

	//初始化各器件驱动
	instance_init();

	//配置PS GPIO
	XGpioPs_SetDirectionPin(&amp;gpiops_inst, MIO_LED, 1);          //设置 PS GPIO 为输出
	XGpioPs_SetOutputEnablePin(&amp;gpiops_inst, MIO_LED ,1);    //使能 PS GPIO 输出
	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value);      //点亮LED

	//配置PL AXI GPIO
	XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
    XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
    XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断

    //设置中断优先级和触发类型(高电平触发)
    XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
    //关联中断ID和中断处理函数
    XScuGic_Connect(&amp;scugic_inst, GPIO_INT_ID, axi_gpio_handler, &amp;axi_gpio_inst);
    //使能AXI GPIO中断
    XScuGic_Enable(&amp;scugic_inst, GPIO_INT_ID);

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
    		(Xil_ExceptionHandler)XScuGic_InterruptHandler, &amp;scugic_inst);
    Xil_ExceptionEnable();

    while(1);

    return 0;
&#125;

//初始化各器件驱动
void instance_init()
&#123;
	//初始化中断控制器驱动
	scugic_cfg_ptr = XScuGic_LookupConfig(SCUGIC_ID);
	XScuGic_CfgInitialize(&amp;scugic_inst, scugic_cfg_ptr, scugic_cfg_ptr-&gt;CpuBaseAddress);

	//初始化PS端  GPIO驱动
	gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
	XGpioPs_CfgInitialize(&amp;gpiops_inst, gpiops_cfg_ptr, gpiops_cfg_ptr-&gt;BaseAddr);

	//初始化PL端  AXI GPIO驱动
	XGpio_Initialize(&amp;axi_gpio_inst, AXI_GPIO_ID);
&#125;

//PL端  AXI GPIO 中断服务(处理)函数
void axi_gpio_handler(void *CallbackRef)
&#123;
	int key_value = 1;
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	print(&quot;Interrupt Detected!\n&quot;);
	XGpio_InterruptDisable(GpioPtr, KEY_MASK);              //关闭 AXI GPIO 中断使能
    key_value = XGpio_DiscreteRead(GpioPtr, KEY_CHANNEL);   //读取按键数据
    if(key_value == 0)&#123;                                     //判断按键按下
    	led_value = ~led_value;
    	XGpioPs_WritePin(&amp;gpiops_inst, MIO_LED, led_value); //改变LED显示状态
    &#125;
    sleep(1);                                               //延时1s 按键消抖
    XGpio_InterruptClear(GpioPtr, KEY_MASK);                //清除中断
    XGpio_InterruptEnable(GpioPtr, KEY_MASK);               //使能AXI GPIO中断
&#125;

   **保存并编译工程** 后，**创建启动镜像** 。选中应用工程，右键选择**Create Boot Image。** 接下来，在弹出的界面中添加生成 boot.bin 所需的文件，然后点击“Create Image”，如图
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/372e816b5fc79bf2ae14f19e207cdfbb.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a22a2517141020dac5bd2d4d4f4cce68.png"></p>
<pre><code>    从上图中可以看到，软件已经给我们自动添加所需的文件。首先是 **Bootloader 启动文件** ，也就是序号 4 处的**fsbl.elf** 。其次是 **FPGA 的配置文件** design_1_wrapper.**bit** ，在上图中序号 5 处。最后是**应用程序** axi_gpio_fsbl.elf 文件，上图中序号 6 处。注意这三个文件的顺序不能错。

    序号 2 处的 bif 文件是生成**BOOT 的配置文件** ，序号 3 处的 **BOOT.bin** 就是我们需要的**启动文件** ，可以烧录到 QSPI Flash 或 eMMC 中，也可以放到 SD 中来启动 ZYNQ MOPSOC。        

    创建完成后，在指定的路径下可以看到生成的两个文件，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a4d08531d1eab8186a97364d2ed699b7.png"></p>
<h3 id="4-下载验证-1"><a href="#4-下载验证-1" class="headerlink" title="4.下载验证"></a>4.下载验证</h3><h4 id="从SD卡中启动程序"><a href="#从SD卡中启动程序" class="headerlink" title="&lt;1&gt;从SD卡中启动程序"></a>&lt;1&gt;从SD卡中启动程序</h4><pre><code>    将 Micro SD 卡插入读卡器，然后在电脑上将其格式化为 FAT32 格式，如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/93b44a4a8a61b36fb0f834c0b31a9c62.png"></p>
<pre><code>    将生成的 BOOT.bin 文件拷贝到 SD 卡根目录下，开发板启动模式改为从SD卡启动即可。
</code></pre>
<h4 id="固化至QSPI-Flash中"><a href="#固化至QSPI-Flash中" class="headerlink" title="&lt;2&gt;固化至QSPI Flash中"></a>&lt;2&gt;固化至QSPI Flash中</h4><pre><code>    将程序固化到 QSPI Flash 需要使用 JTAG 下载器。首先我们将下载器与开发板上的 JTAG 接口连接，下载器另外一端与电脑连接。接下来将开发板上的启动模式开关设置为  JTAG 模式。

    在 Vitis 软件的菜单栏中点击“Program Flash”，如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef30f083ed0db0516b72f0c5fa19d0a1.png"></p>
<pre><code>    在弹出的对话框中指定前面所生成的镜像文件 BOOT.bin 以及 FSBL.elf 文件，如下图中 1 和 2 处所示。 Flash Type 选择 qspi-x4-single，并勾选 Verify after flash。点击“Program”，开始对 Flash 进行编程：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/84bec15e9c53965b8eef13f5187856f4.png"></p>
<pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 32bit QSPI Flash 启动即可。
</code></pre>
<h4 id="固化到-eMMC-中"><a href="#固化到-eMMC-中" class="headerlink" title="&lt;3&gt;固化到 eMMC 中"></a>&lt;3&gt;固化到 eMMC 中</h4><pre><code>    步骤和&lt;2&gt;相同，在Program Flash中的 **Flash Type 选择 emmc** ， 并勾选 Verify after flash，然后点击 Program，如下：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1cd484d42fb06f898814fb196a4dab72.png"></p>
<pre><code>    断开开发板电源，然后将开发板上的启动模式开关设置为 emmc 启动即可。
</code></pre>
<h2 id="三-UART-串口中断实验"><a href="#三-UART-串口中断实验" class="headerlink" title="三.UART 串口中断实验"></a>三.UART 串口中断实验</h2><pre><code>    我们在使用 PS 的时候，通常会添加 UART 控制器，用于打印信息和调试代码。除此之外，PS 在和外部设备通信时，也会经常使用串口进行通信。进一步向大家 UART 控制器以及 UART 控制器利用中断进行通信的方法。
</code></pre>
<h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="MPSOC内UART控制器"><a href="#MPSOC内UART控制器" class="headerlink" title="&lt;1&gt;MPSOC内UART控制器"></a>&lt;1&gt;MPSOC内UART控制器</h4><pre><code>    MPSOC内UART控制器支持可编程的波特率发生器、64 字节的接收 FIFO 和发送 FIFO、产生中断、RXD 和 TXD 信号的环回模式设置以及可配置的数据位长度、停止位和校验方式等。

    UART 控制器的配置以及状态的获取由**控制（Control）和状态寄存器（Status Registers）** 完成。另外， UART 控制器不仅可以连接至 MIO，也可以**映射到 EMIO** ，从而使用 **PL 的端口来实现串口通信的功能** 。

    当 UART 控制器连接到 MIO 时，只有 Tx（发送）和 Rx（接收）两个引脚；而当连接 EMIO 时，除 Tx 和 Rx 引脚外，可选的还有 CTS、RTS、DSR、DCD、RI、DTR 等引脚，这些引脚用于串口的流控制。

    UART 控制器采用独立的接收和发送数据路径，每个路径包含一个 **64 字节的 FIFO** ，控制器对发送和接 收 FIFO 中的数据进行**串并转** 换操作。

    **FIFO 的中断标志** 支持**轮询处理** 或**中断驱动处理** 两种方式。另外，控制器中还有一个模式开关，支持 RXD 和 TXD 信号的各种环回配置。UART 控制器内部框图如下图所示：
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be9467098457f02d978fdaf7b35594d6.png"></p>
<pre><code>    UART 控制器的寄存器通过 **APB 从机接口和 PS AXI 总线** 互联，控制器的寄存器用于对 UART 控制器 进行配置和获取状态。波特率发生器（**Baud Rate Generator** ）为 UART 控制器的接收端和发送端提供位周期 时钟；中断控制器（**GIC** ）为串口的收发提供了中断服务的功能。

    APB 总线接口通过**向 TxFIFO 寄存器写值** ，将数据加载到 TxFIFO 存储器中。当数据加载至 TxFIFO 后， TxFIFO 的空标志变成无效的状态，直到最后一个数据从 TxFIFO 中移出，加载至传**输移位寄存器** ，TxFIFO 恢复空的标志位。同时 TxFIFO 使用 TFULL（满中断状态）用于表示当前 TxFIFO 已经写满，并且会阻止 数据继续写入。如果此时继续执行写操作，那么会触发溢出，数据不会加载到 TxFIFO 中。

    RxFIFO 存储器接收来自接收移位寄存器的数据，当接收完数据后，RxFIFO 空标志信号同样变成无效 的状态，直到所有的数据通过 APB 总线发送出去。RxFIFO 的满标志状态用于表示 RxFIFO 已经写满，并且 会阻止更多的数据写入。

    模式切换（**Mode Switch** ）控制 RxD 和 TxD 的信号连接方式，总共分为四种模式，分别为： **正常模式（Normal Mode）、自动回音模式（Automatic Echo Mode）、本地环回模式（Local Loopback Mode）和远程环回模式（Remote Loopback Mode）** 。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a18a6641a26bc471d59113f30b2dd803.png"></p>
<pre><code>    如果我们只是 用串口来**打印信息** 的话，那么可以直接使用**print()或者 xil_printf()** 函数就可以了，无需在程序中对串口做配置。但是如果我们需要使用 UART 来完成某些特定功能的话，如**串口接收中断** ，那么就要了解 UART 控制器**初始化、UART 中断初始化以及 UART 常用的 API 函数** 等相关内容了。
</code></pre>
<h4 id="UART启动和配置"><a href="#UART启动和配置" class="headerlink" title="&lt;2&gt;UART启动和配置"></a>&lt;2&gt;UART启动和配置</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ddbf21ee27e9c33362e57354d5eca70.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a310074e7bd0be3b5e5e715bd69bcec.png"></p>
<h4 id="收发数据"><a href="#收发数据" class="headerlink" title="&lt;3&gt;收发数据"></a>&lt;3&gt;收发数据</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/12b95a7bcc6acd13e957f41db6c99ca3.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/611810d31ceb34a9530dbcfd49af8288.png"></p>
<h3 id="2-硬件设计-2"><a href="#2-硬件设计-2" class="headerlink" title="2.硬件设计"></a>2.硬件设计</h3><p>DDR4 中存放和运行程序、UART 实现串口通信。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9d5d8180c6ece37e8e66b243cb97514.png"></p>
<pre><code>    本次实验嵌入式系统的搭建和Hello World 实验完全相同，工程名为 uart_intr_loop。 _MPSOC 开发板上的 USB UART 连接的引 脚是 MIO42 和 MIO43，因此在配置界面选择的是 UART0 MIO42..MIO43_ 。图中的 Modem signals 表示是否添加**串口的流控制功能，即调制解调器** ，如果选中的话，会额外增加一些引脚，一般不勾选。需要注意的 是，串口的流控制功能只能用于**EMIO 接口** ，MIO 接口不支持此功能。
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/769bdbcd35d49412cc93d1e56acb5bd4.png"></p>
<pre><code>    接下来，直接导出硬件，然后新建 vitis 文件夹，将导出的 xsa 文件拷贝到里面，最后打开 Vitis 软件， 并将路径指向新建的 vitis 文件夹下。
</code></pre>
<h3 id="3-软件设计-2"><a href="#3-软件设计-2" class="headerlink" title="3.软件设计"></a>3.软件设计</h3><pre><code>    Vitis 中创建了一个名为**uart_intr_loop 的应用工程** 。展开 design_1_wrapper，找到 **platform.spr** 并双击，右面的界面中出现 **design_1_wrapper 的标签页** ，然后找到**板级支持包** 并点击，可以看到**UART 文档和导入示例:**
</code></pre>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4761e85c7ba0a68757090675cb7507de.png"></p>
<pre><code>    如果我们点击**Import Examples** ，会弹出下图所示的导入示例界面，关于**UART 有 5 个示例，** 其中 xuartps_intr_example 是串口中断的示例，可供参考。

    新建main.c文件，代码如下：


#include &quot;xparameters.h&quot;
#include &quot;xuartps.h&quot;
#include &quot;xil_printf.h&quot;
#include &quot;xscugic.h&quot;
#include &quot;stdio.h&quot;

#define UART_DEVICE_ID     XPAR_XUARTPS_0_DEVICE_ID     //串口设备ID
#define INTC_DEVICE_ID     XPAR_SCUGIC_SINGLE_DEVICE_ID //中断ID
#define UART_INT_IRQ_ID    XPAR_XUARTPS_0_INTR          //串口中断ID

XScuGic Intc;              //中断控制器驱动程序实例
XUartPs Uart_Ps;           //串口驱动程序实例

//UART初始化函数
int uart_init(XUartPs* uart_ps)
&#123;
    int status;
    XUartPs_Config *uart_cfg;

    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);
    if (NULL == uart_cfg)
        return XST_FAILURE;
    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //UART设备自检
    status = XUartPs_SelfTest(uart_ps);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置工作模式:正常模式
    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);
    //设置波特率:115200
    XUartPs_SetBaudRate(uart_ps,115200);
    //设置RxFIFO的中断触发等级
    XUartPs_SetFifoThreshold(uart_ps, 1);

    return XST_SUCCESS;
&#125;

//UART中断处理函数
void uart_intr_handler(void *call_back_ref)
&#123;
    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;
    u32 rec_data = 0 ;
    u32 isr_status ;                           //中断状态标志

    //读取中断ID寄存器，判断触发的是哪种中断
    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_IMR_OFFSET);
    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_ISR_OFFSET);

    //判断中断标志位RxFIFO是否触发
    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;
    	rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);
        //清除中断标志
        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,
                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;
    &#125;
    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);
&#125;

//串口中断初始化
int uart_intr_init(XScuGic *intc, XUartPs *uart_ps)
&#123;
    int status;
    //初始化中断控制器
    XScuGic_Config *intc_cfg;
    intc_cfg = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == intc_cfg)
        return XST_FAILURE;
    status = XScuGic_CfgInitialize(intc, intc_cfg,
            intc_cfg-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置并打开中断异常处理功能
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler)XScuGic_InterruptHandler,
            (void *)intc);
    Xil_ExceptionEnable();

    //为中断设置中断处理函数
    XScuGic_Connect(intc, UART_INT_IRQ_ID,
            (Xil_ExceptionHandler) uart_intr_handler,(void *) uart_ps);
    //设置UART的中断触发方式
    XUartPs_SetInterruptMask(uart_ps, XUARTPS_IXR_RXOVR);
    //使能GIC中的串口中断
    XScuGic_Enable(intc, UART_INT_IRQ_ID);
    return XST_SUCCESS;
&#125;

//main函数
int main(void)
&#123;
    int status;

    status = uart_init(&amp;Uart_Ps);    //串口初始化
    if (status == XST_FAILURE) &#123;
        xil_printf(&quot;Uart Initial Failed\r\n&quot;);
        return XST_FAILURE;
    &#125;

    uart_intr_init(&amp;Intc, &amp;Uart_Ps); //串口中断初始化
    while (1);
    return status;
&#125;
</code></pre>
<h5 id="分析："><a href="#分析：" class="headerlink" title="*分析："></a>*分析：</h5><pre><code>    XScuGic 和 XUartPs 为程序中定义的两个结构体。如果在 Vitis 软件中， 按住 Ctrl 键不放，将鼠标移动到 XScuGic 或者 XUartPs 上，当鼠标变成手指状时，单击鼠标左键，会自动 跳转到定义这两个结构体的地方。其中 **XScuGic 包含了中断控制器相关的参数和数据** ，而 **XUartPs 则包含 了串口相关的参数和数据** 。

    在代码的第 15 行至第 40 行完成了对 UART 的初始化。其中代码的第 28 行 **XUartPs_SelfTest** 函数实现 了 UART 设备自检的功能，即使用 UART**本地环回** 的模式，并验证数据是否可以正确发送和接收。 **XUartPs_SetOperMode** 函数设置**串口的工作模式** ，这里输入的参数 XUARTPS_OPER_MODE_NORMAL 为 正常的工作模式。**XUartPs_SetBaudRate** 函数用于设置串口的通信**波特率** ，这里设置的波特率为 115200，如 果需要修改成其它波特率，可直接在此修改输入的参数即可。**XUartPs_SetFifoThreshold** 函数用于设置 RxFIFO 的中断触发等级，即**触发** **RxFIFO 中断的数据个数** ，**这里设置的值为 1（字节）** ，即每收到一个值就触发中断。注意，中断触发等级最大值不超过 63。

    在代码的第 65 行至第 94 行完成了串口中断的初始化。程序首先对**中断控制器进行初始化** ，随后设置 并打开**中断异常处理** 的功能。接下来为串口中断设置**中断处理函数** ，通过 **XScuGic_Connect** 函数进行设置，这里设置的串口中断处理函数为 **uart_intr_handler** 。**XUartPs_SetInterruptMask** 函数用于设置 UART 的**中断触发方式** ，函数输入的参数为 **XUARTPS_IXR_RXOVR** ，**表示达到 RxFIFO 的触发等级** 时，开始触发中断，当然也可以设置成 RxFIFO 为满时触发中断或者为空时触发中断等。最后，通过 **XScuGic_Enable** 函数来**使能 GIC** 中的串口中断。

    在代码的第 42 行至第 63 行为 **UART 中断处理函数** ，由于 RxFIFO 的触发等级设置为 1，因此每次接收到数据都会进入此中断函数。程序中首先**读取中断 ID 寄存器** ，判断触发的是**哪种中断** ，再读取**中断的状态** 。 当判断中断标志位为 **RxFIFO 触发中断** 时，通过 **XUartPs_RecvByte** 函数来**读取接收到的数据** ，并**清除对应的中断标志位** 。最后通过 **XUartPs_SendByte** 函数**发送接收到的数据** ，实现串口环回的功能。
</code></pre>
<p>注：首先程序会对 UART 串口进行初始化，我们知道，当使用一些打印函数的时候（如：xil_printf()），实际上调用的还是 UART 相关的 API<br>函数，如果在<strong>初始化的过程中， 使用打印函数，或者在打印的过程中对串口进行初始化，都会导致串口助手打印信息出错。</strong></p>
<h2 id="四-定时器中断实验"><a href="#四-定时器中断实验" class="headerlink" title="四.定时器中断实验"></a>四.定时器中断实验</h2><pre><code>    MPSOC 中 PS 部分包含许多不同类型的定时器，包括**全局定时器、TTC 定时器、系统看门狗定时器** 等。 定时器可以不受 CPU 的干预，自己独立运行，来完成计时、定时、中断以及计算来自 MIO 或 EMIO 引脚 的信号脉冲宽度等。本章我们将向大家介绍 **TTC**(**三路定时器**)以 TTC(三路定时器)**中断** 的使用方法。
</code></pre>
<h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h3><p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136352300">https://blog.csdn.net/qq_32971095/article/details/136352300</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/27/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SWQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Switch">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/Xilinx%20Vitis%20API%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Xilinx Vitis API常用部分解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 16:57:03" itemprop="dateCreated datePublished" datetime="2024-02-27T16:57:03+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 11:45:06" itemprop="dateModified" datetime="2025-02-08T11:45:06+08:00">2025-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：在源代码中 “ctrl+单击” 可查看详细信息  </p>
<h2 id="一-头文件"><a href="#一-头文件" class="headerlink" title="一.头文件"></a>一.头文件</h2><pre><code>#include &quot;xparameters.h&quot; //器件参数信息
#include &quot;xstatus.h&quot; //包含 XST_FAILURE 和 XST_SUCCESS 的宏定义
#include &quot;xil_printf.h&quot; //包含 print()函数
#include &quot;xgpiops.h&quot; //包含 PS GPIO 的函数
#include &quot;sleep.h&quot; //包含 sleep()函数
</code></pre>
<h2 id="二-宏定义"><a href="#二-宏定义" class="headerlink" title="二.宏定义"></a>二.宏定义</h2><pre><code>//PS_LED1 连接到 MIO38
#define MIO_LED1 38 

//宏定义 GPIO_DEVICE_ID
#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
</code></pre>
<h2 id="三-函数"><a href="#三-函数" class="headerlink" title="三.函数"></a>三.函数</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h3><h4 id="器件初始化"><a href="#器件初始化" class="headerlink" title="&lt;1&gt;器件初始化"></a>&lt;1&gt;器件初始化</h4><pre><code>//PS 端 GPIO 驱动实例
XGpioPs gpiops_inst; 
//PS 端 GPIO 配置信息
XGpioPs_Config *gpiops_cfg_ptr; 


//根据器件 ID 查找配置信息
gpiops_cfg_ptr = XGpioPs_LookupConfig(GPIOPS_ID);
//初始化器件驱动
Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,ConfigPtr-&gt;BaseAddr);
//判断是否初始化成功
if (Status != XST_SUCCESS)return XST_FAILURE;






XGpioPs_Config *XGpioPs_LookupConfig(u16 DeviceId);
/**
*
* This function looks for the device configuration based on the unique device
* ID. The table XGpioPs_ConfigTable[] contains the configuration information
* for each device in the system.
*
* @param	DeviceId is the unique device ID of the device being looked up.
*
* @return	A pointer to the configuration table entry corresponding to the
*		given device ID, or NULL if no match is found.
*
* @note		None.
*
******************************************************************************/



s32 XGpioPs_CfgInitialize(XGpioPs *InstancePtr, const XGpioPs_Config *ConfigPtr,u32 EffectiveAddr);
/*****************************************************************************/
/**
*
* This function initializes a XGpioPs instance/driver.
* All members of the XGpioPs instance structure are initialized and
* StubHandlers are assigned to the Bank Status Handlers.
*
* @param	InstancePtr is a pointer to the XGpioPs instance.
* @param	ConfigPtr points to the XGpioPs device configuration structure.
* @param	EffectiveAddr is the device base address in the virtual memory
*		address space. If the address translation is not used then the
*		physical address should be passed.
*		Unexpected errors may occur if the address mapping is changed
*		after this function is invoked.
*
* @return	XST_SUCCESS always.
*
* @note		None.
*
******************************************************************************/



int XGpio_Initialize(XGpio *InstancePtr, u16 DeviceId);
/****************************************************************************/
/**
* Initialize the XGpio instance provided by the caller based on the
* given DeviceID.
*
* Nothing is done except to initialize the InstancePtr.
*
* @param	InstancePtr is a pointer to an XGpio instance. The memory the
*		pointer references must be pre-allocated by the caller. Further
*		calls to manipulate the instance/driver through the XGpio API
*		must be made with this pointer.
* @param	DeviceId is the unique id of the device controlled by this XGpio
*		instance. Passing in a device id associates the generic XGpio
*		instance to a specific device, as chosen by the caller or
*		application developer.
*
* @return
*		- XST_SUCCESS if the initialization was successful.
*		- XST_DEVICE_NOT_FOUND  if the device configuration data was not
*		  found for a device with the supplied device ID.
*
* @note		None.
*
*****************************************************************************/
</code></pre>
<h4 id="中断配置"><a href="#中断配置" class="headerlink" title="&lt;2&gt;中断配置"></a>&lt;2&gt;中断配置</h4><pre><code>//建立中断系统，使能KEY按键的下降沿中断
//  @param   GicInstancePtr是一个指向XScuGic驱动实例的指针
//  @param   gpio是一个指向连接到中断的GPIO组件实例的指针
//  @param   GpioIntrId是Gpio中断ID
//  @return  如果成功返回XST_SUCCESS, 否则返回XST_FAILURE
int setup_interrupt_system(XScuGic *gic_ins_ptr, XGpioPs *gpio, u16 GpioIntrId)
&#123;
    int status;
    XScuGic_Config *IntcConfig;     //中断控制器配置信息

    //查找中断控制器配置信息并初始化中断控制器驱动
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == IntcConfig) &#123;
        return XST_FAILURE;
    &#125;

    status = XScuGic_CfgInitialize(gic_ins_ptr, IntcConfig,
            IntcConfig-&gt;CpuBaseAddress);
    if (status != XST_SUCCESS) &#123;
        return XST_FAILURE;
    &#125;


    //设置并使能中断异常
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
            (Xil_ExceptionHandler) XScuGic_InterruptHandler, gic_ins_ptr);
    Xil_ExceptionEnable();
    //为中断设置中断处理函数
    status = XScuGic_Connect(gic_ins_ptr, GpioIntrId,
            (Xil_ExceptionHandler) intr_handler, (void *) gpio);
    if (status != XST_SUCCESS) &#123;
        return status;
    &#125;
    //使能来自于Gpio器件的中断
    XScuGic_Enable(gic_ins_ptr, GpioIntrId);
    //设置KEY按键的中断类型为下降沿中断，按ctrl+单击查看其他类型
    XGpioPs_SetIntrTypePin(gpio, KEY, XGPIOPS_IRQ_TYPE_EDGE_FALLING);
    //使能按键KEY中断
    XGpioPs_IntrEnablePin(gpio, KEY);

    return XST_SUCCESS;
&#125;


//设置中断优先级和触发类型(高电平触发)
XScuGic_SetPriorityTriggerType(&amp;scugic_inst, GPIO_INT_ID, 0xA0, 0x1);
</code></pre>
<p> 中断处理函数：</p>
<pre><code>//中断处理函数
//  @param   CallBackRef是指向上层回调引用的指针
static void intr_handler(void *callback_ref)
&#123;
    XGpioPs *gpio = (XGpioPs *) callback_ref;

    //读取KEY按键引脚的中断状态，判断是否发生中断
    if (XGpioPs_IntrGetStatusPin(gpio, KEY))&#123;
        key_press = TRUE;
        XGpioPs_IntrDisablePin(gpio, KEY);         //屏蔽按键KEY中断
        //XGpioPs_IntrClearPin(&amp;gpio, KEY);      //清除按键KEY中断
        //XGpioPs_IntrEnablePin(&amp;gpio, KEY);     //使能按键KEY中断
    &#125;
&#125;
</code></pre>
<h4 id="uart配置"><a href="#uart配置" class="headerlink" title="&lt;3&gt;uart配置"></a>&lt;3&gt;uart配置</h4><pre><code>//UART初始化函数
int uart_init(XUartPs* uart_ps)
&#123;
    int status;
    XUartPs_Config *uart_cfg;

    uart_cfg = XUartPs_LookupConfig(UART_DEVICE_ID);
    if (NULL == uart_cfg)
        return XST_FAILURE;
    status = XUartPs_CfgInitialize(uart_ps, uart_cfg, uart_cfg-&gt;BaseAddress);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //UART设备自检
    status = XUartPs_SelfTest(uart_ps);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    //设置工作模式:正常模式
    XUartPs_SetOperMode(uart_ps, XUARTPS_OPER_MODE_NORMAL);
    //设置波特率:115200
    XUartPs_SetBaudRate(uart_ps,115200);
    //设置RxFIFO的中断触发等级
    XUartPs_SetFifoThreshold(uart_ps, 1);

    return XST_SUCCESS;
&#125;
</code></pre>
<p>中断函数</p>
<pre><code>//UART中断处理函数
void uart_intr_handler(void *call_back_ref)
&#123;
    XUartPs *uart_instance_ptr = (XUartPs *) call_back_ref;
    u32 rec_data = 0 ;
    u32 isr_status ;                           //中断状态标志

    //读取中断ID寄存器，判断触发的是哪种中断
    isr_status = XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_IMR_OFFSET);
    isr_status &amp;= XUartPs_ReadReg(uart_instance_ptr-&gt;Config.BaseAddress,
                   XUARTPS_ISR_OFFSET);

    //判断中断标志位RxFIFO是否触发
    if (isr_status &amp; (u32)XUARTPS_IXR_RXOVR)&#123;
    	rec_data = XUartPs_RecvByte(XPAR_PSU_UART_0_BASEADDR);
        //清除中断标志
        XUartPs_WriteReg(uart_instance_ptr-&gt;Config.BaseAddress,
                XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR) ;
    &#125;
    XUartPs_SendByte(XPAR_PSU_UART_0_BASEADDR,rec_data);
&#125;
</code></pre>
<h3 id="2-GPIO操作"><a href="#2-GPIO操作" class="headerlink" title="2.GPIO操作"></a>2.GPIO操作</h3><pre><code>//设置指定引脚的方向：0 输入，1 输出
XGpioPs_SetDirectionPin(&amp;Gpio, MIOLED0, 1);
//使能指定引脚输出：0 禁止输出使能，1 使能输出
XGpioPs_SetOutputEnablePin(&amp;Gpio, MIOLED0, 1);
//向指定引脚写入数据：0 或 1
XGpioPs_WritePin(&amp;Gpio, MIOLED0, 0x0); 
//从指定引脚读入数据
XGpioPs_ReadPin(&amp;gpiops_inst, MIO_KEY2)


//配置PL AXI GPIO
XGpio_SetDataDirection(&amp;axi_gpio_inst, KEY_CHANNEL, 1);  //设置PL AXI GPIO 通道1为输入
XGpio_InterruptEnable(&amp;axi_gpio_inst, KEY_MASK);         //使能通道1中断
XGpio_InterruptGlobalEnable(&amp;axi_gpio_inst);             //使能AXI GPIO全局中断
</code></pre>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><pre><code>    //uart打印	
    print(&quot;MIO Test! \n\r&quot;);    

    //延时 1 秒
	sleep(1); 
</code></pre>
<p>本文转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32971095/article/details/136315297">https://blog.csdn.net/qq_32971095/article/details/136315297</a>，如有侵权，请联系删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SWQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SWQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xidianswq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xidianswq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3209507800@qq.com" title="E-Mail → 3209507800@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_32971095" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32971095" rel="noopener" target="_blank"><i class="fa fa-link fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Feb 08 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SWQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">790k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


</body>
</html>
